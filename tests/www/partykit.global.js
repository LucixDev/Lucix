"use strict";
var Connect = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name8 in all)
      __defProp(target, name8, { get: all[name8], enumerable: true });
  };
  var __copyProps = (to, from8, except, desc) => {
    if (from8 && typeof from8 === "object" || typeof from8 === "function") {
      for (let key of __getOwnPropNames(from8))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from8[key], enumerable: !(desc = __getOwnPropDesc(from8, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

  // node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.23.1/node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js
  var init_dirname = __esm({
    "node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.23.1/node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/process.js
  var process = {};
  __export(process, {
    _debugEnd: () => _debugEnd,
    _debugProcess: () => _debugProcess,
    _events: () => _events,
    _eventsCount: () => _eventsCount,
    _exiting: () => _exiting,
    _fatalExceptions: () => _fatalExceptions,
    _getActiveHandles: () => _getActiveHandles,
    _getActiveRequests: () => _getActiveRequests,
    _kill: () => _kill,
    _linkedBinding: () => _linkedBinding,
    _maxListeners: () => _maxListeners,
    _preload_modules: () => _preload_modules,
    _rawDebug: () => _rawDebug,
    _startProfilerIdleNotifier: () => _startProfilerIdleNotifier,
    _stopProfilerIdleNotifier: () => _stopProfilerIdleNotifier,
    _tickCallback: () => _tickCallback,
    abort: () => abort,
    addListener: () => addListener,
    allowedNodeEnvironmentFlags: () => allowedNodeEnvironmentFlags,
    arch: () => arch,
    argv: () => argv,
    argv0: () => argv0,
    assert: () => assert,
    binding: () => binding,
    chdir: () => chdir,
    config: () => config,
    cpuUsage: () => cpuUsage,
    cwd: () => cwd,
    debugPort: () => debugPort,
    default: () => process2,
    dlopen: () => dlopen,
    domain: () => domain,
    emit: () => emit,
    emitWarning: () => emitWarning,
    env: () => env,
    execArgv: () => execArgv,
    execPath: () => execPath,
    exit: () => exit,
    features: () => features,
    hasUncaughtExceptionCaptureCallback: () => hasUncaughtExceptionCaptureCallback,
    hrtime: () => hrtime,
    kill: () => kill,
    listeners: () => listeners,
    memoryUsage: () => memoryUsage,
    moduleLoadList: () => moduleLoadList,
    nextTick: () => nextTick,
    off: () => off,
    on: () => on,
    once: () => once,
    openStdin: () => openStdin,
    pid: () => pid,
    platform: () => platform,
    ppid: () => ppid,
    prependListener: () => prependListener,
    prependOnceListener: () => prependOnceListener,
    reallyExit: () => reallyExit,
    release: () => release,
    removeAllListeners: () => removeAllListeners,
    removeListener: () => removeListener,
    resourceUsage: () => resourceUsage,
    setSourceMapsEnabled: () => setSourceMapsEnabled,
    setUncaughtExceptionCaptureCallback: () => setUncaughtExceptionCaptureCallback,
    stderr: () => stderr,
    stdin: () => stdin,
    stdout: () => stdout,
    title: () => title,
    umask: () => umask,
    uptime: () => uptime,
    version: () => version,
    versions: () => versions
  });
  function unimplemented(name8) {
    throw new Error("Node.js process " + name8 + " is not supported by JSPM core outside of Node.js");
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue)
      return;
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length)
      drainQueue();
  }
  function drainQueue() {
    if (draining)
      return;
    var timeout = setTimeout(cleanUpNextTick, 0);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue)
          currentQueue[queueIndex].run();
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i7 = 1; i7 < arguments.length; i7++)
        args[i7 - 1] = arguments[i7];
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining)
      setTimeout(drainQueue, 0);
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function _linkedBinding(name8) {
    unimplemented("_linkedBinding");
  }
  function dlopen(name8) {
    unimplemented("dlopen");
  }
  function _getActiveRequests() {
    return [];
  }
  function _getActiveHandles() {
    return [];
  }
  function assert(condition, message2) {
    if (!condition) throw new Error(message2 || "assertion error");
  }
  function hasUncaughtExceptionCaptureCallback() {
    return false;
  }
  function uptime() {
    return _performance.now() / 1e3;
  }
  function hrtime(previousTimestamp) {
    var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
    var clocktime = _performance.now() * 1e-3;
    var seconds = Math.floor(clocktime) + baseNow;
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += nanoPerSec;
      }
    }
    return [seconds, nanoseconds];
  }
  function on() {
    return process2;
  }
  function listeners(name8) {
    return [];
  }
  var queue, draining, currentQueue, queueIndex, title, arch, platform, env, argv, execArgv, version, versions, emitWarning, binding, umask, cwd, chdir, release, _rawDebug, moduleLoadList, domain, _exiting, config, reallyExit, _kill, cpuUsage, resourceUsage, memoryUsage, kill, exit, openStdin, allowedNodeEnvironmentFlags, features, _fatalExceptions, setUncaughtExceptionCaptureCallback, _tickCallback, _debugProcess, _debugEnd, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, stdout, stderr, stdin, abort, pid, ppid, execPath, debugPort, argv0, _preload_modules, setSourceMapsEnabled, _performance, nowOffset, nanoPerSec, _maxListeners, _events, _eventsCount, addListener, once, off, removeListener, removeAllListeners, emit, prependListener, prependOnceListener, process2;
  var init_process = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/process.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      queue = [];
      draining = false;
      queueIndex = -1;
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      arch = "x64";
      platform = "browser";
      env = {
        PATH: "/usr/bin",
        LANG: navigator.language + ".UTF-8",
        PWD: "/",
        HOME: "/home",
        TMP: "/tmp"
      };
      argv = ["/usr/bin/node"];
      execArgv = [];
      version = "v16.8.0";
      versions = {};
      emitWarning = function(message2, type2) {
        console.warn((type2 ? type2 + ": " : "") + message2);
      };
      binding = function(name8) {
        unimplemented("binding");
      };
      umask = function(mask) {
        return 0;
      };
      cwd = function() {
        return "/";
      };
      chdir = function(dir) {
      };
      release = {
        name: "node",
        sourceUrl: "",
        headersUrl: "",
        libUrl: ""
      };
      _rawDebug = noop;
      moduleLoadList = [];
      domain = {};
      _exiting = false;
      config = {};
      reallyExit = noop;
      _kill = noop;
      cpuUsage = function() {
        return {};
      };
      resourceUsage = cpuUsage;
      memoryUsage = cpuUsage;
      kill = noop;
      exit = noop;
      openStdin = noop;
      allowedNodeEnvironmentFlags = {};
      features = {
        inspector: false,
        debug: false,
        uv: false,
        ipv6: false,
        tls_alpn: false,
        tls_sni: false,
        tls_ocsp: false,
        tls: false,
        cached_builtins: true
      };
      _fatalExceptions = noop;
      setUncaughtExceptionCaptureCallback = noop;
      _tickCallback = noop;
      _debugProcess = noop;
      _debugEnd = noop;
      _startProfilerIdleNotifier = noop;
      _stopProfilerIdleNotifier = noop;
      stdout = void 0;
      stderr = void 0;
      stdin = void 0;
      abort = noop;
      pid = 2;
      ppid = 1;
      execPath = "/bin/usr/node";
      debugPort = 9229;
      argv0 = "node";
      _preload_modules = [];
      setSourceMapsEnabled = noop;
      _performance = {
        now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
        timing: typeof performance !== "undefined" ? performance.timing : void 0
      };
      if (_performance.now === void 0) {
        nowOffset = Date.now();
        if (_performance.timing && _performance.timing.navigationStart) {
          nowOffset = _performance.timing.navigationStart;
        }
        _performance.now = () => Date.now() - nowOffset;
      }
      nanoPerSec = 1e9;
      hrtime.bigint = function(time2) {
        var diff = hrtime(time2);
        if (typeof BigInt === "undefined") {
          return diff[0] * nanoPerSec + diff[1];
        }
        return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
      };
      _maxListeners = 10;
      _events = {};
      _eventsCount = 0;
      addListener = on;
      once = on;
      off = on;
      removeListener = on;
      removeAllListeners = on;
      emit = noop;
      prependListener = on;
      prependOnceListener = on;
      process2 = {
        version,
        versions,
        arch,
        platform,
        release,
        _rawDebug,
        moduleLoadList,
        binding,
        _linkedBinding,
        _events,
        _eventsCount,
        _maxListeners,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        prependListener,
        prependOnceListener,
        listeners,
        domain,
        _exiting,
        config,
        dlopen,
        uptime,
        _getActiveRequests,
        _getActiveHandles,
        reallyExit,
        _kill,
        cpuUsage,
        resourceUsage,
        memoryUsage,
        kill,
        exit,
        openStdin,
        allowedNodeEnvironmentFlags,
        assert,
        features,
        _fatalExceptions,
        setUncaughtExceptionCaptureCallback,
        hasUncaughtExceptionCaptureCallback,
        emitWarning,
        nextTick,
        _tickCallback,
        _debugProcess,
        _debugEnd,
        _startProfilerIdleNotifier,
        _stopProfilerIdleNotifier,
        stdout,
        stdin,
        stderr,
        abort,
        umask,
        chdir,
        cwd,
        env,
        title,
        argv,
        execArgv,
        pid,
        ppid,
        execPath,
        debugPort,
        hrtime,
        argv0,
        _preload_modules,
        setSourceMapsEnabled
      };
    }
  });

  // node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.23.1/node_modules/esbuild-plugin-polyfill-node/polyfills/process.js
  var init_process2 = __esm({
    "node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.23.1/node_modules/esbuild-plugin-polyfill-node/polyfills/process.js"() {
      "use strict";
      init_process();
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/buffer.js
  var buffer_exports = {};
  __export(buffer_exports, {
    Buffer: () => Buffer,
    INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
    default: () => exports2,
    kMaxLength: () => kMaxLength
  });
  function dew$2() {
    if (_dewExec$2) return exports$3;
    _dewExec$2 = true;
    exports$3.byteLength = byteLength;
    exports$3.toByteArray = toByteArray;
    exports$3.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i7 = 0, len = code9.length; i7 < len; ++i7) {
      lookup[i7] = code9[i7];
      revLookup[code9.charCodeAt(i7)] = i7;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i8;
      for (i8 = 0; i8 < len2; i8 += 4) {
        tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i8 = start; i8 < end; i8 += 3) {
        tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$3;
  }
  function dew$1() {
    if (_dewExec$1) return exports$2;
    _dewExec$1 = true;
    exports$2.read = function(buffer4, offset, isLE, mLen, nBytes) {
      var e9, m6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i7 = isLE ? nBytes - 1 : 0;
      var d6 = isLE ? -1 : 1;
      var s6 = buffer4[offset + i7];
      i7 += d6;
      e9 = s6 & (1 << -nBits) - 1;
      s6 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e9 = e9 * 256 + buffer4[offset + i7], i7 += d6, nBits -= 8) {
      }
      m6 = e9 & (1 << -nBits) - 1;
      e9 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m6 = m6 * 256 + buffer4[offset + i7], i7 += d6, nBits -= 8) {
      }
      if (e9 === 0) {
        e9 = 1 - eBias;
      } else if (e9 === eMax) {
        return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
      } else {
        m6 = m6 + Math.pow(2, mLen);
        e9 = e9 - eBias;
      }
      return (s6 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
    };
    exports$2.write = function(buffer4, value, offset, isLE, mLen, nBytes) {
      var e9, m6, c7;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i7 = isLE ? 0 : nBytes - 1;
      var d6 = isLE ? 1 : -1;
      var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m6 = isNaN(value) ? 1 : 0;
        e9 = eMax;
      } else {
        e9 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c7 = Math.pow(2, -e9)) < 1) {
          e9--;
          c7 *= 2;
        }
        if (e9 + eBias >= 1) {
          value += rt / c7;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c7 >= 2) {
          e9++;
          c7 /= 2;
        }
        if (e9 + eBias >= eMax) {
          m6 = 0;
          e9 = eMax;
        } else if (e9 + eBias >= 1) {
          m6 = (value * c7 - 1) * Math.pow(2, mLen);
          e9 = e9 + eBias;
        } else {
          m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e9 = 0;
        }
      }
      for (; mLen >= 8; buffer4[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
      }
      e9 = e9 << mLen | m6;
      eLen += mLen;
      for (; eLen > 0; buffer4[offset + i7] = e9 & 255, i7 += d6, e9 /= 256, eLen -= 8) {
      }
      buffer4[offset + i7 - d6] |= s6 * 128;
    };
    return exports$2;
  }
  function dew() {
    if (_dewExec) return exports$1;
    _dewExec = true;
    const base643 = dew$2();
    const ieee754 = dew$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports$1.Buffer = Buffer2;
    exports$1.SlowBuffer = SlowBuffer;
    exports$1.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports$1.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e9) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length4) {
      if (length4 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length4 + '" is invalid for option "size"');
      }
      const buf3 = new Uint8Array(length4);
      Object.setPrototypeOf(buf3, Buffer2.prototype);
      return buf3;
    }
    function Buffer2(arg, encodingOrOffset, length4) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe2(arg);
      }
      return from8(arg, encodingOrOffset, length4);
    }
    Buffer2.poolSize = 8192;
    function from8(value, encodingOrOffset, length4) {
      if (typeof value === "string") {
        return fromString6(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length4);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length4);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length4);
      }
      const b5 = fromObject(value);
      if (b5) return b5;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length4);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer2.from = function(value, encodingOrOffset, length4) {
      return from8(value, encodingOrOffset, length4);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc4(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc4(size, fill, encoding);
    };
    function allocUnsafe2(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe2(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe2(size);
    };
    function fromString6(string3, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length4 = byteLength(string3, encoding) | 0;
      let buf3 = createBuffer(length4);
      const actual = buf3.write(string3, encoding);
      if (actual !== length4) {
        buf3 = buf3.slice(0, actual);
      }
      return buf3;
    }
    function fromArrayLike(array) {
      const length4 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf3 = createBuffer(length4);
      for (let i7 = 0; i7 < length4; i7 += 1) {
        buf3[i7] = array[i7] & 255;
      }
      return buf3;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length4) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length4 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf3;
      if (byteOffset === void 0 && length4 === void 0) {
        buf3 = new Uint8Array(array);
      } else if (length4 === void 0) {
        buf3 = new Uint8Array(array, byteOffset);
      } else {
        buf3 = new Uint8Array(array, byteOffset, length4);
      }
      Object.setPrototypeOf(buf3, Buffer2.prototype);
      return buf3;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf3 = createBuffer(len);
        if (buf3.length === 0) {
          return buf3;
        }
        obj.copy(buf3, 0, 0, len);
        return buf3;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length4) {
      if (length4 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length4 | 0;
    }
    function SlowBuffer(length4) {
      if (+length4 != length4) {
        length4 = 0;
      }
      return Buffer2.alloc(+length4);
    }
    Buffer2.isBuffer = function isBuffer7(b5) {
      return b5 != null && b5._isBuffer === true && b5 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare5(a7, b5) {
      if (isInstance(a7, Uint8Array)) a7 = Buffer2.from(a7, a7.offset, a7.byteLength);
      if (isInstance(b5, Uint8Array)) b5 = Buffer2.from(b5, b5.offset, b5.byteLength);
      if (!Buffer2.isBuffer(a7) || !Buffer2.isBuffer(b5)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a7 === b5) return 0;
      let x4 = a7.length;
      let y6 = b5.length;
      for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
        if (a7[i7] !== b5[i7]) {
          x4 = a7[i7];
          y6 = b5[i7];
          break;
        }
      }
      if (x4 < y6) return -1;
      if (y6 < x4) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat4(list, length4) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i7;
      if (length4 === void 0) {
        length4 = 0;
        for (i7 = 0; i7 < list.length; ++i7) {
          length4 += list[i7].length;
        }
      }
      const buffer4 = Buffer2.allocUnsafe(length4);
      let pos = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        let buf3 = list[i7];
        if (isInstance(buf3, Uint8Array)) {
          if (pos + buf3.length > buffer4.length) {
            if (!Buffer2.isBuffer(buf3)) buf3 = Buffer2.from(buf3);
            buf3.copy(buffer4, pos);
          } else {
            Uint8Array.prototype.set.call(buffer4, buf3, pos);
          }
        } else if (!Buffer2.isBuffer(buf3)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf3.copy(buffer4, pos);
        }
        pos += buf3.length;
      }
      return buffer4;
    };
    function byteLength(string3, encoding) {
      if (Buffer2.isBuffer(string3)) {
        return string3.length;
      }
      if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
        return string3.byteLength;
      }
      if (typeof string3 !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3);
      }
      const len = string3.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes3(string3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string3).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes3(string3).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice3(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b5, n8, m6) {
      const i7 = b5[n8];
      b5[n8] = b5[m6];
      b5[m6] = i7;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 2) {
        swap(this, i7, i7 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 4) {
        swap(this, i7, i7 + 3);
        swap(this, i7 + 1, i7 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 8) {
        swap(this, i7, i7 + 7);
        swap(this, i7 + 1, i7 + 6);
        swap(this, i7 + 2, i7 + 5);
        swap(this, i7 + 3, i7 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString6() {
      const length4 = this.length;
      if (length4 === 0) return "";
      if (arguments.length === 0) return utf8Slice3(this, 0, length4);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals5(b5) {
      if (!Buffer2.isBuffer(b5)) throw new TypeError("Argument must be a Buffer");
      if (this === b5) return true;
      return Buffer2.compare(this, b5) === 0;
    };
    Buffer2.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports$1.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare5(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x4 = thisEnd - thisStart;
      let y6 = end - start;
      const len = Math.min(x4, y6);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i7 = 0; i7 < len; ++i7) {
        if (thisCopy[i7] !== targetCopy[i7]) {
          x4 = thisCopy[i7];
          y6 = targetCopy[i7];
          break;
        }
      }
      if (x4 < y6) return -1;
      if (y6 < x4) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer4, val, byteOffset, encoding, dir) {
      if (buffer4.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer4.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer4.length + byteOffset;
      if (byteOffset >= buffer4.length) {
        if (dir) return -1;
        else byteOffset = buffer4.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer4, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer4, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer4, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer4, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read6(buf3, i8) {
        if (indexSize === 1) {
          return buf3[i8];
        } else {
          return buf3.readUInt16BE(i8 * indexSize);
        }
      }
      let i7;
      if (dir) {
        let foundIndex = -1;
        for (i7 = byteOffset; i7 < arrLength; i7++) {
          if (read6(arr, i7) === read6(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i7;
            if (i7 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i7 -= i7 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i7 = byteOffset; i7 >= 0; i7--) {
          let found = true;
          for (let j4 = 0; j4 < valLength; j4++) {
            if (read6(arr, i7 + j4) !== read6(val, j4)) {
              found = false;
              break;
            }
          }
          if (found) return i7;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf3, string3, offset, length4) {
      offset = Number(offset) || 0;
      const remaining = buf3.length - offset;
      if (!length4) {
        length4 = remaining;
      } else {
        length4 = Number(length4);
        if (length4 > remaining) {
          length4 = remaining;
        }
      }
      const strLen = string3.length;
      if (length4 > strLen / 2) {
        length4 = strLen / 2;
      }
      let i7;
      for (i7 = 0; i7 < length4; ++i7) {
        const parsed = parseInt(string3.substr(i7 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i7;
        buf3[offset + i7] = parsed;
      }
      return i7;
    }
    function utf8Write(buf3, string3, offset, length4) {
      return blitBuffer(utf8ToBytes3(string3, buf3.length - offset), buf3, offset, length4);
    }
    function asciiWrite(buf3, string3, offset, length4) {
      return blitBuffer(asciiToBytes(string3), buf3, offset, length4);
    }
    function base64Write(buf3, string3, offset, length4) {
      return blitBuffer(base64ToBytes(string3), buf3, offset, length4);
    }
    function ucs2Write(buf3, string3, offset, length4) {
      return blitBuffer(utf16leToBytes(string3, buf3.length - offset), buf3, offset, length4);
    }
    Buffer2.prototype.write = function write7(string3, offset, length4, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length4 = this.length;
        offset = 0;
      } else if (length4 === void 0 && typeof offset === "string") {
        encoding = offset;
        length4 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length4)) {
          length4 = length4 >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length4;
          length4 = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length4 === void 0 || length4 > remaining) length4 = remaining;
      if (string3.length > 0 && (length4 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length4);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length4);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset, length4);
          case "base64":
            return base64Write(this, string3, offset, length4);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length4);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON3() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf3, start, end) {
      if (start === 0 && end === buf3.length) {
        return base643.fromByteArray(buf3);
      } else {
        return base643.fromByteArray(buf3.slice(start, end));
      }
    }
    function utf8Slice3(buf3, start, end) {
      end = Math.min(buf3.length, end);
      const res = [];
      let i7 = start;
      while (i7 < end) {
        const firstByte = buf3[i7];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i7 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf3[i7 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf3[i7 + 1];
              thirdByte = buf3[i7 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf3[i7 + 1];
              thirdByte = buf3[i7 + 2];
              fourthByte = buf3[i7 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i7 += bytesPerSequence;
      }
      return decodeCodePointsArray3(res);
    }
    const MAX_ARGUMENTS_LENGTH3 = 4096;
    function decodeCodePointsArray3(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH3) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i7 = 0;
      while (i7 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH3));
      }
      return res;
    }
    function asciiSlice(buf3, start, end) {
      let ret = "";
      end = Math.min(buf3.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf3[i7] & 127);
      }
      return ret;
    }
    function latin1Slice(buf3, start, end) {
      let ret = "";
      end = Math.min(buf3.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf3[i7]);
      }
      return ret;
    }
    function hexSlice(buf3, start, end) {
      const len = buf3.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i7 = start; i7 < end; ++i7) {
        out += hexSliceLookupTable[buf3[i7]];
      }
      return out;
    }
    function utf16leSlice(buf3, start, end) {
      const bytes = buf3.slice(start, end);
      let res = "";
      for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
        res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice4(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length4) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length4) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i7 = byteLength2;
      let mul = 1;
      let val = this[offset + --i7];
      while (i7 > 0 && (mul *= 256)) {
        val += this[offset + --i7] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE2(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE2(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf3, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf3)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf3.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i7 = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf3, value, offset, min, max) {
      checkIntBI(value, min, max, buf3, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf3, value, offset, min, max) {
      checkIntBI(value, min, max, buf3, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf3[offset + 7] = lo;
      lo = lo >> 8;
      buf3[offset + 6] = lo;
      lo = lo >> 8;
      buf3[offset + 5] = lo;
      lo = lo >> 8;
      buf3[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf3[offset + 3] = hi;
      hi = hi >> 8;
      buf3[offset + 2] = hi;
      hi = hi >> 8;
      buf3[offset + 1] = hi;
      hi = hi >> 8;
      buf3[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf3, value, offset, ext, max, min) {
      if (offset + ext > buf3.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf3, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf3, value, offset, 4);
      }
      ieee754.write(buf3, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE2(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf3, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf3, value, offset, 8);
      }
      ieee754.write(buf3, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE2(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code9 = val.charCodeAt(0);
          if (encoding === "utf8" && code9 < 128 || encoding === "latin1") {
            val = code9;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i7;
      if (typeof val === "number") {
        for (i7 = start; i7 < end; ++i7) {
          this[i7] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i7 = 0; i7 < end - start; ++i7) {
          this[i7 + start] = bytes[i7 % len];
        }
      }
      return this;
    };
    const errors = {};
    function E4(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name8) {
      if (name8) {
        return `${name8} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E4("ERR_INVALID_ARG_TYPE", function(name8, actual) {
      return `The "${name8}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E4("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i7 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i7 >= start + 4; i7 -= 3) {
        res = `_${val.slice(i7 - 3, i7)}${res}`;
      }
      return `${val.slice(0, i7)}${res}`;
    }
    function checkBounds(buf3, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf3[offset] === void 0 || buf3[offset + byteLength2] === void 0) {
        boundsError(offset, buf3.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf3, offset, byteLength2) {
      if (value > max || value < min) {
        const n8 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
          } else {
            range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
          }
        } else {
          range = `>= ${min}${n8} and <= ${max}${n8}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf3, offset, byteLength2);
    }
    function validateNumber(value, name8) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name8, "number", value);
      }
    }
    function boundsError(value, length4, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
      }
      if (length4 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length4}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes3(string3, units) {
      units = units || Infinity;
      let codePoint;
      const length4 = string3.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i7 = 0; i7 < length4; ++i7) {
        codePoint = string3.charCodeAt(i7);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i7 + 1 === length4) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        byteArray.push(str.charCodeAt(i7) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c7, hi, lo;
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        if ((units -= 2) < 0) break;
        c7 = str.charCodeAt(i7);
        hi = c7 >> 8;
        lo = c7 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base643.toByteArray(base64clean(str));
    }
    function blitBuffer(src3, dst, offset, length4) {
      let i7;
      for (i7 = 0; i7 < length4; ++i7) {
        if (i7 + offset >= dst.length || i7 >= src3.length) break;
        dst[i7 + offset] = src3[i7];
      }
      return i7;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet2 = "0123456789abcdef";
      const table = new Array(256);
      for (let i7 = 0; i7 < 16; ++i7) {
        const i16 = i7 * 16;
        for (let j4 = 0; j4 < 16; ++j4) {
          table[i16 + j4] = alphabet2[i7] + alphabet2[j4];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports$1;
  }
  var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports2, Buffer, INSPECT_MAX_BYTES, kMaxLength;
  var init_buffer = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      exports$3 = {};
      _dewExec$2 = false;
      exports$2 = {};
      _dewExec$1 = false;
      exports$1 = {};
      _dewExec = false;
      exports2 = dew();
      exports2["Buffer"];
      exports2["SlowBuffer"];
      exports2["INSPECT_MAX_BYTES"];
      exports2["kMaxLength"];
      Buffer = exports2.Buffer;
      INSPECT_MAX_BYTES = exports2.INSPECT_MAX_BYTES;
      kMaxLength = exports2.kMaxLength;
    }
  });

  // node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.23.1/node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
  var init_buffer2 = __esm({
    "node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.23.1/node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
      "use strict";
      init_buffer();
    }
  });

  // node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.5.4/node_modules/@adviser/cement/chunk-GES3MUGV.js
  function Utf8EnDecoderSingleton() {
    return utf8EnDecoder;
  }
  var __defProp2, __defProps, __getOwnPropDescs, __getOwnPropSymbols, __hasOwnProp2, __propIsEnum, __typeError, __defNormalProp, __spreadValues, __spreadProps, __export2, __accessCheck, __privateGet, __privateAdd, __privateSet, encoder, decoder, Utf8EnDecoder, utf8EnDecoder;
  var init_chunk_GES3MUGV = __esm({
    "node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.5.4/node_modules/@adviser/cement/chunk-GES3MUGV.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      __defProp2 = Object.defineProperty;
      __defProps = Object.defineProperties;
      __getOwnPropDescs = Object.getOwnPropertyDescriptors;
      __getOwnPropSymbols = Object.getOwnPropertySymbols;
      __hasOwnProp2 = Object.prototype.hasOwnProperty;
      __propIsEnum = Object.prototype.propertyIsEnumerable;
      __typeError = (msg) => {
        throw TypeError(msg);
      };
      __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      __spreadValues = (a7, b5) => {
        for (var prop in b5 || (b5 = {}))
          if (__hasOwnProp2.call(b5, prop))
            __defNormalProp(a7, prop, b5[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b5)) {
            if (__propIsEnum.call(b5, prop))
              __defNormalProp(a7, prop, b5[prop]);
          }
        return a7;
      };
      __spreadProps = (a7, b5) => __defProps(a7, __getOwnPropDescs(b5));
      __export2 = (target, all) => {
        for (var name8 in all)
          __defProp2(target, name8, { get: all[name8], enumerable: true });
      };
      __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
      __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
      __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
      __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
      encoder = new TextEncoder();
      decoder = new TextDecoder();
      Utf8EnDecoder = class {
        encode(str) {
          return encoder.encode(str);
        }
        decode(data) {
          return decoder.decode(data);
        }
      };
      utf8EnDecoder = new Utf8EnDecoder();
    }
  });

  // node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.5.4/node_modules/@adviser/cement/chunk-7KFVMTOS.js
  function streamMap(s6, sm) {
    const state = { reader: s6.getReader(), streamMap: sm, idx: 0 };
    return new ReadableStream({
      async pull(controller) {
        const { done, value } = await state.reader.read();
        if (done) {
          if (state.streamMap.Close) {
            state.streamMap.Close();
          }
          controller.close();
          return;
        }
        const promiseOrU = state.streamMap.Map(value, state.idx++);
        let mapped;
        if (promiseOrU instanceof Promise || typeof promiseOrU.then === "function") {
          mapped = await promiseOrU;
        } else {
          mapped = promiseOrU;
        }
        controller.enqueue(mapped);
      }
    });
  }
  async function devnull(a7) {
    const reader = a7.getReader();
    let cnt = 0;
    while (true) {
      const { done } = await reader.read();
      if (done) {
        break;
      }
      cnt++;
    }
    return cnt;
  }
  function array2stream(a7) {
    let i7 = 0;
    return new ReadableStream({
      pull(controller) {
        if (i7 >= a7.length) {
          controller.close();
          return;
        }
        controller.enqueue(a7[i7]);
        i7++;
      }
    });
  }
  async function stream2array(a7) {
    const ret = [];
    const reader = a7.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      ret.push(value);
    }
    return ret;
  }
  async function rebufferArray(a7, chunkSize) {
    return stream2array(rebuffer(array2stream(a7), chunkSize));
  }
  function reChunk(cs, chunkSize) {
    const len = cs.reduce((acc, v6) => acc + v6.length, 0);
    const last2 = cs[cs.length - 1];
    const lastOfs = len - last2.length;
    const rest = last2.subarray(chunkSize - lastOfs);
    cs[cs.length - 1] = last2.subarray(0, chunkSize - lastOfs);
    const chunk = new Uint8Array(chunkSize);
    let ofs = 0;
    for (const c7 of cs) {
      chunk.set(c7, ofs);
      ofs += c7.length;
    }
    return { rest, chunk };
  }
  function pump(ps, controller, next) {
    ps.reader.read().then(({ done, value }) => {
      if (done) {
        if (ps.tmpLen > 0) {
          controller.enqueue(reChunk(ps.tmp, ps.tmpLen).chunk);
        }
        controller.close();
        next();
        return;
      }
      if (ps.tmpLen + value.length > ps.chunkSize) {
        ps.tmp.push(value);
        const res = reChunk(ps.tmp, ps.chunkSize);
        controller.enqueue(res.chunk);
        ps.tmp = [res.rest];
        ps.tmpLen = res.rest.length;
        next();
        return;
      } else if (value.length) {
        ps.tmp.push(value);
        ps.tmpLen += value.length;
      }
      pump(ps, controller, next);
    });
  }
  function rebuffer(a7, chunkSize) {
    const state = {
      reader: a7.getReader(),
      tmp: [],
      tmpLen: 0,
      chunkSize
    };
    return new ReadableStream({
      async pull(controller) {
        return new Promise((resolve9) => {
          pump(state, controller, resolve9);
        });
      }
    });
  }
  async function stream2string(stream, maxSize) {
    if (!stream) {
      return Promise.resolve("");
    }
    const reader = stream.getReader();
    let res = "";
    const decoder2 = new TextDecoder();
    let rSize = 0;
    while (typeof maxSize === "undefined" || rSize < maxSize) {
      try {
        const read6 = await reader.read();
        if (read6.done) {
          break;
        }
        if (maxSize && rSize + read6.value.length > maxSize) {
          read6.value = read6.value.slice(0, maxSize - rSize);
        }
        const block = decoder2.decode(read6.value, { stream: true });
        rSize += read6.value.length;
        res += block;
      } catch (err) {
        return Promise.reject(err);
      }
    }
    return Promise.resolve(res);
  }
  async function stream2uint8array(stream) {
    if (!stream) {
      return Promise.resolve(new Uint8Array());
    }
    const reader = stream.getReader();
    let res = new Uint8Array();
    while (1) {
      try {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        res = new Uint8Array([...res, ...value]);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    return Promise.resolve(res);
  }
  function string2stream(str, ende = Utf8EnDecoderSingleton()) {
    return uint8array2stream(ende.encode(str));
  }
  function uint8array2stream(str) {
    return new ReadableStream({
      start(controller) {
        controller.enqueue(str);
        controller.close();
      }
    });
  }
  var utils_exports, ConsoleWriterStreamDefaultWriter, ConsoleWriterStream, FanoutWriteStream;
  var init_chunk_7KFVMTOS = __esm({
    "node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.5.4/node_modules/@adviser/cement/chunk-7KFVMTOS.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_GES3MUGV();
      utils_exports = {};
      __export2(utils_exports, {
        ConsoleWriterStream: () => ConsoleWriterStream,
        ConsoleWriterStreamDefaultWriter: () => ConsoleWriterStreamDefaultWriter,
        FanoutWriteStream: () => FanoutWriteStream,
        array2stream: () => array2stream,
        devnull: () => devnull,
        rebuffer: () => rebuffer,
        rebufferArray: () => rebufferArray,
        stream2array: () => stream2array,
        stream2string: () => stream2string,
        stream2uint8array: () => stream2uint8array,
        streamMap: () => streamMap,
        string2stream: () => string2stream,
        uint8array2stream: () => uint8array2stream
      });
      ConsoleWriterStreamDefaultWriter = class {
        constructor(stream) {
          this.stream = stream;
          this.desiredSize = null;
          this.decoder = new TextDecoder();
          this._stream = stream;
          this.ready = Promise.resolve(void 0);
          this.closed = Promise.resolve(void 0);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
        abort(reason) {
          throw new Error("Method not implemented.");
        }
        async close() {
        }
        releaseLock() {
          this._stream.locked = false;
          this.ready = Promise.resolve(void 0);
          this.closed = Promise.resolve(void 0);
        }
        async write(chunk) {
          const str = this.decoder.decode(chunk).trimEnd();
          let output = "log";
          try {
            const decode21 = JSON.parse(str);
            output = decode21.level;
          } catch (e9) {
          }
          switch (output) {
            case "error":
              console.error(str);
              break;
            case "warn":
              console.warn(str);
              break;
            default:
              console.log(str);
          }
        }
      };
      ConsoleWriterStream = class {
        constructor() {
          this.locked = false;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
        abort(reason) {
          throw new Error("Method not implemented.");
        }
        async close() {
          return;
        }
        getWriter() {
          if (this.locked) {
            throw new Error("Stream is locked");
          }
          this.locked = true;
          if (!this._writer) {
            this._writer = new ConsoleWriterStreamDefaultWriter(this);
          }
          return this._writer;
        }
      };
      FanoutWriteStream = class {
        constructor(writers) {
          this.desiredSize = null;
          this._writers = writers;
          this.ready = Promise.all(this._writers.map((w4) => w4.ready)).then(() => void 0);
          this.closed = Promise.all(this._writers.map((w4) => w4.closed)).then(() => void 0);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        abort(reason) {
          return Promise.all(this._writers.map((w4) => w4.abort(reason))).then(() => {
          });
        }
        close() {
          return Promise.all(this._writers.map((w4) => w4.close())).then(() => {
          });
        }
        releaseLock() {
          this._writers.map((w4) => w4.releaseLock());
        }
        write(chunk) {
          return Promise.all(this._writers.map((w4) => w4.write(chunk))).then(() => {
          });
        }
      };
    }
  });

  // node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.5.4/node_modules/@adviser/cement/chunk-Q65HLCNL.js
  function TimeFactory(timeMode) {
    switch (timeMode) {
      case "real":
        return new SysTime();
      case "const":
        return new ConstTime();
      case "step":
        return new StepTime();
    }
    return new SysTime();
  }
  function envFactory(opts = {}) {
    return _envFactory.once(() => {
      const found = [new NodeEnvActions(opts), new DenoEnvActions(opts), new BrowserEnvActions(opts)].find((env2) => env2.active());
      if (!found) {
        throw new Error("SysContainer:envFactory: no env available");
      }
      const ret = new EnvImpl(found, opts);
      found.register(ret);
      return ret;
    });
  }
  var Time, SysTime, ConstTime, StepTime, RandomService, IdService, BaseSysAbstraction, WrapperSysAbstraction, _promise, _resolveFn, _rejectFn, Future, ResolveSeq, ResolveOnce, Keyed, KeyedResolvOnce, _node, NodeEnvActions, _deno, DenoEnvActions, BrowserEnvActions, _envFactory, EnvImpl;
  var init_chunk_Q65HLCNL = __esm({
    "node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.5.4/node_modules/@adviser/cement/chunk-Q65HLCNL.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_GES3MUGV();
      Time = class {
        TimeSince(start) {
          const now = this.Now();
          return now.getTime() - start.getTime();
        }
      };
      SysTime = class extends Time {
        Now() {
          return /* @__PURE__ */ new Date();
        }
        Sleep(duration) {
          return new Promise((resolve9) => {
            setTimeout(() => {
              resolve9();
            }, duration);
          });
        }
      };
      ConstTime = class extends Time {
        Now() {
          return new Date(2021, 1, 1, 0, 0, 0, 0);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        Sleep(duration) {
          return Promise.resolve();
        }
      };
      StepTime = class extends Time {
        constructor() {
          super();
          this._step = new ConstTime().Now();
          this._start = this._step;
        }
        Now(steps = 1) {
          for (let i7 = 0; steps > 0 && i7 < steps; i7++) {
            this._step = new Date(this._step.getTime() + 1e3);
          }
          if (steps < 1) {
            this._step = new Date(this._start.getTime() + steps * -1e3);
          }
          return this._step;
        }
        Sleep(duration) {
          this._step = new Date(this._step.getTime() + duration);
          return Promise.resolve();
        }
      };
      RandomService = class {
        constructor(mode) {
          this._step = 0;
          this._mode = mode;
        }
        Random0ToValue(value) {
          switch (this._mode) {
            case "const":
              return 0.5 * value;
            case "step":
              this._step += 1e-4;
              return this._step * value;
            case "random":
              return Math.random() * value;
            default:
              throw new Error("Unknown RandomMode");
          }
        }
      };
      IdService = class {
        constructor(mode) {
          this._step = 0;
          if (!mode) {
            mode = "uuid";
          }
          this._mode = mode;
        }
        NextId() {
          switch (this._mode) {
            case "uuid":
              return crypto.randomUUID();
            case "const":
              return "VeryUniqueID";
            case "step":
              return `STEPId-${this._step++}`;
            default:
              throw new Error("Unknown IDMode");
          }
        }
      };
      BaseSysAbstraction = class {
        constructor(params) {
          this._time = new SysTime();
          this._idService = new IdService();
          this._randomService = new RandomService(
            "random"
            /* RANDOM */
          );
          this._fileSystem = params.FileSystem;
          this._systemService = params.SystemService;
          this._txtEnDe = params.TxtEnDecoder;
          const decoder2 = this._txtEnDe;
          this._stdout = new WritableStream({
            write(chunk) {
              return new Promise((resolve9) => {
                const decoded = decoder2.decode(chunk);
                console.log(decoded.trimEnd());
                resolve9();
              });
            }
          });
          this._stderr = new WritableStream({
            write(chunk) {
              return new Promise((resolve9) => {
                const decoded = decoder2.decode(chunk);
                console.error(decoded.trimEnd());
                resolve9();
              });
            }
          });
        }
      };
      WrapperSysAbstraction = class {
        constructor(base3, params) {
          this._time = base3._time;
          this._stdout = base3._stdout;
          this._stderr = base3._stderr;
          this._idService = base3._idService;
          this._randomService = base3._randomService;
          this._fileSystem = base3._fileSystem;
          this._systemService = base3._systemService;
          if (params) {
            if (params.TimeMode) {
              this._time = TimeFactory(params.TimeMode);
            }
            if (params.Stdout) {
              this._stdout = params.Stdout;
            }
            if (params.Stderr) {
              this._stderr = params.Stderr;
            }
            if (params.IdMode) {
              this._idService = new IdService(params.IdMode);
            }
            if (params.RandomMode) {
              this._randomService = new RandomService(params.RandomMode);
            }
            if (params.FileSystem) {
              this._fileSystem = params.FileSystem;
            }
            if (params.SystemService) {
              this._systemService = params.SystemService;
            }
          }
        }
        Time() {
          return this._time;
        }
        NextId() {
          return this._idService.NextId();
        }
        Random0ToValue(value) {
          return this._randomService.Random0ToValue(value);
        }
        Stdout() {
          return this._stdout;
        }
        Stderr() {
          return this._stderr;
        }
        System() {
          return this._systemService;
        }
        FileSystem() {
          return this._fileSystem;
        }
      };
      Future = class {
        constructor() {
          __privateAdd(this, _promise);
          __privateAdd(this, _resolveFn, () => {
            throw new Error("This Promise is not working as expected.");
          });
          __privateAdd(this, _rejectFn, () => {
            throw new Error("This Promise is not working as expected.");
          });
          __privateSet(this, _promise, new Promise((resolve9, reject) => {
            __privateSet(this, _resolveFn, resolve9);
            __privateSet(this, _rejectFn, reject);
          }));
        }
        async asPromise() {
          return __privateGet(this, _promise);
        }
        resolve(value) {
          __privateGet(this, _resolveFn).call(this, value);
        }
        reject(reason) {
          __privateGet(this, _rejectFn).call(this, reason);
        }
      };
      _promise = /* @__PURE__ */ new WeakMap();
      _resolveFn = /* @__PURE__ */ new WeakMap();
      _rejectFn = /* @__PURE__ */ new WeakMap();
      ResolveSeq = class {
        constructor(ctx) {
          this._seqFutures = [];
          this.ctx = ctx;
        }
        reset() {
        }
        async _step(item) {
          if (!item) {
            return;
          }
          item.fn(this.ctx).then((value) => item.future.resolve(value)).catch((e9) => item.future.reject(e9)).finally(() => {
            this._seqFutures.shift();
            this._step(this._seqFutures[0]);
          });
        }
        async add(fn, id) {
          const future = new Future();
          this._seqFutures.push({ future, fn, id });
          if (this._seqFutures.length === 1) {
            this._step(this._seqFutures[0]);
          }
          return future.asPromise();
        }
      };
      ResolveOnce = class {
        constructor(ctx) {
          this._onceDone = false;
          this._onceFutures = [];
          this._onceOk = false;
          this._isPromise = false;
          this.ctx = ctx;
        }
        get ready() {
          return this._onceDone;
        }
        reset() {
          this._onceDone = false;
          this._onceOk = false;
          this._onceValue = void 0;
          this._onceError = void 0;
          this._onceFutures.length = 0;
        }
        // T extends Option<infer U> ? U : T
        once(fn) {
          if (this._onceDone) {
            if (this._onceError) {
              if (this._isPromise) {
                return Promise.reject(this._onceError);
              } else {
                throw this._onceError;
              }
            }
            if (this._onceOk) {
              if (this._isPromise) {
                return Promise.resolve(this._onceValue);
              } else {
                return this._onceValue;
              }
            }
            throw new Error("ResolveOnce.once impossible");
          }
          const future = new Future();
          this._onceFutures.push(future);
          if (this._onceFutures.length === 1) {
            const okFn = (value) => {
              this._onceValue = value;
              this._onceOk = true;
              this._onceDone = true;
              if (this._isPromise) {
                this._onceFutures.forEach((f7) => f7.resolve(this._onceValue));
              }
              this._onceFutures.length = 0;
            };
            const catchFn = (e9) => {
              this._onceError = e9;
              this._onceOk = false;
              this._onceValue = void 0;
              this._onceDone = true;
              if (this._isPromise) {
                this._onceFutures.forEach((f7) => f7.reject(this._onceError));
              }
              this._onceFutures.length = 0;
            };
            try {
              const ret = fn(this.ctx);
              if (typeof ret.then === "function") {
                this._isPromise = true;
                ret.then(okFn).catch(catchFn);
              } else {
                okFn(ret);
              }
            } catch (e9) {
              catchFn(e9);
            }
          }
          if (this._isPromise) {
            return future.asPromise();
          } else {
            return this.once(fn);
          }
        }
      };
      Keyed = class {
        constructor(factory) {
          this._map = /* @__PURE__ */ new Map();
          this.factory = factory;
        }
        async asyncGet(key) {
          return this.get(await key());
        }
        get(key) {
          if (typeof key === "function") {
            key = key();
          }
          let keyed = this._map.get(key);
          if (!keyed) {
            keyed = this.factory(key);
            this._map.set(key, keyed);
          }
          return keyed;
        }
        unget(key) {
          const keyed = this._map.get(key);
          keyed == null ? void 0 : keyed.reset();
          this._map.delete(key);
        }
        reset() {
          this._map.forEach((keyed) => keyed.reset());
          this._map.clear();
        }
      };
      KeyedResolvOnce = class extends Keyed {
        constructor() {
          super((key) => new ResolveOnce(key));
        }
      };
      NodeEnvActions = class {
        // eslint-disable-next-line @typescript-eslint/no-useless-constructor, @typescript-eslint/no-unused-vars
        constructor(opts) {
          __privateAdd(this, _node, globalThis);
          this._env = this.active() ? __privateGet(this, _node).process.env : {};
        }
        register(env2) {
          return env2;
        }
        active() {
          return typeof __privateGet(this, _node) === "object" && typeof __privateGet(this, _node).process === "object" && typeof __privateGet(this, _node).process.env === "object";
        }
        keys() {
          return Object.keys(this._env);
        }
        get(key) {
          return this._env[key];
        }
        set(key, value) {
          if (value) {
            this._env[key] = value;
          }
        }
        delete(key) {
          delete this._env[key];
        }
      };
      _node = /* @__PURE__ */ new WeakMap();
      DenoEnvActions = class {
        // eslint-disable-next-line @typescript-eslint/no-useless-constructor, @typescript-eslint/no-unused-vars
        constructor(opts) {
          __privateAdd(this, _deno, globalThis);
        }
        get _env() {
          return __privateGet(this, _deno).Deno.env;
        }
        register(env2) {
          return env2;
        }
        active() {
          return typeof __privateGet(this, _deno) === "object" && typeof __privateGet(this, _deno).Deno === "object" && typeof __privateGet(this, _deno).Deno.env === "object";
        }
        keys() {
          return Array.from(this._env.keys());
        }
        get(key) {
          return this._env.get(key);
        }
        set(key, value) {
          if (value) {
            this._env.set(key, value);
          }
        }
        delete(key) {
          this._env.delete(key);
        }
      };
      _deno = /* @__PURE__ */ new WeakMap();
      BrowserEnvActions = class {
        constructor(opts) {
          this.env = /* @__PURE__ */ new Map();
          this.opts = opts;
        }
        get(key) {
          return this.env.get(key);
        }
        set(key, value) {
          if (value) {
            this.env.set(key, value);
          }
        }
        delete(key) {
          this.env.delete(key);
        }
        keys() {
          return Array.from(this.env.keys());
        }
        active() {
          return true;
        }
        register(env2) {
          const sym = Symbol.for(this.opts.symbol || "CP_ENV");
          const browser = globalThis;
          browser[sym] = env2;
          return env2;
        }
      };
      _envFactory = new ResolveOnce();
      EnvImpl = class {
        constructor(map3, opts = {}) {
          this._onSet = [];
          this._map = map3;
          this._updatePresets(opts.presetEnv);
        }
        _updatePresets(presetEnv2) {
          if (!presetEnv2) {
            return;
          }
          for (const [key, value] of presetEnv2) {
            this._map.set(key, value);
          }
        }
        _applyOnSet(onSet, key, value) {
          onSet.forEach((item) => {
            let keys = [];
            if (key) {
              keys = [key];
            } else {
              keys = this._map.keys();
            }
            keys.filter((k4) => {
              if (item.filter.size === 0) {
                return true;
              }
              if (item.filter.has(k4)) {
                return true;
              }
              return false;
            }).forEach((k4) => {
              let v6;
              if (!key && !value) {
                v6 = this._map.get(k4);
              } else if (key && !value) {
                v6 = void 0;
              } else {
                v6 = value;
              }
              item.fn(k4, v6);
            });
          });
        }
        keys() {
          return this._map.keys();
        }
        // filter is not set all sets passed
        onSet(fn, ...filter2) {
          const item = { filter: new Set(filter2), fn };
          this._onSet.push(item);
          this._applyOnSet([item]);
        }
        get(key) {
          return this._map.get(key);
        }
        set(key, value) {
          if (!value) {
            return;
          }
          this._map.set(key, value);
          this._applyOnSet(this._onSet, key, value);
        }
        delete(key) {
          this._map.delete(key);
          this._applyOnSet(this._onSet, key);
        }
      };
    }
  });

  // node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.5.4/node_modules/@adviser/cement/chunk-WMMUXBDX.js
  function WebSysAbstraction(param) {
    if (!my) {
      my = new BaseSysAbstraction({
        TxtEnDecoder: (param == null ? void 0 : param.TxtEnDecoder) || Utf8EnDecoderSingleton(),
        FileSystem: new WebFileService(),
        SystemService: new WebSystemService()
      });
    }
    return new WrapperSysAbstraction(my, param);
  }
  var WebFileService, WebSystemService, my;
  var init_chunk_WMMUXBDX = __esm({
    "node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.5.4/node_modules/@adviser/cement/chunk-WMMUXBDX.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_Q65HLCNL();
      init_chunk_GES3MUGV();
      WebFileService = class {
        get baseDir() {
          throw new Error("basedir-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        create(fname) {
          throw new Error("create-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        readFileString(fname) {
          throw new Error("readFileString-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        writeFileString(fname, content) {
          throw new Error("writeFileString-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        abs(fname) {
          throw new Error("abs-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        join(...paths) {
          throw new Error("join-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        relative(from8, to) {
          throw new Error("relative-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        dirname(fname) {
          throw new Error("dirname-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        basename(fname) {
          throw new Error("basename-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        nodeImport(fname) {
          throw new Error("nodeImport-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        isAbsolute(fname) {
          throw new Error("isAbsolute-Method not implemented.");
        }
      };
      WebSystemService = class {
        Env() {
          return envFactory();
        }
        Args() {
          throw new Error("Args-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        OnExit(hdl) {
          throw new Error("OnExit-Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        Exit(code9) {
          throw new Error("Exit-Method not implemented.");
        }
      };
      my = void 0;
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/identity.js
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var ALIAS, DOC, MAP, PAIR, SCALAR, SEQ, NODE_TYPE, isAlias, isDocument, isMap, isPair, isScalar, isSeq, hasAnchor;
  var init_identity = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/identity.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      ALIAS = Symbol.for("yaml.alias");
      DOC = Symbol.for("yaml.document");
      MAP = Symbol.for("yaml.map");
      PAIR = Symbol.for("yaml.pair");
      SCALAR = Symbol.for("yaml.scalar");
      SEQ = Symbol.for("yaml.seq");
      NODE_TYPE = Symbol.for("yaml.node.type");
      isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
      isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
      isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
      isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
      isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
      isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
      hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/visit.js
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  function visit_(key, node, visitor, path2) {
    const ctrl = callVisitor(key, node, visitor, path2);
    if (isNode(ctrl) || isPair(ctrl)) {
      replaceNode(key, path2, ctrl);
      return visit_(key, ctrl, visitor, path2);
    }
    if (typeof ctrl !== "symbol") {
      if (isCollection(node)) {
        path2 = Object.freeze(path2.concat(node));
        for (let i7 = 0; i7 < node.items.length; ++i7) {
          const ci = visit_(i7, node.items[i7], visitor, path2);
          if (typeof ci === "number")
            i7 = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i7, 1);
            i7 -= 1;
          }
        }
      } else if (isPair(node)) {
        path2 = Object.freeze(path2.concat(node));
        const ck = visit_("key", node.key, visitor, path2);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path2);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  async function visitAsync_(key, node, visitor, path2) {
    const ctrl = await callVisitor(key, node, visitor, path2);
    if (isNode(ctrl) || isPair(ctrl)) {
      replaceNode(key, path2, ctrl);
      return visitAsync_(key, ctrl, visitor, path2);
    }
    if (typeof ctrl !== "symbol") {
      if (isCollection(node)) {
        path2 = Object.freeze(path2.concat(node));
        for (let i7 = 0; i7 < node.items.length; ++i7) {
          const ci = await visitAsync_(i7, node.items[i7], visitor, path2);
          if (typeof ci === "number")
            i7 = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i7, 1);
            i7 -= 1;
          }
        }
      } else if (isPair(node)) {
        path2 = Object.freeze(path2.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path2);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path2);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path2) {
    if (typeof visitor === "function")
      return visitor(key, node, path2);
    if (isMap(node))
      return visitor.Map?.(key, node, path2);
    if (isSeq(node))
      return visitor.Seq?.(key, node, path2);
    if (isPair(node))
      return visitor.Pair?.(key, node, path2);
    if (isScalar(node))
      return visitor.Scalar?.(key, node, path2);
    if (isAlias(node))
      return visitor.Alias?.(key, node, path2);
    return void 0;
  }
  function replaceNode(key, path2, node) {
    const parent = path2[path2.length - 1];
    if (isCollection(parent)) {
      parent.items[key] = node;
    } else if (isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  var BREAK, SKIP, REMOVE;
  var init_visit = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/visit.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      BREAK = Symbol("break visit");
      SKIP = Symbol("skip children");
      REMOVE = Symbol("remove node");
      visit.BREAK = BREAK;
      visit.SKIP = SKIP;
      visit.REMOVE = REMOVE;
      visitAsync.BREAK = BREAK;
      visitAsync.SKIP = SKIP;
      visitAsync.REMOVE = REMOVE;
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/directives.js
  var escapeChars, escapeTagName, Directives;
  var init_directives = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/directives.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_visit();
      escapeChars = {
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
      };
      escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
      Directives = class _Directives {
        constructor(yaml, tags) {
          this.docStart = null;
          this.docEnd = false;
          this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
          this.tags = Object.assign({}, _Directives.defaultTags, tags);
        }
        clone() {
          const copy = new _Directives(this.yaml, this.tags);
          copy.docStart = this.docStart;
          return copy;
        }
        /**
         * During parsing, get a Directives instance for the current document and
         * update the stream state according to the current version's spec.
         */
        atDocument() {
          const res = new _Directives(this.yaml, this.tags);
          switch (this.yaml.version) {
            case "1.1":
              this.atNextDocument = true;
              break;
            case "1.2":
              this.atNextDocument = false;
              this.yaml = {
                explicit: _Directives.defaultYaml.explicit,
                version: "1.2"
              };
              this.tags = Object.assign({}, _Directives.defaultTags);
              break;
          }
          return res;
        }
        /**
         * @param onError - May be called even if the action was successful
         * @returns `true` on success
         */
        add(line, onError) {
          if (this.atNextDocument) {
            this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
            this.tags = Object.assign({}, _Directives.defaultTags);
            this.atNextDocument = false;
          }
          const parts = line.trim().split(/[ \t]+/);
          const name8 = parts.shift();
          switch (name8) {
            case "%TAG": {
              if (parts.length !== 2) {
                onError(0, "%TAG directive should contain exactly two parts");
                if (parts.length < 2)
                  return false;
              }
              const [handle, prefix] = parts;
              this.tags[handle] = prefix;
              return true;
            }
            case "%YAML": {
              this.yaml.explicit = true;
              if (parts.length !== 1) {
                onError(0, "%YAML directive should contain exactly one part");
                return false;
              }
              const [version2] = parts;
              if (version2 === "1.1" || version2 === "1.2") {
                this.yaml.version = version2;
                return true;
              } else {
                const isValid = /^\d+\.\d+$/.test(version2);
                onError(6, `Unsupported YAML version ${version2}`, isValid);
                return false;
              }
            }
            default:
              onError(0, `Unknown directive ${name8}`, true);
              return false;
          }
        }
        /**
         * Resolves a tag, matching handles to those defined in %TAG directives.
         *
         * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
         *   `'!local'` tag, or `null` if unresolvable.
         */
        tagName(source, onError) {
          if (source === "!")
            return "!";
          if (source[0] !== "!") {
            onError(`Not a valid tag: ${source}`);
            return null;
          }
          if (source[1] === "<") {
            const verbatim = source.slice(2, -1);
            if (verbatim === "!" || verbatim === "!!") {
              onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
              return null;
            }
            if (source[source.length - 1] !== ">")
              onError("Verbatim tags must end with a >");
            return verbatim;
          }
          const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
          if (!suffix)
            onError(`The ${source} tag has no suffix`);
          const prefix = this.tags[handle];
          if (prefix) {
            try {
              return prefix + decodeURIComponent(suffix);
            } catch (error) {
              onError(String(error));
              return null;
            }
          }
          if (handle === "!")
            return source;
          onError(`Could not resolve tag: ${source}`);
          return null;
        }
        /**
         * Given a fully resolved tag, returns its printable string form,
         * taking into account current tag prefixes and defaults.
         */
        tagString(tag2) {
          for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag2.startsWith(prefix))
              return handle + escapeTagName(tag2.substring(prefix.length));
          }
          return tag2[0] === "!" ? tag2 : `!<${tag2}>`;
        }
        toString(doc) {
          const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
          const tagEntries = Object.entries(this.tags);
          let tagNames;
          if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
            const tags = {};
            visit(doc.contents, (_key, node) => {
              if (isNode(node) && node.tag)
                tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
          } else
            tagNames = [];
          for (const [handle, prefix] of tagEntries) {
            if (handle === "!!" && prefix === "tag:yaml.org,2002:")
              continue;
            if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
              lines.push(`%TAG ${handle} ${prefix}`);
          }
          return lines.join("\n");
        }
      };
      Directives.defaultYaml = { explicit: false, version: "1.2" };
      Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/anchors.js
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root2) {
    const anchors = /* @__PURE__ */ new Set();
    visit(root2, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude) {
    for (let i7 = 1; true; ++i7) {
      const name8 = `${prefix}${i7}`;
      if (!exclude.has(name8))
        return name8;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = /* @__PURE__ */ new Map();
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        if (!prevAnchors)
          prevAnchors = anchorNames(doc);
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      /**
       * With circular references, the source node is only resolved after all
       * of its child nodes are. This is why anchors are set only after all of
       * the nodes have been created.
       */
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error = new Error("Failed to resolve repeated object (this should not happen)");
            error.source = source;
            throw error;
          }
        }
      },
      sourceObjects
    };
  }
  var init_anchors = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/anchors.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_visit();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/applyReviver.js
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i7 = 0, len = val.length; i7 < len; ++i7) {
          const v0 = val[i7];
          const v1 = applyReviver(reviver, val, String(i7), v0);
          if (v1 === void 0)
            delete val[i7];
          else if (v1 !== v0)
            val[i7] = v1;
        }
      } else if (val instanceof Map) {
        for (const k4 of Array.from(val.keys())) {
          const v0 = val.get(k4);
          const v1 = applyReviver(reviver, val, k4, v0);
          if (v1 === void 0)
            val.delete(k4);
          else if (v1 !== v0)
            val.set(k4, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === void 0)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k4, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k4, v0);
          if (v1 === void 0)
            delete val[k4];
          else if (v1 !== v0)
            val[k4] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }
  var init_applyReviver = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/applyReviver.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/toJS.js
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v6, i7) => toJS(v6, String(i7), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: void 0 };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  var init_toJS = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/toJS.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Node.js
  var NodeBase;
  var init_Node = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Node.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_applyReviver();
      init_identity();
      init_toJS();
      NodeBase = class {
        constructor(type2) {
          Object.defineProperty(this, NODE_TYPE, { value: type2 });
        }
        /** Create a copy of this node.  */
        clone() {
          const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
          if (this.range)
            copy.range = this.range.slice();
          return copy;
        }
        /** A plain JavaScript representation of this node. */
        toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
          if (!isDocument(doc))
            throw new TypeError("A document argument is required");
          const ctx = {
            anchors: /* @__PURE__ */ new Map(),
            doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
          };
          const res = toJS(this, "", ctx);
          if (typeof onAnchor === "function")
            for (const { count, res: res2 } of ctx.anchors.values())
              onAnchor(res2, count);
          return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Alias.js
  function getAliasCount(doc, node, anchors) {
    if (isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors && source && anchors.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (isCollection(node)) {
      let count = 0;
      for (const item of node.items) {
        const c7 = getAliasCount(doc, item, anchors);
        if (c7 > count)
          count = c7;
      }
      return count;
    } else if (isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors);
      const vc = getAliasCount(doc, node.value, anchors);
      return Math.max(kc, vc);
    }
    return 1;
  }
  var Alias;
  var init_Alias = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Alias.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_anchors();
      init_visit();
      init_identity();
      init_Node();
      init_toJS();
      Alias = class extends NodeBase {
        constructor(source) {
          super(ALIAS);
          this.source = source;
          Object.defineProperty(this, "tag", {
            set() {
              throw new Error("Alias nodes cannot have tags");
            }
          });
        }
        /**
         * Resolve the value of this alias within `doc`, finding the last
         * instance of the `source` anchor before this node.
         */
        resolve(doc) {
          let found = void 0;
          visit(doc, {
            Node: (_key, node) => {
              if (node === this)
                return visit.BREAK;
              if (node.anchor === this.source)
                found = node;
            }
          });
          return found;
        }
        toJSON(_arg, ctx) {
          if (!ctx)
            return { source: this.source };
          const { anchors, doc, maxAliasCount } = ctx;
          const source = this.resolve(doc);
          if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
          }
          let data = anchors.get(source);
          if (!data) {
            toJS(source, null, ctx);
            data = anchors.get(source);
          }
          if (!data || data.res === void 0) {
            const msg = "This should not happen: Alias anchor was not resolved?";
            throw new ReferenceError(msg);
          }
          if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
              data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
              const msg = "Excessive alias count indicates a resource exhaustion attack";
              throw new ReferenceError(msg);
            }
          }
          return data.res;
        }
        toString(ctx, _onComment, _onChompKeep) {
          const src3 = `*${this.source}`;
          if (ctx) {
            anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
              const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
              throw new Error(msg);
            }
            if (ctx.implicitKey)
              return `${src3} `;
          }
          return src3;
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Scalar.js
  var isScalarValue, Scalar;
  var init_Scalar = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Scalar.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_Node();
      init_toJS();
      isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
      Scalar = class extends NodeBase {
        constructor(value) {
          super(SCALAR);
          this.value = value;
        }
        toJSON(arg, ctx) {
          return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
        }
        toString() {
          return String(this.value);
        }
      };
      Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
      Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
      Scalar.PLAIN = "PLAIN";
      Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
      Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/createNode.js
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t8) => t8.tag === tagName);
      const tagObj = match.find((t8) => !t8.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t8) => t8.identify?.(value) && !t8.format);
  }
  function createNode(value, tagName, ctx) {
    if (isDocument(value))
      value = value.contents;
    if (isNode(value))
      return value;
    if (isPair(value)) {
      const map3 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
      map3.items.push(value);
      return map3;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
    let ref = void 0;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        if (!ref.anchor)
          ref.anchor = onAnchor(value);
        return new Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema4.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  var defaultTagPrefix;
  var init_createNode = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/createNode.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Alias();
      init_identity();
      init_Scalar();
      defaultTagPrefix = "tag:yaml.org,2002:";
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Collection.js
  function collectionFromPath(schema4, path2, value) {
    let v6 = value;
    for (let i7 = path2.length - 1; i7 >= 0; --i7) {
      const k4 = path2[i7];
      if (typeof k4 === "number" && Number.isInteger(k4) && k4 >= 0) {
        const a7 = [];
        a7[k4] = v6;
        v6 = a7;
      } else {
        v6 = /* @__PURE__ */ new Map([[k4, v6]]);
      }
    }
    return createNode(v6, void 0, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema: schema4,
      sourceObjects: /* @__PURE__ */ new Map()
    });
  }
  var isEmptyPath, Collection;
  var init_Collection = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Collection.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_createNode();
      init_identity();
      init_Node();
      isEmptyPath = (path2) => path2 == null || typeof path2 === "object" && !!path2[Symbol.iterator]().next().done;
      Collection = class extends NodeBase {
        constructor(type2, schema4) {
          super(type2);
          Object.defineProperty(this, "schema", {
            value: schema4,
            configurable: true,
            enumerable: false,
            writable: true
          });
        }
        /**
         * Create a copy of this collection.
         *
         * @param schema - If defined, overwrites the original's schema
         */
        clone(schema4) {
          const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
          if (schema4)
            copy.schema = schema4;
          copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
          if (this.range)
            copy.range = this.range.slice();
          return copy;
        }
        /**
         * Adds a value to the collection. For `!!map` and `!!omap` the value must
         * be a Pair instance or a `{ key, value }` object, which may not have a key
         * that already exists in the map.
         */
        addIn(path2, value) {
          if (isEmptyPath(path2))
            this.add(value);
          else {
            const [key, ...rest] = path2;
            const node = this.get(key, true);
            if (isCollection(node))
              node.addIn(rest, value);
            else if (node === void 0 && this.schema)
              this.set(key, collectionFromPath(this.schema, rest, value));
            else
              throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
          }
        }
        /**
         * Removes a value from the collection.
         * @returns `true` if the item was found and removed.
         */
        deleteIn(path2) {
          const [key, ...rest] = path2;
          if (rest.length === 0)
            return this.delete(key);
          const node = this.get(key, true);
          if (isCollection(node))
            return node.deleteIn(rest);
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
        /**
         * Returns item at `key`, or `undefined` if not found. By default unwraps
         * scalar values from their surrounding node; to disable set `keepScalar` to
         * `true` (collections are always returned intact).
         */
        getIn(path2, keepScalar) {
          const [key, ...rest] = path2;
          const node = this.get(key, true);
          if (rest.length === 0)
            return !keepScalar && isScalar(node) ? node.value : node;
          else
            return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
        }
        hasAllNullValues(allowScalar) {
          return this.items.every((node) => {
            if (!isPair(node))
              return false;
            const n8 = node.value;
            return n8 == null || allowScalar && isScalar(n8) && n8.value == null && !n8.commentBefore && !n8.comment && !n8.tag;
          });
        }
        /**
         * Checks if the collection includes a value with the key `key`.
         */
        hasIn(path2) {
          const [key, ...rest] = path2;
          if (rest.length === 0)
            return this.has(key);
          const node = this.get(key, true);
          return isCollection(node) ? node.hasIn(rest) : false;
        }
        /**
         * Sets a value in this collection. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         */
        setIn(path2, value) {
          const [key, ...rest] = path2;
          if (rest.length === 0) {
            this.set(key, value);
          } else {
            const node = this.get(key, true);
            if (isCollection(node))
              node.setIn(rest, value);
            else if (node === void 0 && this.schema)
              this.set(key, collectionFromPath(this.schema, rest, value));
            else
              throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyComment.js
  function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  var stringifyComment, lineComment;
  var init_stringifyComment = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyComment.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
      lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/foldFlowLines.js
  function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split2 = void 0;
    let prev = void 0;
    let overflow = false;
    let i7 = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i7 = consumeMoreIndentedLines(text, i7, indent.length);
      if (i7 !== -1)
        end = i7 + endStep;
    }
    for (let ch; ch = text[i7 += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i7;
        switch (text[i7 + 1]) {
          case "x":
            i7 += 3;
            break;
          case "u":
            i7 += 5;
            break;
          case "U":
            i7 += 9;
            break;
          default:
            i7 += 1;
        }
        escEnd = i7;
      }
      if (ch === "\n") {
        if (mode === FOLD_BLOCK)
          i7 = consumeMoreIndentedLines(text, i7, indent.length);
        end = i7 + indent.length + endStep;
        split2 = void 0;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
          const next = text[i7 + 1];
          if (next && next !== " " && next !== "\n" && next !== "	")
            split2 = i7;
        }
        if (i7 >= end) {
          if (split2) {
            folds.push(split2);
            end = split2 + endStep;
            split2 = void 0;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "	") {
              prev = ch;
              ch = text[i7 += 1];
              overflow = true;
            }
            const j4 = i7 > escEnd + 1 ? i7 - 2 : escStart - 1;
            if (escapedFolds[j4])
              return text;
            folds.push(j4);
            escapedFolds[j4] = true;
            end = j4 + endStep;
            split2 = void 0;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i8 = 0; i8 < folds.length; ++i8) {
      const fold = folds[i8];
      const end2 = folds[i8 + 1] || text.length;
      if (fold === 0)
        res = `
${indent}${text.slice(0, end2)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `
${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text, i7, indent) {
    let end = i7;
    let start = i7 + 1;
    let ch = text[start];
    while (ch === " " || ch === "	") {
      if (i7 < start + indent) {
        ch = text[++i7];
      } else {
        do {
          ch = text[++i7];
        } while (ch && ch !== "\n");
        end = i7;
        start = i7 + 1;
        ch = text[start];
      }
    }
    return end;
  }
  var FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED;
  var init_foldFlowLines = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/foldFlowLines.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      FOLD_FLOW = "flow";
      FOLD_BLOCK = "block";
      FOLD_QUOTED = "quoted";
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyString.js
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i7 = 0, start = 0; i7 < strLen; ++i7) {
      if (str[i7] === "\n") {
        if (i7 - start > limit)
          return true;
        start = i7 + 1;
        if (strLen - start <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i7 = 0, ch = json[i7]; ch; ch = json[++i7]) {
      if (ch === " " && json[i7 + 1] === "\\" && json[i7 + 2] === "n") {
        str += json.slice(start, i7) + "\\ ";
        i7 += 1;
        start = i7;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i7 + 1]) {
          case "u":
            {
              str += json.slice(start, i7);
              const code9 = json.substr(i7 + 2, 4);
              switch (code9) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code9.substr(0, 2) === "00")
                    str += "\\x" + code9.substr(2);
                  else
                    str += json.substr(i7, 6);
              }
              i7 += 5;
              start = i7 + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i7 + 2] === '"' || json.length < minMultiLineLength) {
              i7 += 1;
            } else {
              str += json.slice(start, i7) + "\n\n";
              while (json[i7 + 2] === "\\" && json[i7 + 3] === "n" && json[i7 + 4] !== '"') {
                str += "\n";
                i7 += 2;
              }
              str += indent;
              if (json[i7 + 2] === " ")
                str += "\\";
              i7 += 1;
              start = i7 + 1;
            }
            break;
          default:
            i7 += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  function blockString({ comment, type: type2, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type2 === Scalar.BLOCK_FOLDED ? false : type2 === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? "|\n" : ">\n";
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== "\n" && ch !== "	" && ch !== " ")
        break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf("\n");
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end) {
      value = value.slice(0, -end.length);
      if (end[end.length - 1] === "\n")
        end = end.slice(0, -1);
      end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === "\n")
        startNlPos = startEnd;
      else
        break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value = value.substring(start.length);
      start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (literal) {
      value = value.replace(/\n+/g, `$&${indent}`);
      return `${header}
${indent}${start}${value}${end}`;
    }
    value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
    return `${header}
${indent}${body}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type: type2, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type2 !== Scalar.PLAIN && value.includes("\n")) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag2) => tag2.default && tag2.tag !== "tag:yaml.org,2002:str" && tag2.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type: type2 } = item;
    if (type2 !== Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type2 = Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.BLOCK_FOLDED:
        case Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type2);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t8 = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t8);
      if (res === null)
        throw new Error(`Unsupported default string type ${t8}`);
    }
    return res;
  }
  var getFoldOptions, containsDocumentMarker, blockEndNewlines;
  var init_stringifyString = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyString.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Scalar();
      init_foldFlowLines();
      getFoldOptions = (ctx, isBlock2) => ({
        indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
        lineWidth: ctx.options.lineWidth,
        minContentWidth: ctx.options.minContentWidth
      });
      containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
      try {
        blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
      } catch {
        blockEndNewlines = /\n+(?!\n|$)/g;
      }
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringify.js
  function createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: /* @__PURE__ */ new Set(),
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match = tags.filter((t8) => t8.tag === item.tag);
      if (match.length > 0)
        return match.find((t8) => t8.format === item.format) ?? match[0];
    }
    let tagObj = void 0;
    let obj;
    if (isScalar(item)) {
      obj = item.value;
      const match = tags.filter((t8) => t8.identify?.(obj));
      tagObj = match.find((t8) => t8.format === item.format) ?? match.find((t8) => !t8.format);
    } else {
      obj = item;
      tagObj = tags.find((t8) => t8.nodeClass && obj instanceof t8.nodeClass);
    }
    if (!tagObj) {
      const name8 = obj?.constructor?.name ?? typeof obj;
      throw new Error(`Tag not resolved for ${name8} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
    if (anchor && anchorIsValid(anchor)) {
      anchors.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag2 = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag2)
      props.push(doc.directives.tagString(tag2));
    return props.join(" ");
  }
  function stringify(item, ctx, onComment, onChompKeep) {
    if (isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = void 0;
    const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o8) => tagObj = o8 });
    if (!tagObj)
      tagObj = getTagObject(ctx.doc.schema.tags, node);
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  var init_stringify = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringify.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_anchors();
      init_identity();
      init_stringifyComment();
      init_stringifyString();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyPair.js
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (isCollection(key) || !isNode(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? "\n" : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === "\n")
          ws = "\n\n";
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf("\n");
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === "\n") {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }
  var init_stringifyPair = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyPair.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_Scalar();
      init_stringify();
      init_stringifyComment();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/log.js
  function warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof process !== "undefined" && process.emitWarning)
        process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  var init_log = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/log.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
  function addPairToJSMap(ctx, map3, { key, value }) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) {
      value = isAlias(value) ? value.resolve(ctx.doc) : value;
      if (isSeq(value))
        for (const it of value.items)
          mergeToJSMap(ctx, map3, it);
      else if (Array.isArray(value))
        for (const it of value)
          mergeToJSMap(ctx, map3, it);
      else
        mergeToJSMap(ctx, map3, value);
    } else {
      const jsKey = toJS(key, "", ctx);
      if (map3 instanceof Map) {
        map3.set(jsKey, toJS(value, jsKey, ctx));
      } else if (map3 instanceof Set) {
        map3.add(jsKey);
      } else {
        const stringKey2 = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS(value, stringKey2, ctx);
        if (stringKey2 in map3)
          Object.defineProperty(map3, stringKey2, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map3[stringKey2] = jsValue;
      }
    }
    return map3;
  }
  function mergeToJSMap(ctx, map3, value) {
    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map3 instanceof Map) {
        if (!map3.has(key))
          map3.set(key, value2);
      } else if (map3 instanceof Set) {
        map3.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map3, key)) {
        Object.defineProperty(map3, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map3;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (isNode(key) && ctx?.doc) {
      const strCtx = createStringifyContext(ctx.doc, {});
      strCtx.anchors = /* @__PURE__ */ new Set();
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  var MERGE_KEY, isMergeKey;
  var init_addPairToJSMap = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_log();
      init_stringify();
      init_identity();
      init_Scalar();
      init_toJS();
      MERGE_KEY = "<<";
      isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Pair.js
  function createPair(key, value, ctx) {
    const k4 = createNode(key, void 0, ctx);
    const v6 = createNode(value, void 0, ctx);
    return new Pair(k4, v6);
  }
  var Pair;
  var init_Pair = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Pair.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_createNode();
      init_stringifyPair();
      init_addPairToJSMap();
      init_identity();
      Pair = class _Pair {
        constructor(key, value = null) {
          Object.defineProperty(this, NODE_TYPE, { value: PAIR });
          this.key = key;
          this.value = value;
        }
        clone(schema4) {
          let { key, value } = this;
          if (isNode(key))
            key = key.clone(schema4);
          if (isNode(value))
            value = value.clone(schema4);
          return new _Pair(key, value);
        }
        toJSON(_4, ctx) {
          const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
          return addPairToJSMap(ctx, pair, this);
        }
        toString(ctx, onComment, onChompKeep) {
          return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyCollection.js
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify4(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i7 = 0; i7 < items.length; ++i7) {
      const item = items[i7];
      let comment2 = null;
      if (isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (isPair(item)) {
        const ik = isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i7 = 1; i7 < lines.length; ++i7) {
        const line = lines[i7];
        str += line ? `
${indent}${line}` : "\n";
      }
    }
    if (comment) {
      str += "\n" + indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i7 = 0; i7 < items.length; ++i7) {
      const item = items[i7];
      let comment = null;
      if (isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment = item.comment;
      } else if (isPair(item)) {
        const ik = isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment = ik.comment;
        }
      }
      if (comment)
        reqNewline = true;
      let str = stringify(item, itemCtx, () => comment = null);
      if (i7 < items.length - 1)
        str += ",";
      if (comment)
        str += lineComment(str, itemIndent, commentString(comment));
      if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
      return start + end;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : "\n";
        return `${str}
${indent}${end}`;
      } else {
        return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      }
    }
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }
  var init_stringifyCollection = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyCollection.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_stringify();
      init_stringifyComment();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/YAMLMap.js
  function findPair(items, key) {
    const k4 = isScalar(key) ? key.value : key;
    for (const it of items) {
      if (isPair(it)) {
        if (it.key === key || it.key === k4)
          return it;
        if (isScalar(it.key) && it.key.value === k4)
          return it;
      }
    }
    return void 0;
  }
  var YAMLMap;
  var init_YAMLMap = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/YAMLMap.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_stringifyCollection();
      init_addPairToJSMap();
      init_Collection();
      init_identity();
      init_Pair();
      init_Scalar();
      YAMLMap = class extends Collection {
        static get tagName() {
          return "tag:yaml.org,2002:map";
        }
        constructor(schema4) {
          super(MAP, schema4);
          this.items = [];
        }
        /**
         * A generic collection parsing method that can be extended
         * to other node classes that inherit from YAMLMap
         */
        static from(schema4, obj, ctx) {
          const { keepUndefined, replacer } = ctx;
          const map3 = new this(schema4);
          const add = (key, value) => {
            if (typeof replacer === "function")
              value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
              return;
            if (value !== void 0 || keepUndefined)
              map3.items.push(createPair(key, value, ctx));
          };
          if (obj instanceof Map) {
            for (const [key, value] of obj)
              add(key, value);
          } else if (obj && typeof obj === "object") {
            for (const key of Object.keys(obj))
              add(key, obj[key]);
          }
          if (typeof schema4.sortMapEntries === "function") {
            map3.items.sort(schema4.sortMapEntries);
          }
          return map3;
        }
        /**
         * Adds a value to the collection.
         *
         * @param overwrite - If not set `true`, using a key that is already in the
         *   collection will throw. Otherwise, overwrites the previous value.
         */
        add(pair, overwrite) {
          let _pair;
          if (isPair(pair))
            _pair = pair;
          else if (!pair || typeof pair !== "object" || !("key" in pair)) {
            _pair = new Pair(pair, pair?.value);
          } else
            _pair = new Pair(pair.key, pair.value);
          const prev = findPair(this.items, _pair.key);
          const sortEntries = this.schema?.sortMapEntries;
          if (prev) {
            if (!overwrite)
              throw new Error(`Key ${_pair.key} already set`);
            if (isScalar(prev.value) && isScalarValue(_pair.value))
              prev.value.value = _pair.value;
            else
              prev.value = _pair.value;
          } else if (sortEntries) {
            const i7 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
            if (i7 === -1)
              this.items.push(_pair);
            else
              this.items.splice(i7, 0, _pair);
          } else {
            this.items.push(_pair);
          }
        }
        delete(key) {
          const it = findPair(this.items, key);
          if (!it)
            return false;
          const del2 = this.items.splice(this.items.indexOf(it), 1);
          return del2.length > 0;
        }
        get(key, keepScalar) {
          const it = findPair(this.items, key);
          const node = it?.value;
          return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
        }
        has(key) {
          return !!findPair(this.items, key);
        }
        set(key, value) {
          this.add(new Pair(key, value), true);
        }
        /**
         * @param ctx - Conversion context, originally set in Document#toJS()
         * @param {Class} Type - If set, forces the returned collection type
         * @returns Instance of Type, Map, or Object
         */
        toJSON(_4, ctx, Type3) {
          const map3 = Type3 ? new Type3() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
          if (ctx?.onCreate)
            ctx.onCreate(map3);
          for (const item of this.items)
            addPairToJSMap(ctx, map3, item);
          return map3;
        }
        toString(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          for (const item of this.items) {
            if (!isPair(item))
              throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
          }
          if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
          return stringifyCollection(this, ctx, {
            blockItemPrefix: "",
            flowChars: { start: "{", end: "}" },
            itemIndent: ctx.indent || "",
            onChompKeep,
            onComment
          });
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/map.js
  var map;
  var init_map = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/map.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_YAMLMap();
      map = {
        collection: "map",
        default: true,
        nodeClass: YAMLMap,
        tag: "tag:yaml.org,2002:map",
        resolve(map3, onError) {
          if (!isMap(map3))
            onError("Expected a mapping for this tag");
          return map3;
        },
        createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/YAMLSeq.js
  function asItemIndex(key) {
    let idx = isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  var YAMLSeq;
  var init_YAMLSeq = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/YAMLSeq.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_createNode();
      init_stringifyCollection();
      init_Collection();
      init_identity();
      init_Scalar();
      init_toJS();
      YAMLSeq = class extends Collection {
        static get tagName() {
          return "tag:yaml.org,2002:seq";
        }
        constructor(schema4) {
          super(SEQ, schema4);
          this.items = [];
        }
        add(value) {
          this.items.push(value);
        }
        /**
         * Removes a value from the collection.
         *
         * `key` must contain a representation of an integer for this to succeed.
         * It may be wrapped in a `Scalar`.
         *
         * @returns `true` if the item was found and removed.
         */
        delete(key) {
          const idx = asItemIndex(key);
          if (typeof idx !== "number")
            return false;
          const del2 = this.items.splice(idx, 1);
          return del2.length > 0;
        }
        get(key, keepScalar) {
          const idx = asItemIndex(key);
          if (typeof idx !== "number")
            return void 0;
          const it = this.items[idx];
          return !keepScalar && isScalar(it) ? it.value : it;
        }
        /**
         * Checks if the collection includes a value with the key `key`.
         *
         * `key` must contain a representation of an integer for this to succeed.
         * It may be wrapped in a `Scalar`.
         */
        has(key) {
          const idx = asItemIndex(key);
          return typeof idx === "number" && idx < this.items.length;
        }
        /**
         * Sets a value in this collection. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         *
         * If `key` does not contain a representation of an integer, this will throw.
         * It may be wrapped in a `Scalar`.
         */
        set(key, value) {
          const idx = asItemIndex(key);
          if (typeof idx !== "number")
            throw new Error(`Expected a valid index, not ${key}.`);
          const prev = this.items[idx];
          if (isScalar(prev) && isScalarValue(value))
            prev.value = value;
          else
            this.items[idx] = value;
        }
        toJSON(_4, ctx) {
          const seq2 = [];
          if (ctx?.onCreate)
            ctx.onCreate(seq2);
          let i7 = 0;
          for (const item of this.items)
            seq2.push(toJS(item, String(i7++), ctx));
          return seq2;
        }
        toString(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          return stringifyCollection(this, ctx, {
            blockItemPrefix: "- ",
            flowChars: { start: "[", end: "]" },
            itemIndent: (ctx.indent || "") + "  ",
            onChompKeep,
            onComment
          });
        }
        static from(schema4, obj, ctx) {
          const { replacer } = ctx;
          const seq2 = new this(schema4);
          if (obj && Symbol.iterator in Object(obj)) {
            let i7 = 0;
            for (let it of obj) {
              if (typeof replacer === "function") {
                const key = obj instanceof Set ? it : String(i7++);
                it = replacer.call(obj, key, it);
              }
              seq2.items.push(createNode(it, void 0, ctx));
            }
          }
          return seq2;
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/seq.js
  var seq;
  var init_seq = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/seq.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_YAMLSeq();
      seq = {
        collection: "seq",
        default: true,
        nodeClass: YAMLSeq,
        tag: "tag:yaml.org,2002:seq",
        resolve(seq2, onError) {
          if (!isSeq(seq2))
            onError("Expected a sequence for this tag");
          return seq2;
        },
        createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/string.js
  var string;
  var init_string = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/string.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_stringifyString();
      string = {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify(item, ctx, onComment, onChompKeep) {
          ctx = Object.assign({ actualString: true }, ctx);
          return stringifyString(item, ctx, onComment, onChompKeep);
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/null.js
  var nullTag;
  var init_null = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/null.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Scalar();
      nullTag = {
        identify: (value) => value == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^(?:~|[Nn]ull|NULL)?$/,
        resolve: () => new Scalar(null),
        stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/bool.js
  var boolTag;
  var init_bool = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/bool.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Scalar();
      boolTag = {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
        resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
        stringify({ source, value }, ctx) {
          if (source && boolTag.test.test(source)) {
            const sv = source[0] === "t" || source[0] === "T";
            if (value === sv)
              return source;
          }
          return value ? ctx.options.trueStr : ctx.options.falseStr;
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyNumber.js
  function stringifyNumber({ format: format8, minFractionDigits, tag: tag2, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n8 = JSON.stringify(value);
    if (!format8 && minFractionDigits && (!tag2 || tag2 === "tag:yaml.org,2002:float") && /^\d/.test(n8)) {
      let i7 = n8.indexOf(".");
      if (i7 < 0) {
        i7 = n8.length;
        n8 += ".";
      }
      let d6 = minFractionDigits - (n8.length - i7 - 1);
      while (d6-- > 0)
        n8 += "0";
    }
    return n8;
  }
  var init_stringifyNumber = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyNumber.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/float.js
  var floatNaN, floatExp, float;
  var init_float = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/float.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Scalar();
      init_stringifyNumber();
      floatNaN = {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
        resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
        stringify: stringifyNumber
      };
      floatExp = {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        format: "EXP",
        test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
        resolve: (str) => parseFloat(str),
        stringify(node) {
          const num = Number(node.value);
          return isFinite(num) ? num.toExponential() : stringifyNumber(node);
        }
      };
      float = {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
        resolve(str) {
          const node = new Scalar(parseFloat(str));
          const dot = str.indexOf(".");
          if (dot !== -1 && str[str.length - 1] === "0")
            node.minFractionDigits = str.length - dot - 1;
          return node;
        },
        stringify: stringifyNumber
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/int.js
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber(node);
  }
  var intIdentify, intResolve, intOct, int, intHex;
  var init_int = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/int.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_stringifyNumber();
      intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
      intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
      intOct = {
        identify: (value) => intIdentify(value) && value >= 0,
        default: true,
        tag: "tag:yaml.org,2002:int",
        format: "OCT",
        test: /^0o[0-7]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
        stringify: (node) => intStringify(node, 8, "0o")
      };
      int = {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^[-+]?[0-9]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
        stringify: stringifyNumber
      };
      intHex = {
        identify: (value) => intIdentify(value) && value >= 0,
        default: true,
        tag: "tag:yaml.org,2002:int",
        format: "HEX",
        test: /^0x[0-9a-fA-F]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
        stringify: (node) => intStringify(node, 16, "0x")
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/schema.js
  var schema;
  var init_schema = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/schema.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_map();
      init_null();
      init_seq();
      init_string();
      init_bool();
      init_float();
      init_int();
      schema = [
        map,
        seq,
        string,
        nullTag,
        boolTag,
        intOct,
        int,
        intHex,
        floatNaN,
        floatExp,
        float
      ];
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/json/schema.js
  function intIdentify2(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON, jsonScalars, jsonError, schema2;
  var init_schema2 = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/json/schema.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Scalar();
      init_map();
      init_seq();
      stringifyJSON = ({ value }) => JSON.stringify(value);
      jsonScalars = [
        {
          identify: (value) => typeof value === "string",
          default: true,
          tag: "tag:yaml.org,2002:str",
          resolve: (str) => str,
          stringify: stringifyJSON
        },
        {
          identify: (value) => value == null,
          createNode: () => new Scalar(null),
          default: true,
          tag: "tag:yaml.org,2002:null",
          test: /^null$/,
          resolve: () => null,
          stringify: stringifyJSON
        },
        {
          identify: (value) => typeof value === "boolean",
          default: true,
          tag: "tag:yaml.org,2002:bool",
          test: /^true|false$/,
          resolve: (str) => str === "true",
          stringify: stringifyJSON
        },
        {
          identify: intIdentify2,
          default: true,
          tag: "tag:yaml.org,2002:int",
          test: /^-?(?:0|[1-9][0-9]*)$/,
          resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
          stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
        },
        {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
          resolve: (str) => parseFloat(str),
          stringify: stringifyJSON
        }
      ];
      jsonError = {
        default: true,
        tag: "",
        test: /^/,
        resolve(str, onError) {
          onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
          return str;
        }
      };
      schema2 = [map, seq].concat(jsonScalars, jsonError);
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
  var binary;
  var init_binary = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Scalar();
      init_stringifyString();
      binary = {
        identify: (value) => value instanceof Uint8Array,
        // Buffer inherits from Uint8Array
        default: false,
        tag: "tag:yaml.org,2002:binary",
        /**
         * Returns a Buffer in node and an Uint8Array in browsers
         *
         * To use the resulting buffer as an image, you'll want to do something like:
         *
         *   const blob = new Blob([buffer], { type: 'image/jpeg' })
         *   document.querySelector('#photo').src = URL.createObjectURL(blob)
         */
        resolve(src3, onError) {
          if (typeof Buffer === "function") {
            return Buffer.from(src3, "base64");
          } else if (typeof atob === "function") {
            const str = atob(src3.replace(/[\n\r]/g, ""));
            const buffer4 = new Uint8Array(str.length);
            for (let i7 = 0; i7 < str.length; ++i7)
              buffer4[i7] = str.charCodeAt(i7);
            return buffer4;
          } else {
            onError("This environment does not support reading binary tags; either Buffer or atob is required");
            return src3;
          }
        },
        stringify({ comment, type: type2, value }, ctx, onComment, onChompKeep) {
          const buf3 = value;
          let str;
          if (typeof Buffer === "function") {
            str = buf3 instanceof Buffer ? buf3.toString("base64") : Buffer.from(buf3.buffer).toString("base64");
          } else if (typeof btoa === "function") {
            let s6 = "";
            for (let i7 = 0; i7 < buf3.length; ++i7)
              s6 += String.fromCharCode(buf3[i7]);
            str = btoa(s6);
          } else {
            throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
          }
          if (!type2)
            type2 = Scalar.BLOCK_LITERAL;
          if (type2 !== Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n8 = Math.ceil(str.length / lineWidth);
            const lines = new Array(n8);
            for (let i7 = 0, o8 = 0; i7 < n8; ++i7, o8 += lineWidth) {
              lines[i7] = str.substr(o8, lineWidth);
            }
            str = lines.join(type2 === Scalar.BLOCK_LITERAL ? "\n" : " ");
          }
          return stringifyString({ comment, type: type2, value: str }, ctx, onComment, onChompKeep);
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
  function resolvePairs(seq2, onError) {
    if (isSeq(seq2)) {
      for (let i7 = 0; i7 < seq2.items.length; ++i7) {
        let item = seq2.items[i7];
        if (isPair(item))
          continue;
        else if (isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair(new Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq2.items[i7] = isPair(item) ? item : new Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq2;
  }
  function createPairs(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq(schema4);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i7 = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i7++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs;
  var init_pairs = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_Pair();
      init_Scalar();
      init_YAMLSeq();
      pairs = {
        collection: "seq",
        default: false,
        tag: "tag:yaml.org,2002:pairs",
        resolve: resolvePairs,
        createNode: createPairs
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
  var YAMLOMap, omap;
  var init_omap = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_toJS();
      init_YAMLMap();
      init_YAMLSeq();
      init_pairs();
      YAMLOMap = class _YAMLOMap extends YAMLSeq {
        constructor() {
          super();
          this.add = YAMLMap.prototype.add.bind(this);
          this.delete = YAMLMap.prototype.delete.bind(this);
          this.get = YAMLMap.prototype.get.bind(this);
          this.has = YAMLMap.prototype.has.bind(this);
          this.set = YAMLMap.prototype.set.bind(this);
          this.tag = _YAMLOMap.tag;
        }
        /**
         * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
         * but TypeScript won't allow widening the signature of a child method.
         */
        toJSON(_4, ctx) {
          if (!ctx)
            return super.toJSON(_4);
          const map3 = /* @__PURE__ */ new Map();
          if (ctx?.onCreate)
            ctx.onCreate(map3);
          for (const pair of this.items) {
            let key, value;
            if (isPair(pair)) {
              key = toJS(pair.key, "", ctx);
              value = toJS(pair.value, key, ctx);
            } else {
              key = toJS(pair, "", ctx);
            }
            if (map3.has(key))
              throw new Error("Ordered maps must not include duplicate keys");
            map3.set(key, value);
          }
          return map3;
        }
        static from(schema4, iterable, ctx) {
          const pairs2 = createPairs(schema4, iterable, ctx);
          const omap2 = new this();
          omap2.items = pairs2.items;
          return omap2;
        }
      };
      YAMLOMap.tag = "tag:yaml.org,2002:omap";
      omap = {
        collection: "seq",
        identify: (value) => value instanceof Map,
        nodeClass: YAMLOMap,
        default: false,
        tag: "tag:yaml.org,2002:omap",
        resolve(seq2, onError) {
          const pairs2 = resolvePairs(seq2, onError);
          const seenKeys = [];
          for (const { key } of pairs2.items) {
            if (isScalar(key)) {
              if (seenKeys.includes(key.value)) {
                onError(`Ordered maps must not include duplicate keys: ${key.value}`);
              } else {
                seenKeys.push(key.value);
              }
            }
          }
          return Object.assign(new YAMLOMap(), pairs2);
        },
        createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag, falseTag;
  var init_bool2 = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Scalar();
      trueTag = {
        identify: (value) => value === true,
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
        resolve: () => new Scalar(true),
        stringify: boolStringify
      };
      falseTag = {
        identify: (value) => value === false,
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
        resolve: () => new Scalar(false),
        stringify: boolStringify
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
  var floatNaN2, floatExp2, float2;
  var init_float2 = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Scalar();
      init_stringifyNumber();
      floatNaN2 = {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
        resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
        stringify: stringifyNumber
      };
      floatExp2 = {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        format: "EXP",
        test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
        resolve: (str) => parseFloat(str.replace(/_/g, "")),
        stringify(node) {
          const num = Number(node.value);
          return isFinite(num) ? num.toExponential() : stringifyNumber(node);
        }
      };
      float2 = {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
        resolve(str) {
          const node = new Scalar(parseFloat(str.replace(/_/g, "")));
          const dot = str.indexOf(".");
          if (dot !== -1) {
            const f7 = str.substring(dot + 1).replace(/_/g, "");
            if (f7[f7.length - 1] === "0")
              node.minFractionDigits = f7.length;
          }
          return node;
        },
        stringify: stringifyNumber
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
  function intResolve2(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n9 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n9 : n9;
    }
    const n8 = parseInt(str, radix);
    return sign === "-" ? -1 * n8 : n8;
  }
  function intStringify2(node, radix, prefix) {
    const { value } = node;
    if (intIdentify3(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber(node);
  }
  var intIdentify3, intBin, intOct2, int2, intHex2;
  var init_int2 = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_stringifyNumber();
      intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
      intBin = {
        identify: intIdentify3,
        default: true,
        tag: "tag:yaml.org,2002:int",
        format: "BIN",
        test: /^[-+]?0b[0-1_]+$/,
        resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
        stringify: (node) => intStringify2(node, 2, "0b")
      };
      intOct2 = {
        identify: intIdentify3,
        default: true,
        tag: "tag:yaml.org,2002:int",
        format: "OCT",
        test: /^[-+]?0[0-7_]+$/,
        resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
        stringify: (node) => intStringify2(node, 8, "0")
      };
      int2 = {
        identify: intIdentify3,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^[-+]?[0-9][0-9_]*$/,
        resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
        stringify: stringifyNumber
      };
      intHex2 = {
        identify: intIdentify3,
        default: true,
        tag: "tag:yaml.org,2002:int",
        format: "HEX",
        test: /^[-+]?0x[0-9a-fA-F_]+$/,
        resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
        stringify: (node) => intStringify2(node, 16, "0x")
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
  var YAMLSet, set;
  var init_set = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_Pair();
      init_YAMLMap();
      YAMLSet = class _YAMLSet extends YAMLMap {
        constructor(schema4) {
          super(schema4);
          this.tag = _YAMLSet.tag;
        }
        add(key) {
          let pair;
          if (isPair(key))
            pair = key;
          else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
            pair = new Pair(key.key, null);
          else
            pair = new Pair(key, null);
          const prev = findPair(this.items, pair.key);
          if (!prev)
            this.items.push(pair);
        }
        /**
         * If `keepPair` is `true`, returns the Pair matching `key`.
         * Otherwise, returns the value of that Pair's key.
         */
        get(key, keepPair) {
          const pair = findPair(this.items, key);
          return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
        }
        set(key, value) {
          if (typeof value !== "boolean")
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
          const prev = findPair(this.items, key);
          if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
          } else if (!prev && value) {
            this.items.push(new Pair(key));
          }
        }
        toJSON(_4, ctx) {
          return super.toJSON(_4, ctx, Set);
        }
        toString(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
          else
            throw new Error("Set items must all have null values");
        }
        static from(schema4, iterable, ctx) {
          const { replacer } = ctx;
          const set4 = new this(schema4);
          if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
              if (typeof replacer === "function")
                value = replacer.call(iterable, value, value);
              set4.items.push(createPair(value, null, ctx));
            }
          return set4;
        }
      };
      YAMLSet.tag = "tag:yaml.org,2002:set";
      set = {
        collection: "map",
        identify: (value) => value instanceof Set,
        nodeClass: YAMLSet,
        default: false,
        tag: "tag:yaml.org,2002:set",
        createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
        resolve(map3, onError) {
          if (isMap(map3)) {
            if (map3.hasAllNullValues(true))
              return Object.assign(new YAMLSet(), map3);
            else
              onError("Set items must all have null values");
          } else
            onError("Expected a mapping for this tag");
          return map3;
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
  function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n8) => asBigInt ? BigInt(n8) : Number(n8);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p7) => res2 * num(60) + num(p7), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n8) => n8;
    if (typeof value === "bigint")
      num = (n8) => BigInt(n8);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n8) => String(n8).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime, floatTime, timestamp;
  var init_timestamp = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_stringifyNumber();
      intTime = {
        identify: (value) => typeof value === "bigint" || Number.isInteger(value),
        default: true,
        tag: "tag:yaml.org,2002:int",
        format: "TIME",
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
        resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
        stringify: stringifySexagesimal
      };
      floatTime = {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        format: "TIME",
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
        resolve: (str) => parseSexagesimal(str, false),
        stringify: stringifySexagesimal
      };
      timestamp = {
        identify: (value) => value instanceof Date,
        default: true,
        tag: "tag:yaml.org,2002:timestamp",
        // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
        // may be omitted altogether, resulting in a date format. In such a case, the time part is
        // assumed to be 00:00:00Z (start of day, UTC).
        test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
        resolve(str) {
          const match = str.match(timestamp.test);
          if (!match)
            throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
          const [, year, month, day, hour, minute, second] = match.map(Number);
          const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
          let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
          const tz = match[8];
          if (tz && tz !== "Z") {
            let d6 = parseSexagesimal(tz, false);
            if (Math.abs(d6) < 30)
              d6 *= 60;
            date -= 6e4 * d6;
          }
          return new Date(date);
        },
        stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
  var schema3;
  var init_schema3 = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_map();
      init_null();
      init_seq();
      init_string();
      init_binary();
      init_bool2();
      init_float2();
      init_int2();
      init_omap();
      init_pairs();
      init_set();
      init_timestamp();
      schema3 = [
        map,
        seq,
        string,
        nullTag,
        trueTag,
        falseTag,
        intBin,
        intOct2,
        int2,
        intHex2,
        floatNaN2,
        floatExp2,
        float2,
        binary,
        omap,
        pairs,
        set,
        intTime,
        floatTime,
        timestamp
      ];
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/tags.js
  function getTags(customTags, schemaName) {
    let tags = schemas.get(schemaName);
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag2 of customTags)
        tags = tags.concat(tag2);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    return tags.map((tag2) => {
      if (typeof tag2 !== "string")
        return tag2;
      const tagObj = tagsByName[tag2];
      if (tagObj)
        return tagObj;
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag "${tag2}"; use one of ${keys}`);
    });
  }
  var schemas, tagsByName, coreKnownTags;
  var init_tags = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/tags.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_map();
      init_null();
      init_seq();
      init_string();
      init_bool();
      init_float();
      init_int();
      init_schema();
      init_schema2();
      init_binary();
      init_omap();
      init_pairs();
      init_schema3();
      init_set();
      init_timestamp();
      schemas = /* @__PURE__ */ new Map([
        ["core", schema],
        ["failsafe", [map, seq, string]],
        ["json", schema2],
        ["yaml11", schema3],
        ["yaml-1.1", schema3]
      ]);
      tagsByName = {
        binary,
        bool: boolTag,
        float,
        floatExp,
        floatNaN,
        floatTime,
        int,
        intHex,
        intOct,
        intTime,
        map,
        null: nullTag,
        omap,
        pairs,
        seq,
        set,
        timestamp
      };
      coreKnownTags = {
        "tag:yaml.org,2002:binary": binary,
        "tag:yaml.org,2002:omap": omap,
        "tag:yaml.org,2002:pairs": pairs,
        "tag:yaml.org,2002:set": set,
        "tag:yaml.org,2002:timestamp": timestamp
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/Schema.js
  var sortMapEntriesByKey, Schema;
  var init_Schema = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/Schema.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_map();
      init_seq();
      init_string();
      init_tags();
      sortMapEntriesByKey = (a7, b5) => a7.key < b5.key ? -1 : a7.key > b5.key ? 1 : 0;
      Schema = class _Schema {
        constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema4, sortMapEntries: sortMapEntries3, toStringDefaults }) {
          this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
          this.merge = !!merge2;
          this.name = typeof schema4 === "string" && schema4 || "core";
          this.knownTags = resolveKnownTags ? coreKnownTags : {};
          this.tags = getTags(customTags, this.name);
          this.toStringOptions = toStringDefaults ?? null;
          Object.defineProperty(this, MAP, { value: map });
          Object.defineProperty(this, SCALAR, { value: string });
          Object.defineProperty(this, SEQ, { value: seq });
          this.sortMapEntries = typeof sortMapEntries3 === "function" ? sortMapEntries3 : sortMapEntries3 === true ? sortMapEntriesByKey : null;
        }
        clone() {
          const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
          copy.tags = this.tags.slice();
          return copy;
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyDocument.js
  function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
      let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes("\n")) {
          lines.push("...");
          lines.push(indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(indentComment(commentString(dc), ""));
      }
    }
    return lines.join("\n") + "\n";
  }
  var init_stringifyDocument = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyDocument.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_stringify();
      init_stringifyComment();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/Document.js
  function assertCollection(contents) {
    if (isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  var Document;
  var init_Document = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/Document.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Alias();
      init_Collection();
      init_identity();
      init_Pair();
      init_toJS();
      init_Schema();
      init_stringifyDocument();
      init_anchors();
      init_applyReviver();
      init_createNode();
      init_directives();
      Document = class _Document {
        constructor(value, replacer, options) {
          this.commentBefore = null;
          this.comment = null;
          this.errors = [];
          this.warnings = [];
          Object.defineProperty(this, NODE_TYPE, { value: DOC });
          let _replacer = null;
          if (typeof replacer === "function" || Array.isArray(replacer)) {
            _replacer = replacer;
          } else if (options === void 0 && replacer) {
            options = replacer;
            replacer = void 0;
          }
          const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: "warn",
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: "1.2"
          }, options);
          this.options = opt;
          let { version: version2 } = opt;
          if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
              version2 = this.directives.yaml.version;
          } else
            this.directives = new Directives({ version: version2 });
          this.setSchema(version2, options);
          this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
        }
        /**
         * Create a deep copy of this Document and its contents.
         *
         * Custom Node values that inherit from `Object` still refer to their original instances.
         */
        clone() {
          const copy = Object.create(_Document.prototype, {
            [NODE_TYPE]: { value: DOC }
          });
          copy.commentBefore = this.commentBefore;
          copy.comment = this.comment;
          copy.errors = this.errors.slice();
          copy.warnings = this.warnings.slice();
          copy.options = Object.assign({}, this.options);
          if (this.directives)
            copy.directives = this.directives.clone();
          copy.schema = this.schema.clone();
          copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
          if (this.range)
            copy.range = this.range.slice();
          return copy;
        }
        /** Adds a value to the document. */
        add(value) {
          if (assertCollection(this.contents))
            this.contents.add(value);
        }
        /** Adds a value to the document. */
        addIn(path2, value) {
          if (assertCollection(this.contents))
            this.contents.addIn(path2, value);
        }
        /**
         * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
         *
         * If `node` already has an anchor, `name` is ignored.
         * Otherwise, the `node.anchor` value will be set to `name`,
         * or if an anchor with that name is already present in the document,
         * `name` will be used as a prefix for a new unique anchor.
         * If `name` is undefined, the generated anchor will use 'a' as a prefix.
         */
        createAlias(node, name8) {
          if (!node.anchor) {
            const prev = anchorNames(this);
            node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            !name8 || prev.has(name8) ? findNewAnchor(name8 || "a", prev) : name8;
          }
          return new Alias(node.anchor);
        }
        createNode(value, replacer, options) {
          let _replacer = void 0;
          if (typeof replacer === "function") {
            value = replacer.call({ "": value }, "", value);
            _replacer = replacer;
          } else if (Array.isArray(replacer)) {
            const keyToStr = (v6) => typeof v6 === "number" || v6 instanceof String || v6 instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
              replacer = replacer.concat(asStr);
            _replacer = replacer;
          } else if (options === void 0 && replacer) {
            options = replacer;
            replacer = void 0;
          }
          const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag2 } = options ?? {};
          const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
            this,
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            anchorPrefix || "a"
          );
          const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
          };
          const node = createNode(value, tag2, ctx);
          if (flow && isCollection(node))
            node.flow = true;
          setAnchors();
          return node;
        }
        /**
         * Convert a key and a value into a `Pair` using the current schema,
         * recursively wrapping all values as `Scalar` or `Collection` nodes.
         */
        createPair(key, value, options = {}) {
          const k4 = this.createNode(key, null, options);
          const v6 = this.createNode(value, null, options);
          return new Pair(k4, v6);
        }
        /**
         * Removes a value from the document.
         * @returns `true` if the item was found and removed.
         */
        delete(key) {
          return assertCollection(this.contents) ? this.contents.delete(key) : false;
        }
        /**
         * Removes a value from the document.
         * @returns `true` if the item was found and removed.
         */
        deleteIn(path2) {
          if (isEmptyPath(path2)) {
            if (this.contents == null)
              return false;
            this.contents = null;
            return true;
          }
          return assertCollection(this.contents) ? this.contents.deleteIn(path2) : false;
        }
        /**
         * Returns item at `key`, or `undefined` if not found. By default unwraps
         * scalar values from their surrounding node; to disable set `keepScalar` to
         * `true` (collections are always returned intact).
         */
        get(key, keepScalar) {
          return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
        }
        /**
         * Returns item at `path`, or `undefined` if not found. By default unwraps
         * scalar values from their surrounding node; to disable set `keepScalar` to
         * `true` (collections are always returned intact).
         */
        getIn(path2, keepScalar) {
          if (isEmptyPath(path2))
            return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
          return isCollection(this.contents) ? this.contents.getIn(path2, keepScalar) : void 0;
        }
        /**
         * Checks if the document includes a value with the key `key`.
         */
        has(key) {
          return isCollection(this.contents) ? this.contents.has(key) : false;
        }
        /**
         * Checks if the document includes a value at `path`.
         */
        hasIn(path2) {
          if (isEmptyPath(path2))
            return this.contents !== void 0;
          return isCollection(this.contents) ? this.contents.hasIn(path2) : false;
        }
        /**
         * Sets a value in this document. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         */
        set(key, value) {
          if (this.contents == null) {
            this.contents = collectionFromPath(this.schema, [key], value);
          } else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
          }
        }
        /**
         * Sets a value in this document. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         */
        setIn(path2, value) {
          if (isEmptyPath(path2)) {
            this.contents = value;
          } else if (this.contents == null) {
            this.contents = collectionFromPath(this.schema, Array.from(path2), value);
          } else if (assertCollection(this.contents)) {
            this.contents.setIn(path2, value);
          }
        }
        /**
         * Change the YAML version and schema used by the document.
         * A `null` version disables support for directives, explicit tags, anchors, and aliases.
         * It also requires the `schema` option to be given as a `Schema` instance value.
         *
         * Overrides all previously set schema options.
         */
        setSchema(version2, options = {}) {
          if (typeof version2 === "number")
            version2 = String(version2);
          let opt;
          switch (version2) {
            case "1.1":
              if (this.directives)
                this.directives.yaml.version = "1.1";
              else
                this.directives = new Directives({ version: "1.1" });
              opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
              break;
            case "1.2":
            case "next":
              if (this.directives)
                this.directives.yaml.version = version2;
              else
                this.directives = new Directives({ version: version2 });
              opt = { merge: false, resolveKnownTags: true, schema: "core" };
              break;
            case null:
              if (this.directives)
                delete this.directives;
              opt = null;
              break;
            default: {
              const sv = JSON.stringify(version2);
              throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
          }
          if (options.schema instanceof Object)
            this.schema = options.schema;
          else if (opt)
            this.schema = new Schema(Object.assign(opt, options));
          else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
        }
        // json & jsonArg are only used from toJSON()
        toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
          const ctx = {
            anchors: /* @__PURE__ */ new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
          };
          const res = toJS(this.contents, jsonArg ?? "", ctx);
          if (typeof onAnchor === "function")
            for (const { count, res: res2 } of ctx.anchors.values())
              onAnchor(res2, count);
          return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
        }
        /**
         * A JSON representation of the document `contents`.
         *
         * @param jsonArg Used by `JSON.stringify` to indicate the array index or
         *   property name.
         */
        toJSON(jsonArg, onAnchor) {
          return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
        }
        /** A YAML representation of the document. */
        toString(options = {}) {
          if (this.errors.length > 0)
            throw new Error("Document with errors cannot be stringified");
          if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s6 = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s6}`);
          }
          return stringifyDocument(this, options);
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/errors.js
  var YAMLError, YAMLParseError, YAMLWarning, prettifyError;
  var init_errors = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/errors.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      YAMLError = class extends Error {
        constructor(name8, pos, code9, message2) {
          super();
          this.name = name8;
          this.code = code9;
          this.message = message2;
          this.pos = pos;
        }
      };
      YAMLParseError = class extends YAMLError {
        constructor(pos, code9, message2) {
          super("YAMLParseError", pos, code9, message2);
        }
      };
      YAMLWarning = class extends YAMLError {
        constructor(pos, code9, message2) {
          super("YAMLWarning", pos, code9, message2);
        }
      };
      prettifyError = (src3, lc) => (error) => {
        if (error.pos[0] === -1)
          return;
        error.linePos = error.pos.map((pos) => lc.linePos(pos));
        const { line, col } = error.linePos[0];
        error.message += ` at line ${line}, column ${col}`;
        let ci = col - 1;
        let lineStr = src3.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
        if (ci >= 60 && lineStr.length > 80) {
          const trimStart = Math.min(ci - 39, lineStr.length - 79);
          lineStr = "\u2026" + lineStr.substring(trimStart);
          ci -= trimStart - 1;
        }
        if (lineStr.length > 80)
          lineStr = lineStr.substring(0, 79) + "\u2026";
        if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
          let prev = src3.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
          if (prev.length > 80)
            prev = prev.substring(0, 79) + "\u2026\n";
          lineStr = prev + lineStr;
        }
        if (/[^ ]/.test(lineStr)) {
          let count = 1;
          const end = error.linePos[1];
          if (end && end.line === line && end.col > col) {
            count = Math.max(1, Math.min(end.col - col, 80 - ci));
          }
          const pointer = " ".repeat(ci) + "^".repeat(count);
          error.message += `:

${lineStr}
${pointer}
`;
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-props.js
  function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag2 = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag2)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          if (start === null)
            start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag2)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag2 = token;
          if (start === null)
            start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag2)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        // else fallthrough
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last2 = tokens[tokens.length - 1];
    const end = last2 ? last2.offset + last2.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
      onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      anchor,
      tag: tag2,
      newlineAfterProp,
      end,
      start: start ?? end
    };
  }
  var init_resolve_props = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-props.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-contains-newline.js
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes("\n"))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  var init_util_contains_newline = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-contains-newline.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
  function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  }
  var init_util_flow_indent_check = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_util_contains_newline();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-map-includes.js
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a7, b5) => a7 === b5 || isScalar(a7) && isScalar(b5) && a7.value === b5.value && !(a7.value === "<<" && ctx.schema.merge);
    return items.some((pair) => isEqual(pair.key, search));
  }
  var init_util_map_includes = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-map-includes.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-block-map.js
  function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag2) {
    const NodeClass = tag2?.nodeClass ?? YAMLMap;
    const map3 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep: sep2, value } = collItem;
      const keyProps = resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep2?.[0],
        offset,
        onError,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep2) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map3.comment)
              map3.comment += "\n" + keyProps.comment;
            else
              map3.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || containsNewline(key)) {
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, key, onError);
      if (mapIncludes(ctx, map3.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps(sep2 ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep2, null, valueProps, onError);
        if (ctx.schema.compat)
          flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map3.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += "\n" + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map3.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map3.range = [bm.offset, offset, commentEnd ?? offset];
    return map3;
  }
  var startColMsg;
  var init_resolve_block_map = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-block-map.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Pair();
      init_YAMLMap();
      init_resolve_props();
      init_util_contains_newline();
      init_util_flow_indent_check();
      init_util_map_includes();
      startColMsg = "All mapping items must start at the same column";
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-block-seq.js
  function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag2) {
    const NodeClass = tag2?.nodeClass ?? YAMLSeq;
    const seq2 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
      const props = resolveProps(start, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value && value.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq2.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq2.items.push(node);
    }
    seq2.range = [bs.offset, offset, commentEnd ?? offset];
    return seq2;
  }
  var init_resolve_block_seq = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-block-seq.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_YAMLSeq();
      init_resolve_props();
      init_util_flow_indent_check();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-end.js
  function resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep2 = "";
      for (const token of end) {
        const { source, type: type2 } = token;
        switch (type2) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep2 + cb;
            sep2 = "";
            break;
          }
          case "newline":
            if (comment)
              sep2 += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type2} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }
  var init_resolve_end = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-end.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
  function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag2) {
    const isMap2 = fc.start.source === "{";
    const fcName = isMap2 ? "flow map" : "flow sequence";
    const NodeClass = tag2?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i7 = 0; i7 < fc.items.length; ++i7) {
      const collItem = fc.items[i7];
      const { start, key, sep: sep2, value } = collItem;
      const props = resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep2?.[0],
        offset,
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep2 && !value) {
          if (i7 === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i7 < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += "\n" + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap2 && ctx.options.strict && containsNewline(key))
          onError(
            key,
            // checked by containsNewline()
            "MULTILINE_IMPLICIT_KEY",
            "Implicit keys of flow sequence pairs need to be on a single line"
          );
      }
      if (i7 === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop: for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += "\n" + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap2 && !sep2 && !props.found) {
        const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep2, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        const keyStart = props.end;
        const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        const valueProps = resolveProps(sep2 ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap2 && !props.found && ctx.options.strict) {
            if (sep2)
              for (const st of sep2) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source && value.source[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep2, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += "\n" + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap2) {
          const map3 = coll;
          if (mapIncludes(ctx, map3.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map3.items.push(pair);
        } else {
          const map3 = new YAMLMap(ctx.schema);
          map3.flow = true;
          map3.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map3.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map3);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap2 ? "}" : "]";
    const [ce2, ...ee2] = fc.end;
    let cePos = offset;
    if (ce2 && ce2.source === expectedEnd)
      cePos = ce2.offset + ce2.source.length;
    else {
      const name8 = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name8} must end with a ${expectedEnd}` : `${name8} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce2 && ce2.source.length !== 1)
        ee2.unshift(ce2);
    }
    if (ee2.length > 0) {
      const end = resolveEnd(ee2, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += "\n" + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [fc.offset, cePos, end.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }
  var blockMsg, isBlock;
  var init_resolve_flow_collection = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_Pair();
      init_YAMLMap();
      init_YAMLSeq();
      init_resolve_end();
      init_resolve_props();
      init_util_contains_newline();
      init_util_map_includes();
      blockMsg = "Block collections are not allowed within flow collections";
      isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-collection.js
  function resolveCollection(CN2, ctx, token, onError, tagName, tag2) {
    const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag2) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag2) : resolveFlowCollection(CN2, ctx, token, onError, tag2);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN2, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message2 = "Missing newline after block sequence props";
        onError(lastProp, "MISSING_CHAR", message2);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
    let tag2 = ctx.schema.tags.find((t8) => t8.tag === tagName && t8.collection === expType);
    if (!tag2) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt && kt.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag2 = kt;
      } else {
        if (kt?.collection) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN2, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag2);
    const res = tag2.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = isNode(res) ? res : new Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag2?.format)
      node.format = tag2.format;
    return node;
  }
  var init_compose_collection = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-collection.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_Scalar();
      init_YAMLMap();
      init_YAMLSeq();
      init_resolve_block_map();
      init_resolve_block_seq();
      init_resolve_flow_collection();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
  function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start, start, start] };
    const type2 = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i7 = lines.length - 1; i7 >= 0; --i7) {
      const content = lines[i7][1];
      if (content === "" || content === "\r")
        chompStart = i7;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return { value: value2, type: type2, comment: header.comment, range: [start, end2, end2] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i7 = 0; i7 < chompStart; ++i7) {
      const [indent, content] = lines[i7];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message2 = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message2);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i7;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message2 = "Block scalar values in collections must be indented";
          onError(offset, "BAD_INDENT", message2);
        }
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i7 = lines.length - 1; i7 >= chompStart; --i7) {
      if (lines[i7][0].length > trimIndent)
        chompStart = i7 + 1;
    }
    let value = "";
    let sep2 = "";
    let prevMoreIndented = false;
    for (let i7 = 0; i7 < contentStart; ++i7)
      value += lines[i7][0].slice(trimIndent) + "\n";
    for (let i7 = contentStart; i7 < chompStart; ++i7) {
      let [indent, content] = lines[i7];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src3 = header.indent ? "explicit indentation indicator" : "first line";
        const message2 = `Block scalar lines must not be less indented than their ${src3}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message2);
        indent = "";
      }
      if (type2 === Scalar.BLOCK_LITERAL) {
        value += sep2 + indent.slice(trimIndent) + content;
        sep2 = "\n";
      } else if (indent.length > trimIndent || content[0] === "	") {
        if (sep2 === " ")
          sep2 = "\n";
        else if (!prevMoreIndented && sep2 === "\n")
          sep2 = "\n\n";
        value += sep2 + indent.slice(trimIndent) + content;
        sep2 = "\n";
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep2 === "\n")
          value += "\n";
        else
          sep2 = "\n";
      } else {
        value += sep2 + content;
        sep2 = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i7 = chompStart; i7 < lines.length; ++i7)
          value += "\n" + lines[i7][0].slice(trimIndent);
        if (value[value.length - 1] !== "\n")
          value += "\n";
        break;
      default:
        value += "\n";
    }
    const end = start + header.length + scalar.source.length;
    return { value, type: type2, comment: header.comment, range: [start, end, end] };
  }
  function parseBlockScalarHeader({ offset, props }, strict2, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for (let i7 = 1; i7 < source.length; ++i7) {
      const ch = source[i7];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n8 = Number(ch);
        if (!indent && n8)
          indent = n8;
        else if (error === -1)
          error = offset + i7;
      }
    }
    if (error !== -1)
      onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length4 = source.length;
    for (let i7 = 1; i7 < props.length; ++i7) {
      const token = props[i7];
      switch (token.type) {
        case "space":
          hasSpace = true;
        // fallthrough
        case "newline":
          length4 += token.source.length;
          break;
        case "comment":
          if (strict2 && !hasSpace) {
            const message2 = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message2);
          }
          length4 += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length4 += token.source.length;
          break;
        /* istanbul ignore next should not happen */
        default: {
          const message2 = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message2);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length4 += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length: length4 };
  }
  function splitLines(source) {
    const split2 = source.split(/\n( *)/);
    const first = split2[0];
    const m6 = first.match(/^( *)/);
    const line0 = m6?.[1] ? [m6[1], first.slice(m6[1].length)] : ["", first];
    const lines = [line0];
    for (let i7 = 1; i7 < split2.length; i7 += 2)
      lines.push([split2[i7], split2[i7 + 1]]);
    return lines;
  }
  var init_resolve_block_scalar = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Scalar();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
  function resolveFlowScalar(scalar, strict2, onError) {
    const { offset, type: type2, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code9, msg) => onError(offset + rel, code9, msg);
    switch (type2) {
      case "scalar":
        _type = Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      /* istanbul ignore next should not happen */
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type2}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re2 = resolveEnd(end, valueEnd, strict2, onError);
    return {
      value,
      type: _type,
      comment: re2.comment,
      range: [offset, valueEnd, re2.offset]
    };
  }
  function plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      /* istanbul ignore next should not happen */
      case "	":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first, line;
    try {
      first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
      line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
    } catch {
      first = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep2 = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep2 === "\n")
          res += sep2;
        else
          sep2 = "\n";
      } else {
        res += sep2 + match[1];
        sep2 = " ";
      }
      pos = line.lastIndex;
    }
    const last2 = /[ \t]*(.*)/sy;
    last2.lastIndex = pos;
    match = last2.exec(source);
    return res + sep2 + (match?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError) {
    let res = "";
    for (let i7 = 1; i7 < source.length - 1; ++i7) {
      const ch = source[i7];
      if (ch === "\r" && source[i7 + 1] === "\n")
        continue;
      if (ch === "\n") {
        const { fold, offset } = foldNewline(source, i7);
        res += fold;
        i7 = offset;
      } else if (ch === "\\") {
        let next = source[++i7];
        const cc = escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === "\n") {
          next = source[i7 + 1];
          while (next === " " || next === "	")
            next = source[++i7 + 1];
        } else if (next === "\r" && source[i7 + 1] === "\n") {
          next = source[++i7 + 1];
          while (next === " " || next === "	")
            next = source[++i7 + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length4 = { x: 2, u: 4, U: 8 }[next];
          res += parseCharCode(source, i7 + 1, length4, onError);
          i7 += length4;
        } else {
          const raw = source.substr(i7 - 1, 2);
          onError(i7 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "	") {
        const wsStart = i7;
        let next = source[i7 + 1];
        while (next === " " || next === "	")
          next = source[++i7 + 1];
        if (next !== "\n" && !(next === "\r" && source[i7 + 2] === "\n"))
          res += i7 > wsStart ? source.slice(wsStart, i7 + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== "\n")
        break;
      if (ch === "\n")
        fold += "\n";
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  }
  function parseCharCode(source, offset, length4, onError) {
    const cc = source.substr(offset, length4);
    const ok2 = cc.length === length4 && /^[0-9a-fA-F]+$/.test(cc);
    const code9 = ok2 ? parseInt(cc, 16) : NaN;
    if (isNaN(code9)) {
      const raw = source.substr(offset - 2, length4 + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code9);
  }
  var escapeCodes;
  var init_resolve_flow_scalar = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Scalar();
      init_resolve_end();
      escapeCodes = {
        "0": "\0",
        // null character
        a: "\x07",
        // bell character
        b: "\b",
        // backspace
        e: "\x1B",
        // escape character
        f: "\f",
        // form feed
        n: "\n",
        // line feed
        r: "\r",
        // carriage return
        t: "	",
        // horizontal tab
        v: "\v",
        // vertical tab
        N: "\x85",
        // Unicode next line
        _: "\xA0",
        // Unicode non-breaking space
        L: "\u2028",
        // Unicode line separator
        P: "\u2029",
        // Unicode paragraph separator
        " ": " ",
        '"': '"',
        "/": "/",
        "\\": "\\",
        "	": "	"
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-scalar.js
  function composeScalar(ctx, token, tagToken, onError) {
    const { value, type: type2, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    const tag2 = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
    let scalar;
    try {
      const res = tag2.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = isScalar(res) ? res : new Scalar(res);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type2)
      scalar.type = type2;
    if (tagName)
      scalar.tag = tagName;
    if (tag2.format)
      scalar.format = tag2.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema4[SCALAR];
    const matchWithTest = [];
    for (const tag2 of schema4.tags) {
      if (!tag2.collection && tag2.tag === tagName) {
        if (tag2.default && tag2.test)
          matchWithTest.push(tag2);
        else
          return tag2;
      }
    }
    for (const tag2 of matchWithTest)
      if (tag2.test?.test(value))
        return tag2;
    const kt = schema4.knownTags[tagName];
    if (kt && !kt.collection) {
      schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema4[SCALAR];
  }
  function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
    const tag2 = schema4.tags.find((tag3) => tag3.default && tag3.test?.test(value)) || schema4[SCALAR];
    if (schema4.compat) {
      const compat = schema4.compat.find((tag3) => tag3.default && tag3.test?.test(value)) ?? schema4[SCALAR];
      if (tag2.tag !== compat.tag) {
        const ts = directives.tagString(tag2.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag2;
  }
  var init_compose_scalar = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-scalar.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_identity();
      init_Scalar();
      init_resolve_block_scalar();
      init_resolve_flow_scalar();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
  function emptyScalarPosition(offset, before, pos) {
    if (before) {
      if (pos === null)
        pos = before.length;
      for (let i7 = pos - 1; i7 >= 0; --i7) {
        let st = before[i7];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i7];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i7];
        }
        break;
      }
    }
    return offset;
  }
  var init_util_empty_scalar_position = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-node.js
  function composeNode(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag: tag2 } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError);
        if (anchor || tag2)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar(ctx, token, tag2, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection(CN, ctx, token, props, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message2 = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message2);
        node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag: tag2, end }, onError) {
    const token = {
      type: "scalar",
      offset: emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar(ctx, token, tag2, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re2 = resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re2.offset];
    if (re2.comment)
      alias.comment = re2.comment;
    return alias;
  }
  var CN;
  var init_compose_node = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-node.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Alias();
      init_compose_collection();
      init_compose_scalar();
      init_resolve_end();
      init_util_empty_scalar_position();
      CN = { composeNode, composeEmptyNode };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-doc.js
  function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document(void 0, opts);
    const ctx = {
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps(start, {
      indicator: "doc-start",
      next: value ?? end?.[0],
      offset,
      onError,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re2 = resolveEnd(end, contentEnd, false, onError);
    if (re2.comment)
      doc.comment = re2.comment;
    doc.range = [offset, contentEnd, re2.offset];
    return doc;
  }
  var init_compose_doc = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-doc.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Document();
      init_compose_node();
      init_resolve_end();
      init_resolve_props();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/composer.js
  function getErrorPos(src3) {
    if (typeof src3 === "number")
      return [src3, src3 + 1];
    if (Array.isArray(src3))
      return src3.length === 2 ? src3 : [src3[0], src3[1]];
    const { offset, source } = src3;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i7 = 0; i7 < prelude.length; ++i7) {
      const source = prelude[i7];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i7 + 1]?.[0] !== "#")
            i7 += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }
  var Composer;
  var init_composer = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/composer.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_directives();
      init_Document();
      init_errors();
      init_identity();
      init_compose_doc();
      init_resolve_end();
      Composer = class {
        constructor(options = {}) {
          this.doc = null;
          this.atDirectives = false;
          this.prelude = [];
          this.errors = [];
          this.warnings = [];
          this.onError = (source, code9, message2, warning) => {
            const pos = getErrorPos(source);
            if (warning)
              this.warnings.push(new YAMLWarning(pos, code9, message2));
            else
              this.errors.push(new YAMLParseError(pos, code9, message2));
          };
          this.directives = new Directives({ version: options.version || "1.2" });
          this.options = options;
        }
        decorate(doc, afterDoc) {
          const { comment, afterEmptyLine } = parsePrelude(this.prelude);
          if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
              doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
            } else if (afterEmptyLine || doc.directives.docStart || !dc) {
              doc.commentBefore = comment;
            } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
              let it = dc.items[0];
              if (isPair(it))
                it = it.key;
              const cb = it.commentBefore;
              it.commentBefore = cb ? `${comment}
${cb}` : comment;
            } else {
              const cb = dc.commentBefore;
              dc.commentBefore = cb ? `${comment}
${cb}` : comment;
            }
          }
          if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
          } else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
          }
          this.prelude = [];
          this.errors = [];
          this.warnings = [];
        }
        /**
         * Current stream status information.
         *
         * Mostly useful at the end of input for an empty stream.
         */
        streamInfo() {
          return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
          };
        }
        /**
         * Compose tokens into documents.
         *
         * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
         * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
         */
        *compose(tokens, forceDoc = false, endOffset = -1) {
          for (const token of tokens)
            yield* this.next(token);
          yield* this.end(forceDoc, endOffset);
        }
        /** Advance the composer by one CST token. */
        *next(token) {
          switch (token.type) {
            case "directive":
              this.directives.add(token.source, (offset, message2, warning) => {
                const pos = getErrorPos(token);
                pos[0] += offset;
                this.onError(pos, "BAD_DIRECTIVE", message2, warning);
              });
              this.prelude.push(token.source);
              this.atDirectives = true;
              break;
            case "document": {
              const doc = composeDoc(this.options, this.directives, token, this.onError);
              if (this.atDirectives && !doc.directives.docStart)
                this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
              this.decorate(doc, false);
              if (this.doc)
                yield this.doc;
              this.doc = doc;
              this.atDirectives = false;
              break;
            }
            case "byte-order-mark":
            case "space":
              break;
            case "comment":
            case "newline":
              this.prelude.push(token.source);
              break;
            case "error": {
              const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
              const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
              if (this.atDirectives || !this.doc)
                this.errors.push(error);
              else
                this.doc.errors.push(error);
              break;
            }
            case "doc-end": {
              if (!this.doc) {
                const msg = "Unexpected doc-end without preceding document";
                this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
                break;
              }
              this.doc.directives.docEnd = true;
              const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
              this.decorate(this.doc, true);
              if (end.comment) {
                const dc = this.doc.comment;
                this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
              }
              this.doc.range[2] = end.offset;
              break;
            }
            default:
              this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
          }
        }
        /**
         * Call at end of input to yield any remaining document.
         *
         * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
         * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
         */
        *end(forceDoc = false, endOffset = -1) {
          if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
          } else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document(void 0, opts);
            if (this.atDirectives)
              this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
          }
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst-scalar.js
  function resolveAsScalar(token, strict2 = true, onError) {
    if (token) {
      const _onError = (pos, code9, message2) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code9, message2);
        else
          throw new YAMLParseError([offset, offset + 1], code9, message2);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar(token, strict2, _onError);
        case "block-scalar":
          return resolveBlockScalar({ options: { strict: strict2 } }, token, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context2) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type: type2 = "PLAIN" } = context2;
    const source = stringifyString({ type: type2, value }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context2.end ?? [
      { type: "newline", offset: -1, indent, source: "\n" }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he2 = source.indexOf("\n");
        const head = source.substring(0, he2);
        const body = source.substring(he2 + 1) + "\n";
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, end))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end };
      default:
        return { type: "scalar", offset, indent, source, end };
    }
  }
  function setScalarValue(token, value, context2 = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type: type2 } = context2;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type2)
      switch (token.type) {
        case "single-quoted-scalar":
          type2 = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type2 = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type2 = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type2 = "PLAIN";
      }
    const source = stringifyString({ type: type2, value }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he2 = source.indexOf("\n");
    const head = source.substring(0, he2);
    const body = source.substring(he2 + 1) + "\n";
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type2) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type2;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type: type2, source, end });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
        delete token.items;
        Object.assign(token, { type: type2, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: type2, indent, source, end });
      }
    }
  }
  var init_cst_scalar = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst-scalar.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_resolve_block_scalar();
      init_resolve_flow_scalar();
      init_errors();
      init_stringifyString();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst-stringify.js
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start, key, sep: sep2, value }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep2)
      for (const st of sep2)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }
  var stringify2;
  var init_cst_stringify = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst-stringify.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst-visit.js
  function visit2(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  function _visit(path2, item, visitor) {
    let ctrl = visitor(item, path2);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i7 = 0; i7 < token.items.length; ++i7) {
          const ci = _visit(Object.freeze(path2.concat([[field, i7]])), token.items[i7], visitor);
          if (typeof ci === "number")
            i7 = ci - 1;
          else if (ci === BREAK2)
            return BREAK2;
          else if (ci === REMOVE2) {
            token.items.splice(i7, 1);
            i7 -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path2);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path2) : ctrl;
  }
  var BREAK2, SKIP2, REMOVE2;
  var init_cst_visit = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst-visit.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      BREAK2 = Symbol("break visit");
      SKIP2 = Symbol("skip children");
      REMOVE2 = Symbol("remove item");
      visit2.BREAK = BREAK2;
      visit2.SKIP = SKIP2;
      visit2.REMOVE = REMOVE2;
      visit2.itemAtPath = (cst, path2) => {
        let item = cst;
        for (const [field, index2] of path2) {
          const tok = item?.[field];
          if (tok && "items" in tok) {
            item = tok.items[index2];
          } else
            return void 0;
        }
        return item;
      };
      visit2.parentCollection = (cst, path2) => {
        const parent = visit2.itemAtPath(cst, path2.slice(0, -1));
        const field = path2[path2.length - 1][0];
        const coll = parent?.[field];
        if (coll && "items" in coll)
          return coll;
        throw new Error("Parent collection not found");
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst.js
  var cst_exports = {};
  __export(cst_exports, {
    BOM: () => BOM,
    DOCUMENT: () => DOCUMENT,
    FLOW_END: () => FLOW_END,
    SCALAR: () => SCALAR2,
    createScalarToken: () => createScalarToken,
    isCollection: () => isCollection2,
    isScalar: () => isScalar2,
    prettyToken: () => prettyToken,
    resolveAsScalar: () => resolveAsScalar,
    setScalarValue: () => setScalarValue,
    stringify: () => stringify2,
    tokenType: () => tokenType,
    visit: () => visit2
  });
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR2:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR2:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case "\n":
      case "\r\n":
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "	":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  var BOM, DOCUMENT, FLOW_END, SCALAR2, isCollection2, isScalar2;
  var init_cst = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_cst_scalar();
      init_cst_stringify();
      init_cst_visit();
      BOM = "\uFEFF";
      DOCUMENT = "";
      FLOW_END = "";
      SCALAR2 = "";
      isCollection2 = (token) => !!token && "items" in token;
      isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/lexer.js
  function isEmpty(ch) {
    switch (ch) {
      case void 0:
      case " ":
      case "\n":
      case "\r":
      case "	":
        return true;
      default:
        return false;
    }
  }
  var hexDigits, tagChars, flowIndicatorChars, invalidAnchorChars, isNotAnchorChar, Lexer;
  var init_lexer = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/lexer.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_cst();
      hexDigits = new Set("0123456789ABCDEFabcdef");
      tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
      flowIndicatorChars = new Set(",[]{}");
      invalidAnchorChars = new Set(" ,[]{}\n\r	");
      isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
      Lexer = class {
        constructor() {
          this.atEnd = false;
          this.blockScalarIndent = -1;
          this.blockScalarKeep = false;
          this.buffer = "";
          this.flowKey = false;
          this.flowLevel = 0;
          this.indentNext = 0;
          this.indentValue = 0;
          this.lineEndPos = null;
          this.next = null;
          this.pos = 0;
        }
        /**
         * Generate YAML tokens from the `source` string. If `incomplete`,
         * a part of the last line may be left as a buffer for the next call.
         *
         * @returns A generator of lexical tokens
         */
        *lex(source, incomplete = false) {
          if (source) {
            if (typeof source !== "string")
              throw TypeError("source is not a string");
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
          }
          this.atEnd = !incomplete;
          let next = this.next ?? "stream";
          while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
        }
        atLineEnd() {
          let i7 = this.pos;
          let ch = this.buffer[i7];
          while (ch === " " || ch === "	")
            ch = this.buffer[++i7];
          if (!ch || ch === "#" || ch === "\n")
            return true;
          if (ch === "\r")
            return this.buffer[i7 + 1] === "\n";
          return false;
        }
        charAt(n8) {
          return this.buffer[this.pos + n8];
        }
        continueScalar(offset) {
          let ch = this.buffer[offset];
          if (this.indentNext > 0) {
            let indent = 0;
            while (ch === " ")
              ch = this.buffer[++indent + offset];
            if (ch === "\r") {
              const next = this.buffer[indent + offset + 1];
              if (next === "\n" || !next && !this.atEnd)
                return offset + indent + 1;
            }
            return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
          }
          if (ch === "-" || ch === ".") {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
              return -1;
          }
          return offset;
        }
        getLine() {
          let end = this.lineEndPos;
          if (typeof end !== "number" || end !== -1 && end < this.pos) {
            end = this.buffer.indexOf("\n", this.pos);
            this.lineEndPos = end;
          }
          if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
          if (this.buffer[end - 1] === "\r")
            end -= 1;
          return this.buffer.substring(this.pos, end);
        }
        hasChars(n8) {
          return this.pos + n8 <= this.buffer.length;
        }
        setNext(state) {
          this.buffer = this.buffer.substring(this.pos);
          this.pos = 0;
          this.lineEndPos = null;
          this.next = state;
          return null;
        }
        peek(n8) {
          return this.buffer.substr(this.pos, n8);
        }
        *parseNext(next) {
          switch (next) {
            case "stream":
              return yield* this.parseStream();
            case "line-start":
              return yield* this.parseLineStart();
            case "block-start":
              return yield* this.parseBlockStart();
            case "doc":
              return yield* this.parseDocument();
            case "flow":
              return yield* this.parseFlowCollection();
            case "quoted-scalar":
              return yield* this.parseQuotedScalar();
            case "block-scalar":
              return yield* this.parseBlockScalar();
            case "plain-scalar":
              return yield* this.parsePlainScalar();
          }
        }
        *parseStream() {
          let line = this.getLine();
          if (line === null)
            return this.setNext("stream");
          if (line[0] === BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
          }
          if (line[0] === "%") {
            let dirEnd = line.length;
            let cs = line.indexOf("#");
            while (cs !== -1) {
              const ch = line[cs - 1];
              if (ch === " " || ch === "	") {
                dirEnd = cs - 1;
                break;
              } else {
                cs = line.indexOf("#", cs + 1);
              }
            }
            while (true) {
              const ch = line[dirEnd - 1];
              if (ch === " " || ch === "	")
                dirEnd -= 1;
              else
                break;
            }
            const n8 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n8);
            this.pushNewline();
            return "stream";
          }
          if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return "stream";
          }
          yield DOCUMENT;
          return yield* this.parseLineStart();
        }
        *parseLineStart() {
          const ch = this.charAt(0);
          if (!ch && !this.atEnd)
            return this.setNext("line-start");
          if (ch === "-" || ch === ".") {
            if (!this.atEnd && !this.hasChars(4))
              return this.setNext("line-start");
            const s6 = this.peek(3);
            if ((s6 === "---" || s6 === "...") && isEmpty(this.charAt(3))) {
              yield* this.pushCount(3);
              this.indentValue = 0;
              this.indentNext = 0;
              return s6 === "---" ? "doc" : "stream";
            }
          }
          this.indentValue = yield* this.pushSpaces(false);
          if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
          return yield* this.parseBlockStart();
        }
        *parseBlockStart() {
          const [ch0, ch1] = this.peek(2);
          if (!ch1 && !this.atEnd)
            return this.setNext("block-start");
          if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
            const n8 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n8;
            return yield* this.parseBlockStart();
          }
          return "doc";
        }
        *parseDocument() {
          yield* this.pushSpaces(true);
          const line = this.getLine();
          if (line === null)
            return this.setNext("doc");
          let n8 = yield* this.pushIndicators();
          switch (line[n8]) {
            case "#":
              yield* this.pushCount(line.length - n8);
            // fallthrough
            case void 0:
              yield* this.pushNewline();
              return yield* this.parseLineStart();
            case "{":
            case "[":
              yield* this.pushCount(1);
              this.flowKey = false;
              this.flowLevel = 1;
              return "flow";
            case "}":
            case "]":
              yield* this.pushCount(1);
              return "doc";
            case "*":
              yield* this.pushUntil(isNotAnchorChar);
              return "doc";
            case '"':
            case "'":
              return yield* this.parseQuotedScalar();
            case "|":
            case ">":
              n8 += yield* this.parseBlockScalarHeader();
              n8 += yield* this.pushSpaces(true);
              yield* this.pushCount(line.length - n8);
              yield* this.pushNewline();
              return yield* this.parseBlockScalar();
            default:
              return yield* this.parsePlainScalar();
          }
        }
        *parseFlowCollection() {
          let nl, sp;
          let indent = -1;
          do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
              sp = yield* this.pushSpaces(false);
              this.indentValue = indent = sp;
            } else {
              sp = 0;
            }
            sp += yield* this.pushSpaces(true);
          } while (nl + sp > 0);
          const line = this.getLine();
          if (line === null)
            return this.setNext("flow");
          if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
            const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
            if (!atFlowEndMarker) {
              this.flowLevel = 0;
              yield FLOW_END;
              return yield* this.parseLineStart();
            }
          }
          let n8 = 0;
          while (line[n8] === ",") {
            n8 += yield* this.pushCount(1);
            n8 += yield* this.pushSpaces(true);
            this.flowKey = false;
          }
          n8 += yield* this.pushIndicators();
          switch (line[n8]) {
            case void 0:
              return "flow";
            case "#":
              yield* this.pushCount(line.length - n8);
              return "flow";
            case "{":
            case "[":
              yield* this.pushCount(1);
              this.flowKey = false;
              this.flowLevel += 1;
              return "flow";
            case "}":
            case "]":
              yield* this.pushCount(1);
              this.flowKey = true;
              this.flowLevel -= 1;
              return this.flowLevel ? "flow" : "doc";
            case "*":
              yield* this.pushUntil(isNotAnchorChar);
              return "flow";
            case '"':
            case "'":
              this.flowKey = true;
              return yield* this.parseQuotedScalar();
            case ":": {
              const next = this.charAt(1);
              if (this.flowKey || isEmpty(next) || next === ",") {
                this.flowKey = false;
                yield* this.pushCount(1);
                yield* this.pushSpaces(true);
                return "flow";
              }
            }
            // fallthrough
            default:
              this.flowKey = false;
              return yield* this.parsePlainScalar();
          }
        }
        *parseQuotedScalar() {
          const quote = this.charAt(0);
          let end = this.buffer.indexOf(quote, this.pos + 1);
          if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
              end = this.buffer.indexOf("'", end + 2);
          } else {
            while (end !== -1) {
              let n8 = 0;
              while (this.buffer[end - 1 - n8] === "\\")
                n8 += 1;
              if (n8 % 2 === 0)
                break;
              end = this.buffer.indexOf('"', end + 1);
            }
          }
          const qb = this.buffer.substring(0, end);
          let nl = qb.indexOf("\n", this.pos);
          if (nl !== -1) {
            while (nl !== -1) {
              const cs = this.continueScalar(nl + 1);
              if (cs === -1)
                break;
              nl = qb.indexOf("\n", cs);
            }
            if (nl !== -1) {
              end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
            }
          }
          if (end === -1) {
            if (!this.atEnd)
              return this.setNext("quoted-scalar");
            end = this.buffer.length;
          }
          yield* this.pushToIndex(end + 1, false);
          return this.flowLevel ? "flow" : "doc";
        }
        *parseBlockScalarHeader() {
          this.blockScalarIndent = -1;
          this.blockScalarKeep = false;
          let i7 = this.pos;
          while (true) {
            const ch = this.buffer[++i7];
            if (ch === "+")
              this.blockScalarKeep = true;
            else if (ch > "0" && ch <= "9")
              this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== "-")
              break;
          }
          return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
        }
        *parseBlockScalar() {
          let nl = this.pos - 1;
          let indent = 0;
          let ch;
          loop: for (let i8 = this.pos; ch = this.buffer[i8]; ++i8) {
            switch (ch) {
              case " ":
                indent += 1;
                break;
              case "\n":
                nl = i8;
                indent = 0;
                break;
              case "\r": {
                const next = this.buffer[i8 + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === "\n")
                  break;
              }
              // fallthrough
              default:
                break loop;
            }
          }
          if (!ch && !this.atEnd)
            return this.setNext("block-scalar");
          if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
              this.indentNext = indent;
            else {
              this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
            }
            do {
              const cs = this.continueScalar(nl + 1);
              if (cs === -1)
                break;
              nl = this.buffer.indexOf("\n", cs);
            } while (nl !== -1);
            if (nl === -1) {
              if (!this.atEnd)
                return this.setNext("block-scalar");
              nl = this.buffer.length;
            }
          }
          let i7 = nl + 1;
          ch = this.buffer[i7];
          while (ch === " ")
            ch = this.buffer[++i7];
          if (ch === "	") {
            while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
              ch = this.buffer[++i7];
            nl = i7 - 1;
          } else if (!this.blockScalarKeep) {
            do {
              let i8 = nl - 1;
              let ch2 = this.buffer[i8];
              if (ch2 === "\r")
                ch2 = this.buffer[--i8];
              const lastChar = i8;
              while (ch2 === " ")
                ch2 = this.buffer[--i8];
              if (ch2 === "\n" && i8 >= this.pos && i8 + 1 + indent > lastChar)
                nl = i8;
              else
                break;
            } while (true);
          }
          yield SCALAR2;
          yield* this.pushToIndex(nl + 1, true);
          return yield* this.parseLineStart();
        }
        *parsePlainScalar() {
          const inFlow = this.flowLevel > 0;
          let end = this.pos - 1;
          let i7 = this.pos - 1;
          let ch;
          while (ch = this.buffer[++i7]) {
            if (ch === ":") {
              const next = this.buffer[i7 + 1];
              if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
                break;
              end = i7;
            } else if (isEmpty(ch)) {
              let next = this.buffer[i7 + 1];
              if (ch === "\r") {
                if (next === "\n") {
                  i7 += 1;
                  ch = "\n";
                  next = this.buffer[i7 + 1];
                } else
                  end = i7;
              }
              if (next === "#" || inFlow && flowIndicatorChars.has(next))
                break;
              if (ch === "\n") {
                const cs = this.continueScalar(i7 + 1);
                if (cs === -1)
                  break;
                i7 = Math.max(i7, cs - 2);
              }
            } else {
              if (inFlow && flowIndicatorChars.has(ch))
                break;
              end = i7;
            }
          }
          if (!ch && !this.atEnd)
            return this.setNext("plain-scalar");
          yield SCALAR2;
          yield* this.pushToIndex(end + 1, true);
          return inFlow ? "flow" : "doc";
        }
        *pushCount(n8) {
          if (n8 > 0) {
            yield this.buffer.substr(this.pos, n8);
            this.pos += n8;
            return n8;
          }
          return 0;
        }
        *pushToIndex(i7, allowEmpty) {
          const s6 = this.buffer.slice(this.pos, i7);
          if (s6) {
            yield s6;
            this.pos += s6.length;
            return s6.length;
          } else if (allowEmpty)
            yield "";
          return 0;
        }
        *pushIndicators() {
          switch (this.charAt(0)) {
            case "!":
              return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            case "&":
              return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            case "-":
            // this is an error
            case "?":
            // this is an error outside flow collections
            case ":": {
              const inFlow = this.flowLevel > 0;
              const ch1 = this.charAt(1);
              if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
                if (!inFlow)
                  this.indentNext = this.indentValue + 1;
                else if (this.flowKey)
                  this.flowKey = false;
                return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
              }
            }
          }
          return 0;
        }
        *pushTag() {
          if (this.charAt(1) === "<") {
            let i7 = this.pos + 2;
            let ch = this.buffer[i7];
            while (!isEmpty(ch) && ch !== ">")
              ch = this.buffer[++i7];
            return yield* this.pushToIndex(ch === ">" ? i7 + 1 : i7, false);
          } else {
            let i7 = this.pos + 1;
            let ch = this.buffer[i7];
            while (ch) {
              if (tagChars.has(ch))
                ch = this.buffer[++i7];
              else if (ch === "%" && hexDigits.has(this.buffer[i7 + 1]) && hexDigits.has(this.buffer[i7 + 2])) {
                ch = this.buffer[i7 += 3];
              } else
                break;
            }
            return yield* this.pushToIndex(i7, false);
          }
        }
        *pushNewline() {
          const ch = this.buffer[this.pos];
          if (ch === "\n")
            return yield* this.pushCount(1);
          else if (ch === "\r" && this.charAt(1) === "\n")
            return yield* this.pushCount(2);
          else
            return 0;
        }
        *pushSpaces(allowTabs) {
          let i7 = this.pos - 1;
          let ch;
          do {
            ch = this.buffer[++i7];
          } while (ch === " " || allowTabs && ch === "	");
          const n8 = i7 - this.pos;
          if (n8 > 0) {
            yield this.buffer.substr(this.pos, n8);
            this.pos = i7;
          }
          return n8;
        }
        *pushUntil(test) {
          let i7 = this.pos;
          let ch = this.buffer[i7];
          while (!test(ch))
            ch = this.buffer[++i7];
          return yield* this.pushToIndex(i7, false);
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/line-counter.js
  var LineCounter;
  var init_line_counter = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/line-counter.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      LineCounter = class {
        constructor() {
          this.lineStarts = [];
          this.addNewLine = (offset) => this.lineStarts.push(offset);
          this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
              const mid = low + high >> 1;
              if (this.lineStarts[mid] < offset)
                low = mid + 1;
              else
                high = mid;
            }
            if (this.lineStarts[low] === offset)
              return { line: low + 1, col: 1 };
            if (low === 0)
              return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
          };
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/parser.js
  function includesToken(list, type2) {
    for (let i7 = 0; i7 < list.length; ++i7)
      if (list[i7].type === type2)
        return true;
    return false;
  }
  function findNonEmptyIndex(list) {
    for (let i7 = 0; i7 < list.length; ++i7) {
      switch (list[i7].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i7;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      /* istanbul ignore next should not happen */
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i7 = prev.length;
    loop: while (--i7 >= 0) {
      switch (prev[i7].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
    while (prev[++i7]?.type === "space") {
    }
    return prev.splice(i7, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }
  var Parser;
  var init_parser = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/parser.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_cst();
      init_lexer();
      Parser = class {
        /**
         * @param onNewLine - If defined, called separately with the start position of
         *   each new line (in `parse()`, including the start of input).
         */
        constructor(onNewLine) {
          this.atNewLine = true;
          this.atScalar = false;
          this.indent = 0;
          this.offset = 0;
          this.onKeyLine = false;
          this.stack = [];
          this.source = "";
          this.type = "";
          this.lexer = new Lexer();
          this.onNewLine = onNewLine;
        }
        /**
         * Parse `source` as a YAML stream.
         * If `incomplete`, a part of the last line may be left as a buffer for the next call.
         *
         * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
         *
         * @returns A generator of tokens representing each directive, document, and other structure.
         */
        *parse(source, incomplete = false) {
          if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
          for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
          if (!incomplete)
            yield* this.end();
        }
        /**
         * Advance the parser by the `source` of one lexical token.
         */
        *next(source) {
          this.source = source;
          if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
          }
          const type2 = tokenType(source);
          if (!type2) {
            const message2 = `Not a YAML token: ${source}`;
            yield* this.pop({ type: "error", offset: this.offset, message: message2, source });
            this.offset += source.length;
          } else if (type2 === "scalar") {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = "scalar";
          } else {
            this.type = type2;
            yield* this.step();
            switch (type2) {
              case "newline":
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine)
                  this.onNewLine(this.offset + source.length);
                break;
              case "space":
                if (this.atNewLine && source[0] === " ")
                  this.indent += source.length;
                break;
              case "explicit-key-ind":
              case "map-value-ind":
              case "seq-item-ind":
                if (this.atNewLine)
                  this.indent += source.length;
                break;
              case "doc-mode":
              case "flow-error-end":
                return;
              default:
                this.atNewLine = false;
            }
            this.offset += source.length;
          }
        }
        /** Call at end of input to push out any remaining constructions */
        *end() {
          while (this.stack.length > 0)
            yield* this.pop();
        }
        get sourceToken() {
          const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
          };
          return st;
        }
        *step() {
          const top = this.peek(1);
          if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
            while (this.stack.length > 0)
              yield* this.pop();
            this.stack.push({
              type: "doc-end",
              offset: this.offset,
              source: this.source
            });
            return;
          }
          if (!top)
            return yield* this.stream();
          switch (top.type) {
            case "document":
              return yield* this.document(top);
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
              return yield* this.scalar(top);
            case "block-scalar":
              return yield* this.blockScalar(top);
            case "block-map":
              return yield* this.blockMap(top);
            case "block-seq":
              return yield* this.blockSequence(top);
            case "flow-collection":
              return yield* this.flowCollection(top);
            case "doc-end":
              return yield* this.documentEnd(top);
          }
          yield* this.pop();
        }
        peek(n8) {
          return this.stack[this.stack.length - n8];
        }
        *pop(error) {
          const token = error ?? this.stack.pop();
          if (!token) {
            const message2 = "Tried to pop an empty stack";
            yield { type: "error", offset: this.offset, source: "", message: message2 };
          } else if (this.stack.length === 0) {
            yield token;
          } else {
            const top = this.peek(1);
            if (token.type === "block-scalar") {
              token.indent = "indent" in top ? top.indent : 0;
            } else if (token.type === "flow-collection" && top.type === "document") {
              token.indent = 0;
            }
            if (token.type === "flow-collection")
              fixFlowSeqItems(token);
            switch (top.type) {
              case "document":
                top.value = token;
                break;
              case "block-scalar":
                top.props.push(token);
                break;
              case "block-map": {
                const it = top.items[top.items.length - 1];
                if (it.value) {
                  top.items.push({ start: [], key: token, sep: [] });
                  this.onKeyLine = true;
                  return;
                } else if (it.sep) {
                  it.value = token;
                } else {
                  Object.assign(it, { key: token, sep: [] });
                  this.onKeyLine = !it.explicitKey;
                  return;
                }
                break;
              }
              case "block-seq": {
                const it = top.items[top.items.length - 1];
                if (it.value)
                  top.items.push({ start: [], value: token });
                else
                  it.value = token;
                break;
              }
              case "flow-collection": {
                const it = top.items[top.items.length - 1];
                if (!it || it.value)
                  top.items.push({ start: [], key: token, sep: [] });
                else if (it.sep)
                  it.value = token;
                else
                  Object.assign(it, { key: token, sep: [] });
                return;
              }
              /* istanbul ignore next should not happen */
              default:
                yield* this.pop();
                yield* this.pop(token);
            }
            if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
              const last2 = token.items[token.items.length - 1];
              if (last2 && !last2.sep && !last2.value && last2.start.length > 0 && findNonEmptyIndex(last2.start) === -1 && (token.indent === 0 || last2.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
                if (top.type === "document")
                  top.end = last2.start;
                else
                  top.items.push({ start: last2.start });
                token.items.splice(-1, 1);
              }
            }
          }
        }
        *stream() {
          switch (this.type) {
            case "directive-line":
              yield { type: "directive", offset: this.offset, source: this.source };
              return;
            case "byte-order-mark":
            case "space":
            case "comment":
            case "newline":
              yield this.sourceToken;
              return;
            case "doc-mode":
            case "doc-start": {
              const doc = {
                type: "document",
                offset: this.offset,
                start: []
              };
              if (this.type === "doc-start")
                doc.start.push(this.sourceToken);
              this.stack.push(doc);
              return;
            }
          }
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
          };
        }
        *document(doc) {
          if (doc.value)
            return yield* this.lineEnd(doc);
          switch (this.type) {
            case "doc-start": {
              if (findNonEmptyIndex(doc.start) !== -1) {
                yield* this.pop();
                yield* this.step();
              } else
                doc.start.push(this.sourceToken);
              return;
            }
            case "anchor":
            case "tag":
            case "space":
            case "comment":
            case "newline":
              doc.start.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(doc);
          if (bv)
            this.stack.push(bv);
          else {
            yield {
              type: "error",
              offset: this.offset,
              message: `Unexpected ${this.type} token in YAML document`,
              source: this.source
            };
          }
        }
        *scalar(scalar) {
          if (this.type === "map-value-ind") {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep2;
            if (scalar.end) {
              sep2 = scalar.end;
              sep2.push(this.sourceToken);
              delete scalar.end;
            } else
              sep2 = [this.sourceToken];
            const map3 = {
              type: "block-map",
              offset: scalar.offset,
              indent: scalar.indent,
              items: [{ start, key: scalar, sep: sep2 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map3;
          } else
            yield* this.lineEnd(scalar);
        }
        *blockScalar(scalar) {
          switch (this.type) {
            case "space":
            case "comment":
            case "newline":
              scalar.props.push(this.sourceToken);
              return;
            case "scalar":
              scalar.source = this.source;
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine) {
                let nl = this.source.indexOf("\n") + 1;
                while (nl !== 0) {
                  this.onNewLine(this.offset + nl);
                  nl = this.source.indexOf("\n", nl) + 1;
                }
              }
              yield* this.pop();
              break;
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.step();
          }
        }
        *blockMap(map3) {
          const it = map3.items[map3.items.length - 1];
          switch (this.type) {
            case "newline":
              this.onKeyLine = false;
              if (it.value) {
                const end = "end" in it.value ? it.value.end : void 0;
                const last2 = Array.isArray(end) ? end[end.length - 1] : void 0;
                if (last2?.type === "comment")
                  end?.push(this.sourceToken);
                else
                  map3.items.push({ start: [this.sourceToken] });
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "space":
            case "comment":
              if (it.value) {
                map3.items.push({ start: [this.sourceToken] });
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                if (this.atIndentedComment(it.start, map3.indent)) {
                  const prev = map3.items[map3.items.length - 2];
                  const end = prev?.value?.end;
                  if (Array.isArray(end)) {
                    Array.prototype.push.apply(end, it.start);
                    end.push(this.sourceToken);
                    map3.items.pop();
                    return;
                  }
                }
                it.start.push(this.sourceToken);
              }
              return;
          }
          if (this.indent >= map3.indent) {
            const atMapIndent = !this.onKeyLine && this.indent === map3.indent;
            const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
            let start = [];
            if (atNextItem && it.sep && !it.value) {
              const nl = [];
              for (let i7 = 0; i7 < it.sep.length; ++i7) {
                const st = it.sep[i7];
                switch (st.type) {
                  case "newline":
                    nl.push(i7);
                    break;
                  case "space":
                    break;
                  case "comment":
                    if (st.indent > map3.indent)
                      nl.length = 0;
                    break;
                  default:
                    nl.length = 0;
                }
              }
              if (nl.length >= 2)
                start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
              case "anchor":
              case "tag":
                if (atNextItem || it.value) {
                  start.push(this.sourceToken);
                  map3.items.push({ start });
                  this.onKeyLine = true;
                } else if (it.sep) {
                  it.sep.push(this.sourceToken);
                } else {
                  it.start.push(this.sourceToken);
                }
                return;
              case "explicit-key-ind":
                if (!it.sep && !it.explicitKey) {
                  it.start.push(this.sourceToken);
                  it.explicitKey = true;
                } else if (atNextItem || it.value) {
                  start.push(this.sourceToken);
                  map3.items.push({ start, explicitKey: true });
                } else {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken], explicitKey: true }]
                  });
                }
                this.onKeyLine = true;
                return;
              case "map-value-ind":
                if (it.explicitKey) {
                  if (!it.sep) {
                    if (includesToken(it.start, "newline")) {
                      Object.assign(it, { key: null, sep: [this.sourceToken] });
                    } else {
                      const start2 = getFirstKeyStartProps(it.start);
                      this.stack.push({
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                      });
                    }
                  } else if (it.value) {
                    map3.items.push({ start: [], key: null, sep: [this.sourceToken] });
                  } else if (includesToken(it.sep, "map-value-ind")) {
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start, key: null, sep: [this.sourceToken] }]
                    });
                  } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                    const start2 = getFirstKeyStartProps(it.start);
                    const key = it.key;
                    const sep2 = it.sep;
                    sep2.push(this.sourceToken);
                    delete it.key;
                    delete it.sep;
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key, sep: sep2 }]
                    });
                  } else if (start.length > 0) {
                    it.sep = it.sep.concat(start, this.sourceToken);
                  } else {
                    it.sep.push(this.sourceToken);
                  }
                } else {
                  if (!it.sep) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else if (it.value || atNextItem) {
                    map3.items.push({ start, key: null, sep: [this.sourceToken] });
                  } else if (includesToken(it.sep, "map-value-ind")) {
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: [], key: null, sep: [this.sourceToken] }]
                    });
                  } else {
                    it.sep.push(this.sourceToken);
                  }
                }
                this.onKeyLine = true;
                return;
              case "alias":
              case "scalar":
              case "single-quoted-scalar":
              case "double-quoted-scalar": {
                const fs3 = this.flowScalar(this.type);
                if (atNextItem || it.value) {
                  map3.items.push({ start, key: fs3, sep: [] });
                  this.onKeyLine = true;
                } else if (it.sep) {
                  this.stack.push(fs3);
                } else {
                  Object.assign(it, { key: fs3, sep: [] });
                  this.onKeyLine = true;
                }
                return;
              }
              default: {
                const bv = this.startBlockValue(map3);
                if (bv) {
                  if (atMapIndent && bv.type !== "block-seq") {
                    map3.items.push({ start });
                  }
                  this.stack.push(bv);
                  return;
                }
              }
            }
          }
          yield* this.pop();
          yield* this.step();
        }
        *blockSequence(seq2) {
          const it = seq2.items[seq2.items.length - 1];
          switch (this.type) {
            case "newline":
              if (it.value) {
                const end = "end" in it.value ? it.value.end : void 0;
                const last2 = Array.isArray(end) ? end[end.length - 1] : void 0;
                if (last2?.type === "comment")
                  end?.push(this.sourceToken);
                else
                  seq2.items.push({ start: [this.sourceToken] });
              } else
                it.start.push(this.sourceToken);
              return;
            case "space":
            case "comment":
              if (it.value)
                seq2.items.push({ start: [this.sourceToken] });
              else {
                if (this.atIndentedComment(it.start, seq2.indent)) {
                  const prev = seq2.items[seq2.items.length - 2];
                  const end = prev?.value?.end;
                  if (Array.isArray(end)) {
                    Array.prototype.push.apply(end, it.start);
                    end.push(this.sourceToken);
                    seq2.items.pop();
                    return;
                  }
                }
                it.start.push(this.sourceToken);
              }
              return;
            case "anchor":
            case "tag":
              if (it.value || this.indent <= seq2.indent)
                break;
              it.start.push(this.sourceToken);
              return;
            case "seq-item-ind":
              if (this.indent !== seq2.indent)
                break;
              if (it.value || includesToken(it.start, "seq-item-ind"))
                seq2.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
          }
          if (this.indent > seq2.indent) {
            const bv = this.startBlockValue(seq2);
            if (bv) {
              this.stack.push(bv);
              return;
            }
          }
          yield* this.pop();
          yield* this.step();
        }
        *flowCollection(fc) {
          const it = fc.items[fc.items.length - 1];
          if (this.type === "flow-error-end") {
            let top;
            do {
              yield* this.pop();
              top = this.peek(1);
            } while (top && top.type === "flow-collection");
          } else if (fc.end.length === 0) {
            switch (this.type) {
              case "comma":
              case "explicit-key-ind":
                if (!it || it.sep)
                  fc.items.push({ start: [this.sourceToken] });
                else
                  it.start.push(this.sourceToken);
                return;
              case "map-value-ind":
                if (!it || it.value)
                  fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                else if (it.sep)
                  it.sep.push(this.sourceToken);
                else
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                return;
              case "space":
              case "comment":
              case "newline":
              case "anchor":
              case "tag":
                if (!it || it.value)
                  fc.items.push({ start: [this.sourceToken] });
                else if (it.sep)
                  it.sep.push(this.sourceToken);
                else
                  it.start.push(this.sourceToken);
                return;
              case "alias":
              case "scalar":
              case "single-quoted-scalar":
              case "double-quoted-scalar": {
                const fs3 = this.flowScalar(this.type);
                if (!it || it.value)
                  fc.items.push({ start: [], key: fs3, sep: [] });
                else if (it.sep)
                  this.stack.push(fs3);
                else
                  Object.assign(it, { key: fs3, sep: [] });
                return;
              }
              case "flow-map-end":
              case "flow-seq-end":
                fc.end.push(this.sourceToken);
                return;
            }
            const bv = this.startBlockValue(fc);
            if (bv)
              this.stack.push(bv);
            else {
              yield* this.pop();
              yield* this.step();
            }
          } else {
            const parent = this.peek(2);
            if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
              yield* this.pop();
              yield* this.step();
            } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
              const prev = getPrevProps(parent);
              const start = getFirstKeyStartProps(prev);
              fixFlowSeqItems(fc);
              const sep2 = fc.end.splice(1, fc.end.length);
              sep2.push(this.sourceToken);
              const map3 = {
                type: "block-map",
                offset: fc.offset,
                indent: fc.indent,
                items: [{ start, key: fc, sep: sep2 }]
              };
              this.onKeyLine = true;
              this.stack[this.stack.length - 1] = map3;
            } else {
              yield* this.lineEnd(fc);
            }
          }
        }
        flowScalar(type2) {
          if (this.onNewLine) {
            let nl = this.source.indexOf("\n") + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf("\n", nl) + 1;
            }
          }
          return {
            type: type2,
            offset: this.offset,
            indent: this.indent,
            source: this.source
          };
        }
        startBlockValue(parent) {
          switch (this.type) {
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
              return this.flowScalar(this.type);
            case "block-scalar-header":
              return {
                type: "block-scalar",
                offset: this.offset,
                indent: this.indent,
                props: [this.sourceToken],
                source: ""
              };
            case "flow-map-start":
            case "flow-seq-start":
              return {
                type: "flow-collection",
                offset: this.offset,
                indent: this.indent,
                start: this.sourceToken,
                items: [],
                end: []
              };
            case "seq-item-ind":
              return {
                type: "block-seq",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken] }]
              };
            case "explicit-key-ind": {
              this.onKeyLine = true;
              const prev = getPrevProps(parent);
              const start = getFirstKeyStartProps(prev);
              start.push(this.sourceToken);
              return {
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, explicitKey: true }]
              };
            }
            case "map-value-ind": {
              this.onKeyLine = true;
              const prev = getPrevProps(parent);
              const start = getFirstKeyStartProps(prev);
              return {
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              };
            }
          }
          return null;
        }
        atIndentedComment(start, indent) {
          if (this.type !== "comment")
            return false;
          if (this.indent <= indent)
            return false;
          return start.every((st) => st.type === "newline" || st.type === "space");
        }
        *documentEnd(docEnd) {
          if (this.type !== "doc-mode") {
            if (docEnd.end)
              docEnd.end.push(this.sourceToken);
            else
              docEnd.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
          }
        }
        *lineEnd(token) {
          switch (this.type) {
            case "comma":
            case "doc-start":
            case "doc-end":
            case "flow-seq-end":
            case "flow-map-end":
            case "map-value-ind":
              yield* this.pop();
              yield* this.step();
              break;
            case "newline":
              this.onKeyLine = false;
            // fallthrough
            case "space":
            case "comment":
            default:
              if (token.end)
                token.end.push(this.sourceToken);
              else
                token.end = [this.sourceToken];
              if (this.type === "newline")
                yield* this.pop();
          }
        }
      };
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/public-api.js
  function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
    return { lineCounter, prettyErrors };
  }
  function parseAllDocuments(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser = new Parser(lineCounter?.addNewLine);
    const composer = new Composer(options);
    const docs = Array.from(composer.compose(parser.parse(source)));
    if (prettyErrors && lineCounter)
      for (const doc of docs) {
        doc.errors.forEach(prettifyError(source, lineCounter));
        doc.warnings.forEach(prettifyError(source, lineCounter));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer.streamInfo());
  }
  function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser = new Parser(lineCounter?.addNewLine);
    const composer = new Composer(options);
    let doc = null;
    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
    return doc;
  }
  function parse(src3, reviver, options) {
    let _reviver = void 0;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === void 0 && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument(src3, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  }
  function stringify3(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
    }
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === void 0) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return void 0;
    }
    return new Document(value, _replacer, options).toString(options);
  }
  var init_public_api = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/public-api.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_composer();
      init_Document();
      init_errors();
      init_log();
      init_line_counter();
      init_parser();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/index.js
  var dist_exports = {};
  __export(dist_exports, {
    Alias: () => Alias,
    CST: () => cst_exports,
    Composer: () => Composer,
    Document: () => Document,
    Lexer: () => Lexer,
    LineCounter: () => LineCounter,
    Pair: () => Pair,
    Parser: () => Parser,
    Scalar: () => Scalar,
    Schema: () => Schema,
    YAMLError: () => YAMLError,
    YAMLMap: () => YAMLMap,
    YAMLParseError: () => YAMLParseError,
    YAMLSeq: () => YAMLSeq,
    YAMLWarning: () => YAMLWarning,
    isAlias: () => isAlias,
    isCollection: () => isCollection,
    isDocument: () => isDocument,
    isMap: () => isMap,
    isNode: () => isNode,
    isPair: () => isPair,
    isScalar: () => isScalar,
    isSeq: () => isSeq,
    parse: () => parse,
    parseAllDocuments: () => parseAllDocuments,
    parseDocument: () => parseDocument,
    stringify: () => stringify3,
    visit: () => visit,
    visitAsync: () => visitAsync
  });
  var init_dist = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/index.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_composer();
      init_Document();
      init_Schema();
      init_errors();
      init_Alias();
      init_identity();
      init_Pair();
      init_Scalar();
      init_YAMLMap();
      init_YAMLSeq();
      init_cst();
      init_lexer();
      init_line_counter();
      init_parser();
      init_public_api();
      init_visit();
    }
  });

  // node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/index.js
  var browser_default;
  var init_browser = __esm({
    "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/index.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_dist();
      init_dist();
      browser_default = dist_exports;
    }
  });

  // node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.5.4/node_modules/@adviser/cement/index.js
  function bin2text(hex, lineFn, size = 0) {
    const arr = new Uint8Array(hex.buffer, hex.byteOffset, hex.byteLength);
    let cutted = "  ";
    if (size == 0) {
      size = arr.length;
    }
    size = Math.min(size, arr.length);
    const cols = 16;
    for (let line = 0; line < size; line += cols) {
      if (line + cols <= size || arr.length == size) {
      } else {
        line = arr.length - arr.length % cols;
        size = arr.length;
        cutted = ">>";
      }
      const l7 = [line.toString(16).padStart(4, "0"), cutted];
      for (let col = 0; col < cols; col++) {
        if (line + col < size) {
          l7.push(arr[line + col].toString(16).padStart(2, "0"));
        } else {
          l7.push("  ");
        }
        l7.push(" ");
      }
      for (let col = 0; col < cols; col++) {
        if (line + col < size) {
          const ch = arr[line + col];
          l7.push(ch >= 32 && ch < 127 ? String.fromCharCode(ch) : ".");
        }
      }
      lineFn(l7.join(""));
    }
  }
  function bin2string(hex, size = 0) {
    const collector = [];
    bin2text(
      hex,
      (line) => {
        collector.push(line);
      },
      size
    );
    return collector.join("\n");
  }
  function removeSelfRef(lineEnd) {
    const cache3 = /* @__PURE__ */ new Set();
    return function(key, value) {
      if (typeof value === "object" && value !== null) {
        if (cache3.has(value)) return "...";
        cache3.add(value);
      }
      return lineEnd ? value + lineEnd : value;
    };
  }
  function asyncLogValue(val) {
    throw new Error("Not implemented");
  }
  function logValue(val, state = /* @__PURE__ */ new Set([Math.random()])) {
    switch (typeof val) {
      case "function":
        return new LogValue(val);
      case "string": {
        try {
          const ret = JSON.parse(val);
          if (typeof ret === "object" && ret !== null) {
            return logValue(ret, state);
          }
        } catch (e9) {
          if (val.match(/[\n\r]/)) {
            const lines = val.trimEnd().split(/[\n\r]/);
            return new LogValue(() => lines);
          }
        }
        return new LogValue(() => val.toString());
      }
      case "number":
        return new LogValue(() => val);
      case "boolean":
        return new LogValue(() => val);
      case "object": {
        if (ArrayBuffer.isView(val)) {
          return logValue(bin2string(val, 512));
        }
        if (Array.isArray(val)) {
          return new LogValue(() => val.map((v6) => logValue(v6).value()));
        }
        if (val === null) {
          return new LogValue(() => "null");
        }
        if (state.has(val)) {
          return new LogValue(() => "...");
        }
        state.add(val);
        const res = {};
        const typedVal = val;
        for (const key in typedVal) {
          const element = typedVal[key];
          if (element instanceof LogValue) {
            res[key] = element;
          } else {
            res[key] = logValue(element, state);
          }
        }
        return new LogValue(() => res);
      }
      default:
        if (!val) {
          return new LogValue(() => "--Falsy--");
        }
        throw new Error(`Invalid type:${typeof val}`);
    }
  }
  function IsLogger(obj) {
    return typeof obj === "object" && [
      "Module",
      "EnableLevel",
      "DisableLevel",
      "SetDebug",
      "Str",
      "Error",
      "Warn",
      "Debug",
      "Log",
      "WithLevel",
      "Err",
      "Info",
      "Timestamp",
      "Any",
      "Dur",
      "Uint64"
    ].map((fn) => typeof obj[fn] === "function").reduce((a7, b5) => a7 && b5, true);
  }
  function exception2Result(fn) {
    try {
      const res = fn();
      if (res instanceof Promise) {
        return res.then((value) => Result.Ok(value)).catch((e9) => Result.Err(e9));
      }
      return Result.Ok(res);
    } catch (e9) {
      return Result.Err(e9);
    }
  }
  function falsy2undef(value) {
    return value === void 0 || value === null ? void 0 : value;
  }
  function ensureURLWithDefaultProto(url, defaultProtocol) {
    if (!url) {
      return new MutableURL(`${defaultProtocol}//`);
    }
    if (typeof url === "string") {
      try {
        return new MutableURL(url);
      } catch (e9) {
        return new MutableURL(`${defaultProtocol}//${url}`);
      }
    } else {
      return new MutableURL(url.toString());
    }
  }
  function isURL(value) {
    return value instanceof URL || !!value && typeof value.searchParams === "object" && typeof value.searchParams.sort === "function" && typeof value.hash === "string";
  }
  function from(fac, strURLUri, defaultProtocol) {
    switch (typeof falsy2undef(strURLUri)) {
      case "undefined":
        return fac(new MutableURL(`${defaultProtocol}///`));
      case "string":
        return fac(ensureURLWithDefaultProto(strURLUri, defaultProtocol));
      case "object":
        if (BuildURI.is(strURLUri)) {
          return fac(new MutableURL(strURLUri._url.toString()));
        } else if (URI.is(strURLUri)) {
          return fac(new MutableURL(strURLUri._url.toString()));
        } else if (isURL(strURLUri)) {
          return fac(new MutableURL(strURLUri.toString()));
        }
        throw new Error(`unknown object type: ${strURLUri}`);
      default:
        throw new Error(`Invalid argument: ${typeof strURLUri}`);
    }
  }
  function isSet(value, ref = globalThis) {
    const [head, ...tail] = value.split(".");
    if (["object", "function"].includes(typeof ref) && ref && ["object", "function"].includes(typeof ref[head]) && ref[head]) {
      if (tail.length <= 1) {
        return true;
      }
      return isSet(tail.join("."), ref[head]);
    }
    return false;
  }
  function runtimeFn() {
    const gt = globalThis;
    const isReactNative = isSet("navigator.product") && typeof gt["navigator"] === "object" && gt["navigator"]["product"] === "ReactNative";
    let isNodeIsh = false;
    if (!isSet("Deno")) {
      isNodeIsh = isSet("process.versions.node") && !isReactNative;
    }
    const isDeno = isSet("Deno");
    return {
      isNodeIsh,
      isBrowser: !(isNodeIsh || isDeno) && !isReactNative,
      isDeno,
      isReactNative
    };
  }
  function LevelHandlerSingleton() {
    return levelSingleton;
  }
  function getLen(value) {
    if (Array.isArray(value)) {
      return logValue(() => value.length);
    } else if (typeof value === "string") {
      return logValue(() => value.length);
    } else if (typeof value === "object" && value !== null) {
      if (typeof value.size === "number") {
        return logValue(() => value.size);
      } else if (typeof value.length === "number") {
        return logValue(() => value.length);
      }
      return logValue(() => Object.keys(value).length);
    }
    return logValue(() => -1);
  }
  function hash(value) {
    return "not implemented";
  }
  function toLogValue(lop) {
    if (lop && typeof lop.then === "function") {
      throw new Error("async logValue Not implemented");
    }
    return lop;
  }
  function randomBytes(size) {
    const bytes = new Uint8Array(size);
    if (size > 0) {
      crypto.getRandomValues(bytes);
    }
    return bytes;
  }
  function digestSHA256(data) {
    return Promise.resolve(crypto.subtle.digest("SHA-256", data));
  }
  function toCryptoRuntime(cryptoOpts = {}) {
    const runtime = {
      importKey: cryptoOpts.importKey || crypto.subtle.importKey.bind(crypto.subtle),
      exportKey: cryptoOpts.exportKey || crypto.subtle.exportKey.bind(crypto.subtle),
      encrypt: cryptoOpts.encrypt || crypto.subtle.encrypt.bind(crypto.subtle),
      decrypt: cryptoOpts.decrypt || crypto.subtle.decrypt.bind(crypto.subtle),
      randomBytes: cryptoOpts.randomBytes || randomBytes,
      digestSHA256: cryptoOpts.digestSHA256 || digestSHA256
    };
    return runtime;
  }
  var LogValue, Result, ResultOK, ResultError, MutableURL, BuildURI, hasHostPartProtocols, URI, LogWriterStream, LevelHandlerImpl, levelSingleton, JSONFormatter, YAMLFormatter, LoggerImpl, WithLoggerBuilder, VERSION;
  var init_cement = __esm({
    "node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.5.4/node_modules/@adviser/cement/index.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_7KFVMTOS();
      init_chunk_WMMUXBDX();
      init_chunk_Q65HLCNL();
      init_chunk_GES3MUGV();
      init_browser();
      LogValue = class {
        constructor(fn) {
          this.fn = fn;
        }
        value() {
          return this.fn();
        }
        toJSON() {
          return this.value();
        }
      };
      Result = class _Result {
        static Ok(t8) {
          return new ResultOK(t8);
        }
        static Err(t8) {
          if (typeof t8 === "string") {
            return new ResultError(new Error(t8));
          }
          return new ResultError(t8);
        }
        static Is(t8) {
          if (!t8) {
            return false;
          }
          if (t8 instanceof _Result) {
            return true;
          }
          const rt = t8;
          if ([typeof rt.is_ok, typeof rt.is_err, typeof rt.unwrap, typeof rt.unwrap_err].every((x4) => x4 === "function")) {
            return true;
          }
          return false;
        }
        isOk() {
          return this.is_ok();
        }
        isErr() {
          return this.is_err();
        }
        Ok() {
          return this.unwrap();
        }
        Err() {
          return this.unwrap_err();
        }
      };
      ResultOK = class extends Result {
        constructor(t8) {
          super();
          this._t = t8;
        }
        is_ok() {
          return true;
        }
        is_err() {
          return false;
        }
        unwrap_err() {
          throw new Error("Result is Ok");
        }
        unwrap() {
          return this._t;
        }
      };
      ResultError = class extends Result {
        constructor(t8) {
          super();
          this._error = t8;
        }
        is_ok() {
          return false;
        }
        is_err() {
          return true;
        }
        unwrap() {
          throw new Error(`Result is Err: ${this._error}`);
        }
        unwrap_err() {
          return this._error;
        }
      };
      MutableURL = class _MutableURL extends URL {
        constructor(urlStr) {
          super("defect://does.not.exist");
          const partedURL = urlStr.split(":");
          this._hasHostpart = hasHostPartProtocols.has(partedURL[0]);
          let hostPartUrl = ["http", ...partedURL.slice(1)].join(":");
          if (!this._hasHostpart) {
            const pathname = hostPartUrl.replace(/http:\/\/[/]*/, "").replace(/[#?].*$/, "");
            hostPartUrl = hostPartUrl.replace(/http:\/\//, `http://localhost/${pathname}`);
          }
          try {
            this._sysURL = new URL(hostPartUrl);
          } catch (ie) {
            const e9 = ie;
            e9.message = `${e9.message} for URL: ${urlStr}`;
            throw e9;
          }
          this._protocol = `${partedURL[0]}:`;
          if (this._hasHostpart) {
            this._pathname = this._sysURL.pathname;
          } else {
            this._pathname = urlStr.replace(new RegExp(`^${this._protocol}//`), "").replace(/[#?].*$/, "");
          }
          this.hash = this._sysURL.hash;
        }
        clone() {
          return new _MutableURL(this.toString());
        }
        get host() {
          if (!this._hasHostpart) {
            throw new Error(
              `you can use hostname only if protocol is ${this.toString()} ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`
            );
          }
          return this._sysURL.host;
        }
        get port() {
          if (!this._hasHostpart) {
            throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
          }
          return this._sysURL.port;
        }
        set port(p7) {
          if (!this._hasHostpart) {
            throw new Error(`you can use port only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
          }
          this._sysURL.port = p7;
        }
        get hostname() {
          if (!this._hasHostpart) {
            throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
          }
          return this._sysURL.hostname;
        }
        set hostname(h8) {
          if (!this._hasHostpart) {
            throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
          }
          this._sysURL.hostname = h8;
        }
        set pathname(p7) {
          this._pathname = p7;
        }
        get pathname() {
          return this._pathname;
        }
        get protocol() {
          return this._protocol;
        }
        set protocol(p7) {
          if (!p7.endsWith(":")) {
            p7 = `${p7}:`;
          }
          this._protocol = p7;
        }
        get searchParams() {
          return this._sysURL.searchParams;
        }
        toString() {
          let search = "";
          if (this._sysURL.searchParams.size) {
            for (const [key, value] of Array.from(this._sysURL.searchParams.entries()).sort((a7, b5) => a7[0].localeCompare(b5[0]))) {
              search += `${!search.length ? "?" : "&"}${key}=${encodeURIComponent(value)}`;
            }
          }
          let hostpart = "";
          if (this._hasHostpart) {
            hostpart = this._sysURL.hostname;
            if (this._sysURL.port) {
              hostpart += `:${this._sysURL.port}`;
            }
            if (!this._pathname.startsWith("/")) {
              hostpart += "/";
            }
          }
          return `${this._protocol}//${hostpart}${this._pathname}${search}`;
        }
      };
      BuildURI = class _BuildURI {
        // pathname needs this
        constructor(url) {
          this._url = url;
        }
        static is(value) {
          return value instanceof _BuildURI || !!value && typeof value.delParam === "function" && typeof value.setParam === "function";
        }
        static from(strURLUri, defaultProtocol = "file:") {
          return from((url) => new _BuildURI(url), strURLUri, defaultProtocol);
        }
        port(p7) {
          this._url.port = p7;
          return this;
        }
        hostname(h8) {
          this._url.hostname = h8;
          return this;
        }
        // password(p: string) {
        //   this._url.password = p;
        //   return this;
        // }
        // port(p: string) {
        //   this._url.port = p;
        //   return this;
        // }
        // username(u: string) {
        //   this._url.username = u;
        //   return this;
        // }
        // search(s: string) {
        //   this._url.search = s;
        //   return this;
        // }
        protocol(p7) {
          this._url.protocol = p7;
          return this;
        }
        pathname(p7) {
          this._url.pathname = p7;
          return this;
        }
        // hash(h: string) {
        //   this._url.hash = h;
        //   return this;
        // }
        // host(h: string) {
        //   this._url.host = h;
        //   return this;
        // }
        delParam(key) {
          this._url.searchParams.delete(key);
          return this;
        }
        defParam(key, str) {
          if (!this._url.searchParams.has(key)) {
            this._url.searchParams.set(key, str);
          }
          return this;
        }
        setParam(key, str) {
          this._url.searchParams.set(key, str);
          return this;
        }
        hasParam(key) {
          return this._url.searchParams.has(key);
        }
        getParam(key) {
          return falsy2undef(this._url.searchParams.get(key));
        }
        toString() {
          this._url.searchParams.sort();
          return this._url.toString();
        }
        toJSON() {
          return this.toString();
        }
        URI() {
          return URI.from(this._url);
        }
      };
      hasHostPartProtocols = /* @__PURE__ */ new Set(["http", "https", "ws", "wss"]);
      URI = class _URI {
        static protocolHasHostpart(protocol) {
          protocol = protocol.replace(/:$/, "");
          hasHostPartProtocols.add(protocol);
          return () => {
            hasHostPartProtocols.delete(protocol);
          };
        }
        // if no protocol is provided, default to file:
        static merge(into, from22, defaultProtocol = "file:") {
          const intoUrl = BuildURI.from(into, defaultProtocol);
          const fromUrl = _URI.from(from22, defaultProtocol);
          intoUrl.protocol(fromUrl.protocol);
          const fPath = fromUrl.pathname;
          if (!(fPath.length === 0 || fPath === "/" || fPath === "./")) {
            intoUrl.pathname(fromUrl.pathname);
          }
          for (const [key, value] of fromUrl.getParams) {
            intoUrl.setParam(key, value);
          }
          return intoUrl.URI();
        }
        static is(value) {
          return value instanceof _URI || !!value && typeof value.asURL === "function" && typeof value.getParam === "function" && typeof value.hasParam === "function";
        }
        // if no protocol is provided, default to file:
        static from(strURLUri, defaultProtocol = "file:") {
          return from((url) => new _URI(url), strURLUri, defaultProtocol);
        }
        static fromResult(strURLUri, defaultProtocol = "file:") {
          return exception2Result(() => from((url) => new _URI(url), strURLUri, defaultProtocol));
        }
        constructor(url) {
          this._url = url.clone();
        }
        build() {
          return BuildURI.from(this._url);
        }
        get hostname() {
          return this._url.hostname;
        }
        // get password(): string {
        //   return this._url.password;
        // }
        get port() {
          return this._url.port;
        }
        get host() {
          return this._url.host;
        }
        // get username(): string {
        //   return this._url.username;
        // }
        // get search(): string {
        //   return this._url.search;
        // }
        get protocol() {
          return this._url.protocol;
        }
        get pathname() {
          return this._url.pathname;
        }
        // get hash(): string {
        //   return this._url.hash;
        // }
        // get host(): string {
        //   return this._url.host;
        // }
        get getParams() {
          return this._url.searchParams.entries();
        }
        hasParam(key) {
          return this._url.searchParams.has(key);
        }
        getParam(key) {
          return falsy2undef(this._url.searchParams.get(key));
        }
        clone() {
          return new _URI(this._url);
        }
        asURL() {
          return this._url.clone();
        }
        toString() {
          return this._url.toString();
        }
        toJSON() {
          return this.toString();
        }
        asObj() {
          const pathURI = {
            style: "path",
            protocol: this.protocol,
            pathname: this.pathname,
            searchParams: Object.fromEntries(this.getParams)
          };
          if (hasHostPartProtocols.has(this.protocol.replace(/:$/, ""))) {
            return __spreadProps(__spreadValues({}, pathURI), {
              style: "host",
              hostname: this.hostname,
              port: this.port
            });
          }
          return pathURI;
        }
      };
      LogWriterStream = class {
        constructor(out) {
          this._toFlush = [];
          this._flushIsRunning = false;
          this._flushDoneFns = [];
          this._out = out;
        }
        write(encoded) {
          const my2 = async () => {
            try {
              const writer = this._out.getWriter();
              await writer.ready;
              await writer.write(encoded);
              await writer.releaseLock();
            } catch (err) {
              console.error("Chunk error:", err);
            }
          };
          this._toFlush.push(my2);
          this._flush();
        }
        _flush(toFlush = void 0, done) {
          if (done) {
            this._flushDoneFns.push(done);
          }
          if (this._toFlush.length == 0) {
            this._flushIsRunning = false;
            this._flushDoneFns.forEach((fn) => fn());
            this._flushDoneFns = [];
            return;
          }
          if (!toFlush && this._toFlush.length == 1 && !this._flushIsRunning) {
            this._flushIsRunning = true;
          } else if (!toFlush) {
            return;
          }
          const my2 = this._toFlush.shift();
          my2 == null ? void 0 : my2().finally(() => {
            this._flush(this._toFlush);
          });
        }
      };
      LevelHandlerImpl = class {
        constructor() {
          this._globalLevels = /* @__PURE__ */ new Set([
            "info",
            "error",
            "warn"
            /* WARN */
          ]);
          this._modules = /* @__PURE__ */ new Map();
          this.isStackExposed = false;
        }
        enableLevel(level, ...modules) {
          if (modules.length == 0) {
            this._globalLevels.add(level);
            return;
          }
          this.forModules(
            level,
            (p7) => {
              this._modules.set(p7, /* @__PURE__ */ new Set([...this._globalLevels, level]));
            },
            ...modules
          );
        }
        disableLevel(level, ...modules) {
          if (modules.length == 0) {
            this._globalLevels.delete(level);
            return;
          }
          this.forModules(
            level,
            (p7) => {
              this._modules.delete(p7);
            },
            ...modules
          );
        }
        setExposeStack(enable) {
          this.isStackExposed = !!enable;
        }
        forModules(level, fnAction, ...modules) {
          for (const m6 of modules.flat()) {
            if (typeof m6 !== "string") {
              continue;
            }
            const parts = m6.split(",").map((s6) => s6.trim()).filter((s6) => s6.length);
            for (const p7 of parts) {
              fnAction(p7);
            }
          }
        }
        setDebug(...modules) {
          this.forModules(
            "debug",
            (p7) => {
              this._modules.set(p7, /* @__PURE__ */ new Set([
                ...this._globalLevels,
                "debug"
                /* DEBUG */
              ]));
            },
            ...modules
          );
        }
        isEnabled(ilevel, module2) {
          const level = ilevel;
          if (typeof module2 === "string") {
            const levels = this._modules.get(module2);
            if (levels && levels.has(level)) {
              return true;
            }
          }
          const wlevel = this._modules.get("*");
          if (wlevel && typeof level === "string") {
            if (wlevel.has(level)) {
              return true;
            }
          }
          if (typeof level !== "string") {
            return true;
          }
          return this._globalLevels.has(level);
        }
      };
      levelSingleton = new LevelHandlerImpl();
      JSONFormatter = class {
        constructor(txtEnde, space) {
          this._txtEnDe = txtEnde;
          this._space = space;
        }
        format(attr) {
          return this._txtEnDe.encode(JSON.stringify(attr, removeSelfRef(), this._space) + "\n");
        }
      };
      YAMLFormatter = class {
        constructor(txtEnde, space) {
          this._txtEnDe = txtEnde;
          this._space = space;
        }
        format(attr) {
          return this._txtEnDe.encode("---\n" + browser_default.stringify(attr, removeSelfRef(), this._space) + "\n");
        }
      };
      LoggerImpl = class _LoggerImpl {
        // readonly _id: string = "logger-" + Math.random().toString(36)
        constructor(params) {
          this._attributes = {};
          if (!params) {
            params = {};
          }
          if (!params.sys) {
            this._sys = WebSysAbstraction();
          } else {
            this._sys = params.sys;
          }
          if (!params.txtEnDe) {
            this._txtEnDe = Utf8EnDecoderSingleton();
          } else {
            this._txtEnDe = params.txtEnDe;
          }
          if (!params.formatter) {
            this._formatter = new JSONFormatter(this._txtEnDe);
          } else {
            this._formatter = params.formatter;
          }
          if (params.logWriter) {
            this._logWriter = params.logWriter;
          } else {
            if (!params.out) {
              const rt = runtimeFn();
              let stream;
              if (rt.isBrowser) {
                stream = new ConsoleWriterStream();
              } else {
                if (rt.isNodeIsh || rt.isReactNative || rt.isDeno) {
                  stream = this._sys.Stdout();
                } else {
                  throw new Error("No output defined for runtime");
                }
              }
              this._logWriter = new LogWriterStream(stream);
            } else {
              this._logWriter = new LogWriterStream(params.out);
            }
          }
          if (!params.withAttributes) {
            this._withAttributes = {};
          } else {
            this._withAttributes = __spreadValues({}, params.withAttributes);
          }
          this._attributes = __spreadValues({}, this._withAttributes);
          if (params.levelHandler) {
            this._levelHandler = params.levelHandler;
          } else {
            this._levelHandler = LevelHandlerSingleton();
          }
        }
        TxtEnDe() {
          return this._txtEnDe;
        }
        Attributes() {
          return JSON.parse(JSON.stringify(this._attributes, removeSelfRef()));
        }
        SetExposeStack(enable) {
          this._levelHandler.setExposeStack(enable);
          return this;
        }
        EnableLevel(level, ...modules) {
          this._levelHandler.enableLevel(level, ...modules);
          return this;
        }
        DisableLevel(level, ...modules) {
          this._levelHandler.disableLevel(level, ...modules);
          return this;
        }
        Module(key) {
          this._attributes["module"] = logValue(key);
          this._withAttributes["module"] = logValue(key);
          return this;
        }
        // if the string is "*" it will enable for all modules
        SetDebug(...modules) {
          this._levelHandler.setDebug(...modules);
          return this;
        }
        SetFormatter(formatter) {
          this._formatter = formatter;
          return this;
        }
        Timestamp() {
          this._attributes["ts"] = logValue(() => this._sys.Time().Now().toISOString());
          return this;
        }
        Warn() {
          this._attributes["level"] = logValue(
            "warn"
            /* WARN */
          );
          return this;
        }
        Log() {
          return this;
        }
        Debug() {
          this._attributes["level"] = logValue(
            "debug"
            /* DEBUG */
          );
          return this;
        }
        Error() {
          this._attributes["level"] = logValue(
            "error"
            /* ERROR */
          );
          return this;
        }
        Info() {
          this._attributes["level"] = logValue(
            "info"
            /* INFO */
          );
          return this;
        }
        Err(err) {
          var _a;
          if (Result.Is(err)) {
            if (err.isOk()) {
              this.Result("noerror", err);
            } else {
              this.Result("error", err);
            }
          } else if (err instanceof Error) {
            this._attributes["error"] = logValue(err.message);
            if (this._levelHandler.isStackExposed) {
              this._attributes["stack"] = logValue((_a = err.stack) == null ? void 0 : _a.split("\n").map((s6) => s6.trim()));
            }
          } else {
            this._attributes["error"] = logValue("" + err);
          }
          return this;
        }
        WithLevel(l7) {
          this._attributes["level"] = logValue(l7);
          return this;
        }
        Ref(key, action) {
          if (typeof action === "function") {
            this._attributes[key] = logValue(action);
          } else if (typeof action.toString === "function") {
            this._attributes[key] = logValue(() => action.toString());
          } else {
            this._attributes[key] = logValue("INVALID REF");
          }
          return this;
        }
        Bool(key, value) {
          this._attributes[key] = logValue(!!value);
          return this;
        }
        Result(key, res) {
          if (res.isOk()) {
            this._attributes[key] = logValue(res.Ok());
          } else {
            this.Err(res.Err());
          }
          return this;
        }
        Len(value, key = "len") {
          this._attributes[key] = getLen(value);
          return this;
        }
        Hash(value, key = "hash") {
          this._attributes[key] = asyncLogValue(async () => `${getLen(value).value()}:${await hash(value)}`);
          return this;
        }
        Url(url, key = "url") {
          this.Ref(key, () => URI.from(url).toString());
          return this;
        }
        Str(key, value) {
          this._attributes[key] = logValue(value);
          return this;
        }
        Any(key, value) {
          this._attributes[key] = logValue(value);
          return this;
        }
        Dur(key, nsec) {
          this._attributes[key] = logValue(`${nsec}ms`);
          return this;
        }
        Uint64(key, value) {
          this._attributes[key] = logValue(value);
          return this;
        }
        Int(key, value) {
          return this.Uint64(key, value);
        }
        async Flush() {
          return new Promise((resolve9) => {
            this._logWriter._flush(void 0, resolve9);
          });
        }
        With() {
          return new WithLoggerBuilder(
            new _LoggerImpl({
              logWriter: this._logWriter,
              sys: this._sys,
              levelHandler: this._levelHandler,
              formatter: this._formatter,
              withAttributes: __spreadValues({
                module: this._attributes["module"]
              }, this._withAttributes)
            })
          );
        }
        _resetAttributes(fn) {
          const ret = fn();
          Object.keys(this._attributes).forEach((key) => {
            delete this._attributes[key];
          });
          Object.assign(this._attributes, this._withAttributes);
          return ret;
        }
        Msg(...args) {
          const fnError = this._resetAttributes(() => {
            var _a, _b;
            const doWrite = this._levelHandler.isEnabled(
              (_a = toLogValue(this._attributes["level"])) == null ? void 0 : _a.value(),
              (_b = toLogValue(this._attributes["module"])) == null ? void 0 : _b.value()
            );
            this._attributes["msg"] = logValue(args.join(" "));
            const msg = this._attributes["msg"].value();
            if (typeof msg === "string" && !msg.trim().length) {
              delete this._attributes["msg"];
            }
            let fnRet = () => this._formatter.format(__spreadValues({}, this._attributes));
            if (doWrite) {
              const encoded = fnRet();
              this._logWriter.write(encoded);
              fnRet = () => encoded;
            }
            return fnRet;
          });
          return {
            AsError: () => new Error(this._txtEnDe.decode(fnError()))
          };
        }
      };
      WithLoggerBuilder = class {
        constructor(li) {
          this._li = li;
        }
        TxtEnDe() {
          return this._li.TxtEnDe();
        }
        Logger() {
          Object.assign(this._li._withAttributes, this._li._attributes);
          return this._li;
        }
        Attributes() {
          return __spreadValues({}, this._li._attributes);
        }
        SetExposeStack(enable) {
          this._li._levelHandler.setExposeStack(enable);
          return this;
        }
        SetFormatter(fmt) {
          this._li.SetFormatter(fmt);
          return this;
        }
        EnableLevel(level, ...modules) {
          this._li._levelHandler.enableLevel(level, ...modules);
          return this;
        }
        DisableLevel(level, ...modules) {
          this._li._levelHandler.enableLevel(level, ...modules);
          return this;
        }
        Module(key) {
          this._li.Module(key);
          return this;
        }
        SetDebug(...modules) {
          this._li.SetDebug(...modules);
          return this;
        }
        Str(key, value) {
          this._li.Str(key, value);
          return this;
        }
        Len(value, key) {
          this._li.Len(value, key);
          return this;
        }
        Hash(value, key) {
          this._li.Hash(value, key);
          return this;
        }
        Ref(key, action) {
          this._li.Ref(key, action);
          return this;
        }
        Bool(key, value) {
          this._li.Bool(key, value);
          return this;
        }
        Result(key, res) {
          this._li.Result(key, res);
          return this;
        }
        Url(url, key) {
          this._li.Url(url, key);
          return this;
        }
        Int(key, value) {
          this._li.Int(key, value);
          return this;
        }
        Log() {
          this._li.Log();
          return this;
        }
        WithLevel(level) {
          this._li.WithLevel(level);
          return this;
        }
        Error() {
          this._li.Error();
          return this;
        }
        Warn() {
          this._li.Error();
          return this;
        }
        Debug() {
          this._li.Debug();
          return this;
        }
        Err(err) {
          this._li.Err(err);
          return this;
        }
        Info() {
          this._li.Info();
          return this;
        }
        Timestamp() {
          this._li.Timestamp();
          return this;
        }
        Any(key, value) {
          this._li.Any(key, value);
          return this;
        }
        Dur(key, nsec) {
          this._li.Dur(key, nsec);
          return this;
        }
        Uint64(key, value) {
          this._li.Uint64(key, value);
          return this;
        }
      };
      VERSION = Object.keys({
        __packageVersion__: "xxxx"
      })[0];
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/chunk-7EWIAXTM.js
  var FILESTORE_VERSION;
  var init_chunk_7EWIAXTM = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/chunk-7EWIAXTM.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      FILESTORE_VERSION = "v0.19-file";
    }
  });

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/bytes.js
  var bytes_exports = {};
  __export(bytes_exports, {
    coerce: () => coerce,
    empty: () => empty,
    equals: () => equals,
    fromHex: () => fromHex,
    fromString: () => fromString,
    isBinary: () => isBinary,
    toHex: () => toHex,
    toString: () => toString
  });
  function toHex(d6) {
    return d6.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
  }
  function fromHex(hex) {
    const hexes = hex.match(/../g);
    return hexes != null ? new Uint8Array(hexes.map((b5) => parseInt(b5, 16))) : empty;
  }
  function equals(aa, bb) {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce(o8) {
    if (o8 instanceof Uint8Array && o8.constructor.name === "Uint8Array")
      return o8;
    if (o8 instanceof ArrayBuffer)
      return new Uint8Array(o8);
    if (ArrayBuffer.isView(o8)) {
      return new Uint8Array(o8.buffer, o8.byteOffset, o8.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function isBinary(o8) {
    return o8 instanceof ArrayBuffer || ArrayBuffer.isView(o8);
  }
  function fromString(str) {
    return new TextEncoder().encode(str);
  }
  function toString(b5) {
    return new TextDecoder().decode(b5);
  }
  var empty;
  var init_bytes = __esm({
    "node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/bytes.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      empty = new Uint8Array(0);
    }
  });

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/vendor/base-x.js
  function base(ALPHABET, name8) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j4 = 0; j4 < BASE_MAP.length; j4++) {
      BASE_MAP[j4] = 255;
    }
    for (var i7 = 0; i7 < ALPHABET.length; i7++) {
      var x4 = ALPHABET.charAt(i7);
      var xc = x4.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x4 + " is ambiguous");
      }
      BASE_MAP[xc] = i7;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode18(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length4 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i8 = 0;
        for (var it1 = size - 1; (carry !== 0 || i8 < length4) && it1 !== -1; it1--, i8++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i8;
        pbegin++;
      }
      var it2 = size - length4;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length4 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i8 = 0;
        for (var it3 = size - 1; (carry !== 0 || i8 < length4) && it3 !== -1; it3--, i8++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i8;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length4;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j5 = zeroes;
      while (it4 !== size) {
        vch[j5++] = b256[it4++];
      }
      return vch;
    }
    function decode21(string3) {
      var buffer4 = decodeUnsafe(string3);
      if (buffer4) {
        return buffer4;
      }
      throw new Error(`Non-${name8} character`);
    }
    return {
      encode: encode18,
      decodeUnsafe,
      decode: decode21
    };
  }
  var src, _brrp__multiformats_scope_baseX, base_x_default;
  var init_base_x = __esm({
    "node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/vendor/base-x.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      src = base;
      _brrp__multiformats_scope_baseX = src;
      base_x_default = _brrp__multiformats_scope_baseX;
    }
  });

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/bases/base.js
  function or(left, right) {
    return new ComposedDecoder({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  function from2({ name: name8, prefix, encode: encode18, decode: decode21 }) {
    return new Codec(name8, prefix, encode18, decode21);
  }
  function baseX({ name: name8, prefix, alphabet: alphabet2 }) {
    const { encode: encode18, decode: decode21 } = base_x_default(alphabet2, name8);
    return from2({
      prefix,
      name: name8,
      encode: encode18,
      decode: (text) => coerce(decode21(text))
    });
  }
  function decode(string3, alphabet2, bitsPerChar, name8) {
    const codes = {};
    for (let i7 = 0; i7 < alphabet2.length; ++i7) {
      codes[alphabet2[i7]] = i7;
    }
    let end = string3.length;
    while (string3[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer4 = 0;
    let written = 0;
    for (let i7 = 0; i7 < end; ++i7) {
      const value = codes[string3[i7]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name8} character`);
      }
      buffer4 = buffer4 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer4 >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer4 << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode(data, alphabet2, bitsPerChar) {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer4 = 0;
    for (let i7 = 0; i7 < data.length; ++i7) {
      buffer4 = buffer4 << 8 | data[i7];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet2[mask & buffer4 >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet2[mask & buffer4 << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function rfc4648({ name: name8, prefix, bitsPerChar, alphabet: alphabet2 }) {
    return from2({
      prefix,
      name: name8,
      encode(input) {
        return encode(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode(input, alphabet2, bitsPerChar, name8);
      }
    });
  }
  var Encoder, Decoder, ComposedDecoder, Codec;
  var init_base = __esm({
    "node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/bases/base.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_bytes();
      init_base_x();
      Encoder = class {
        name;
        prefix;
        baseEncode;
        constructor(name8, prefix, baseEncode) {
          this.name = name8;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
        }
        encode(bytes) {
          if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      Decoder = class {
        name;
        prefix;
        baseDecode;
        prefixCodePoint;
        constructor(name8, prefix, baseDecode) {
          this.name = name8;
          this.prefix = prefix;
          const prefixCodePoint = prefix.codePointAt(0);
          if (prefixCodePoint === void 0) {
            throw new Error("Invalid prefix character");
          }
          this.prefixCodePoint = prefixCodePoint;
          this.baseDecode = baseDecode;
        }
        decode(text) {
          if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
          } else {
            throw Error("Can only multibase decode strings");
          }
        }
        or(decoder2) {
          return or(this, decoder2);
        }
      };
      ComposedDecoder = class {
        decoders;
        constructor(decoders) {
          this.decoders = decoders;
        }
        or(decoder2) {
          return or(this, decoder2);
        }
        decode(input) {
          const prefix = input[0];
          const decoder2 = this.decoders[prefix];
          if (decoder2 != null) {
            return decoder2.decode(input);
          } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
          }
        }
      };
      Codec = class {
        name;
        prefix;
        baseEncode;
        baseDecode;
        encoder;
        decoder;
        constructor(name8, prefix, baseEncode, baseDecode) {
          this.name = name8;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
          this.baseDecode = baseDecode;
          this.encoder = new Encoder(name8, prefix, baseEncode);
          this.decoder = new Decoder(name8, prefix, baseDecode);
        }
        encode(input) {
          return this.encoder.encode(input);
        }
        decode(input) {
          return this.decoder.decode(input);
        }
      };
    }
  });

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/bases/base58.js
  var base58btc, base58flickr;
  var init_base58 = __esm({
    "node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/bases/base58.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_base();
      base58btc = baseX({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      });
      base58flickr = baseX({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      });
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/chunk-MAK4D54P.js
  function presetEnv() {
    const penv = new Map([
      // ["FP_DEBUG", "xxx"],
      // ["FP_ENV", "development"],
      ...Array.from(
        Object.entries(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          globalThis[Symbol.for("FP_PRESET_ENV")] || {}
        )
      )
      // .map(([k, v]) => [k, v as string])
    ]);
    return penv;
  }
  function ensureSuperThis(osthis) {
    const env2 = envFactory({
      symbol: osthis?.env?.symbol || "FP_ENV",
      presetEnv: osthis?.env?.presetEnv || presetEnv()
    });
    return new superThis({
      logger: osthis?.logger || globalLogger,
      env: env2,
      crypto: osthis?.crypto || toCryptoRuntime(),
      ctx: osthis?.ctx || {},
      pathOps,
      txt: osthis?.txt || txtOps
    });
  }
  function ensureSuperLog(sthis, componentName, ctx) {
    return sthis.clone({
      logger: ensureLogger(sthis, componentName, ctx)
    });
  }
  function ensureLogger(sthis, componentName, ctx) {
    let logger = globalLogger;
    if (IsLogger(sthis)) {
      logger = sthis;
    } else if (sthis && IsLogger(sthis.logger)) {
      logger = sthis.logger;
    }
    const cLogger = logger.With().Module(componentName);
    const debug = [];
    let exposeStack = false;
    if (ctx) {
      if ("debug" in ctx) {
        if (typeof ctx.debug === "string" && ctx.debug.length > 0) {
          debug.push(ctx.debug);
        } else {
          debug.push(componentName);
        }
        delete ctx.debug;
      }
      if ("exposeStack" in ctx) {
        exposeStack = true;
        delete ctx.exposeStack;
      }
      if ("this" in ctx) {
        cLogger.Str("this", sthis.nextId(4).str);
        delete ctx.this;
      }
      for (const [key, value] of Object.entries(ctx)) {
        switch (typeof value) {
          case "string":
            cLogger.Str(key, value);
            break;
          case "number":
            cLogger.Uint64(key, value);
            break;
          default:
            if (value instanceof Date) {
              cLogger.Str(key, value.toISOString());
            } else if (isURL(value)) {
              cLogger.Str(key, value.toString());
            } else if (typeof value === "function") {
              cLogger.Ref(key, value);
            } else {
              cLogger.Any(key, value);
            }
            break;
        }
      }
    }
    registerFP_DEBUG.once(async () => {
      sthis.env.onSet(
        (key, value) => {
          switch (key) {
            case "FP_FORMAT": {
              switch (value) {
                case "jsonice":
                  logger.SetFormatter(new JSONFormatter(logger.TxtEnDe(), 2));
                  break;
                case "yaml":
                  logger.SetFormatter(new YAMLFormatter(logger.TxtEnDe(), 2));
                  break;
                case "json":
                default:
                  logger.SetFormatter(new JSONFormatter(logger.TxtEnDe()));
                  break;
              }
              break;
            }
            case "FP_DEBUG":
              logger.SetDebug(value || []);
              break;
            case "FP_STACK":
              logger.SetExposeStack(!!value);
              break;
          }
        },
        "FP_FORMAT",
        "FP_DEBUG",
        "FP_STACK"
      );
    }).finally(() => {
    });
    if (debug.length > 0) {
      logger.SetDebug(debug);
    }
    if (exposeStack) {
      logger.SetExposeStack(true);
    }
    const out = cLogger.Logger();
    return out;
  }
  function getStore(url, sthis, joiner) {
    const store = url.getParam("store");
    switch (store) {
      case "data":
      case "wal":
      case "meta":
        break;
      default:
        throw sthis.logger.Error().Url(url).Msg(`store not found`).AsError();
    }
    let name8 = store;
    if (url.hasParam("index")) {
      name8 = joiner(url.getParam("index") || "idx", name8);
    }
    return { store, name: name8 };
  }
  function getKey(url, logger) {
    const result = url.getParam("key");
    if (!result) throw logger.Error().Str("url", url.toString()).Msg(`key not found`).AsError();
    return result;
  }
  async function exceptionWrapper(fn) {
    return fn().catch((e9) => Result.Err(e9));
  }
  function isNotFoundError(e9) {
    if (Result.Is(e9)) {
      if (e9.isOk()) return false;
      e9 = e9.Err();
    }
    if (e9.code === "ENOENT") return true;
    return false;
  }
  function dataDir(sthis, name8, base3) {
    if (!base3) {
      if (!runtimeFn().isBrowser) {
        const home = sthis.env.get("HOME") || "./";
        base3 = sthis.env.get("FP_STORAGE_URL") || `file://${sthis.pathOps.join(home, ".fireproof")}`;
      } else {
        base3 = sthis.env.get("FP_STORAGE_URL") || `indexdb://fp`;
      }
    }
    return URI.from(base3.toString()).build().setParam("name", name8 || "").URI();
  }
  function UInt8ArrayEqual(a7, b5) {
    if (a7.length !== b5.length) {
      return false;
    }
    for (let i7 = 0; i7 < a7.length; i7++) {
      if (a7[i7] !== b5[i7]) {
        return false;
      }
    }
    return true;
  }
  var __defProp3, __export3, globalLogger, registerFP_DEBUG, superThis, pathOpsImpl, pathOps, txtOps, NotFoundError;
  var init_chunk_MAK4D54P = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/chunk-MAK4D54P.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_cement();
      init_base58();
      __defProp3 = Object.defineProperty;
      __export3 = (target, all) => {
        for (var name8 in all)
          __defProp3(target, name8, { get: all[name8], enumerable: true });
      };
      globalLogger = new LoggerImpl();
      registerFP_DEBUG = new ResolveOnce();
      superThis = class _superThis {
        constructor(opts) {
          this.logger = opts.logger;
          this.env = opts.env;
          this.crypto = opts.crypto;
          this.pathOps = opts.pathOps;
          this.txt = opts.txt;
          this.ctx = { ...opts.ctx };
        }
        nextId(bytes = 6) {
          const bin = this.crypto.randomBytes(bytes);
          return {
            str: base58btc.encode(bin),
            bin
          };
        }
        start() {
          return Promise.resolve();
        }
        clone(override) {
          return new _superThis({
            logger: override.logger || this.logger,
            env: envFactory(override.env) || this.env,
            crypto: override.crypto || this.crypto,
            pathOps: override.pathOps || this.pathOps,
            txt: override.txt || this.txt,
            ctx: { ...this.ctx, ...override.ctx }
          });
        }
      };
      pathOpsImpl = class {
        join(...paths) {
          return paths.map((i7) => i7.replace(/\/+$/, "")).join("/");
        }
        dirname(path2) {
          return path2.split("/").slice(0, -1).join("/");
        }
        // homedir() {
        //     throw new Error("SysContainer:homedir is not available in seeded state");
        //   }
      };
      pathOps = new pathOpsImpl();
      txtOps = {
        encode: (input) => new TextEncoder().encode(input),
        decode: (input) => new TextDecoder().decode(input)
      };
      NotFoundError = class extends Error {
        constructor() {
          super(...arguments);
          this.code = "ENOENT";
        }
      };
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/constants.js
  var require_constants = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/constants.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.constants = void 0;
      exports9.constants = {
        O_RDONLY: 0,
        O_WRONLY: 1,
        O_RDWR: 2,
        S_IFMT: 61440,
        S_IFREG: 32768,
        S_IFDIR: 16384,
        S_IFCHR: 8192,
        S_IFBLK: 24576,
        S_IFIFO: 4096,
        S_IFLNK: 40960,
        S_IFSOCK: 49152,
        O_CREAT: 64,
        O_EXCL: 128,
        O_NOCTTY: 256,
        O_TRUNC: 512,
        O_APPEND: 1024,
        O_DIRECTORY: 65536,
        O_NOATIME: 262144,
        O_NOFOLLOW: 131072,
        O_SYNC: 1052672,
        O_SYMLINK: 2097152,
        O_DIRECT: 16384,
        O_NONBLOCK: 2048,
        S_IRWXU: 448,
        S_IRUSR: 256,
        S_IWUSR: 128,
        S_IXUSR: 64,
        S_IRWXG: 56,
        S_IRGRP: 32,
        S_IWGRP: 16,
        S_IXGRP: 8,
        S_IRWXO: 7,
        S_IROTH: 4,
        S_IWOTH: 2,
        S_IXOTH: 1,
        F_OK: 0,
        R_OK: 4,
        W_OK: 2,
        X_OK: 1,
        UV_FS_SYMLINK_DIR: 1,
        UV_FS_SYMLINK_JUNCTION: 2,
        UV_FS_COPYFILE_EXCL: 1,
        UV_FS_COPYFILE_FICLONE: 2,
        UV_FS_COPYFILE_FICLONE_FORCE: 4,
        COPYFILE_EXCL: 1,
        COPYFILE_FICLONE: 2,
        COPYFILE_FICLONE_FORCE: 4
      };
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/Stats.js
  var require_Stats = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/Stats.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.Stats = void 0;
      var constants_1 = require_constants();
      var { S_IFMT, S_IFDIR, S_IFREG, S_IFBLK, S_IFCHR, S_IFLNK, S_IFIFO, S_IFSOCK } = constants_1.constants;
      var Stats2 = class _Stats {
        static build(node, bigint = false) {
          const stats = new _Stats();
          const { uid, gid, atime, mtime, ctime } = node;
          const getStatNumber = !bigint ? (number) => number : (number) => BigInt(number);
          stats.uid = getStatNumber(uid);
          stats.gid = getStatNumber(gid);
          stats.rdev = getStatNumber(0);
          stats.blksize = getStatNumber(4096);
          stats.ino = getStatNumber(node.ino);
          stats.size = getStatNumber(node.getSize());
          stats.blocks = getStatNumber(1);
          stats.atime = atime;
          stats.mtime = mtime;
          stats.ctime = ctime;
          stats.birthtime = ctime;
          stats.atimeMs = getStatNumber(atime.getTime());
          stats.mtimeMs = getStatNumber(mtime.getTime());
          const ctimeMs = getStatNumber(ctime.getTime());
          stats.ctimeMs = ctimeMs;
          stats.birthtimeMs = ctimeMs;
          if (bigint) {
            stats.atimeNs = BigInt(atime.getTime()) * BigInt(1e6);
            stats.mtimeNs = BigInt(mtime.getTime()) * BigInt(1e6);
            const ctimeNs = BigInt(ctime.getTime()) * BigInt(1e6);
            stats.ctimeNs = ctimeNs;
            stats.birthtimeNs = ctimeNs;
          }
          stats.dev = getStatNumber(0);
          stats.mode = getStatNumber(node.mode);
          stats.nlink = getStatNumber(node.nlink);
          return stats;
        }
        _checkModeProperty(property) {
          return (Number(this.mode) & S_IFMT) === property;
        }
        isDirectory() {
          return this._checkModeProperty(S_IFDIR);
        }
        isFile() {
          return this._checkModeProperty(S_IFREG);
        }
        isBlockDevice() {
          return this._checkModeProperty(S_IFBLK);
        }
        isCharacterDevice() {
          return this._checkModeProperty(S_IFCHR);
        }
        isSymbolicLink() {
          return this._checkModeProperty(S_IFLNK);
        }
        isFIFO() {
          return this._checkModeProperty(S_IFIFO);
        }
        isSocket() {
          return this._checkModeProperty(S_IFSOCK);
        }
      };
      exports9.Stats = Stats2;
      exports9.default = Stats2;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/internal/buffer.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/internal/buffer.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.bufferFrom = exports9.bufferAllocUnsafe = exports9.Buffer = void 0;
      var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
      Object.defineProperty(exports9, "Buffer", { enumerable: true, get: function() {
        return buffer_1.Buffer;
      } });
      function bufferV0P12Ponyfill(arg0, ...args) {
        return new buffer_1.Buffer(arg0, ...args);
      }
      var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
      exports9.bufferAllocUnsafe = bufferAllocUnsafe;
      var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
      exports9.bufferFrom = bufferFrom;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js
  function i() {
    throw new Error("setTimeout has not been defined");
  }
  function u() {
    throw new Error("clearTimeout has not been defined");
  }
  function c(e9) {
    if (t === setTimeout) return setTimeout(e9, 0);
    if ((t === i || !t) && setTimeout) return t = setTimeout, setTimeout(e9, 0);
    try {
      return t(e9, 0);
    } catch (n8) {
      try {
        return t.call(null, e9, 0);
      } catch (n9) {
        return t.call(this || r, e9, 0);
      }
    }
  }
  function h() {
    f && l && (f = false, l.length ? s = l.concat(s) : a = -1, s.length && d());
  }
  function d() {
    if (!f) {
      var e9 = c(h);
      f = true;
      for (var t8 = s.length; t8; ) {
        for (l = s, s = []; ++a < t8; ) l && l[a].run();
        a = -1, t8 = s.length;
      }
      l = null, f = false, function(e10) {
        if (n === clearTimeout) return clearTimeout(e10);
        if ((n === u || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e10);
        try {
          n(e10);
        } catch (t9) {
          try {
            return n.call(null, e10);
          } catch (t10) {
            return n.call(this || r, e10);
          }
        }
      }(e9);
    }
  }
  function m(e9, t8) {
    (this || r).fun = e9, (this || r).array = t8;
  }
  function p() {
  }
  var e, t, n, r, o, l, s, f, a, T;
  var init_chunk_5decc758 = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      r = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
      o = e = {};
      !function() {
        try {
          t = "function" == typeof setTimeout ? setTimeout : i;
        } catch (e9) {
          t = i;
        }
        try {
          n = "function" == typeof clearTimeout ? clearTimeout : u;
        } catch (e9) {
          n = u;
        }
      }();
      s = [];
      f = false;
      a = -1;
      o.nextTick = function(e9) {
        var t8 = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var n8 = 1; n8 < arguments.length; n8++) t8[n8 - 1] = arguments[n8];
        s.push(new m(e9, t8)), 1 !== s.length || f || c(d);
      }, m.prototype.run = function() {
        (this || r).fun.apply(null, (this || r).array);
      }, o.title = "browser", o.browser = true, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = p, o.addListener = p, o.once = p, o.off = p, o.removeListener = p, o.removeAllListeners = p, o.emit = p, o.prependListener = p, o.prependOnceListener = p, o.listeners = function(e9) {
        return [];
      }, o.binding = function(e9) {
        throw new Error("process.binding is not supported");
      }, o.cwd = function() {
        return "/";
      }, o.chdir = function(e9) {
        throw new Error("process.chdir is not supported");
      }, o.umask = function() {
        return 0;
      };
      T = e;
      T.addListener;
      T.argv;
      T.binding;
      T.browser;
      T.chdir;
      T.cwd;
      T.emit;
      T.env;
      T.listeners;
      T.nextTick;
      T.off;
      T.on;
      T.once;
      T.prependListener;
      T.prependOnceListener;
      T.removeAllListeners;
      T.removeListener;
      T.title;
      T.umask;
      T.version;
      T.versions;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js
  function c$1(e9) {
    return e9.call.bind(e9);
  }
  function O(e9, t8) {
    if ("object" != typeof e9) return false;
    try {
      return t8(e9), true;
    } catch (e10) {
      return false;
    }
  }
  function S(e9) {
    return l$1 && y ? void 0 !== b(e9) : B(e9) || k(e9) || E(e9) || D(e9) || U(e9) || P(e9) || x(e9) || I(e9) || M(e9) || z(e9) || F(e9);
  }
  function B(e9) {
    return l$1 && y ? "Uint8Array" === b(e9) : "[object Uint8Array]" === m2(e9) || u$1(e9) && void 0 !== e9.buffer;
  }
  function k(e9) {
    return l$1 && y ? "Uint8ClampedArray" === b(e9) : "[object Uint8ClampedArray]" === m2(e9);
  }
  function E(e9) {
    return l$1 && y ? "Uint16Array" === b(e9) : "[object Uint16Array]" === m2(e9);
  }
  function D(e9) {
    return l$1 && y ? "Uint32Array" === b(e9) : "[object Uint32Array]" === m2(e9);
  }
  function U(e9) {
    return l$1 && y ? "Int8Array" === b(e9) : "[object Int8Array]" === m2(e9);
  }
  function P(e9) {
    return l$1 && y ? "Int16Array" === b(e9) : "[object Int16Array]" === m2(e9);
  }
  function x(e9) {
    return l$1 && y ? "Int32Array" === b(e9) : "[object Int32Array]" === m2(e9);
  }
  function I(e9) {
    return l$1 && y ? "Float32Array" === b(e9) : "[object Float32Array]" === m2(e9);
  }
  function M(e9) {
    return l$1 && y ? "Float64Array" === b(e9) : "[object Float64Array]" === m2(e9);
  }
  function z(e9) {
    return l$1 && y ? "BigInt64Array" === b(e9) : "[object BigInt64Array]" === m2(e9);
  }
  function F(e9) {
    return l$1 && y ? "BigUint64Array" === b(e9) : "[object BigUint64Array]" === m2(e9);
  }
  function T2(e9) {
    return "[object Map]" === m2(e9);
  }
  function N(e9) {
    return "[object Set]" === m2(e9);
  }
  function W(e9) {
    return "[object WeakMap]" === m2(e9);
  }
  function $(e9) {
    return "[object WeakSet]" === m2(e9);
  }
  function C(e9) {
    return "[object ArrayBuffer]" === m2(e9);
  }
  function V(e9) {
    return "undefined" != typeof ArrayBuffer && (C.working ? C(e9) : e9 instanceof ArrayBuffer);
  }
  function G(e9) {
    return "[object DataView]" === m2(e9);
  }
  function R(e9) {
    return "undefined" != typeof DataView && (G.working ? G(e9) : e9 instanceof DataView);
  }
  function J(e9) {
    return "[object SharedArrayBuffer]" === m2(e9);
  }
  function _(e9) {
    return "undefined" != typeof SharedArrayBuffer && (J.working ? J(e9) : e9 instanceof SharedArrayBuffer);
  }
  function H(e9) {
    return O(e9, h2);
  }
  function Z(e9) {
    return O(e9, j);
  }
  function q(e9) {
    return O(e9, A);
  }
  function K(e9) {
    return s2 && O(e9, w);
  }
  function L(e9) {
    return p2 && O(e9, v);
  }
  function oe(e9, t8) {
    var r9 = { seen: [], stylize: fe };
    return arguments.length >= 3 && (r9.depth = arguments[2]), arguments.length >= 4 && (r9.colors = arguments[3]), ye(t8) ? r9.showHidden = t8 : t8 && X._extend(r9, t8), be(r9.showHidden) && (r9.showHidden = false), be(r9.depth) && (r9.depth = 2), be(r9.colors) && (r9.colors = false), be(r9.customInspect) && (r9.customInspect = true), r9.colors && (r9.stylize = ue), ae(r9, e9, r9.depth);
  }
  function ue(e9, t8) {
    var r9 = oe.styles[t8];
    return r9 ? "\x1B[" + oe.colors[r9][0] + "m" + e9 + "\x1B[" + oe.colors[r9][1] + "m" : e9;
  }
  function fe(e9, t8) {
    return e9;
  }
  function ae(e9, t8, r9) {
    if (e9.customInspect && t8 && we(t8.inspect) && t8.inspect !== X.inspect && (!t8.constructor || t8.constructor.prototype !== t8)) {
      var n8 = t8.inspect(r9, e9);
      return ge(n8) || (n8 = ae(e9, n8, r9)), n8;
    }
    var i7 = function(e10, t9) {
      if (be(t9)) return e10.stylize("undefined", "undefined");
      if (ge(t9)) {
        var r10 = "'" + JSON.stringify(t9).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e10.stylize(r10, "string");
      }
      if (de(t9)) return e10.stylize("" + t9, "number");
      if (ye(t9)) return e10.stylize("" + t9, "boolean");
      if (le(t9)) return e10.stylize("null", "null");
    }(e9, t8);
    if (i7) return i7;
    var o8 = Object.keys(t8), u7 = function(e10) {
      var t9 = {};
      return e10.forEach(function(e11, r10) {
        t9[e11] = true;
      }), t9;
    }(o8);
    if (e9.showHidden && (o8 = Object.getOwnPropertyNames(t8)), Ae(t8) && (o8.indexOf("message") >= 0 || o8.indexOf("description") >= 0)) return ce(t8);
    if (0 === o8.length) {
      if (we(t8)) {
        var f7 = t8.name ? ": " + t8.name : "";
        return e9.stylize("[Function" + f7 + "]", "special");
      }
      if (me(t8)) return e9.stylize(RegExp.prototype.toString.call(t8), "regexp");
      if (je(t8)) return e9.stylize(Date.prototype.toString.call(t8), "date");
      if (Ae(t8)) return ce(t8);
    }
    var a7, c7 = "", s6 = false, p7 = ["{", "}"];
    (pe(t8) && (s6 = true, p7 = ["[", "]"]), we(t8)) && (c7 = " [Function" + (t8.name ? ": " + t8.name : "") + "]");
    return me(t8) && (c7 = " " + RegExp.prototype.toString.call(t8)), je(t8) && (c7 = " " + Date.prototype.toUTCString.call(t8)), Ae(t8) && (c7 = " " + ce(t8)), 0 !== o8.length || s6 && 0 != t8.length ? r9 < 0 ? me(t8) ? e9.stylize(RegExp.prototype.toString.call(t8), "regexp") : e9.stylize("[Object]", "special") : (e9.seen.push(t8), a7 = s6 ? function(e10, t9, r10, n9, i8) {
      for (var o9 = [], u8 = 0, f8 = t9.length; u8 < f8; ++u8) ke(t9, String(u8)) ? o9.push(se(e10, t9, r10, n9, String(u8), true)) : o9.push("");
      return i8.forEach(function(i9) {
        i9.match(/^\d+$/) || o9.push(se(e10, t9, r10, n9, i9, true));
      }), o9;
    }(e9, t8, r9, u7, o8) : o8.map(function(n9) {
      return se(e9, t8, r9, u7, n9, s6);
    }), e9.seen.pop(), function(e10, t9, r10) {
      var n9 = 0;
      if (e10.reduce(function(e11, t10) {
        return n9++, t10.indexOf("\n") >= 0 && n9++, e11 + t10.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60) return r10[0] + ("" === t9 ? "" : t9 + "\n ") + " " + e10.join(",\n  ") + " " + r10[1];
      return r10[0] + t9 + " " + e10.join(", ") + " " + r10[1];
    }(a7, c7, p7)) : p7[0] + c7 + p7[1];
  }
  function ce(e9) {
    return "[" + Error.prototype.toString.call(e9) + "]";
  }
  function se(e9, t8, r9, n8, i7, o8) {
    var u7, f7, a7;
    if ((a7 = Object.getOwnPropertyDescriptor(t8, i7) || { value: t8[i7] }).get ? f7 = a7.set ? e9.stylize("[Getter/Setter]", "special") : e9.stylize("[Getter]", "special") : a7.set && (f7 = e9.stylize("[Setter]", "special")), ke(n8, i7) || (u7 = "[" + i7 + "]"), f7 || (e9.seen.indexOf(a7.value) < 0 ? (f7 = le(r9) ? ae(e9, a7.value, null) : ae(e9, a7.value, r9 - 1)).indexOf("\n") > -1 && (f7 = o8 ? f7.split("\n").map(function(e10) {
      return "  " + e10;
    }).join("\n").substr(2) : "\n" + f7.split("\n").map(function(e10) {
      return "   " + e10;
    }).join("\n")) : f7 = e9.stylize("[Circular]", "special")), be(u7)) {
      if (o8 && i7.match(/^\d+$/)) return f7;
      (u7 = JSON.stringify("" + i7)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u7 = u7.substr(1, u7.length - 2), u7 = e9.stylize(u7, "name")) : (u7 = u7.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u7 = e9.stylize(u7, "string"));
    }
    return u7 + ": " + f7;
  }
  function pe(e9) {
    return Array.isArray(e9);
  }
  function ye(e9) {
    return "boolean" == typeof e9;
  }
  function le(e9) {
    return null === e9;
  }
  function de(e9) {
    return "number" == typeof e9;
  }
  function ge(e9) {
    return "string" == typeof e9;
  }
  function be(e9) {
    return void 0 === e9;
  }
  function me(e9) {
    return he(e9) && "[object RegExp]" === ve(e9);
  }
  function he(e9) {
    return "object" == typeof e9 && null !== e9;
  }
  function je(e9) {
    return he(e9) && "[object Date]" === ve(e9);
  }
  function Ae(e9) {
    return he(e9) && ("[object Error]" === ve(e9) || e9 instanceof Error);
  }
  function we(e9) {
    return "function" == typeof e9;
  }
  function ve(e9) {
    return Object.prototype.toString.call(e9);
  }
  function Oe(e9) {
    return e9 < 10 ? "0" + e9.toString(10) : e9.toString(10);
  }
  function Be() {
    var e9 = /* @__PURE__ */ new Date(), t8 = [Oe(e9.getHours()), Oe(e9.getMinutes()), Oe(e9.getSeconds())].join(":");
    return [e9.getDate(), Se[e9.getMonth()], t8].join(" ");
  }
  function ke(e9, t8) {
    return Object.prototype.hasOwnProperty.call(e9, t8);
  }
  function De(e9, t8) {
    if (!e9) {
      var r9 = new Error("Promise was rejected with a falsy value");
      r9.reason = e9, e9 = r9;
    }
    return t8(e9);
  }
  var t2, e2, o2, n2, r2, l2, t$1, o$1, n$1, e$1, r$1, c2, u2, i2, t$2, i$1, o$2, u$1, f2, a2, s2, p2, y, l$1, d2, m2, h2, j, A, Q, X, Y, ee, te, re, ne, ie, Se, Ee;
  var init_chunk_b4205b57 = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_5decc758();
      t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
      e2 = Object.prototype.toString;
      o2 = function(o8) {
        return !(t2 && o8 && "object" == typeof o8 && Symbol.toStringTag in o8) && "[object Arguments]" === e2.call(o8);
      };
      n2 = function(t8) {
        return !!o2(t8) || null !== t8 && "object" == typeof t8 && "number" == typeof t8.length && t8.length >= 0 && "[object Array]" !== e2.call(t8) && "[object Function]" === e2.call(t8.callee);
      };
      r2 = function() {
        return o2(arguments);
      }();
      o2.isLegacyArguments = n2;
      l2 = r2 ? o2 : n2;
      t$1 = Object.prototype.toString;
      o$1 = Function.prototype.toString;
      n$1 = /^\s*(?:function)?\*/;
      e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
      r$1 = Object.getPrototypeOf;
      c2 = function() {
        if (!e$1) return false;
        try {
          return Function("return function*() {}")();
        } catch (t8) {
        }
      }();
      u2 = c2 ? r$1(c2) : {};
      i2 = function(c7) {
        return "function" == typeof c7 && (!!n$1.test(o$1.call(c7)) || (e$1 ? r$1(c7) === u2 : "[object GeneratorFunction]" === t$1.call(c7)));
      };
      t$2 = "function" == typeof Object.create ? function(t8, e9) {
        e9 && (t8.super_ = e9, t8.prototype = Object.create(e9.prototype, { constructor: { value: t8, enumerable: false, writable: true, configurable: true } }));
      } : function(t8, e9) {
        if (e9) {
          t8.super_ = e9;
          var o8 = function() {
          };
          o8.prototype = e9.prototype, t8.prototype = new o8(), t8.prototype.constructor = t8;
        }
      };
      i$1 = function(e9) {
        return e9 && "object" == typeof e9 && "function" == typeof e9.copy && "function" == typeof e9.fill && "function" == typeof e9.readUInt8;
      };
      o$2 = {};
      u$1 = i$1;
      f2 = l2;
      a2 = i2;
      s2 = "undefined" != typeof BigInt;
      p2 = "undefined" != typeof Symbol;
      y = p2 && void 0 !== Symbol.toStringTag;
      l$1 = "undefined" != typeof Uint8Array;
      d2 = "undefined" != typeof ArrayBuffer;
      if (l$1 && y) var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
      m2 = c$1(Object.prototype.toString);
      h2 = c$1(Number.prototype.valueOf);
      j = c$1(String.prototype.valueOf);
      A = c$1(Boolean.prototype.valueOf);
      if (s2) var w = c$1(BigInt.prototype.valueOf);
      if (p2) var v = c$1(Symbol.prototype.valueOf);
      o$2.isArgumentsObject = f2, o$2.isGeneratorFunction = a2, o$2.isPromise = function(e9) {
        return "undefined" != typeof Promise && e9 instanceof Promise || null !== e9 && "object" == typeof e9 && "function" == typeof e9.then && "function" == typeof e9.catch;
      }, o$2.isArrayBufferView = function(e9) {
        return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e9) : S(e9) || R(e9);
      }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = "undefined" != typeof Map && T2(/* @__PURE__ */ new Map()), o$2.isMap = function(e9) {
        return "undefined" != typeof Map && (T2.working ? T2(e9) : e9 instanceof Map);
      }, N.working = "undefined" != typeof Set && N(/* @__PURE__ */ new Set()), o$2.isSet = function(e9) {
        return "undefined" != typeof Set && (N.working ? N(e9) : e9 instanceof Set);
      }, W.working = "undefined" != typeof WeakMap && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e9) {
        return "undefined" != typeof WeakMap && (W.working ? W(e9) : e9 instanceof WeakMap);
      }, $.working = "undefined" != typeof WeakSet && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e9) {
        return $(e9);
      }, C.working = "undefined" != typeof ArrayBuffer && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = "undefined" != typeof SharedArrayBuffer && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e9) {
        return "[object AsyncFunction]" === m2(e9);
      }, o$2.isMapIterator = function(e9) {
        return "[object Map Iterator]" === m2(e9);
      }, o$2.isSetIterator = function(e9) {
        return "[object Set Iterator]" === m2(e9);
      }, o$2.isGeneratorObject = function(e9) {
        return "[object Generator]" === m2(e9);
      }, o$2.isWebAssemblyCompiledModule = function(e9) {
        return "[object WebAssembly.Module]" === m2(e9);
      }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e9) {
        return H(e9) || Z(e9) || q(e9) || K(e9) || L(e9);
      }, o$2.isAnyArrayBuffer = function(e9) {
        return l$1 && (V(e9) || _(e9));
      }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e9) {
        Object.defineProperty(o$2, e9, { enumerable: false, value: function() {
          throw new Error(e9 + " is not supported in userland");
        } });
      });
      Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
      X = {};
      Y = T;
      ee = Object.getOwnPropertyDescriptors || function(e9) {
        for (var t8 = Object.keys(e9), r9 = {}, n8 = 0; n8 < t8.length; n8++) r9[t8[n8]] = Object.getOwnPropertyDescriptor(e9, t8[n8]);
        return r9;
      };
      te = /%[sdj%]/g;
      X.format = function(e9) {
        if (!ge(e9)) {
          for (var t8 = [], r9 = 0; r9 < arguments.length; r9++) t8.push(oe(arguments[r9]));
          return t8.join(" ");
        }
        r9 = 1;
        for (var n8 = arguments, i7 = n8.length, o8 = String(e9).replace(te, function(e10) {
          if ("%%" === e10) return "%";
          if (r9 >= i7) return e10;
          switch (e10) {
            case "%s":
              return String(n8[r9++]);
            case "%d":
              return Number(n8[r9++]);
            case "%j":
              try {
                return JSON.stringify(n8[r9++]);
              } catch (e11) {
                return "[Circular]";
              }
            default:
              return e10;
          }
        }), u7 = n8[r9]; r9 < i7; u7 = n8[++r9]) le(u7) || !he(u7) ? o8 += " " + u7 : o8 += " " + oe(u7);
        return o8;
      }, X.deprecate = function(e9, t8) {
        if (void 0 !== Y && true === Y.noDeprecation) return e9;
        if (void 0 === Y) return function() {
          return X.deprecate(e9, t8).apply(this || Q, arguments);
        };
        var r9 = false;
        return function() {
          if (!r9) {
            if (Y.throwDeprecation) throw new Error(t8);
            Y.traceDeprecation ? console.trace(t8) : console.error(t8), r9 = true;
          }
          return e9.apply(this || Q, arguments);
        };
      };
      re = {};
      ne = /^$/;
      if (Y.env.NODE_DEBUG) {
        ie = Y.env.NODE_DEBUG;
        ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
      }
      X.debuglog = function(e9) {
        if (e9 = e9.toUpperCase(), !re[e9]) if (ne.test(e9)) {
          var t8 = Y.pid;
          re[e9] = function() {
            var r9 = X.format.apply(X, arguments);
            console.error("%s %d: %s", e9, t8, r9);
          };
        } else re[e9] = function() {
        };
        return re[e9];
      }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e9) {
        return null == e9;
      }, X.isNumber = de, X.isString = ge, X.isSymbol = function(e9) {
        return "symbol" == typeof e9;
      }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e9) {
        return null === e9 || "boolean" == typeof e9 || "number" == typeof e9 || "string" == typeof e9 || "symbol" == typeof e9 || void 0 === e9;
      }, X.isBuffer = i$1;
      Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      X.log = function() {
        console.log("%s - %s", Be(), X.format.apply(X, arguments));
      }, X.inherits = t$2, X._extend = function(e9, t8) {
        if (!t8 || !he(t8)) return e9;
        for (var r9 = Object.keys(t8), n8 = r9.length; n8--; ) e9[r9[n8]] = t8[r9[n8]];
        return e9;
      };
      Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
      X.promisify = function(e9) {
        if ("function" != typeof e9) throw new TypeError('The "original" argument must be of type Function');
        if (Ee && e9[Ee]) {
          var t8;
          if ("function" != typeof (t8 = e9[Ee])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(t8, Ee, { value: t8, enumerable: false, writable: false, configurable: true }), t8;
        }
        function t8() {
          for (var t9, r9, n8 = new Promise(function(e10, n9) {
            t9 = e10, r9 = n9;
          }), i7 = [], o8 = 0; o8 < arguments.length; o8++) i7.push(arguments[o8]);
          i7.push(function(e10, n9) {
            e10 ? r9(e10) : t9(n9);
          });
          try {
            e9.apply(this || Q, i7);
          } catch (e10) {
            r9(e10);
          }
          return n8;
        }
        return Object.setPrototypeOf(t8, Object.getPrototypeOf(e9)), Ee && Object.defineProperty(t8, Ee, { value: t8, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t8, ee(e9));
      }, X.promisify.custom = Ee, X.callbackify = function(e9) {
        if ("function" != typeof e9) throw new TypeError('The "original" argument must be of type Function');
        function t8() {
          for (var t9 = [], r9 = 0; r9 < arguments.length; r9++) t9.push(arguments[r9]);
          var n8 = t9.pop();
          if ("function" != typeof n8) throw new TypeError("The last argument must be of type Function");
          var i7 = this || Q, o8 = function() {
            return n8.apply(i7, arguments);
          };
          e9.apply(this || Q, t9).then(function(e10) {
            Y.nextTick(o8.bind(null, null, e10));
          }, function(e10) {
            Y.nextTick(De.bind(null, e10, o8));
          });
        }
        return Object.setPrototypeOf(t8, Object.getPrototypeOf(e9)), Object.defineProperties(t8, ee(e9)), t8;
      };
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/assert.js
  var assert_exports = {};
  __export(assert_exports, {
    AssertionError: () => AssertionError,
    deepEqual: () => deepEqual,
    deepStrictEqual: () => deepStrictEqual,
    default: () => et,
    doesNotReject: () => doesNotReject,
    doesNotThrow: () => doesNotThrow,
    equal: () => equal,
    fail: () => fail,
    ifError: () => ifError,
    notDeepEqual: () => notDeepEqual,
    notDeepStrictEqual: () => notDeepStrictEqual,
    notEqual: () => notEqual,
    notStrictEqual: () => notStrictEqual,
    ok: () => ok,
    rejects: () => rejects,
    strict: () => strict,
    strictEqual: () => strictEqual,
    throws: () => throws
  });
  function e3(e9, r9) {
    if (null == e9) throw new TypeError("Cannot convert first argument to object");
    for (var t8 = Object(e9), n8 = 1; n8 < arguments.length; n8++) {
      var o8 = arguments[n8];
      if (null != o8) for (var a7 = Object.keys(Object(o8)), l7 = 0, i7 = a7.length; l7 < i7; l7++) {
        var c7 = a7[l7], b5 = Object.getOwnPropertyDescriptor(o8, c7);
        void 0 !== b5 && b5.enumerable && (t8[c7] = o8[c7]);
      }
    }
    return t8;
  }
  function i$5() {
    if (a$6) return c$4;
    function e9(t8) {
      return (e9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
        return typeof t9;
      } : function(t9) {
        return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
      })(t8);
    }
    function n8(t8, n9) {
      return !n9 || "object" !== e9(n9) && "function" != typeof n9 ? function(t9) {
        if (void 0 === t9) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t9;
      }(t8) : n9;
    }
    function r9(t8) {
      return (r9 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t9) {
        return t9.__proto__ || Object.getPrototypeOf(t9);
      })(t8);
    }
    function o8(t8, e10) {
      return (o8 = Object.setPrototypeOf || function(t9, e11) {
        return t9.__proto__ = e11, t9;
      })(t8, e10);
    }
    a$6 = true;
    var i7, u7, l7 = {};
    function f7(t8, e10, c7) {
      c7 || (c7 = Error);
      var a7 = function(c8) {
        function a8(o9, c9, i8) {
          var u8;
          return !function(t9, e11) {
            if (!(t9 instanceof e11)) throw new TypeError("Cannot call a class as a function");
          }(this, a8), (u8 = n8(this, r9(a8).call(this, function(t9, n9, r10) {
            return "string" == typeof e10 ? e10 : e10(t9, n9, r10);
          }(o9, c9, i8)))).code = t8, u8;
        }
        return !function(t9, e11) {
          if ("function" != typeof e11 && null !== e11) throw new TypeError("Super expression must either be null or a function");
          t9.prototype = Object.create(e11 && e11.prototype, { constructor: { value: t9, writable: true, configurable: true } }), e11 && o8(t9, e11);
        }(a8, c8), a8;
      }(c7);
      l7[t8] = a7;
    }
    function s6(t8, e10) {
      if (Array.isArray(t8)) {
        var n9 = t8.length;
        return t8 = t8.map(function(t9) {
          return String(t9);
        }), n9 > 2 ? "one of ".concat(e10, " ").concat(t8.slice(0, n9 - 1).join(", "), ", or ") + t8[n9 - 1] : 2 === n9 ? "one of ".concat(e10, " ").concat(t8[0], " or ").concat(t8[1]) : "of ".concat(e10, " ").concat(t8[0]);
      }
      return "of ".concat(e10, " ").concat(String(t8));
    }
    return f7("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f7("ERR_INVALID_ARG_TYPE", function(t8, n9, r10) {
      var o9, c7, u8;
      if (void 0 === i7 && (i7 = tt()), i7("string" == typeof t8, "'name' must be a string"), "string" == typeof n9 && (c7 = "not ", n9.substr(0, c7.length) === c7) ? (o9 = "must not be", n9 = n9.replace(/^not /, "")) : o9 = "must be", function(t9, e10, n10) {
        return (void 0 === n10 || n10 > t9.length) && (n10 = t9.length), t9.substring(n10 - e10.length, n10) === e10;
      }(t8, " argument")) u8 = "The ".concat(t8, " ").concat(o9, " ").concat(s6(n9, "type"));
      else {
        var l8 = function(t9, e10, n10) {
          return "number" != typeof n10 && (n10 = 0), !(n10 + e10.length > t9.length) && -1 !== t9.indexOf(e10, n10);
        }(t8, ".") ? "property" : "argument";
        u8 = 'The "'.concat(t8, '" ').concat(l8, " ").concat(o9, " ").concat(s6(n9, "type"));
      }
      return u8 += ". Received type ".concat(e9(r10));
    }, TypeError), f7("ERR_INVALID_ARG_VALUE", function(e10, n9) {
      var r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
      void 0 === u7 && (u7 = X);
      var o9 = u7.inspect(n9);
      return o9.length > 128 && (o9 = "".concat(o9.slice(0, 128), "...")), "The argument '".concat(e10, "' ").concat(r10, ". Received ").concat(o9);
    }, TypeError), f7("ERR_INVALID_RETURN_VALUE", function(t8, n9, r10) {
      var o9;
      return o9 = r10 && r10.constructor && r10.constructor.name ? "instance of ".concat(r10.constructor.name) : "type ".concat(e9(r10)), "Expected ".concat(t8, ' to be returned from the "').concat(n9, '"') + " function but got ".concat(o9, ".");
    }, TypeError), f7("ERR_MISSING_ARGS", function() {
      for (var t8 = arguments.length, e10 = new Array(t8), n9 = 0; n9 < t8; n9++) e10[n9] = arguments[n9];
      void 0 === i7 && (i7 = tt()), i7(e10.length > 0, "At least one arg needs to be specified");
      var r10 = "The ", o9 = e10.length;
      switch (e10 = e10.map(function(t9) {
        return '"'.concat(t9, '"');
      }), o9) {
        case 1:
          r10 += "".concat(e10[0], " argument");
          break;
        case 2:
          r10 += "".concat(e10[0], " and ").concat(e10[1], " arguments");
          break;
        default:
          r10 += e10.slice(0, o9 - 1).join(", "), r10 += ", and ".concat(e10[o9 - 1], " arguments");
      }
      return "".concat(r10, " must be specified");
    }, TypeError), c$4.codes = l7, c$4;
  }
  function f$6() {
    if (l$6) return u$5;
    l$6 = true;
    var n8 = T;
    function r9(t8, e9, n9) {
      return e9 in t8 ? Object.defineProperty(t8, e9, { value: n9, enumerable: true, configurable: true, writable: true }) : t8[e9] = n9, t8;
    }
    function o8(t8, e9) {
      for (var n9 = 0; n9 < e9.length; n9++) {
        var r10 = e9[n9];
        r10.enumerable = r10.enumerable || false, r10.configurable = true, "value" in r10 && (r10.writable = true), Object.defineProperty(t8, r10.key, r10);
      }
    }
    function c7(t8, e9) {
      return !e9 || "object" !== y6(e9) && "function" != typeof e9 ? a7(t8) : e9;
    }
    function a7(t8) {
      if (void 0 === t8) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t8;
    }
    function f7(t8) {
      var e9 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return (f7 = function(t9) {
        if (null === t9 || (n9 = t9, -1 === Function.toString.call(n9).indexOf("[native code]"))) return t9;
        var n9;
        if ("function" != typeof t9) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== e9) {
          if (e9.has(t9)) return e9.get(t9);
          e9.set(t9, r10);
        }
        function r10() {
          return p7(t9, arguments, h8(this).constructor);
        }
        return r10.prototype = Object.create(t9.prototype, { constructor: { value: r10, enumerable: false, writable: true, configurable: true } }), g5(r10, t9);
      })(t8);
    }
    function s6() {
      if ("undefined" == typeof Reflect || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if ("function" == typeof Proxy) return true;
      try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        })), true;
      } catch (t8) {
        return false;
      }
    }
    function p7(t8, e9, n9) {
      return (p7 = s6() ? Reflect.construct : function(t9, e10, n10) {
        var r10 = [null];
        r10.push.apply(r10, e10);
        var o9 = new (Function.bind.apply(t9, r10))();
        return n10 && g5(o9, n10.prototype), o9;
      }).apply(null, arguments);
    }
    function g5(t8, e9) {
      return (g5 = Object.setPrototypeOf || function(t9, e10) {
        return t9.__proto__ = e10, t9;
      })(t8, e9);
    }
    function h8(t8) {
      return (h8 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t9) {
        return t9.__proto__ || Object.getPrototypeOf(t9);
      })(t8);
    }
    function y6(t8) {
      return (y6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
        return typeof t9;
      } : function(t9) {
        return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
      })(t8);
    }
    var b5 = X.inspect, v6 = i$5().codes.ERR_INVALID_ARG_TYPE;
    function d6(t8, e9, n9) {
      return (void 0 === n9 || n9 > t8.length) && (n9 = t8.length), t8.substring(n9 - e9.length, n9) === e9;
    }
    var m6 = "", E4 = "", w4 = "", S4 = "", j4 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
    function O5(t8) {
      var e9 = Object.keys(t8), n9 = Object.create(Object.getPrototypeOf(t8));
      return e9.forEach(function(e10) {
        n9[e10] = t8[e10];
      }), Object.defineProperty(n9, "message", { value: t8.message }), n9;
    }
    function x4(t8) {
      return b5(t8, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
    }
    function q3(t8, e9, r10) {
      var o9 = "", c8 = "", a8 = 0, i7 = "", u7 = false, l7 = x4(t8), f8 = l7.split("\n"), s7 = x4(e9).split("\n"), p8 = 0, g6 = "";
      if ("strictEqual" === r10 && "object" === y6(t8) && "object" === y6(e9) && null !== t8 && null !== e9 && (r10 = "strictEqualObject"), 1 === f8.length && 1 === s7.length && f8[0] !== s7[0]) {
        var h9 = f8[0].length + s7[0].length;
        if (h9 <= 10) {
          if (!("object" === y6(t8) && null !== t8 || "object" === y6(e9) && null !== e9 || 0 === t8 && 0 === e9)) return "".concat(j4[r10], "\n\n") + "".concat(f8[0], " !== ").concat(s7[0], "\n");
        } else if ("strictEqualObject" !== r10) {
          if (h9 < (n8.stderr && n8.stderr.isTTY ? n8.stderr.columns : 80)) {
            for (; f8[0][p8] === s7[0][p8]; ) p8++;
            p8 > 2 && (g6 = "\n  ".concat(function(t9, e10) {
              if (e10 = Math.floor(e10), 0 == t9.length || 0 == e10) return "";
              var n9 = t9.length * e10;
              for (e10 = Math.floor(Math.log(e10) / Math.log(2)); e10; ) t9 += t9, e10--;
              return t9 += t9.substring(0, n9 - t9.length);
            }(" ", p8), "^"), p8 = 0);
          }
        }
      }
      for (var b6 = f8[f8.length - 1], v7 = s7[s7.length - 1]; b6 === v7 && (p8++ < 2 ? i7 = "\n  ".concat(b6).concat(i7) : o9 = b6, f8.pop(), s7.pop(), 0 !== f8.length && 0 !== s7.length); ) b6 = f8[f8.length - 1], v7 = s7[s7.length - 1];
      var O6 = Math.max(f8.length, s7.length);
      if (0 === O6) {
        var q4 = l7.split("\n");
        if (q4.length > 30) for (q4[26] = "".concat(m6, "...").concat(S4); q4.length > 27; ) q4.pop();
        return "".concat(j4.notIdentical, "\n\n").concat(q4.join("\n"), "\n");
      }
      p8 > 3 && (i7 = "\n".concat(m6, "...").concat(S4).concat(i7), u7 = true), "" !== o9 && (i7 = "\n  ".concat(o9).concat(i7), o9 = "");
      var R5 = 0, A4 = j4[r10] + "\n".concat(E4, "+ actual").concat(S4, " ").concat(w4, "- expected").concat(S4), k4 = " ".concat(m6, "...").concat(S4, " Lines skipped");
      for (p8 = 0; p8 < O6; p8++) {
        var _4 = p8 - a8;
        if (f8.length < p8 + 1) _4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(s7[p8 - 2]), R5++), c8 += "\n  ".concat(s7[p8 - 1]), R5++), a8 = p8, o9 += "\n".concat(w4, "-").concat(S4, " ").concat(s7[p8]), R5++;
        else if (s7.length < p8 + 1) _4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(f8[p8 - 2]), R5++), c8 += "\n  ".concat(f8[p8 - 1]), R5++), a8 = p8, c8 += "\n".concat(E4, "+").concat(S4, " ").concat(f8[p8]), R5++;
        else {
          var T5 = s7[p8], P4 = f8[p8], I4 = P4 !== T5 && (!d6(P4, ",") || P4.slice(0, -1) !== T5);
          I4 && d6(T5, ",") && T5.slice(0, -1) === P4 && (I4 = false, P4 += ","), I4 ? (_4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(f8[p8 - 2]), R5++), c8 += "\n  ".concat(f8[p8 - 1]), R5++), a8 = p8, c8 += "\n".concat(E4, "+").concat(S4, " ").concat(P4), o9 += "\n".concat(w4, "-").concat(S4, " ").concat(T5), R5 += 2) : (c8 += o9, o9 = "", 1 !== _4 && 0 !== p8 || (c8 += "\n  ".concat(P4), R5++));
        }
        if (R5 > 20 && p8 < O6 - 2) return "".concat(A4).concat(k4, "\n").concat(c8, "\n").concat(m6, "...").concat(S4).concat(o9, "\n") + "".concat(m6, "...").concat(S4);
      }
      return "".concat(A4).concat(u7 ? k4 : "", "\n").concat(c8).concat(o9).concat(i7).concat(g6);
    }
    var R4 = function(t8) {
      function e9(t9) {
        var r10;
        if (!function(t10, e10) {
          if (!(t10 instanceof e10)) throw new TypeError("Cannot call a class as a function");
        }(this, e9), "object" !== y6(t9) || null === t9) throw new v6("options", "Object", t9);
        var o9 = t9.message, i8 = t9.operator, u8 = t9.stackStartFn, l7 = t9.actual, f8 = t9.expected, s7 = Error.stackTraceLimit;
        if (Error.stackTraceLimit = 0, null != o9) r10 = c7(this, h8(e9).call(this, String(o9)));
        else if (n8.stderr && n8.stderr.isTTY && (n8.stderr && n8.stderr.getColorDepth && 1 !== n8.stderr.getColorDepth() ? (m6 = "\x1B[34m", E4 = "\x1B[32m", S4 = "\x1B[39m", w4 = "\x1B[31m") : (m6 = "", E4 = "", S4 = "", w4 = "")), "object" === y6(l7) && null !== l7 && "object" === y6(f8) && null !== f8 && "stack" in l7 && l7 instanceof Error && "stack" in f8 && f8 instanceof Error && (l7 = O5(l7), f8 = O5(f8)), "deepStrictEqual" === i8 || "strictEqual" === i8) r10 = c7(this, h8(e9).call(this, q3(l7, f8, i8)));
        else if ("notDeepStrictEqual" === i8 || "notStrictEqual" === i8) {
          var p8 = j4[i8], g6 = x4(l7).split("\n");
          if ("notStrictEqual" === i8 && "object" === y6(l7) && null !== l7 && (p8 = j4.notStrictEqualObject), g6.length > 30) for (g6[26] = "".concat(m6, "...").concat(S4); g6.length > 27; ) g6.pop();
          r10 = 1 === g6.length ? c7(this, h8(e9).call(this, "".concat(p8, " ").concat(g6[0]))) : c7(this, h8(e9).call(this, "".concat(p8, "\n\n").concat(g6.join("\n"), "\n")));
        } else {
          var b6 = x4(l7), d7 = "", R5 = j4[i8];
          "notDeepEqual" === i8 || "notEqual" === i8 ? (b6 = "".concat(j4[i8], "\n\n").concat(b6)).length > 1024 && (b6 = "".concat(b6.slice(0, 1021), "...")) : (d7 = "".concat(x4(f8)), b6.length > 512 && (b6 = "".concat(b6.slice(0, 509), "...")), d7.length > 512 && (d7 = "".concat(d7.slice(0, 509), "...")), "deepEqual" === i8 || "equal" === i8 ? b6 = "".concat(R5, "\n\n").concat(b6, "\n\nshould equal\n\n") : d7 = " ".concat(i8, " ").concat(d7)), r10 = c7(this, h8(e9).call(this, "".concat(b6).concat(d7)));
        }
        return Error.stackTraceLimit = s7, r10.generatedMessage = !o9, Object.defineProperty(a7(r10), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r10.code = "ERR_ASSERTION", r10.actual = l7, r10.expected = f8, r10.operator = i8, Error.captureStackTrace && Error.captureStackTrace(a7(r10), u8), r10.stack, r10.name = "AssertionError", c7(r10);
      }
      var i7, u7;
      return !function(t9, e10) {
        if ("function" != typeof e10 && null !== e10) throw new TypeError("Super expression must either be null or a function");
        t9.prototype = Object.create(e10 && e10.prototype, { constructor: { value: t9, writable: true, configurable: true } }), e10 && g5(t9, e10);
      }(e9, t8), i7 = e9, (u7 = [{ key: "toString", value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      } }, { key: b5.custom, value: function(t9, e10) {
        return b5(this, function(t10) {
          for (var e11 = 1; e11 < arguments.length; e11++) {
            var n9 = null != arguments[e11] ? arguments[e11] : {}, o9 = Object.keys(n9);
            "function" == typeof Object.getOwnPropertySymbols && (o9 = o9.concat(Object.getOwnPropertySymbols(n9).filter(function(t11) {
              return Object.getOwnPropertyDescriptor(n9, t11).enumerable;
            }))), o9.forEach(function(e12) {
              r9(t10, e12, n9[e12]);
            });
          }
          return t10;
        }({}, e10, { customInspect: false, depth: 0 }));
      } }]) && o8(i7.prototype, u7), e9;
    }(f7(Error));
    return u$5 = R4;
  }
  function s$3(t8, e9) {
    return function(t9) {
      if (Array.isArray(t9)) return t9;
    }(t8) || function(t9, e10) {
      var n8 = [], r9 = true, o8 = false, c7 = void 0;
      try {
        for (var a7, i7 = t9[Symbol.iterator](); !(r9 = (a7 = i7.next()).done) && (n8.push(a7.value), !e10 || n8.length !== e10); r9 = true) ;
      } catch (t10) {
        o8 = true, c7 = t10;
      } finally {
        try {
          r9 || null == i7.return || i7.return();
        } finally {
          if (o8) throw c7;
        }
      }
      return n8;
    }(t8, e9) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }();
  }
  function p$3(t8) {
    return (p$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
      return typeof t9;
    } : function(t9) {
      return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
    })(t8);
  }
  function m$2(t8) {
    return t8.call.bind(t8);
  }
  function U2(t8) {
    if (0 === t8.length || t8.length > 10) return true;
    for (var e9 = 0; e9 < t8.length; e9++) {
      var n8 = t8.charCodeAt(e9);
      if (n8 < 48 || n8 > 57) return true;
    }
    return 10 === t8.length && t8 >= Math.pow(2, 32);
  }
  function G2(t8) {
    return Object.keys(t8).filter(U2).concat(v$1(t8).filter(Object.prototype.propertyIsEnumerable.bind(t8)));
  }
  function V2(t8, e9) {
    if (t8 === e9) return 0;
    for (var n8 = t8.length, r9 = e9.length, o8 = 0, c7 = Math.min(n8, r9); o8 < c7; ++o8) if (t8[o8] !== e9[o8]) {
      n8 = t8[o8], r9 = e9[o8];
      break;
    }
    return n8 < r9 ? -1 : r9 < n8 ? 1 : 0;
  }
  function B2(t8, e9, n8, r9) {
    if (t8 === e9) return 0 !== t8 || (!n8 || b$1(t8, e9));
    if (n8) {
      if ("object" !== p$3(t8)) return "number" == typeof t8 && d$1(t8) && d$1(e9);
      if ("object" !== p$3(e9) || null === t8 || null === e9) return false;
      if (Object.getPrototypeOf(t8) !== Object.getPrototypeOf(e9)) return false;
    } else {
      if (null === t8 || "object" !== p$3(t8)) return (null === e9 || "object" !== p$3(e9)) && t8 == e9;
      if (null === e9 || "object" !== p$3(e9)) return false;
    }
    var o8, c7, a7, i7, u7 = S2(t8);
    if (u7 !== S2(e9)) return false;
    if (Array.isArray(t8)) {
      if (t8.length !== e9.length) return false;
      var l7 = G2(t8), f7 = G2(e9);
      return l7.length === f7.length && C2(t8, e9, n8, r9, 1, l7);
    }
    if ("[object Object]" === u7 && (!R2(t8) && R2(e9) || !k2(t8) && k2(e9))) return false;
    if (q2(t8)) {
      if (!q2(e9) || Date.prototype.getTime.call(t8) !== Date.prototype.getTime.call(e9)) return false;
    } else if (A$1(t8)) {
      if (!A$1(e9) || (a7 = t8, i7 = e9, !(g$1 ? a7.source === i7.source && a7.flags === i7.flags : RegExp.prototype.toString.call(a7) === RegExp.prototype.toString.call(i7)))) return false;
    } else if (_2(t8) || t8 instanceof Error) {
      if (t8.message !== e9.message || t8.name !== e9.name) return false;
    } else {
      if (x2(t8)) {
        if (n8 || !L2(t8) && !M2(t8)) {
          if (!function(t9, e10) {
            return t9.byteLength === e10.byteLength && 0 === V2(new Uint8Array(t9.buffer, t9.byteOffset, t9.byteLength), new Uint8Array(e10.buffer, e10.byteOffset, e10.byteLength));
          }(t8, e9)) return false;
        } else if (!function(t9, e10) {
          if (t9.byteLength !== e10.byteLength) return false;
          for (var n9 = 0; n9 < t9.byteLength; n9++) if (t9[n9] !== e10[n9]) return false;
          return true;
        }(t8, e9)) return false;
        var s6 = G2(t8), h8 = G2(e9);
        return s6.length === h8.length && C2(t8, e9, n8, r9, 0, s6);
      }
      if (k2(t8)) return !(!k2(e9) || t8.size !== e9.size) && C2(t8, e9, n8, r9, 2);
      if (R2(t8)) return !(!R2(e9) || t8.size !== e9.size) && C2(t8, e9, n8, r9, 3);
      if (O2(t8)) {
        if (c7 = e9, (o8 = t8).byteLength !== c7.byteLength || 0 !== V2(new Uint8Array(o8), new Uint8Array(c7))) return false;
      } else if (T3(t8) && !function(t9, e10) {
        return P$1(t9) ? P$1(e10) && b$1(Number.prototype.valueOf.call(t9), Number.prototype.valueOf.call(e10)) : I2(t9) ? I2(e10) && String.prototype.valueOf.call(t9) === String.prototype.valueOf.call(e10) : D2(t9) ? D2(e10) && Boolean.prototype.valueOf.call(t9) === Boolean.prototype.valueOf.call(e10) : F2(t9) ? F2(e10) && BigInt.prototype.valueOf.call(t9) === BigInt.prototype.valueOf.call(e10) : N$1(e10) && Symbol.prototype.valueOf.call(t9) === Symbol.prototype.valueOf.call(e10);
      }(t8, e9)) return false;
    }
    return C2(t8, e9, n8, r9, 0);
  }
  function z2(t8, e9) {
    return e9.filter(function(e10) {
      return w$1(t8, e10);
    });
  }
  function C2(t8, e9, n8, r9, o8, c7) {
    if (5 === arguments.length) {
      c7 = Object.keys(t8);
      var a7 = Object.keys(e9);
      if (c7.length !== a7.length) return false;
    }
    for (var i7 = 0; i7 < c7.length; i7++) if (!E2(e9, c7[i7])) return false;
    if (n8 && 5 === arguments.length) {
      var u7 = v$1(t8);
      if (0 !== u7.length) {
        var l7 = 0;
        for (i7 = 0; i7 < u7.length; i7++) {
          var f7 = u7[i7];
          if (w$1(t8, f7)) {
            if (!w$1(e9, f7)) return false;
            c7.push(f7), l7++;
          } else if (w$1(e9, f7)) return false;
        }
        var s6 = v$1(e9);
        if (u7.length !== s6.length && z2(e9, s6).length !== l7) return false;
      } else {
        var p7 = v$1(e9);
        if (0 !== p7.length && 0 !== z2(e9, p7).length) return false;
      }
    }
    if (0 === c7.length && (0 === o8 || 1 === o8 && 0 === t8.length || 0 === t8.size)) return true;
    if (void 0 === r9) r9 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
    else {
      var g5 = r9.val1.get(t8);
      if (void 0 !== g5) {
        var h8 = r9.val2.get(e9);
        if (void 0 !== h8) return g5 === h8;
      }
      r9.position++;
    }
    r9.val1.set(t8, r9.position), r9.val2.set(e9, r9.position);
    var y6 = Q2(t8, e9, n8, c7, r9, o8);
    return r9.val1.delete(t8), r9.val2.delete(e9), y6;
  }
  function Y2(t8, e9, n8, r9) {
    for (var o8 = h$1(t8), c7 = 0; c7 < o8.length; c7++) {
      var a7 = o8[c7];
      if (B2(e9, a7, n8, r9)) return t8.delete(a7), true;
    }
    return false;
  }
  function W2(t8) {
    switch (p$3(t8)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return false;
      case "string":
        t8 = +t8;
      case "number":
        if (d$1(t8)) return false;
    }
    return true;
  }
  function H2(t8, e9, n8) {
    var r9 = W2(n8);
    return null != r9 ? r9 : e9.has(r9) && !t8.has(r9);
  }
  function J2(t8, e9, n8, r9, o8) {
    var c7 = W2(n8);
    if (null != c7) return c7;
    var a7 = e9.get(c7);
    return !(void 0 === a7 && !e9.has(c7) || !B2(r9, a7, false, o8)) && (!t8.has(c7) && B2(r9, a7, false, o8));
  }
  function K2(t8, e9, n8, r9, o8, c7) {
    for (var a7 = h$1(t8), i7 = 0; i7 < a7.length; i7++) {
      var u7 = a7[i7];
      if (B2(n8, u7, o8, c7) && B2(r9, e9.get(u7), o8, c7)) return t8.delete(u7), true;
    }
    return false;
  }
  function Q2(t8, e9, n8, r9, o8, c7) {
    var a7 = 0;
    if (2 === c7) {
      if (!function(t9, e10, n9, r10) {
        for (var o9 = null, c8 = h$1(t9), a8 = 0; a8 < c8.length; a8++) {
          var i8 = c8[a8];
          if ("object" === p$3(i8) && null !== i8) null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(i8);
          else if (!e10.has(i8)) {
            if (n9) return false;
            if (!H2(t9, e10, i8)) return false;
            null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(i8);
          }
        }
        if (null !== o9) {
          for (var u8 = h$1(e10), l8 = 0; l8 < u8.length; l8++) {
            var f7 = u8[l8];
            if ("object" === p$3(f7) && null !== f7) {
              if (!Y2(o9, f7, n9, r10)) return false;
            } else if (!n9 && !t9.has(f7) && !Y2(o9, f7, n9, r10)) return false;
          }
          return 0 === o9.size;
        }
        return true;
      }(t8, e9, n8, o8)) return false;
    } else if (3 === c7) {
      if (!function(t9, e10, n9, r10) {
        for (var o9 = null, c8 = y$2(t9), a8 = 0; a8 < c8.length; a8++) {
          var i8 = s$3(c8[a8], 2), u8 = i8[0], l8 = i8[1];
          if ("object" === p$3(u8) && null !== u8) null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(u8);
          else {
            var f7 = e10.get(u8);
            if (void 0 === f7 && !e10.has(u8) || !B2(l8, f7, n9, r10)) {
              if (n9) return false;
              if (!J2(t9, e10, u8, l8, r10)) return false;
              null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(u8);
            }
          }
        }
        if (null !== o9) {
          for (var g5 = y$2(e10), h8 = 0; h8 < g5.length; h8++) {
            var b5 = s$3(g5[h8], 2), v6 = (u8 = b5[0], b5[1]);
            if ("object" === p$3(u8) && null !== u8) {
              if (!K2(o9, t9, u8, v6, n9, r10)) return false;
            } else if (!(n9 || t9.has(u8) && B2(t9.get(u8), v6, false, r10) || K2(o9, t9, u8, v6, false, r10))) return false;
          }
          return 0 === o9.size;
        }
        return true;
      }(t8, e9, n8, o8)) return false;
    } else if (1 === c7) for (; a7 < t8.length; a7++) {
      if (!E2(t8, a7)) {
        if (E2(e9, a7)) return false;
        for (var i7 = Object.keys(t8); a7 < i7.length; a7++) {
          var u7 = i7[a7];
          if (!E2(e9, u7) || !B2(t8[u7], e9[u7], n8, o8)) return false;
        }
        return i7.length === Object.keys(e9).length;
      }
      if (!E2(e9, a7) || !B2(t8[a7], e9[a7], n8, o8)) return false;
    }
    for (a7 = 0; a7 < r9.length; a7++) {
      var l7 = r9[a7];
      if (!B2(t8[l7], e9[l7], n8, o8)) return false;
    }
    return true;
  }
  function tt() {
    if ($$1) return Z2;
    $$1 = true;
    var o8 = T;
    function c7(t8) {
      return (c7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
        return typeof t9;
      } : function(t9) {
        return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
      })(t8);
    }
    var a7, u7, l7 = i$5().codes, s6 = l7.ERR_AMBIGUOUS_ARGUMENT, p7 = l7.ERR_INVALID_ARG_TYPE, g5 = l7.ERR_INVALID_ARG_VALUE, h8 = l7.ERR_INVALID_RETURN_VALUE, y6 = l7.ERR_MISSING_ARGS, b5 = f$6(), v6 = X.inspect, d6 = X.types, m$12 = d6.isPromise, E4 = d6.isRegExp, w4 = Object.assign ? Object.assign : r3.assign, S4 = Object.is ? Object.is : m3;
    function j4() {
      a7 = X2.isDeepEqual, u7 = X2.isDeepStrictEqual;
    }
    var O5 = false, x4 = Z2 = k4, q3 = {};
    function R4(t8) {
      if (t8.message instanceof Error) throw t8.message;
      throw new b5(t8);
    }
    function A4(t8, e9, n8, r9) {
      if (!n8) {
        var o9 = false;
        if (0 === e9) o9 = true, r9 = "No value argument passed to `assert.ok()`";
        else if (r9 instanceof Error) throw r9;
        var c8 = new b5({ actual: n8, expected: true, message: r9, operator: "==", stackStartFn: t8 });
        throw c8.generatedMessage = o9, c8;
      }
    }
    function k4() {
      for (var t8 = arguments.length, e9 = new Array(t8), n8 = 0; n8 < t8; n8++) e9[n8] = arguments[n8];
      A4.apply(void 0, [k4, e9.length].concat(e9));
    }
    x4.fail = function t8(e9, n8, r9, c8, a8) {
      var i7, u8 = arguments.length;
      if (0 === u8) i7 = "Failed";
      else if (1 === u8) r9 = e9, e9 = void 0;
      else {
        if (false === O5) {
          O5 = true;
          var l8 = o8.emitWarning ? o8.emitWarning : console.warn.bind(console);
          l8("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        2 === u8 && (c8 = "!=");
      }
      if (r9 instanceof Error) throw r9;
      var f7 = { actual: e9, expected: n8, operator: void 0 === c8 ? "fail" : c8, stackStartFn: a8 || t8 };
      void 0 !== r9 && (f7.message = r9);
      var s7 = new b5(f7);
      throw i7 && (s7.message = i7, s7.generatedMessage = true), s7;
    }, x4.AssertionError = b5, x4.ok = k4, x4.equal = function t8(e9, n8, r9) {
      if (arguments.length < 2) throw new y6("actual", "expected");
      e9 != n8 && R4({ actual: e9, expected: n8, message: r9, operator: "==", stackStartFn: t8 });
    }, x4.notEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2) throw new y6("actual", "expected");
      e9 == n8 && R4({ actual: e9, expected: n8, message: r9, operator: "!=", stackStartFn: t8 });
    }, x4.deepEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2) throw new y6("actual", "expected");
      void 0 === a7 && j4(), a7(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: "deepEqual", stackStartFn: t8 });
    }, x4.notDeepEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2) throw new y6("actual", "expected");
      void 0 === a7 && j4(), a7(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: "notDeepEqual", stackStartFn: t8 });
    }, x4.deepStrictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2) throw new y6("actual", "expected");
      void 0 === a7 && j4(), u7(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: "deepStrictEqual", stackStartFn: t8 });
    }, x4.notDeepStrictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2) throw new y6("actual", "expected");
      void 0 === a7 && j4();
      u7(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: "notDeepStrictEqual", stackStartFn: t8 });
    }, x4.strictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2) throw new y6("actual", "expected");
      S4(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: "strictEqual", stackStartFn: t8 });
    }, x4.notStrictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2) throw new y6("actual", "expected");
      S4(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: "notStrictEqual", stackStartFn: t8 });
    };
    var _4 = function t8(e9, n8, r9) {
      var o9 = this;
      !function(t9, e10) {
        if (!(t9 instanceof e10)) throw new TypeError("Cannot call a class as a function");
      }(this, t8), n8.forEach(function(t9) {
        t9 in e9 && (void 0 !== r9 && "string" == typeof r9[t9] && E4(e9[t9]) && e9[t9].test(r9[t9]) ? o9[t9] = r9[t9] : o9[t9] = e9[t9]);
      });
    };
    function T5(t8, e9, n8, r9, o9, c8) {
      if (!(n8 in t8) || !u7(t8[n8], e9[n8])) {
        if (!r9) {
          var a8 = new _4(t8, o9), i7 = new _4(e9, o9, t8), l8 = new b5({ actual: a8, expected: i7, operator: "deepStrictEqual", stackStartFn: c8 });
          throw l8.actual = t8, l8.expected = e9, l8.operator = c8.name, l8;
        }
        R4({ actual: t8, expected: e9, message: r9, operator: c8.name, stackStartFn: c8 });
      }
    }
    function P4(t8, e9, n8, r9) {
      if ("function" != typeof e9) {
        if (E4(e9)) return e9.test(t8);
        if (2 === arguments.length) throw new p7("expected", ["Function", "RegExp"], e9);
        if ("object" !== c7(t8) || null === t8) {
          var o9 = new b5({ actual: t8, expected: e9, message: n8, operator: "deepStrictEqual", stackStartFn: r9 });
          throw o9.operator = r9.name, o9;
        }
        var i7 = Object.keys(e9);
        if (e9 instanceof Error) i7.push("name", "message");
        else if (0 === i7.length) throw new g5("error", e9, "may not be an empty object");
        return void 0 === a7 && j4(), i7.forEach(function(o10) {
          "string" == typeof t8[o10] && E4(e9[o10]) && e9[o10].test(t8[o10]) || T5(t8, e9, o10, n8, i7, r9);
        }), true;
      }
      return void 0 !== e9.prototype && t8 instanceof e9 || !Error.isPrototypeOf(e9) && true === e9.call({}, t8);
    }
    function I4(t8) {
      if ("function" != typeof t8) throw new p7("fn", "Function", t8);
      try {
        t8();
      } catch (t9) {
        return t9;
      }
      return q3;
    }
    function D4(t8) {
      return m$12(t8) || null !== t8 && "object" === c7(t8) && "function" == typeof t8.then && "function" == typeof t8.catch;
    }
    function F4(t8) {
      return Promise.resolve().then(function() {
        var e9;
        if ("function" == typeof t8) {
          if (!D4(e9 = t8())) throw new h8("instance of Promise", "promiseFn", e9);
        } else {
          if (!D4(t8)) throw new p7("promiseFn", ["Function", "Promise"], t8);
          e9 = t8;
        }
        return Promise.resolve().then(function() {
          return e9;
        }).then(function() {
          return q3;
        }).catch(function(t9) {
          return t9;
        });
      });
    }
    function N10(t8, e9, n8, r9) {
      if ("string" == typeof n8) {
        if (4 === arguments.length) throw new p7("error", ["Object", "Error", "Function", "RegExp"], n8);
        if ("object" === c7(e9) && null !== e9) {
          if (e9.message === n8) throw new s6("error/message", 'The error message "'.concat(e9.message, '" is identical to the message.'));
        } else if (e9 === n8) throw new s6("error/message", 'The error "'.concat(e9, '" is identical to the message.'));
        r9 = n8, n8 = void 0;
      } else if (null != n8 && "object" !== c7(n8) && "function" != typeof n8) throw new p7("error", ["Object", "Error", "Function", "RegExp"], n8);
      if (e9 === q3) {
        var o9 = "";
        n8 && n8.name && (o9 += " (".concat(n8.name, ")")), o9 += r9 ? ": ".concat(r9) : ".";
        var a8 = "rejects" === t8.name ? "rejection" : "exception";
        R4({ actual: void 0, expected: n8, operator: t8.name, message: "Missing expected ".concat(a8).concat(o9), stackStartFn: t8 });
      }
      if (n8 && !P4(e9, n8, r9, t8)) throw e9;
    }
    function L4(t8, e9, n8, r9) {
      if (e9 !== q3) {
        if ("string" == typeof n8 && (r9 = n8, n8 = void 0), !n8 || P4(e9, n8)) {
          var o9 = r9 ? ": ".concat(r9) : ".", c8 = "doesNotReject" === t8.name ? "rejection" : "exception";
          R4({ actual: e9, expected: n8, operator: t8.name, message: "Got unwanted ".concat(c8).concat(o9, "\n") + 'Actual message: "'.concat(e9 && e9.message, '"'), stackStartFn: t8 });
        }
        throw e9;
      }
    }
    function M4() {
      for (var t8 = arguments.length, e9 = new Array(t8), n8 = 0; n8 < t8; n8++) e9[n8] = arguments[n8];
      A4.apply(void 0, [M4, e9.length].concat(e9));
    }
    return x4.throws = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++) r9[o9 - 1] = arguments[o9];
      N10.apply(void 0, [t8, I4(e9)].concat(r9));
    }, x4.rejects = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++) r9[o9 - 1] = arguments[o9];
      return F4(e9).then(function(e10) {
        return N10.apply(void 0, [t8, e10].concat(r9));
      });
    }, x4.doesNotThrow = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++) r9[o9 - 1] = arguments[o9];
      L4.apply(void 0, [t8, I4(e9)].concat(r9));
    }, x4.doesNotReject = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++) r9[o9 - 1] = arguments[o9];
      return F4(e9).then(function(e10) {
        return L4.apply(void 0, [t8, e10].concat(r9));
      });
    }, x4.ifError = function t8(e9) {
      if (null != e9) {
        var n8 = "ifError got unwanted exception: ";
        "object" === c7(e9) && "string" == typeof e9.message ? 0 === e9.message.length && e9.constructor ? n8 += e9.constructor.name : n8 += e9.message : n8 += v6(e9);
        var r9 = new b5({ actual: e9, expected: null, operator: "ifError", message: n8, stackStartFn: t8 }), o9 = e9.stack;
        if ("string" == typeof o9) {
          var a8 = o9.split("\n");
          a8.shift();
          for (var i7 = r9.stack.split("\n"), u8 = 0; u8 < a8.length; u8++) {
            var l8 = i7.indexOf(a8[u8]);
            if (-1 !== l8) {
              i7 = i7.slice(0, l8);
              break;
            }
          }
          r9.stack = "".concat(i7.join("\n"), "\n").concat(a8.join("\n"));
        }
        throw r9;
      }
    }, x4.strict = w4(M4, x4, { equal: x4.strictEqual, deepEqual: x4.deepStrictEqual, notEqual: x4.notStrictEqual, notDeepEqual: x4.notDeepStrictEqual }), x4.strict.strict = x4.strict, Z2;
  }
  var r3, t3, e$12, r$12, n8, o8, c7, l7, i7, a7, u7, f7, p7, s6, y2, b2, g2, h3, $2, j2, w2, r$2, e$2, o$12, n$12, a$1, c$12, l$12, u$12, f$1, t$12, f$2, e$3, l$2, t$22, n$2, o$22, r$3, e$4, o$3, t$3, n$3, y$1, a$2, i$12, d3, f$3, u$2, A2, l$3, v2, P2, c$2, t$4, p$1, o$4, i$2, a$3, l$4, r$4, n$4, i$3, o$5, c$3, f$4, u$3, s$1, a$4, l$5, p$2, m3, N2, e$5, i$4, n$5, t$5, u$4, a$5, m$1, o$6, s$2, f$5, c$4, a$6, u$5, l$6, g$1, h$1, y$2, b$1, v$1, d$1, E2, w$1, S2, j$1, O2, x2, q2, R2, A$1, k2, _2, T3, P$1, I2, D2, F2, N$1, L2, M2, X2, Z2, $$1, et, AssertionError, deepEqual, deepStrictEqual, doesNotReject, doesNotThrow, equal, fail, ifError, notDeepEqual, notDeepStrictEqual, notEqual, notStrictEqual, ok, rejects, strict, strictEqual, throws;
  var init_assert = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/assert.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      r3 = { assign: e3, polyfill: function() {
        Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e3 });
      } };
      e$12 = Object.prototype.toString;
      r$12 = function(t8) {
        var r9 = e$12.call(t8), n8 = "[object Arguments]" === r9;
        return n8 || (n8 = "[object Array]" !== r9 && null !== t8 && "object" == typeof t8 && "number" == typeof t8.length && t8.length >= 0 && "[object Function]" === e$12.call(t8.callee)), n8;
      };
      if (!Object.keys) {
        n8 = Object.prototype.hasOwnProperty, o8 = Object.prototype.toString, c7 = r$12, l7 = Object.prototype.propertyIsEnumerable, i7 = !l7.call({ toString: null }, "toString"), a7 = l7.call(function() {
        }, "prototype"), u7 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], f7 = function(t8) {
          var e9 = t8.constructor;
          return e9 && e9.prototype === t8;
        }, p7 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s6 = function() {
          if ("undefined" == typeof window) return false;
          for (var t8 in window) try {
            if (!p7["$" + t8] && n8.call(window, t8) && null !== window[t8] && "object" == typeof window[t8]) try {
              f7(window[t8]);
            } catch (t9) {
              return true;
            }
          } catch (t9) {
            return true;
          }
          return false;
        }();
        t3 = function(t8) {
          var e9 = null !== t8 && "object" == typeof t8, r9 = "[object Function]" === o8.call(t8), l8 = c7(t8), p8 = e9 && "[object String]" === o8.call(t8), y6 = [];
          if (!e9 && !r9 && !l8) throw new TypeError("Object.keys called on a non-object");
          var b5 = a7 && r9;
          if (p8 && t8.length > 0 && !n8.call(t8, 0)) for (var g5 = 0; g5 < t8.length; ++g5) y6.push(String(g5));
          if (l8 && t8.length > 0) for (var h8 = 0; h8 < t8.length; ++h8) y6.push(String(h8));
          else for (var $3 in t8) b5 && "prototype" === $3 || !n8.call(t8, $3) || y6.push(String($3));
          if (i7) for (var j4 = function(t9) {
            if ("undefined" == typeof window || !s6) return f7(t9);
            try {
              return f7(t9);
            } catch (t10) {
              return false;
            }
          }(t8), w4 = 0; w4 < u7.length; ++w4) j4 && "constructor" === u7[w4] || !n8.call(t8, u7[w4]) || y6.push(u7[w4]);
          return y6;
        };
      }
      y2 = t3;
      b2 = Array.prototype.slice;
      g2 = r$12;
      h3 = Object.keys;
      $2 = h3 ? function(t8) {
        return h3(t8);
      } : y2;
      j2 = Object.keys;
      $2.shim = function() {
        Object.keys ? function() {
          var t8 = Object.keys(arguments);
          return t8 && t8.length === arguments.length;
        }(1, 2) || (Object.keys = function(t8) {
          return g2(t8) ? j2(b2.call(t8)) : j2(t8);
        }) : Object.keys = $2;
        return Object.keys || $2;
      };
      w2 = $2;
      r$2 = w2;
      e$2 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
      o$12 = Object.prototype.toString;
      n$12 = Array.prototype.concat;
      a$1 = Object.defineProperty;
      c$12 = a$1 && function() {
        var t8 = {};
        try {
          for (var r9 in a$1(t8, "x", { enumerable: false, value: t8 }), t8) return false;
          return t8.x === t8;
        } catch (t9) {
          return false;
        }
      }();
      l$12 = function(t8, r9, e9, n8) {
        var l7;
        (!(r9 in t8) || "function" == typeof (l7 = n8) && "[object Function]" === o$12.call(l7) && n8()) && (c$12 ? a$1(t8, r9, { configurable: true, enumerable: false, value: e9, writable: true }) : t8[r9] = e9);
      };
      u$12 = function(t8, o8) {
        var a7 = arguments.length > 2 ? arguments[2] : {}, c7 = r$2(o8);
        e$2 && (c7 = n$12.call(c7, Object.getOwnPropertySymbols(o8)));
        for (var u7 = 0; u7 < c7.length; u7 += 1) l$12(t8, c7[u7], o8[c7[u7]], a7[c7[u7]]);
      };
      u$12.supportsDescriptors = !!c$12;
      f$1 = u$12;
      t$12 = function() {
        if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return false;
        if ("symbol" == typeof Symbol.iterator) return true;
        var t8 = {}, e9 = Symbol("test"), r9 = Object(e9);
        if ("string" == typeof e9) return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(e9)) return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(r9)) return false;
        for (e9 in t8[e9] = 42, t8) return false;
        if ("function" == typeof Object.keys && 0 !== Object.keys(t8).length) return false;
        if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t8).length) return false;
        var o8 = Object.getOwnPropertySymbols(t8);
        if (1 !== o8.length || o8[0] !== e9) return false;
        if (!Object.prototype.propertyIsEnumerable.call(t8, e9)) return false;
        if ("function" == typeof Object.getOwnPropertyDescriptor) {
          var n8 = Object.getOwnPropertyDescriptor(t8, e9);
          if (42 !== n8.value || true !== n8.enumerable) return false;
        }
        return true;
      };
      f$2 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global).Symbol;
      e$3 = t$12;
      l$2 = function() {
        return "function" == typeof f$2 && ("function" == typeof Symbol && ("symbol" == typeof f$2("foo") && ("symbol" == typeof Symbol("bar") && e$3())));
      };
      t$22 = "Function.prototype.bind called on incompatible ";
      n$2 = Array.prototype.slice;
      o$22 = Object.prototype.toString;
      r$3 = function(r9) {
        var e9 = this;
        if ("function" != typeof e9 || "[object Function]" !== o$22.call(e9)) throw new TypeError(t$22 + e9);
        for (var p7, i7 = n$2.call(arguments, 1), c7 = function() {
          if (this instanceof p7) {
            var t8 = e9.apply(this, i7.concat(n$2.call(arguments)));
            return Object(t8) === t8 ? t8 : this;
          }
          return e9.apply(r9, i7.concat(n$2.call(arguments)));
        }, a7 = Math.max(0, e9.length - i7.length), l7 = [], u7 = 0; u7 < a7; u7++) l7.push("$" + u7);
        if (p7 = Function("binder", "return function (" + l7.join(",") + "){ return binder.apply(this,arguments); }")(c7), e9.prototype) {
          var y6 = function() {
          };
          y6.prototype = e9.prototype, p7.prototype = new y6(), y6.prototype = null;
        }
        return p7;
      };
      e$4 = Function.prototype.bind || r$3;
      o$3 = TypeError;
      t$3 = Object.getOwnPropertyDescriptor;
      if (t$3) try {
        t$3({}, "");
      } catch (r9) {
        t$3 = null;
      }
      n$3 = function() {
        throw new o$3();
      };
      y$1 = t$3 ? function() {
        try {
          return arguments.callee, n$3;
        } catch (r9) {
          try {
            return t$3(arguments, "callee").get;
          } catch (r10) {
            return n$3;
          }
        }
      }() : n$3;
      a$2 = l$2();
      i$12 = Object.getPrototypeOf || function(r9) {
        return r9.__proto__;
      };
      d3 = "undefined" == typeof Uint8Array ? void 0 : i$12(Uint8Array);
      f$3 = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": a$2 ? i$12([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a$2 ? i$12(i$12([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && a$2 ? i$12((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && a$2 ? i$12((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": a$2 ? i$12(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": a$2 ? Symbol : void 0, "%SymbolPrototype%": a$2 ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": y$1, "%TypedArray%": d3, "%TypedArrayPrototype%": d3 ? d3.prototype : void 0, "%TypeError%": o$3, "%TypeErrorPrototype%": o$3.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype };
      u$2 = e$4.call(Function.call, String.prototype.replace);
      A2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      l$3 = /\\(\\)?/g;
      v2 = function(r9) {
        var e9 = [];
        return u$2(r9, A2, function(r10, o8, t8, n8) {
          e9[e9.length] = t8 ? u$2(n8, l$3, "$1") : o8 || r10;
        }), e9;
      };
      P2 = function(r9, e9) {
        if (!(r9 in f$3)) throw new SyntaxError("intrinsic " + r9 + " does not exist!");
        if (void 0 === f$3[r9] && !e9) throw new o$3("intrinsic " + r9 + " exists, but is not available. Please file an issue!");
        return f$3[r9];
      };
      c$2 = function(r9, e9) {
        if ("string" != typeof r9 || 0 === r9.length) throw new TypeError("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && "boolean" != typeof e9) throw new TypeError('"allowMissing" argument must be a boolean');
        for (var n8 = v2(r9), y6 = P2("%" + (n8.length > 0 ? n8[0] : "") + "%", e9), a7 = 1; a7 < n8.length; a7 += 1) if (null != y6) if (t$3 && a7 + 1 >= n8.length) {
          var i7 = t$3(y6, n8[a7]);
          if (!e9 && !(n8[a7] in y6)) throw new o$3("base intrinsic for " + r9 + " exists, but the property is not available.");
          y6 = i7 ? i7.get || i7.value : y6[n8[a7]];
        } else y6 = y6[n8[a7]];
        return y6;
      };
      p$1 = e$4;
      o$4 = c$2("%Function%");
      i$2 = o$4.apply;
      a$3 = o$4.call;
      (t$4 = function() {
        return p$1.apply(a$3, arguments);
      }).apply = function() {
        return p$1.apply(i$2, arguments);
      };
      l$4 = t$4;
      i$3 = function(t8) {
        return t8 != t8;
      };
      o$5 = (r$4 = function(t8, e9) {
        return 0 === t8 && 0 === e9 ? 1 / t8 == 1 / e9 : t8 === e9 || !(!i$3(t8) || !i$3(e9));
      }, r$4);
      c$3 = (n$4 = function() {
        return "function" == typeof Object.is ? Object.is : o$5;
      }, n$4);
      f$4 = f$1;
      u$3 = f$1;
      s$1 = r$4;
      a$4 = n$4;
      l$5 = function() {
        var t8 = c$3();
        return f$4(Object, { is: t8 }, { is: function() {
          return Object.is !== t8;
        } }), t8;
      };
      p$2 = l$4(a$4(), Object);
      u$3(p$2, { getPolyfill: a$4, implementation: s$1, shim: l$5 });
      m3 = p$2;
      N2 = function(r9) {
        return r9 != r9;
      };
      i$4 = N2;
      n$5 = (e$5 = function() {
        return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$4;
      }, f$1);
      t$5 = e$5;
      u$4 = f$1;
      a$5 = N2;
      m$1 = e$5;
      o$6 = function() {
        var r9 = t$5();
        return n$5(Number, { isNaN: r9 }, { isNaN: function() {
          return Number.isNaN !== r9;
        } }), r9;
      };
      s$2 = m$1();
      u$4(s$2, { getPolyfill: m$1, implementation: a$5, shim: o$6 });
      f$5 = s$2;
      c$4 = {};
      a$6 = false;
      u$5 = {};
      l$6 = false;
      g$1 = void 0 !== /a/g.flags;
      h$1 = function(t8) {
        var e9 = [];
        return t8.forEach(function(t9) {
          return e9.push(t9);
        }), e9;
      };
      y$2 = function(t8) {
        var e9 = [];
        return t8.forEach(function(t9, n8) {
          return e9.push([n8, t9]);
        }), e9;
      };
      b$1 = Object.is ? Object.is : m3;
      v$1 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return [];
      };
      d$1 = Number.isNaN ? Number.isNaN : f$5;
      E2 = m$2(Object.prototype.hasOwnProperty);
      w$1 = m$2(Object.prototype.propertyIsEnumerable);
      S2 = m$2(Object.prototype.toString);
      j$1 = X.types;
      O2 = j$1.isAnyArrayBuffer;
      x2 = j$1.isArrayBufferView;
      q2 = j$1.isDate;
      R2 = j$1.isMap;
      A$1 = j$1.isRegExp;
      k2 = j$1.isSet;
      _2 = j$1.isNativeError;
      T3 = j$1.isBoxedPrimitive;
      P$1 = j$1.isNumberObject;
      I2 = j$1.isStringObject;
      D2 = j$1.isBooleanObject;
      F2 = j$1.isBigIntObject;
      N$1 = j$1.isSymbolObject;
      L2 = j$1.isFloat32Array;
      M2 = j$1.isFloat64Array;
      X2 = { isDeepEqual: function(t8, e9) {
        return B2(t8, e9, false);
      }, isDeepStrictEqual: function(t8, e9) {
        return B2(t8, e9, true);
      } };
      Z2 = {};
      $$1 = false;
      et = tt();
      et.AssertionError;
      et.deepEqual;
      et.deepStrictEqual;
      et.doesNotReject;
      et.doesNotThrow;
      et.equal;
      et.fail;
      et.ifError;
      et.notDeepEqual;
      et.notDeepStrictEqual;
      et.notEqual;
      et.notStrictEqual;
      et.ok;
      et.rejects;
      et.strict;
      et.strictEqual;
      et.throws;
      et.AssertionError;
      et.deepEqual;
      et.deepStrictEqual;
      et.doesNotReject;
      et.doesNotThrow;
      et.equal;
      et.fail;
      et.ifError;
      et.notDeepEqual;
      et.notDeepStrictEqual;
      et.notEqual;
      et.notStrictEqual;
      et.ok;
      et.rejects;
      et.strict;
      et.strictEqual;
      et.throws;
      AssertionError = et.AssertionError;
      deepEqual = et.deepEqual;
      deepStrictEqual = et.deepStrictEqual;
      doesNotReject = et.doesNotReject;
      doesNotThrow = et.doesNotThrow;
      equal = et.equal;
      fail = et.fail;
      ifError = et.ifError;
      notDeepEqual = et.notDeepEqual;
      notDeepStrictEqual = et.notDeepStrictEqual;
      notEqual = et.notEqual;
      notStrictEqual = et.notStrictEqual;
      ok = et.ok;
      rejects = et.rejects;
      strict = et.strict;
      strictEqual = et.strictEqual;
      throws = et.throws;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js
  var _extend, callbackify, debuglog, deprecate, format, inherits, inspect, isArray, isBoolean, isBuffer, isDate, isError, isFunction, isNull, isNullOrUndefined, isNumber, isObject, isPrimitive, isRegExp, isString, isSymbol, isUndefined, log, promisify, types, TextEncoder2, TextDecoder2;
  var init_chunk_ce0fbc82 = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      X._extend;
      X.callbackify;
      X.debuglog;
      X.deprecate;
      X.format;
      X.inherits;
      X.inspect;
      X.isArray;
      X.isBoolean;
      X.isBuffer;
      X.isDate;
      X.isError;
      X.isFunction;
      X.isNull;
      X.isNullOrUndefined;
      X.isNumber;
      X.isObject;
      X.isPrimitive;
      X.isRegExp;
      X.isString;
      X.isSymbol;
      X.isUndefined;
      X.log;
      X.promisify;
      _extend = X._extend;
      callbackify = X.callbackify;
      debuglog = X.debuglog;
      deprecate = X.deprecate;
      format = X.format;
      inherits = X.inherits;
      inspect = X.inspect;
      isArray = X.isArray;
      isBoolean = X.isBoolean;
      isBuffer = X.isBuffer;
      isDate = X.isDate;
      isError = X.isError;
      isFunction = X.isFunction;
      isNull = X.isNull;
      isNullOrUndefined = X.isNullOrUndefined;
      isNumber = X.isNumber;
      isObject = X.isObject;
      isPrimitive = X.isPrimitive;
      isRegExp = X.isRegExp;
      isString = X.isString;
      isSymbol = X.isSymbol;
      isUndefined = X.isUndefined;
      log = X.log;
      promisify = X.promisify;
      types = X.types;
      TextEncoder2 = self.TextEncoder;
      TextDecoder2 = self.TextDecoder;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/util.js
  var util_exports = {};
  __export(util_exports, {
    TextDecoder: () => TextDecoder3,
    TextEncoder: () => TextEncoder3,
    _extend: () => _extend2,
    callbackify: () => callbackify2,
    debuglog: () => debuglog2,
    default: () => X,
    deprecate: () => deprecate2,
    format: () => format2,
    inherits: () => inherits2,
    inspect: () => inspect2,
    isArray: () => isArray2,
    isBoolean: () => isBoolean2,
    isBuffer: () => isBuffer2,
    isDate: () => isDate2,
    isError: () => isError2,
    isFunction: () => isFunction2,
    isNull: () => isNull2,
    isNullOrUndefined: () => isNullOrUndefined2,
    isNumber: () => isNumber2,
    isObject: () => isObject2,
    isPrimitive: () => isPrimitive2,
    isRegExp: () => isRegExp2,
    isString: () => isString2,
    isSymbol: () => isSymbol2,
    isUndefined: () => isUndefined2,
    log: () => log2,
    promisify: () => promisify2,
    types: () => types2
  });
  var _extend2, callbackify2, debuglog2, deprecate2, format2, inherits2, inspect2, isArray2, isBoolean2, isBuffer2, isDate2, isError2, isFunction2, isNull2, isNullOrUndefined2, isNumber2, isObject2, isPrimitive2, isRegExp2, isString2, isSymbol2, isUndefined2, log2, promisify2, types2, TextEncoder3, TextDecoder3;
  var init_util = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/util.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      _extend2 = X._extend;
      callbackify2 = X.callbackify;
      debuglog2 = X.debuglog;
      deprecate2 = X.deprecate;
      format2 = X.format;
      inherits2 = X.inherits;
      inspect2 = X.inspect;
      isArray2 = X.isArray;
      isBoolean2 = X.isBoolean;
      isBuffer2 = X.isBuffer;
      isDate2 = X.isDate;
      isError2 = X.isError;
      isFunction2 = X.isFunction;
      isNull2 = X.isNull;
      isNullOrUndefined2 = X.isNullOrUndefined;
      isNumber2 = X.isNumber;
      isObject2 = X.isObject;
      isPrimitive2 = X.isPrimitive;
      isRegExp2 = X.isRegExp;
      isString2 = X.isString;
      isSymbol2 = X.isSymbol;
      isUndefined2 = X.isUndefined;
      log2 = X.log;
      promisify2 = X.promisify;
      types2 = X.types;
      TextEncoder3 = X.TextEncoder = globalThis.TextEncoder;
      TextDecoder3 = X.TextDecoder = globalThis.TextDecoder;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/internal/errors.js
  var require_errors = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/internal/errors.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.AssertionError = exports9.RangeError = exports9.TypeError = exports9.Error = void 0;
      exports9.message = message2;
      exports9.E = E4;
      var assert3 = (init_assert(), __toCommonJS(assert_exports));
      var util = (init_util(), __toCommonJS(util_exports));
      var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
      var messages = {};
      function makeNodeError(Base) {
        return class NodeError extends Base {
          constructor(key, ...args) {
            super(message2(key, args));
            this.code = key;
            this[kCode] = key;
            this.name = `${super.name} [${this[kCode]}]`;
          }
        };
      }
      var g5 = typeof globalThis !== "undefined" ? globalThis : global;
      var AssertionError2 = class extends g5.Error {
        constructor(options) {
          if (typeof options !== "object" || options === null) {
            throw new exports9.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
          }
          if (options.message) {
            super(options.message);
          } else {
            super(`${util.inspect(options.actual).slice(0, 128)} ${options.operator} ${util.inspect(options.expected).slice(0, 128)}`);
          }
          this.generatedMessage = !options.message;
          this.name = "AssertionError [ERR_ASSERTION]";
          this.code = "ERR_ASSERTION";
          this.actual = options.actual;
          this.expected = options.expected;
          this.operator = options.operator;
          exports9.Error.captureStackTrace(this, options.stackStartFunction);
        }
      };
      exports9.AssertionError = AssertionError2;
      function message2(key, args) {
        assert3.strictEqual(typeof key, "string");
        const msg = messages[key];
        assert3(msg, `An invalid error message key was used: ${key}.`);
        let fmt;
        if (typeof msg === "function") {
          fmt = msg;
        } else {
          fmt = util.format;
          if (args === void 0 || args.length === 0)
            return msg;
          args.unshift(msg);
        }
        return String(fmt.apply(null, args));
      }
      function E4(sym, val) {
        messages[sym] = typeof val === "function" ? val : String(val);
      }
      exports9.Error = makeNodeError(g5.Error);
      exports9.TypeError = makeNodeError(g5.TypeError);
      exports9.RangeError = makeNodeError(g5.RangeError);
      E4("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
      E4("ERR_ASSERTION", "%s");
      E4("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
      E4("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
      E4("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
      E4("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
      E4("ERR_DNS_SET_SERVERS_FAILED", (err, servers) => `c-ares failed to set servers: "${err}" [${servers}]`);
      E4("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
      E4("ERR_ENCODING_NOT_SUPPORTED", (enc) => `The "${enc}" encoding is not supported`);
      E4("ERR_ENCODING_INVALID_ENCODED_DATA", (enc) => `The encoded data was not valid for encoding ${enc}`);
      E4("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
      E4("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
      E4("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
      E4("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
      E4("ERR_INVALID_ARG_TYPE", invalidArgType);
      E4("ERR_INVALID_ARRAY_LENGTH", (name8, len, actual) => {
        assert3.strictEqual(typeof actual, "number");
        return `The array "${name8}" (length ${actual}) must be of length ${len}.`;
      });
      E4("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
      E4("ERR_INVALID_CALLBACK", "Callback must be a function");
      E4("ERR_INVALID_CHAR", "Invalid character in %s");
      E4("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
      E4("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
      E4("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
      E4("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
      E4("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
      E4("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
      E4("ERR_INVALID_OPT_VALUE", (name8, value) => {
        return `The value "${String(value)}" is invalid for option "${name8}"`;
      });
      E4("ERR_INVALID_OPT_VALUE_ENCODING", (value) => `The value "${String(value)}" is invalid for option "encoding"`);
      E4("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
      E4("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
      E4("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
      E4("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
      E4("ERR_INVALID_URL", "Invalid URL: %s");
      E4("ERR_INVALID_URL_SCHEME", (expected) => `The URL must be ${oneOf(expected, "scheme")}`);
      E4("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
      E4("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
      E4("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
      E4("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
      E4("ERR_MISSING_ARGS", missingArgs);
      E4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      E4("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
      E4("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
      E4("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
      E4("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
      E4("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
      E4("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
      E4("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
      E4("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
      E4("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
      E4("ERR_SOCKET_CLOSED", "Socket is closed");
      E4("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
      E4("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
      E4("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
      E4("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
      E4("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
      E4("ERR_TLS_DH_PARAM_SIZE", (size) => `DH parameter size ${size} is less than 2048`);
      E4("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
      E4("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
      E4("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
      E4("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
      E4("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
      E4("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
      E4("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
      E4("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
      E4("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
      E4("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
      E4("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
      function invalidArgType(name8, expected, actual) {
        assert3(name8, "name is required");
        let determiner;
        if (expected.includes("not ")) {
          determiner = "must not be";
          expected = expected.split("not ")[1];
        } else {
          determiner = "must be";
        }
        let msg;
        if (Array.isArray(name8)) {
          const names = name8.map((val) => `"${val}"`).join(", ");
          msg = `The ${names} arguments ${determiner} ${oneOf(expected, "type")}`;
        } else if (name8.includes(" argument")) {
          msg = `The ${name8} ${determiner} ${oneOf(expected, "type")}`;
        } else {
          const type2 = name8.includes(".") ? "property" : "argument";
          msg = `The "${name8}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
        }
        if (arguments.length >= 3) {
          msg += `. Received type ${actual !== null ? typeof actual : "null"}`;
        }
        return msg;
      }
      function missingArgs(...args) {
        assert3(args.length > 0, "At least one arg needs to be specified");
        let msg = "The ";
        const len = args.length;
        args = args.map((a7) => `"${a7}"`);
        switch (len) {
          case 1:
            msg += `${args[0]} argument`;
            break;
          case 2:
            msg += `${args[0]} and ${args[1]} arguments`;
            break;
          default:
            msg += args.slice(0, len - 1).join(", ");
            msg += `, and ${args[len - 1]} arguments`;
            break;
        }
        return `${msg} must be specified`;
      }
      function oneOf(expected, thing) {
        assert3(expected, "expected is required");
        assert3(typeof thing === "string", "thing is required");
        if (Array.isArray(expected)) {
          const len = expected.length;
          assert3(len > 0, "At least one expected value needs to be specified");
          expected = expected.map((i7) => String(i7));
          if (len > 2) {
            return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
          } else if (len === 2) {
            return `one of ${thing} ${expected[0]} or ${expected[1]}`;
          } else {
            return `of ${thing} ${expected[0]}`;
          }
        } else {
          return `of ${thing} ${String(expected)}`;
        }
      }
      function bufferOutOfBounds(name8, isWriting) {
        if (isWriting) {
          return "Attempt to write outside buffer bounds";
        } else {
          return `"${name8}" is outside of buffer bounds`;
        }
      }
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/encoding.js
  var require_encoding = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/encoding.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.ENCODING_UTF8 = void 0;
      exports9.assertEncoding = assertEncoding;
      exports9.strToEncoding = strToEncoding;
      var buffer_1 = require_buffer();
      var errors = require_errors();
      exports9.ENCODING_UTF8 = "utf8";
      function assertEncoding(encoding) {
        if (encoding && !buffer_1.Buffer.isEncoding(encoding))
          throw new errors.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
      }
      function strToEncoding(str, encoding) {
        if (!encoding || encoding === exports9.ENCODING_UTF8)
          return str;
        if (encoding === "buffer")
          return new buffer_1.Buffer(str);
        return new buffer_1.Buffer(str).toString(encoding);
      }
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/Dirent.js
  var require_Dirent = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/Dirent.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.Dirent = void 0;
      var constants_1 = require_constants();
      var encoding_1 = require_encoding();
      var { S_IFMT, S_IFDIR, S_IFREG, S_IFBLK, S_IFCHR, S_IFLNK, S_IFIFO, S_IFSOCK } = constants_1.constants;
      var Dirent2 = class _Dirent {
        constructor() {
          this.name = "";
          this.path = "";
          this.parentPath = "";
          this.mode = 0;
        }
        static build(link4, encoding) {
          const dirent = new _Dirent();
          const { mode } = link4.getNode();
          dirent.name = (0, encoding_1.strToEncoding)(link4.getName(), encoding);
          dirent.mode = mode;
          dirent.path = link4.getParentPath();
          dirent.parentPath = dirent.path;
          return dirent;
        }
        _checkModeProperty(property) {
          return (this.mode & S_IFMT) === property;
        }
        isDirectory() {
          return this._checkModeProperty(S_IFDIR);
        }
        isFile() {
          return this._checkModeProperty(S_IFREG);
        }
        isBlockDevice() {
          return this._checkModeProperty(S_IFBLK);
        }
        isCharacterDevice() {
          return this._checkModeProperty(S_IFCHR);
        }
        isSymbolicLink() {
          return this._checkModeProperty(S_IFLNK);
        }
        isFIFO() {
          return this._checkModeProperty(S_IFIFO);
        }
        isSocket() {
          return this._checkModeProperty(S_IFSOCK);
        }
      };
      exports9.Dirent = Dirent2;
      exports9.default = Dirent2;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js
  function dew2() {
    if (_dewExec2) return exports3;
    _dewExec2 = true;
    var process4 = exports3 = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e9) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e9) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e9) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e10) {
          return cachedSetTimeout.call(this || _global, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e9) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e10) {
          return cachedClearTimeout.call(this || _global, marker);
        }
      }
    }
    var queue2 = [];
    var draining2 = false;
    var currentQueue2;
    var queueIndex2 = -1;
    function cleanUpNextTick2() {
      if (!draining2 || !currentQueue2) {
        return;
      }
      draining2 = false;
      if (currentQueue2.length) {
        queue2 = currentQueue2.concat(queue2);
      } else {
        queueIndex2 = -1;
      }
      if (queue2.length) {
        drainQueue2();
      }
    }
    function drainQueue2() {
      if (draining2) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick2);
      draining2 = true;
      var len = queue2.length;
      while (len) {
        currentQueue2 = queue2;
        queue2 = [];
        while (++queueIndex2 < len) {
          if (currentQueue2) {
            currentQueue2[queueIndex2].run();
          }
        }
        queueIndex2 = -1;
        len = queue2.length;
      }
      currentQueue2 = null;
      draining2 = false;
      runClearTimeout(timeout);
    }
    process4.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i7 = 1; i7 < arguments.length; i7++) {
          args[i7 - 1] = arguments[i7];
        }
      }
      queue2.push(new Item2(fun, args));
      if (queue2.length === 1 && !draining2) {
        runTimeout(drainQueue2);
      }
    };
    function Item2(fun, array) {
      (this || _global).fun = fun;
      (this || _global).array = array;
    }
    Item2.prototype.run = function() {
      (this || _global).fun.apply(null, (this || _global).array);
    };
    process4.title = "browser";
    process4.browser = true;
    process4.env = {};
    process4.argv = [];
    process4.version = "";
    process4.versions = {};
    function noop3() {
    }
    process4.on = noop3;
    process4.addListener = noop3;
    process4.once = noop3;
    process4.off = noop3;
    process4.removeListener = noop3;
    process4.removeAllListeners = noop3;
    process4.emit = noop3;
    process4.prependListener = noop3;
    process4.prependOnceListener = noop3;
    process4.listeners = function(name8) {
      return [];
    };
    process4.binding = function(name8) {
      throw new Error("process.binding is not supported");
    };
    process4.cwd = function() {
      return "/";
    };
    process4.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process4.umask = function() {
      return 0;
    };
    return exports3;
  }
  var exports3, _dewExec2, _global, process3;
  var init_chunk_2eac56ff = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      exports3 = {};
      _dewExec2 = false;
      _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      process3 = dew2();
      process3.platform = "browser";
      process3.addListener;
      process3.argv;
      process3.binding;
      process3.browser;
      process3.chdir;
      process3.cwd;
      process3.emit;
      process3.env;
      process3.listeners;
      process3.nextTick;
      process3.off;
      process3.on;
      process3.once;
      process3.prependListener;
      process3.prependOnceListener;
      process3.removeAllListeners;
      process3.removeListener;
      process3.title;
      process3.umask;
      process3.version;
      process3.versions;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js
  function dew3() {
    if (_dewExec3) return exports$12;
    _dewExec3 = true;
    var process$1 = process3;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code9;
      for (var i7 = 0; i7 <= path2.length; ++i7) {
        if (i7 < path2.length) code9 = path2.charCodeAt(i7);
        else if (code9 === 47) break;
        else code9 = 47;
        if (code9 === 47) {
          if (lastSlash === i7 - 1 || dots === 1) ;
          else if (lastSlash !== i7 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i7;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i7;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0) res += "/..";
              else res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0) res += "/" + path2.slice(lastSlash + 1, i7);
            else res = path2.slice(lastSlash + 1, i7);
            lastSegmentLength = i7 - lastSlash - 1;
          }
          lastSlash = i7;
          dots = 0;
        } else if (code9 === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep2, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base3 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base3;
      }
      if (dir === pathObject.root) {
        return dir + base3;
      }
      return dir + sep2 + base3;
    }
    var posix2 = {
      // path.resolve([from ...], to)
      resolve: function resolve9() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
          var path2;
          if (i7 >= 0) path2 = arguments[i7];
          else {
            if (cwd2 === void 0) cwd2 = process$1.cwd();
            path2 = cwd2;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0) return "/" + resolvedPath;
          else return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize2(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var isAbsolute2 = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute2);
        if (path2.length === 0 && !isAbsolute2) path2 = ".";
        if (path2.length > 0 && trailingSeparator) path2 += "/";
        if (isAbsolute2) return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute2(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join3() {
        if (arguments.length === 0) return ".";
        var joined;
        for (var i7 = 0; i7 < arguments.length; ++i7) {
          var arg = arguments[i7];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0) joined = arg;
            else joined += "/" + arg;
          }
        }
        if (joined === void 0) return ".";
        return posix2.normalize(joined);
      },
      relative: function relative2(from8, to) {
        assertPath(from8);
        assertPath(to);
        if (from8 === to) return "";
        from8 = posix2.resolve(from8);
        to = posix2.resolve(to);
        if (from8 === to) return "";
        var fromStart = 1;
        for (; fromStart < from8.length; ++fromStart) {
          if (from8.charCodeAt(fromStart) !== 47) break;
        }
        var fromEnd = from8.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length4 = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i7 = 0;
        for (; i7 <= length4; ++i7) {
          if (i7 === length4) {
            if (toLen > length4) {
              if (to.charCodeAt(toStart + i7) === 47) {
                return to.slice(toStart + i7 + 1);
              } else if (i7 === 0) {
                return to.slice(toStart + i7);
              }
            } else if (fromLen > length4) {
              if (from8.charCodeAt(fromStart + i7) === 47) {
                lastCommonSep = i7;
              } else if (i7 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from8.charCodeAt(fromStart + i7);
          var toCode = to.charCodeAt(toStart + i7);
          if (fromCode !== toCode) break;
          else if (fromCode === 47) lastCommonSep = i7;
        }
        var out = "";
        for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
          if (i7 === fromEnd || from8.charCodeAt(i7) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
          }
        }
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47) ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong2(path2) {
        return path2;
      },
      dirname: function dirname2(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var code9 = path2.charCodeAt(0);
        var hasRoot = code9 === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i7 = path2.length - 1; i7 >= 1; --i7) {
          code9 = path2.charCodeAt(i7);
          if (code9 === 47) {
            if (!matchedSlash) {
              end = i7;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path2.slice(0, end);
      },
      basename: function basename2(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i7;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            var code9 = path2.charCodeAt(i7);
            if (code9 === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i7 + 1;
              }
              if (extIdx >= 0) {
                if (code9 === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i7;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            if (path2.charCodeAt(i7) === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i7 + 1;
            }
          }
          if (end === -1) return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname2(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i7 = path2.length - 1; i7 >= 0; --i7) {
          var code9 = path2.charCodeAt(i7);
          if (code9 === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code9 === 46) {
            if (startDot === -1) startDot = i7;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format8(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse7(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0) return ret;
        var code9 = path2.charCodeAt(0);
        var isAbsolute2 = code9 === 47;
        var start;
        if (isAbsolute2) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i7 = path2.length - 1;
        var preDotState = 0;
        for (; i7 >= start; --i7) {
          code9 = path2.charCodeAt(i7);
          if (code9 === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code9 === 46) {
            if (startDot === -1) startDot = i7;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute2) ret.base = ret.name = path2.slice(1, end);
            else ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute2) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute2) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix2.posix = posix2;
    exports$12 = posix2;
    return exports$12;
  }
  var exports$12, _dewExec3, exports4;
  var init_chunk_23dbec7b = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_2eac56ff();
      exports$12 = {};
      _dewExec3 = false;
      exports4 = dew3();
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/path.js
  var path_exports = {};
  __export(path_exports, {
    _makeLong: () => _makeLong,
    basename: () => basename,
    default: () => exports4,
    delimiter: () => delimiter,
    dirname: () => dirname,
    extname: () => extname,
    format: () => format3,
    isAbsolute: () => isAbsolute,
    join: () => join,
    normalize: () => normalize,
    parse: () => parse2,
    posix: () => posix,
    relative: () => relative,
    resolve: () => resolve,
    sep: () => sep,
    win32: () => win32
  });
  var _makeLong, basename, delimiter, dirname, extname, format3, isAbsolute, join, normalize, parse2, posix, relative, resolve, sep, win32;
  var init_path = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/path.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_23dbec7b();
      init_chunk_23dbec7b();
      init_chunk_2eac56ff();
      _makeLong = exports4._makeLong;
      basename = exports4.basename;
      delimiter = exports4.delimiter;
      dirname = exports4.dirname;
      extname = exports4.extname;
      format3 = exports4.format;
      isAbsolute = exports4.isAbsolute;
      join = exports4.join;
      normalize = exports4.normalize;
      parse2 = exports4.parse;
      posix = exports4.posix;
      relative = exports4.relative;
      resolve = exports4.resolve;
      sep = exports4.sep;
      win32 = exports4.win32;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/process.js
  var require_process = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/process.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.createProcess = createProcess;
      var maybeReturnProcess = () => {
        if (typeof process !== "undefined") {
          return process;
        }
        try {
          return init_process(), __toCommonJS(process);
        } catch (_a) {
          return void 0;
        }
      };
      function createProcess() {
        const p7 = maybeReturnProcess() || {};
        if (!p7.cwd)
          p7.cwd = () => "/";
        if (!p7.emitWarning)
          p7.emitWarning = (message2, type2) => {
            console.warn(`${type2}${type2 ? ": " : ""}${message2}`);
          };
        if (!p7.env)
          p7.env = {};
        return p7;
      }
      exports9.default = createProcess();
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js
  function o3() {
    o3.init.call(this);
  }
  function u3(e9) {
    if ("function" != typeof e9) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e9);
  }
  function f3(e9) {
    return void 0 === e9._maxListeners ? o3.defaultMaxListeners : e9._maxListeners;
  }
  function v3(e9, t8, n8, r9) {
    var i7, o8, s6, v6;
    if (u3(n8), void 0 === (o8 = e9._events) ? (o8 = e9._events = /* @__PURE__ */ Object.create(null), e9._eventsCount = 0) : (void 0 !== o8.newListener && (e9.emit("newListener", t8, n8.listener ? n8.listener : n8), o8 = e9._events), s6 = o8[t8]), void 0 === s6) s6 = o8[t8] = n8, ++e9._eventsCount;
    else if ("function" == typeof s6 ? s6 = o8[t8] = r9 ? [n8, s6] : [s6, n8] : r9 ? s6.unshift(n8) : s6.push(n8), (i7 = f3(e9)) > 0 && s6.length > i7 && !s6.warned) {
      s6.warned = true;
      var a7 = new Error("Possible EventEmitter memory leak detected. " + s6.length + " " + String(t8) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a7.name = "MaxListenersExceededWarning", a7.emitter = e9, a7.type = t8, a7.count = s6.length, v6 = a7, console && console.warn && console.warn(v6);
    }
    return e9;
  }
  function a3() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function l3(e9, t8, n8) {
    var r9 = { fired: false, wrapFn: void 0, target: e9, type: t8, listener: n8 }, i7 = a3.bind(r9);
    return i7.listener = n8, r9.wrapFn = i7, i7;
  }
  function h4(e9, t8, n8) {
    var r9 = e9._events;
    if (void 0 === r9) return [];
    var i7 = r9[t8];
    return void 0 === i7 ? [] : "function" == typeof i7 ? n8 ? [i7.listener || i7] : [i7] : n8 ? function(e10) {
      for (var t9 = new Array(e10.length), n9 = 0; n9 < t9.length; ++n9) t9[n9] = e10[n9].listener || e10[n9];
      return t9;
    }(i7) : c3(i7, i7.length);
  }
  function p3(e9) {
    var t8 = this._events;
    if (void 0 !== t8) {
      var n8 = t8[e9];
      if ("function" == typeof n8) return 1;
      if (void 0 !== n8) return n8.length;
    }
    return 0;
  }
  function c3(e9, t8) {
    for (var n8 = new Array(t8), r9 = 0; r9 < t8; ++r9) n8[r9] = e9[r9];
    return n8;
  }
  var e4, t4, n3, r4, i3, s3, y3;
  var init_chunk_4bd36a8f = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      n3 = "object" == typeof Reflect ? Reflect : null;
      r4 = n3 && "function" == typeof n3.apply ? n3.apply : function(e9, t8, n8) {
        return Function.prototype.apply.call(e9, t8, n8);
      };
      t4 = n3 && "function" == typeof n3.ownKeys ? n3.ownKeys : Object.getOwnPropertySymbols ? function(e9) {
        return Object.getOwnPropertyNames(e9).concat(Object.getOwnPropertySymbols(e9));
      } : function(e9) {
        return Object.getOwnPropertyNames(e9);
      };
      i3 = Number.isNaN || function(e9) {
        return e9 != e9;
      };
      e4 = o3, o3.EventEmitter = o3, o3.prototype._events = void 0, o3.prototype._eventsCount = 0, o3.prototype._maxListeners = void 0;
      s3 = 10;
      Object.defineProperty(o3, "defaultMaxListeners", { enumerable: true, get: function() {
        return s3;
      }, set: function(e9) {
        if ("number" != typeof e9 || e9 < 0 || i3(e9)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e9 + ".");
        s3 = e9;
      } }), o3.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, o3.prototype.setMaxListeners = function(e9) {
        if ("number" != typeof e9 || e9 < 0 || i3(e9)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e9 + ".");
        return this._maxListeners = e9, this;
      }, o3.prototype.getMaxListeners = function() {
        return f3(this);
      }, o3.prototype.emit = function(e9) {
        for (var t8 = [], n8 = 1; n8 < arguments.length; n8++) t8.push(arguments[n8]);
        var i7 = "error" === e9, o8 = this._events;
        if (void 0 !== o8) i7 = i7 && void 0 === o8.error;
        else if (!i7) return false;
        if (i7) {
          var s6;
          if (t8.length > 0 && (s6 = t8[0]), s6 instanceof Error) throw s6;
          var u7 = new Error("Unhandled error." + (s6 ? " (" + s6.message + ")" : ""));
          throw u7.context = s6, u7;
        }
        var f7 = o8[e9];
        if (void 0 === f7) return false;
        if ("function" == typeof f7) r4(f7, this, t8);
        else {
          var v6 = f7.length, a7 = c3(f7, v6);
          for (n8 = 0; n8 < v6; ++n8) r4(a7[n8], this, t8);
        }
        return true;
      }, o3.prototype.addListener = function(e9, t8) {
        return v3(this, e9, t8, false);
      }, o3.prototype.on = o3.prototype.addListener, o3.prototype.prependListener = function(e9, t8) {
        return v3(this, e9, t8, true);
      }, o3.prototype.once = function(e9, t8) {
        return u3(t8), this.on(e9, l3(this, e9, t8)), this;
      }, o3.prototype.prependOnceListener = function(e9, t8) {
        return u3(t8), this.prependListener(e9, l3(this, e9, t8)), this;
      }, o3.prototype.removeListener = function(e9, t8) {
        var n8, r9, i7, o8, s6;
        if (u3(t8), void 0 === (r9 = this._events)) return this;
        if (void 0 === (n8 = r9[e9])) return this;
        if (n8 === t8 || n8.listener === t8) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r9[e9], r9.removeListener && this.emit("removeListener", e9, n8.listener || t8));
        else if ("function" != typeof n8) {
          for (i7 = -1, o8 = n8.length - 1; o8 >= 0; o8--) if (n8[o8] === t8 || n8[o8].listener === t8) {
            s6 = n8[o8].listener, i7 = o8;
            break;
          }
          if (i7 < 0) return this;
          0 === i7 ? n8.shift() : !function(e10, t9) {
            for (; t9 + 1 < e10.length; t9++) e10[t9] = e10[t9 + 1];
            e10.pop();
          }(n8, i7), 1 === n8.length && (r9[e9] = n8[0]), void 0 !== r9.removeListener && this.emit("removeListener", e9, s6 || t8);
        }
        return this;
      }, o3.prototype.off = o3.prototype.removeListener, o3.prototype.removeAllListeners = function(e9) {
        var t8, n8, r9;
        if (void 0 === (n8 = this._events)) return this;
        if (void 0 === n8.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n8[e9] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n8[e9]), this;
        if (0 === arguments.length) {
          var i7, o8 = Object.keys(n8);
          for (r9 = 0; r9 < o8.length; ++r9) "removeListener" !== (i7 = o8[r9]) && this.removeAllListeners(i7);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (t8 = n8[e9])) this.removeListener(e9, t8);
        else if (void 0 !== t8) for (r9 = t8.length - 1; r9 >= 0; r9--) this.removeListener(e9, t8[r9]);
        return this;
      }, o3.prototype.listeners = function(e9) {
        return h4(this, e9, true);
      }, o3.prototype.rawListeners = function(e9) {
        return h4(this, e9, false);
      }, o3.listenerCount = function(e9, t8) {
        return "function" == typeof e9.listenerCount ? e9.listenerCount(t8) : p3.call(e9, t8);
      }, o3.prototype.listenerCount = p3, o3.prototype.eventNames = function() {
        return this._eventsCount > 0 ? t4(this._events) : [];
      };
      y3 = e4;
      y3.EventEmitter;
      y3.defaultMaxListeners;
      y3.init;
      y3.listenerCount;
      y3.EventEmitter;
      y3.defaultMaxListeners;
      y3.init;
      y3.listenerCount;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/events.js
  var events_exports = {};
  __export(events_exports, {
    EventEmitter: () => EventEmitter,
    default: () => y3,
    defaultMaxListeners: () => defaultMaxListeners,
    init: () => init,
    listenerCount: () => listenerCount,
    on: () => on2,
    once: () => once2
  });
  var EventEmitter, defaultMaxListeners, init, listenerCount, on2, once2;
  var init_events = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/events.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_4bd36a8f();
      init_chunk_4bd36a8f();
      y3.once = function(emitter, event) {
        return new Promise((resolve9, reject) => {
          function eventListener(...args) {
            if (errorListener !== void 0) {
              emitter.removeListener("error", errorListener);
            }
            resolve9(args);
          }
          let errorListener;
          if (event !== "error") {
            errorListener = (err) => {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          emitter.once(event, eventListener);
        });
      };
      y3.on = function(emitter, event) {
        const unconsumedEventValues = [];
        const unconsumedPromises = [];
        let error = null;
        let finished2 = false;
        const iterator = {
          async next() {
            const value = unconsumedEventValues.shift();
            if (value) {
              return createIterResult(value, false);
            }
            if (error) {
              const p7 = Promise.reject(error);
              error = null;
              return p7;
            }
            if (finished2) {
              return createIterResult(void 0, true);
            }
            return new Promise((resolve9, reject) => unconsumedPromises.push({ resolve: resolve9, reject }));
          },
          async return() {
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
            finished2 = true;
            for (const promise of unconsumedPromises) {
              promise.resolve(createIterResult(void 0, true));
            }
            return createIterResult(void 0, true);
          },
          throw(err) {
            error = err;
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
        emitter.on(event, eventHandler);
        emitter.on("error", errorHandler);
        return iterator;
        function eventHandler(...args) {
          const promise = unconsumedPromises.shift();
          if (promise) {
            promise.resolve(createIterResult(args, false));
          } else {
            unconsumedEventValues.push(args);
          }
        }
        function errorHandler(err) {
          finished2 = true;
          const toError = unconsumedPromises.shift();
          if (toError) {
            toError.reject(err);
          } else {
            error = err;
          }
          iterator.return();
        }
      };
      ({
        EventEmitter,
        defaultMaxListeners,
        init,
        listenerCount,
        on: on2,
        once: once2
      } = y3);
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node.js
  var require_node = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.File = exports9.Link = exports9.Node = exports9.SEP = void 0;
      var process_1 = require_process();
      var buffer_1 = require_buffer();
      var constants_1 = require_constants();
      var events_1 = (init_events(), __toCommonJS(events_exports));
      var Stats_1 = require_Stats();
      var { S_IFMT, S_IFDIR, S_IFREG, S_IFLNK, O_APPEND } = constants_1.constants;
      var getuid = () => {
        var _a, _b;
        return (_b = (_a = process_1.default.getuid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0;
      };
      var getgid = () => {
        var _a, _b;
        return (_b = (_a = process_1.default.getgid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0;
      };
      exports9.SEP = "/";
      var Node4 = class extends events_1.EventEmitter {
        constructor(ino, perm = 438) {
          super();
          this._uid = getuid();
          this._gid = getgid();
          this._atime = /* @__PURE__ */ new Date();
          this._mtime = /* @__PURE__ */ new Date();
          this._ctime = /* @__PURE__ */ new Date();
          this._perm = 438;
          this.mode = S_IFREG;
          this._nlink = 1;
          this._perm = perm;
          this.mode |= perm;
          this.ino = ino;
        }
        set ctime(ctime) {
          this._ctime = ctime;
        }
        get ctime() {
          return this._ctime;
        }
        set uid(uid) {
          this._uid = uid;
          this.ctime = /* @__PURE__ */ new Date();
        }
        get uid() {
          return this._uid;
        }
        set gid(gid) {
          this._gid = gid;
          this.ctime = /* @__PURE__ */ new Date();
        }
        get gid() {
          return this._gid;
        }
        set atime(atime) {
          this._atime = atime;
          this.ctime = /* @__PURE__ */ new Date();
        }
        get atime() {
          return this._atime;
        }
        set mtime(mtime) {
          this._mtime = mtime;
          this.ctime = /* @__PURE__ */ new Date();
        }
        get mtime() {
          return this._mtime;
        }
        set perm(perm) {
          this._perm = perm;
          this.ctime = /* @__PURE__ */ new Date();
        }
        get perm() {
          return this._perm;
        }
        set nlink(nlink) {
          this._nlink = nlink;
          this.ctime = /* @__PURE__ */ new Date();
        }
        get nlink() {
          return this._nlink;
        }
        getString(encoding = "utf8") {
          this.atime = /* @__PURE__ */ new Date();
          return this.getBuffer().toString(encoding);
        }
        setString(str) {
          this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
          this.touch();
        }
        getBuffer() {
          this.atime = /* @__PURE__ */ new Date();
          if (!this.buf)
            this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
          return (0, buffer_1.bufferFrom)(this.buf);
        }
        setBuffer(buf3) {
          this.buf = (0, buffer_1.bufferFrom)(buf3);
          this.touch();
        }
        getSize() {
          return this.buf ? this.buf.length : 0;
        }
        setModeProperty(property) {
          this.mode = this.mode & ~S_IFMT | property;
        }
        setIsFile() {
          this.setModeProperty(S_IFREG);
        }
        setIsDirectory() {
          this.setModeProperty(S_IFDIR);
        }
        setIsSymlink() {
          this.setModeProperty(S_IFLNK);
        }
        isFile() {
          return (this.mode & S_IFMT) === S_IFREG;
        }
        isDirectory() {
          return (this.mode & S_IFMT) === S_IFDIR;
        }
        isSymlink() {
          return (this.mode & S_IFMT) === S_IFLNK;
        }
        makeSymlink(steps) {
          this.symlink = steps;
          this.setIsSymlink();
        }
        write(buf3, off2 = 0, len = buf3.length, pos = 0) {
          if (!this.buf)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          if (pos + len > this.buf.length) {
            const newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
            this.buf.copy(newBuf, 0, 0, this.buf.length);
            this.buf = newBuf;
          }
          buf3.copy(this.buf, pos, off2, off2 + len);
          this.touch();
          return len;
        }
        // Returns the number of bytes read.
        read(buf3, off2 = 0, len = buf3.byteLength, pos = 0) {
          this.atime = /* @__PURE__ */ new Date();
          if (!this.buf)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          let actualLen = len;
          if (actualLen > buf3.byteLength) {
            actualLen = buf3.byteLength;
          }
          if (actualLen + pos > this.buf.length) {
            actualLen = this.buf.length - pos;
          }
          const buf22 = buf3 instanceof buffer_1.Buffer ? buf3 : buffer_1.Buffer.from(buf3.buffer);
          this.buf.copy(buf22, off2, pos, pos + actualLen);
          return actualLen;
        }
        truncate(len = 0) {
          if (!len)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          else {
            if (!this.buf)
              this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
            if (len <= this.buf.length) {
              this.buf = this.buf.slice(0, len);
            } else {
              const buf3 = (0, buffer_1.bufferAllocUnsafe)(len);
              this.buf.copy(buf3);
              buf3.fill(0, this.buf.length);
              this.buf = buf3;
            }
          }
          this.touch();
        }
        chmod(perm) {
          this.perm = perm;
          this.mode = this.mode & ~511 | perm;
          this.touch();
        }
        chown(uid, gid) {
          this.uid = uid;
          this.gid = gid;
          this.touch();
        }
        touch() {
          this.mtime = /* @__PURE__ */ new Date();
          this.emit("change", this);
        }
        canRead(uid = getuid(), gid = getgid()) {
          if (this.perm & 4) {
            return true;
          }
          if (gid === this.gid) {
            if (this.perm & 32) {
              return true;
            }
          }
          if (uid === this.uid) {
            if (this.perm & 256) {
              return true;
            }
          }
          return false;
        }
        canWrite(uid = getuid(), gid = getgid()) {
          if (this.perm & 2) {
            return true;
          }
          if (gid === this.gid) {
            if (this.perm & 16) {
              return true;
            }
          }
          if (uid === this.uid) {
            if (this.perm & 128) {
              return true;
            }
          }
          return false;
        }
        canExecute(uid = getuid(), gid = getgid()) {
          if (this.perm & 1) {
            return true;
          }
          if (gid === this.gid) {
            if (this.perm & 8) {
              return true;
            }
          }
          if (uid === this.uid) {
            if (this.perm & 64) {
              return true;
            }
          }
          return false;
        }
        del() {
          this.emit("delete", this);
        }
        toJSON() {
          return {
            ino: this.ino,
            uid: this.uid,
            gid: this.gid,
            atime: this.atime.getTime(),
            mtime: this.mtime.getTime(),
            ctime: this.ctime.getTime(),
            perm: this.perm,
            mode: this.mode,
            nlink: this.nlink,
            symlink: this.symlink,
            data: this.getString()
          };
        }
      };
      exports9.Node = Node4;
      var Link = class _Link extends events_1.EventEmitter {
        get steps() {
          return this._steps;
        }
        // Recursively sync children steps, e.g. in case of dir rename
        set steps(val) {
          this._steps = val;
          for (const [child, link4] of this.children.entries()) {
            if (child === "." || child === "..") {
              continue;
            }
            link4 === null || link4 === void 0 ? void 0 : link4.syncSteps();
          }
        }
        constructor(vol2, parent, name8) {
          super();
          this.children = /* @__PURE__ */ new Map();
          this._steps = [];
          this.ino = 0;
          this.length = 0;
          this.vol = vol2;
          this.parent = parent;
          this.name = name8;
          this.syncSteps();
        }
        setNode(node) {
          this.node = node;
          this.ino = node.ino;
        }
        getNode() {
          return this.node;
        }
        createChild(name8, node = this.vol.createNode()) {
          const link4 = new _Link(this.vol, this, name8);
          link4.setNode(node);
          if (node.isDirectory()) {
            link4.children.set(".", link4);
            link4.getNode().nlink++;
          }
          this.setChild(name8, link4);
          return link4;
        }
        setChild(name8, link4 = new _Link(this.vol, this, name8)) {
          this.children.set(name8, link4);
          link4.parent = this;
          this.length++;
          const node = link4.getNode();
          if (node.isDirectory()) {
            link4.children.set("..", this);
            this.getNode().nlink++;
          }
          this.getNode().mtime = /* @__PURE__ */ new Date();
          this.emit("child:add", link4, this);
          return link4;
        }
        deleteChild(link4) {
          const node = link4.getNode();
          if (node.isDirectory()) {
            link4.children.delete("..");
            this.getNode().nlink--;
          }
          this.children.delete(link4.getName());
          this.length--;
          this.getNode().mtime = /* @__PURE__ */ new Date();
          this.emit("child:delete", link4, this);
        }
        getChild(name8) {
          this.getNode().mtime = /* @__PURE__ */ new Date();
          return this.children.get(name8);
        }
        getPath() {
          return this.steps.join(exports9.SEP);
        }
        getParentPath() {
          return this.steps.slice(0, -1).join(exports9.SEP);
        }
        getName() {
          return this.steps[this.steps.length - 1];
        }
        // del() {
        //     const parent = this.parent;
        //     if(parent) {
        //         parent.deleteChild(link);
        //     }
        //     this.parent = null;
        //     this.vol = null;
        // }
        toJSON() {
          return {
            steps: this.steps,
            ino: this.ino,
            children: Array.from(this.children.keys())
          };
        }
        syncSteps() {
          this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];
        }
      };
      exports9.Link = Link;
      var File2 = class {
        /**
         * Open a Link-Node pair. `node` is provided separately as that might be a different node
         * rather the one `link` points to, because it might be a symlink.
         * @param link
         * @param node
         * @param flags
         * @param fd
         */
        constructor(link4, node, flags, fd) {
          this.link = link4;
          this.node = node;
          this.flags = flags;
          this.fd = fd;
          this.position = 0;
          if (this.flags & O_APPEND)
            this.position = this.getSize();
        }
        getString(encoding = "utf8") {
          return this.node.getString();
        }
        setString(str) {
          this.node.setString(str);
        }
        getBuffer() {
          return this.node.getBuffer();
        }
        setBuffer(buf3) {
          this.node.setBuffer(buf3);
        }
        getSize() {
          return this.node.getSize();
        }
        truncate(len) {
          this.node.truncate(len);
        }
        seekTo(position) {
          this.position = position;
        }
        stats() {
          return Stats_1.default.build(this.node);
        }
        write(buf3, offset = 0, length4 = buf3.length, position) {
          if (typeof position !== "number")
            position = this.position;
          const bytes = this.node.write(buf3, offset, length4, position);
          this.position = position + bytes;
          return bytes;
        }
        read(buf3, offset = 0, length4 = buf3.byteLength, position) {
          if (typeof position !== "number")
            position = this.position;
          const bytes = this.node.read(buf3, offset, length4, position);
          this.position = position + bytes;
          return bytes;
        }
        chmod(perm) {
          this.node.chmod(perm);
        }
        chown(uid, gid) {
          this.node.chown(uid, gid);
        }
      };
      exports9.File = File2;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/setImmediate.js
  var require_setImmediate = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/setImmediate.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var _setImmediate;
      if (typeof setImmediate === "function")
        _setImmediate = setImmediate.bind(typeof globalThis !== "undefined" ? globalThis : global);
      else
        _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : global);
      exports9.default = _setImmediate;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/queueMicrotask.js
  var require_queueMicrotask = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/queueMicrotask.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.default = typeof queueMicrotask === "function" ? queueMicrotask : (cb) => Promise.resolve().then(() => cb()).catch(() => {
      });
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/setTimeoutUnref.js
  var require_setTimeoutUnref = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/setTimeoutUnref.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      function setTimeoutUnref(callback, time2, args) {
        const ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : global, arguments);
        if (ref && typeof ref === "object" && typeof ref.unref === "function")
          ref.unref();
        return ref;
      }
      exports9.default = setTimeoutUnref;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js
  function u$22(r9) {
    var t8 = r9.length;
    if (t8 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var e9 = r9.indexOf("=");
    return -1 === e9 && (e9 = t8), [e9, e9 === t8 ? 0 : 4 - e9 % 4];
  }
  function c$13(r9, e9, n8) {
    for (var o8, a7, h8 = [], u7 = e9; u7 < n8; u7 += 3) o8 = (r9[u7] << 16 & 16711680) + (r9[u7 + 1] << 8 & 65280) + (255 & r9[u7 + 2]), h8.push(t$13[(a7 = o8) >> 18 & 63] + t$13[a7 >> 12 & 63] + t$13[a7 >> 6 & 63] + t$13[63 & a7]);
    return h8.join("");
  }
  function f$22(t8) {
    if (t8 > 2147483647) throw new RangeError('The value "' + t8 + '" is invalid for option "size"');
    var r9 = new Uint8Array(t8);
    return Object.setPrototypeOf(r9, u$1$1.prototype), r9;
  }
  function u$1$1(t8, r9, e9) {
    if ("number" == typeof t8) {
      if ("string" == typeof r9) throw new TypeError('The "string" argument must be of type string. Received type number');
      return a$22(t8);
    }
    return s$12(t8, r9, e9);
  }
  function s$12(t8, r9, e9) {
    if ("string" == typeof t8) return function(t9, r10) {
      "string" == typeof r10 && "" !== r10 || (r10 = "utf8");
      if (!u$1$1.isEncoding(r10)) throw new TypeError("Unknown encoding: " + r10);
      var e10 = 0 | y4(t9, r10), n9 = f$22(e10), i8 = n9.write(t9, r10);
      i8 !== e10 && (n9 = n9.slice(0, i8));
      return n9;
    }(t8, r9);
    if (ArrayBuffer.isView(t8)) return p4(t8);
    if (null == t8) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t8);
    if (F3(t8, ArrayBuffer) || t8 && F3(t8.buffer, ArrayBuffer)) return c$1$1(t8, r9, e9);
    if ("undefined" != typeof SharedArrayBuffer && (F3(t8, SharedArrayBuffer) || t8 && F3(t8.buffer, SharedArrayBuffer))) return c$1$1(t8, r9, e9);
    if ("number" == typeof t8) throw new TypeError('The "value" argument must not be of type number. Received type number');
    var n8 = t8.valueOf && t8.valueOf();
    if (null != n8 && n8 !== t8) return u$1$1.from(n8, r9, e9);
    var i7 = function(t9) {
      if (u$1$1.isBuffer(t9)) {
        var r10 = 0 | l$13(t9.length), e10 = f$22(r10);
        return 0 === e10.length || t9.copy(e10, 0, 0, r10), e10;
      }
      if (void 0 !== t9.length) return "number" != typeof t9.length || N3(t9.length) ? f$22(0) : p4(t9);
      if ("Buffer" === t9.type && Array.isArray(t9.data)) return p4(t9.data);
    }(t8);
    if (i7) return i7;
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t8[Symbol.toPrimitive]) return u$1$1.from(t8[Symbol.toPrimitive]("string"), r9, e9);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t8);
  }
  function h$1$1(t8) {
    if ("number" != typeof t8) throw new TypeError('"size" argument must be of type number');
    if (t8 < 0) throw new RangeError('The value "' + t8 + '" is invalid for option "size"');
  }
  function a$22(t8) {
    return h$1$1(t8), f$22(t8 < 0 ? 0 : 0 | l$13(t8));
  }
  function p4(t8) {
    for (var r9 = t8.length < 0 ? 0 : 0 | l$13(t8.length), e9 = f$22(r9), n8 = 0; n8 < r9; n8 += 1) e9[n8] = 255 & t8[n8];
    return e9;
  }
  function c$1$1(t8, r9, e9) {
    if (r9 < 0 || t8.byteLength < r9) throw new RangeError('"offset" is outside of buffer bounds');
    if (t8.byteLength < r9 + (e9 || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var n8;
    return n8 = void 0 === r9 && void 0 === e9 ? new Uint8Array(t8) : void 0 === e9 ? new Uint8Array(t8, r9) : new Uint8Array(t8, r9, e9), Object.setPrototypeOf(n8, u$1$1.prototype), n8;
  }
  function l$13(t8) {
    if (t8 >= 2147483647) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
    return 0 | t8;
  }
  function y4(t8, r9) {
    if (u$1$1.isBuffer(t8)) return t8.length;
    if (ArrayBuffer.isView(t8) || F3(t8, ArrayBuffer)) return t8.byteLength;
    if ("string" != typeof t8) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t8);
    var e9 = t8.length, n8 = arguments.length > 2 && true === arguments[2];
    if (!n8 && 0 === e9) return 0;
    for (var i7 = false; ; ) switch (r9) {
      case "ascii":
      case "latin1":
      case "binary":
        return e9;
      case "utf8":
      case "utf-8":
        return _3(t8).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * e9;
      case "hex":
        return e9 >>> 1;
      case "base64":
        return z3(t8).length;
      default:
        if (i7) return n8 ? -1 : _3(t8).length;
        r9 = ("" + r9).toLowerCase(), i7 = true;
    }
  }
  function g3(t8, r9, e9) {
    var n8 = false;
    if ((void 0 === r9 || r9 < 0) && (r9 = 0), r9 > this.length) return "";
    if ((void 0 === e9 || e9 > this.length) && (e9 = this.length), e9 <= 0) return "";
    if ((e9 >>>= 0) <= (r9 >>>= 0)) return "";
    for (t8 || (t8 = "utf8"); ; ) switch (t8) {
      case "hex":
        return O3(this, r9, e9);
      case "utf8":
      case "utf-8":
        return I3(this, r9, e9);
      case "ascii":
        return S3(this, r9, e9);
      case "latin1":
      case "binary":
        return R3(this, r9, e9);
      case "base64":
        return T4(this, r9, e9);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return L3(this, r9, e9);
      default:
        if (n8) throw new TypeError("Unknown encoding: " + t8);
        t8 = (t8 + "").toLowerCase(), n8 = true;
    }
  }
  function w3(t8, r9, e9) {
    var n8 = t8[r9];
    t8[r9] = t8[e9], t8[e9] = n8;
  }
  function d4(t8, r9, e9, n8, i7) {
    if (0 === t8.length) return -1;
    if ("string" == typeof e9 ? (n8 = e9, e9 = 0) : e9 > 2147483647 ? e9 = 2147483647 : e9 < -2147483648 && (e9 = -2147483648), N3(e9 = +e9) && (e9 = i7 ? 0 : t8.length - 1), e9 < 0 && (e9 = t8.length + e9), e9 >= t8.length) {
      if (i7) return -1;
      e9 = t8.length - 1;
    } else if (e9 < 0) {
      if (!i7) return -1;
      e9 = 0;
    }
    if ("string" == typeof r9 && (r9 = u$1$1.from(r9, n8)), u$1$1.isBuffer(r9)) return 0 === r9.length ? -1 : v4(t8, r9, e9, n8, i7);
    if ("number" == typeof r9) return r9 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i7 ? Uint8Array.prototype.indexOf.call(t8, r9, e9) : Uint8Array.prototype.lastIndexOf.call(t8, r9, e9) : v4(t8, [r9], e9, n8, i7);
    throw new TypeError("val must be string, number or Buffer");
  }
  function v4(t8, r9, e9, n8, i7) {
    var o8, f7 = 1, u7 = t8.length, s6 = r9.length;
    if (void 0 !== n8 && ("ucs2" === (n8 = String(n8).toLowerCase()) || "ucs-2" === n8 || "utf16le" === n8 || "utf-16le" === n8)) {
      if (t8.length < 2 || r9.length < 2) return -1;
      f7 = 2, u7 /= 2, s6 /= 2, e9 /= 2;
    }
    function h8(t9, r10) {
      return 1 === f7 ? t9[r10] : t9.readUInt16BE(r10 * f7);
    }
    if (i7) {
      var a7 = -1;
      for (o8 = e9; o8 < u7; o8++) if (h8(t8, o8) === h8(r9, -1 === a7 ? 0 : o8 - a7)) {
        if (-1 === a7 && (a7 = o8), o8 - a7 + 1 === s6) return a7 * f7;
      } else -1 !== a7 && (o8 -= o8 - a7), a7 = -1;
    } else for (e9 + s6 > u7 && (e9 = u7 - s6), o8 = e9; o8 >= 0; o8--) {
      for (var p7 = true, c7 = 0; c7 < s6; c7++) if (h8(t8, o8 + c7) !== h8(r9, c7)) {
        p7 = false;
        break;
      }
      if (p7) return o8;
    }
    return -1;
  }
  function b3(t8, r9, e9, n8) {
    e9 = Number(e9) || 0;
    var i7 = t8.length - e9;
    n8 ? (n8 = Number(n8)) > i7 && (n8 = i7) : n8 = i7;
    var o8 = r9.length;
    n8 > o8 / 2 && (n8 = o8 / 2);
    for (var f7 = 0; f7 < n8; ++f7) {
      var u7 = parseInt(r9.substr(2 * f7, 2), 16);
      if (N3(u7)) return f7;
      t8[e9 + f7] = u7;
    }
    return f7;
  }
  function m4(t8, r9, e9, n8) {
    return D3(_3(r9, t8.length - e9), t8, e9, n8);
  }
  function E3(t8, r9, e9, n8) {
    return D3(function(t9) {
      for (var r10 = [], e10 = 0; e10 < t9.length; ++e10) r10.push(255 & t9.charCodeAt(e10));
      return r10;
    }(r9), t8, e9, n8);
  }
  function B3(t8, r9, e9, n8) {
    return E3(t8, r9, e9, n8);
  }
  function A3(t8, r9, e9, n8) {
    return D3(z3(r9), t8, e9, n8);
  }
  function U3(t8, r9, e9, n8) {
    return D3(function(t9, r10) {
      for (var e10, n9, i7, o8 = [], f7 = 0; f7 < t9.length && !((r10 -= 2) < 0); ++f7) e10 = t9.charCodeAt(f7), n9 = e10 >> 8, i7 = e10 % 256, o8.push(i7), o8.push(n9);
      return o8;
    }(r9, t8.length - e9), t8, e9, n8);
  }
  function T4(t8, r9, e9) {
    return 0 === r9 && e9 === t8.length ? n$1$1.fromByteArray(t8) : n$1$1.fromByteArray(t8.slice(r9, e9));
  }
  function I3(t8, r9, e9) {
    e9 = Math.min(t8.length, e9);
    for (var n8 = [], i7 = r9; i7 < e9; ) {
      var o8, f7, u7, s6, h8 = t8[i7], a7 = null, p7 = h8 > 239 ? 4 : h8 > 223 ? 3 : h8 > 191 ? 2 : 1;
      if (i7 + p7 <= e9) switch (p7) {
        case 1:
          h8 < 128 && (a7 = h8);
          break;
        case 2:
          128 == (192 & (o8 = t8[i7 + 1])) && (s6 = (31 & h8) << 6 | 63 & o8) > 127 && (a7 = s6);
          break;
        case 3:
          o8 = t8[i7 + 1], f7 = t8[i7 + 2], 128 == (192 & o8) && 128 == (192 & f7) && (s6 = (15 & h8) << 12 | (63 & o8) << 6 | 63 & f7) > 2047 && (s6 < 55296 || s6 > 57343) && (a7 = s6);
          break;
        case 4:
          o8 = t8[i7 + 1], f7 = t8[i7 + 2], u7 = t8[i7 + 3], 128 == (192 & o8) && 128 == (192 & f7) && 128 == (192 & u7) && (s6 = (15 & h8) << 18 | (63 & o8) << 12 | (63 & f7) << 6 | 63 & u7) > 65535 && s6 < 1114112 && (a7 = s6);
      }
      null === a7 ? (a7 = 65533, p7 = 1) : a7 > 65535 && (a7 -= 65536, n8.push(a7 >>> 10 & 1023 | 55296), a7 = 56320 | 1023 & a7), n8.push(a7), i7 += p7;
    }
    return function(t9) {
      var r10 = t9.length;
      if (r10 <= 4096) return String.fromCharCode.apply(String, t9);
      var e10 = "", n9 = 0;
      for (; n9 < r10; ) e10 += String.fromCharCode.apply(String, t9.slice(n9, n9 += 4096));
      return e10;
    }(n8);
  }
  function S3(t8, r9, e9) {
    var n8 = "";
    e9 = Math.min(t8.length, e9);
    for (var i7 = r9; i7 < e9; ++i7) n8 += String.fromCharCode(127 & t8[i7]);
    return n8;
  }
  function R3(t8, r9, e9) {
    var n8 = "";
    e9 = Math.min(t8.length, e9);
    for (var i7 = r9; i7 < e9; ++i7) n8 += String.fromCharCode(t8[i7]);
    return n8;
  }
  function O3(t8, r9, e9) {
    var n8 = t8.length;
    (!r9 || r9 < 0) && (r9 = 0), (!e9 || e9 < 0 || e9 > n8) && (e9 = n8);
    for (var i7 = "", o8 = r9; o8 < e9; ++o8) i7 += Y3[t8[o8]];
    return i7;
  }
  function L3(t8, r9, e9) {
    for (var n8 = t8.slice(r9, e9), i7 = "", o8 = 0; o8 < n8.length; o8 += 2) i7 += String.fromCharCode(n8[o8] + 256 * n8[o8 + 1]);
    return i7;
  }
  function x3(t8, r9, e9) {
    if (t8 % 1 != 0 || t8 < 0) throw new RangeError("offset is not uint");
    if (t8 + r9 > e9) throw new RangeError("Trying to access beyond buffer length");
  }
  function C3(t8, r9, e9, n8, i7, o8) {
    if (!u$1$1.isBuffer(t8)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r9 > i7 || r9 < o8) throw new RangeError('"value" argument is out of bounds');
    if (e9 + n8 > t8.length) throw new RangeError("Index out of range");
  }
  function P3(t8, r9, e9, n8, i7, o8) {
    if (e9 + n8 > t8.length) throw new RangeError("Index out of range");
    if (e9 < 0) throw new RangeError("Index out of range");
  }
  function k3(t8, r9, e9, n8, o8) {
    return r9 = +r9, e9 >>>= 0, o8 || P3(t8, 0, e9, 4), i$13.write(t8, r9, e9, n8, 23, 4), e9 + 4;
  }
  function M3(t8, r9, e9, n8, o8) {
    return r9 = +r9, e9 >>>= 0, o8 || P3(t8, 0, e9, 8), i$13.write(t8, r9, e9, n8, 52, 8), e9 + 8;
  }
  function _3(t8, r9) {
    var e9;
    r9 = r9 || 1 / 0;
    for (var n8 = t8.length, i7 = null, o8 = [], f7 = 0; f7 < n8; ++f7) {
      if ((e9 = t8.charCodeAt(f7)) > 55295 && e9 < 57344) {
        if (!i7) {
          if (e9 > 56319) {
            (r9 -= 3) > -1 && o8.push(239, 191, 189);
            continue;
          }
          if (f7 + 1 === n8) {
            (r9 -= 3) > -1 && o8.push(239, 191, 189);
            continue;
          }
          i7 = e9;
          continue;
        }
        if (e9 < 56320) {
          (r9 -= 3) > -1 && o8.push(239, 191, 189), i7 = e9;
          continue;
        }
        e9 = 65536 + (i7 - 55296 << 10 | e9 - 56320);
      } else i7 && (r9 -= 3) > -1 && o8.push(239, 191, 189);
      if (i7 = null, e9 < 128) {
        if ((r9 -= 1) < 0) break;
        o8.push(e9);
      } else if (e9 < 2048) {
        if ((r9 -= 2) < 0) break;
        o8.push(e9 >> 6 | 192, 63 & e9 | 128);
      } else if (e9 < 65536) {
        if ((r9 -= 3) < 0) break;
        o8.push(e9 >> 12 | 224, e9 >> 6 & 63 | 128, 63 & e9 | 128);
      } else {
        if (!(e9 < 1114112)) throw new Error("Invalid code point");
        if ((r9 -= 4) < 0) break;
        o8.push(e9 >> 18 | 240, e9 >> 12 & 63 | 128, e9 >> 6 & 63 | 128, 63 & e9 | 128);
      }
    }
    return o8;
  }
  function z3(t8) {
    return n$1$1.toByteArray(function(t9) {
      if ((t9 = (t9 = t9.split("=")[0]).trim().replace(j3, "")).length < 2) return "";
      for (; t9.length % 4 != 0; ) t9 += "=";
      return t9;
    }(t8));
  }
  function D3(t8, r9, e9, n8) {
    for (var i7 = 0; i7 < n8 && !(i7 + e9 >= r9.length || i7 >= t8.length); ++i7) r9[i7 + e9] = t8[i7];
    return i7;
  }
  function F3(t8, r9) {
    return t8 instanceof r9 || null != t8 && null != t8.constructor && null != t8.constructor.name && t8.constructor.name === r9.name;
  }
  function N3(t8) {
    return t8 != t8;
  }
  function t5(r9, e9) {
    for (var n8 in r9) e9[n8] = r9[n8];
  }
  function f4(r9, e9, n8) {
    return o4(r9, e9, n8);
  }
  function a4(t8) {
    var e9;
    switch (this.encoding = function(t9) {
      var e10 = function(t10) {
        if (!t10) return "utf8";
        for (var e11; ; ) switch (t10) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t10;
          default:
            if (e11) return;
            t10 = ("" + t10).toLowerCase(), e11 = true;
        }
      }(t9);
      if ("string" != typeof e10 && (s4.isEncoding === i4 || !i4(t9))) throw new Error("Unknown encoding: " + t9);
      return e10 || t9;
    }(t8), this.encoding) {
      case "utf16le":
        this.text = h5, this.end = l4, e9 = 4;
        break;
      case "utf8":
        this.fillLast = n$13, e9 = 4;
        break;
      case "base64":
        this.text = u$13, this.end = o$13, e9 = 3;
        break;
      default:
        return this.write = f$12, this.end = c4, void 0;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s4.allocUnsafe(e9);
  }
  function r5(t8) {
    return t8 <= 127 ? 0 : t8 >> 5 == 6 ? 2 : t8 >> 4 == 14 ? 3 : t8 >> 3 == 30 ? 4 : t8 >> 6 == 2 ? -1 : -2;
  }
  function n$13(t8) {
    var e9 = this.lastTotal - this.lastNeed, s6 = function(t9, e10, s7) {
      if (128 != (192 & e10[0])) return t9.lastNeed = 0, "\uFFFD";
      if (t9.lastNeed > 1 && e10.length > 1) {
        if (128 != (192 & e10[1])) return t9.lastNeed = 1, "\uFFFD";
        if (t9.lastNeed > 2 && e10.length > 2 && 128 != (192 & e10[2])) return t9.lastNeed = 2, "\uFFFD";
      }
    }(this, t8);
    return void 0 !== s6 ? s6 : this.lastNeed <= t8.length ? (t8.copy(this.lastChar, e9, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t8.copy(this.lastChar, e9, 0, t8.length), this.lastNeed -= t8.length, void 0);
  }
  function h5(t8, e9) {
    if ((t8.length - e9) % 2 == 0) {
      var s6 = t8.toString("utf16le", e9);
      if (s6) {
        var i7 = s6.charCodeAt(s6.length - 1);
        if (i7 >= 55296 && i7 <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t8[t8.length - 2], this.lastChar[1] = t8[t8.length - 1], s6.slice(0, -1);
      }
      return s6;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t8[t8.length - 1], t8.toString("utf16le", e9, t8.length - 1);
  }
  function l4(t8) {
    var e9 = t8 && t8.length ? this.write(t8) : "";
    if (this.lastNeed) {
      var s6 = this.lastTotal - this.lastNeed;
      return e9 + this.lastChar.toString("utf16le", 0, s6);
    }
    return e9;
  }
  function u$13(t8, e9) {
    var s6 = (t8.length - e9) % 3;
    return 0 === s6 ? t8.toString("base64", e9) : (this.lastNeed = 3 - s6, this.lastTotal = 3, 1 === s6 ? this.lastChar[0] = t8[t8.length - 1] : (this.lastChar[0] = t8[t8.length - 2], this.lastChar[1] = t8[t8.length - 1]), t8.toString("base64", e9, t8.length - s6));
  }
  function o$13(t8) {
    var e9 = t8 && t8.length ? this.write(t8) : "";
    return this.lastNeed ? e9 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e9;
  }
  function f$12(t8) {
    return t8.toString(this.encoding);
  }
  function c4(t8) {
    return t8 && t8.length ? this.write(t8) : "";
  }
  var r$13, t$13, e$22, n$22, o$23, a$12, h$12, a$1$1, e$1$1, n$1$1, i$13, o$1$1, j3, Y3, e5, n4, o4, u4, e$13, s4, i4;
  var init_chunk_4ccc3a29 = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      for (r$13 = { byteLength: function(r9) {
        var t8 = u$22(r9), e9 = t8[0], n8 = t8[1];
        return 3 * (e9 + n8) / 4 - n8;
      }, toByteArray: function(r9) {
        var t8, o8, a7 = u$22(r9), h8 = a7[0], c7 = a7[1], d6 = new n$22(function(r10, t9, e9) {
          return 3 * (t9 + e9) / 4 - e9;
        }(0, h8, c7)), f7 = 0, A4 = c7 > 0 ? h8 - 4 : h8;
        for (o8 = 0; o8 < A4; o8 += 4) t8 = e$22[r9.charCodeAt(o8)] << 18 | e$22[r9.charCodeAt(o8 + 1)] << 12 | e$22[r9.charCodeAt(o8 + 2)] << 6 | e$22[r9.charCodeAt(o8 + 3)], d6[f7++] = t8 >> 16 & 255, d6[f7++] = t8 >> 8 & 255, d6[f7++] = 255 & t8;
        2 === c7 && (t8 = e$22[r9.charCodeAt(o8)] << 2 | e$22[r9.charCodeAt(o8 + 1)] >> 4, d6[f7++] = 255 & t8);
        1 === c7 && (t8 = e$22[r9.charCodeAt(o8)] << 10 | e$22[r9.charCodeAt(o8 + 1)] << 4 | e$22[r9.charCodeAt(o8 + 2)] >> 2, d6[f7++] = t8 >> 8 & 255, d6[f7++] = 255 & t8);
        return d6;
      }, fromByteArray: function(r9) {
        for (var e9, n8 = r9.length, o8 = n8 % 3, a7 = [], h8 = 0, u7 = n8 - o8; h8 < u7; h8 += 16383) a7.push(c$13(r9, h8, h8 + 16383 > u7 ? u7 : h8 + 16383));
        1 === o8 ? (e9 = r9[n8 - 1], a7.push(t$13[e9 >> 2] + t$13[e9 << 4 & 63] + "==")) : 2 === o8 && (e9 = (r9[n8 - 2] << 8) + r9[n8 - 1], a7.push(t$13[e9 >> 10] + t$13[e9 >> 4 & 63] + t$13[e9 << 2 & 63] + "="));
        return a7.join("");
      } }, t$13 = [], e$22 = [], n$22 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$23 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$12 = 0, h$12 = o$23.length; a$12 < h$12; ++a$12) t$13[a$12] = o$23[a$12], e$22[o$23.charCodeAt(a$12)] = a$12;
      e$22["-".charCodeAt(0)] = 62, e$22["_".charCodeAt(0)] = 63;
      a$1$1 = { read: function(a7, t8, o8, r9, h8) {
        var M4, f7, p7 = 8 * h8 - r9 - 1, w4 = (1 << p7) - 1, e9 = w4 >> 1, i7 = -7, N10 = o8 ? h8 - 1 : 0, n8 = o8 ? -1 : 1, u7 = a7[t8 + N10];
        for (N10 += n8, M4 = u7 & (1 << -i7) - 1, u7 >>= -i7, i7 += p7; i7 > 0; M4 = 256 * M4 + a7[t8 + N10], N10 += n8, i7 -= 8) ;
        for (f7 = M4 & (1 << -i7) - 1, M4 >>= -i7, i7 += r9; i7 > 0; f7 = 256 * f7 + a7[t8 + N10], N10 += n8, i7 -= 8) ;
        if (0 === M4) M4 = 1 - e9;
        else {
          if (M4 === w4) return f7 ? NaN : 1 / 0 * (u7 ? -1 : 1);
          f7 += Math.pow(2, r9), M4 -= e9;
        }
        return (u7 ? -1 : 1) * f7 * Math.pow(2, M4 - r9);
      }, write: function(a7, t8, o8, r9, h8, M4) {
        var f7, p7, w4, e9 = 8 * M4 - h8 - 1, i7 = (1 << e9) - 1, N10 = i7 >> 1, n8 = 23 === h8 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u7 = r9 ? 0 : M4 - 1, l7 = r9 ? 1 : -1, s6 = t8 < 0 || 0 === t8 && 1 / t8 < 0 ? 1 : 0;
        for (t8 = Math.abs(t8), isNaN(t8) || t8 === 1 / 0 ? (p7 = isNaN(t8) ? 1 : 0, f7 = i7) : (f7 = Math.floor(Math.log(t8) / Math.LN2), t8 * (w4 = Math.pow(2, -f7)) < 1 && (f7--, w4 *= 2), (t8 += f7 + N10 >= 1 ? n8 / w4 : n8 * Math.pow(2, 1 - N10)) * w4 >= 2 && (f7++, w4 /= 2), f7 + N10 >= i7 ? (p7 = 0, f7 = i7) : f7 + N10 >= 1 ? (p7 = (t8 * w4 - 1) * Math.pow(2, h8), f7 += N10) : (p7 = t8 * Math.pow(2, N10 - 1) * Math.pow(2, h8), f7 = 0)); h8 >= 8; a7[o8 + u7] = 255 & p7, u7 += l7, p7 /= 256, h8 -= 8) ;
        for (f7 = f7 << h8 | p7, e9 += h8; e9 > 0; a7[o8 + u7] = 255 & f7, u7 += l7, f7 /= 256, e9 -= 8) ;
        a7[o8 + u7 - l7] |= 128 * s6;
      } };
      e$1$1 = {};
      n$1$1 = r$13;
      i$13 = a$1$1;
      o$1$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
      e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t8) {
        +t8 != t8 && (t8 = 0);
        return u$1$1.alloc(+t8);
      }, e$1$1.INSPECT_MAX_BYTES = 50;
      e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
        try {
          var t8 = new Uint8Array(1), r9 = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(r9, Uint8Array.prototype), Object.setPrototypeOf(t8, r9), 42 === t8.foo();
        } catch (t9) {
          return false;
        }
      }(), u$1$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: true, get: function() {
        if (u$1$1.isBuffer(this)) return this.buffer;
      } }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: true, get: function() {
        if (u$1$1.isBuffer(this)) return this.byteOffset;
      } }), u$1$1.poolSize = 8192, u$1$1.from = function(t8, r9, e9) {
        return s$12(t8, r9, e9);
      }, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t8, r9, e9) {
        return function(t9, r10, e10) {
          return h$1$1(t9), t9 <= 0 ? f$22(t9) : void 0 !== r10 ? "string" == typeof e10 ? f$22(t9).fill(r10, e10) : f$22(t9).fill(r10) : f$22(t9);
        }(t8, r9, e9);
      }, u$1$1.allocUnsafe = function(t8) {
        return a$22(t8);
      }, u$1$1.allocUnsafeSlow = function(t8) {
        return a$22(t8);
      }, u$1$1.isBuffer = function(t8) {
        return null != t8 && true === t8._isBuffer && t8 !== u$1$1.prototype;
      }, u$1$1.compare = function(t8, r9) {
        if (F3(t8, Uint8Array) && (t8 = u$1$1.from(t8, t8.offset, t8.byteLength)), F3(r9, Uint8Array) && (r9 = u$1$1.from(r9, r9.offset, r9.byteLength)), !u$1$1.isBuffer(t8) || !u$1$1.isBuffer(r9)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (t8 === r9) return 0;
        for (var e9 = t8.length, n8 = r9.length, i7 = 0, o8 = Math.min(e9, n8); i7 < o8; ++i7) if (t8[i7] !== r9[i7]) {
          e9 = t8[i7], n8 = r9[i7];
          break;
        }
        return e9 < n8 ? -1 : n8 < e9 ? 1 : 0;
      }, u$1$1.isEncoding = function(t8) {
        switch (String(t8).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, u$1$1.concat = function(t8, r9) {
        if (!Array.isArray(t8)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t8.length) return u$1$1.alloc(0);
        var e9;
        if (void 0 === r9) for (r9 = 0, e9 = 0; e9 < t8.length; ++e9) r9 += t8[e9].length;
        var n8 = u$1$1.allocUnsafe(r9), i7 = 0;
        for (e9 = 0; e9 < t8.length; ++e9) {
          var o8 = t8[e9];
          if (F3(o8, Uint8Array) && (o8 = u$1$1.from(o8)), !u$1$1.isBuffer(o8)) throw new TypeError('"list" argument must be an Array of Buffers');
          o8.copy(n8, i7), i7 += o8.length;
        }
        return n8;
      }, u$1$1.byteLength = y4, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
        var t8 = this.length;
        if (t8 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var r9 = 0; r9 < t8; r9 += 2) w3(this, r9, r9 + 1);
        return this;
      }, u$1$1.prototype.swap32 = function() {
        var t8 = this.length;
        if (t8 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var r9 = 0; r9 < t8; r9 += 4) w3(this, r9, r9 + 3), w3(this, r9 + 1, r9 + 2);
        return this;
      }, u$1$1.prototype.swap64 = function() {
        var t8 = this.length;
        if (t8 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var r9 = 0; r9 < t8; r9 += 8) w3(this, r9, r9 + 7), w3(this, r9 + 1, r9 + 6), w3(this, r9 + 2, r9 + 5), w3(this, r9 + 3, r9 + 4);
        return this;
      }, u$1$1.prototype.toString = function() {
        var t8 = this.length;
        return 0 === t8 ? "" : 0 === arguments.length ? I3(this, 0, t8) : g3.apply(this, arguments);
      }, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t8) {
        if (!u$1$1.isBuffer(t8)) throw new TypeError("Argument must be a Buffer");
        return this === t8 || 0 === u$1$1.compare(this, t8);
      }, u$1$1.prototype.inspect = function() {
        var t8 = "", r9 = e$1$1.INSPECT_MAX_BYTES;
        return t8 = this.toString("hex", 0, r9).replace(/(.{2})/g, "$1 ").trim(), this.length > r9 && (t8 += " ... "), "<Buffer " + t8 + ">";
      }, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t8, r9, e9, n8, i7) {
        if (F3(t8, Uint8Array) && (t8 = u$1$1.from(t8, t8.offset, t8.byteLength)), !u$1$1.isBuffer(t8)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t8);
        if (void 0 === r9 && (r9 = 0), void 0 === e9 && (e9 = t8 ? t8.length : 0), void 0 === n8 && (n8 = 0), void 0 === i7 && (i7 = this.length), r9 < 0 || e9 > t8.length || n8 < 0 || i7 > this.length) throw new RangeError("out of range index");
        if (n8 >= i7 && r9 >= e9) return 0;
        if (n8 >= i7) return -1;
        if (r9 >= e9) return 1;
        if (this === t8) return 0;
        for (var o8 = (i7 >>>= 0) - (n8 >>>= 0), f7 = (e9 >>>= 0) - (r9 >>>= 0), s6 = Math.min(o8, f7), h8 = this.slice(n8, i7), a7 = t8.slice(r9, e9), p7 = 0; p7 < s6; ++p7) if (h8[p7] !== a7[p7]) {
          o8 = h8[p7], f7 = a7[p7];
          break;
        }
        return o8 < f7 ? -1 : f7 < o8 ? 1 : 0;
      }, u$1$1.prototype.includes = function(t8, r9, e9) {
        return -1 !== this.indexOf(t8, r9, e9);
      }, u$1$1.prototype.indexOf = function(t8, r9, e9) {
        return d4(this, t8, r9, e9, true);
      }, u$1$1.prototype.lastIndexOf = function(t8, r9, e9) {
        return d4(this, t8, r9, e9, false);
      }, u$1$1.prototype.write = function(t8, r9, e9, n8) {
        if (void 0 === r9) n8 = "utf8", e9 = this.length, r9 = 0;
        else if (void 0 === e9 && "string" == typeof r9) n8 = r9, e9 = this.length, r9 = 0;
        else {
          if (!isFinite(r9)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          r9 >>>= 0, isFinite(e9) ? (e9 >>>= 0, void 0 === n8 && (n8 = "utf8")) : (n8 = e9, e9 = void 0);
        }
        var i7 = this.length - r9;
        if ((void 0 === e9 || e9 > i7) && (e9 = i7), t8.length > 0 && (e9 < 0 || r9 < 0) || r9 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        n8 || (n8 = "utf8");
        for (var o8 = false; ; ) switch (n8) {
          case "hex":
            return b3(this, t8, r9, e9);
          case "utf8":
          case "utf-8":
            return m4(this, t8, r9, e9);
          case "ascii":
            return E3(this, t8, r9, e9);
          case "latin1":
          case "binary":
            return B3(this, t8, r9, e9);
          case "base64":
            return A3(this, t8, r9, e9);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return U3(this, t8, r9, e9);
          default:
            if (o8) throw new TypeError("Unknown encoding: " + n8);
            n8 = ("" + n8).toLowerCase(), o8 = true;
        }
      }, u$1$1.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      u$1$1.prototype.slice = function(t8, r9) {
        var e9 = this.length;
        (t8 = ~~t8) < 0 ? (t8 += e9) < 0 && (t8 = 0) : t8 > e9 && (t8 = e9), (r9 = void 0 === r9 ? e9 : ~~r9) < 0 ? (r9 += e9) < 0 && (r9 = 0) : r9 > e9 && (r9 = e9), r9 < t8 && (r9 = t8);
        var n8 = this.subarray(t8, r9);
        return Object.setPrototypeOf(n8, u$1$1.prototype), n8;
      }, u$1$1.prototype.readUIntLE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x3(t8, r9, this.length);
        for (var n8 = this[t8], i7 = 1, o8 = 0; ++o8 < r9 && (i7 *= 256); ) n8 += this[t8 + o8] * i7;
        return n8;
      }, u$1$1.prototype.readUIntBE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x3(t8, r9, this.length);
        for (var n8 = this[t8 + --r9], i7 = 1; r9 > 0 && (i7 *= 256); ) n8 += this[t8 + --r9] * i7;
        return n8;
      }, u$1$1.prototype.readUInt8 = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 1, this.length), this[t8];
      }, u$1$1.prototype.readUInt16LE = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 2, this.length), this[t8] | this[t8 + 1] << 8;
      }, u$1$1.prototype.readUInt16BE = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 2, this.length), this[t8] << 8 | this[t8 + 1];
      }, u$1$1.prototype.readUInt32LE = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 4, this.length), (this[t8] | this[t8 + 1] << 8 | this[t8 + 2] << 16) + 16777216 * this[t8 + 3];
      }, u$1$1.prototype.readUInt32BE = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 4, this.length), 16777216 * this[t8] + (this[t8 + 1] << 16 | this[t8 + 2] << 8 | this[t8 + 3]);
      }, u$1$1.prototype.readIntLE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x3(t8, r9, this.length);
        for (var n8 = this[t8], i7 = 1, o8 = 0; ++o8 < r9 && (i7 *= 256); ) n8 += this[t8 + o8] * i7;
        return n8 >= (i7 *= 128) && (n8 -= Math.pow(2, 8 * r9)), n8;
      }, u$1$1.prototype.readIntBE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x3(t8, r9, this.length);
        for (var n8 = r9, i7 = 1, o8 = this[t8 + --n8]; n8 > 0 && (i7 *= 256); ) o8 += this[t8 + --n8] * i7;
        return o8 >= (i7 *= 128) && (o8 -= Math.pow(2, 8 * r9)), o8;
      }, u$1$1.prototype.readInt8 = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 1, this.length), 128 & this[t8] ? -1 * (255 - this[t8] + 1) : this[t8];
      }, u$1$1.prototype.readInt16LE = function(t8, r9) {
        t8 >>>= 0, r9 || x3(t8, 2, this.length);
        var e9 = this[t8] | this[t8 + 1] << 8;
        return 32768 & e9 ? 4294901760 | e9 : e9;
      }, u$1$1.prototype.readInt16BE = function(t8, r9) {
        t8 >>>= 0, r9 || x3(t8, 2, this.length);
        var e9 = this[t8 + 1] | this[t8] << 8;
        return 32768 & e9 ? 4294901760 | e9 : e9;
      }, u$1$1.prototype.readInt32LE = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 4, this.length), this[t8] | this[t8 + 1] << 8 | this[t8 + 2] << 16 | this[t8 + 3] << 24;
      }, u$1$1.prototype.readInt32BE = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 4, this.length), this[t8] << 24 | this[t8 + 1] << 16 | this[t8 + 2] << 8 | this[t8 + 3];
      }, u$1$1.prototype.readFloatLE = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 4, this.length), i$13.read(this, t8, true, 23, 4);
      }, u$1$1.prototype.readFloatBE = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 4, this.length), i$13.read(this, t8, false, 23, 4);
      }, u$1$1.prototype.readDoubleLE = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 8, this.length), i$13.read(this, t8, true, 52, 8);
      }, u$1$1.prototype.readDoubleBE = function(t8, r9) {
        return t8 >>>= 0, r9 || x3(t8, 8, this.length), i$13.read(this, t8, false, 52, 8);
      }, u$1$1.prototype.writeUIntLE = function(t8, r9, e9, n8) {
        (t8 = +t8, r9 >>>= 0, e9 >>>= 0, n8) || C3(this, t8, r9, e9, Math.pow(2, 8 * e9) - 1, 0);
        var i7 = 1, o8 = 0;
        for (this[r9] = 255 & t8; ++o8 < e9 && (i7 *= 256); ) this[r9 + o8] = t8 / i7 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeUIntBE = function(t8, r9, e9, n8) {
        (t8 = +t8, r9 >>>= 0, e9 >>>= 0, n8) || C3(this, t8, r9, e9, Math.pow(2, 8 * e9) - 1, 0);
        var i7 = e9 - 1, o8 = 1;
        for (this[r9 + i7] = 255 & t8; --i7 >= 0 && (o8 *= 256); ) this[r9 + i7] = t8 / o8 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeUInt8 = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 1, 255, 0), this[r9] = 255 & t8, r9 + 1;
      }, u$1$1.prototype.writeUInt16LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 2, 65535, 0), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, r9 + 2;
      }, u$1$1.prototype.writeUInt16BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 2, 65535, 0), this[r9] = t8 >>> 8, this[r9 + 1] = 255 & t8, r9 + 2;
      }, u$1$1.prototype.writeUInt32LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 4, 4294967295, 0), this[r9 + 3] = t8 >>> 24, this[r9 + 2] = t8 >>> 16, this[r9 + 1] = t8 >>> 8, this[r9] = 255 & t8, r9 + 4;
      }, u$1$1.prototype.writeUInt32BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 4, 4294967295, 0), this[r9] = t8 >>> 24, this[r9 + 1] = t8 >>> 16, this[r9 + 2] = t8 >>> 8, this[r9 + 3] = 255 & t8, r9 + 4;
      }, u$1$1.prototype.writeIntLE = function(t8, r9, e9, n8) {
        if (t8 = +t8, r9 >>>= 0, !n8) {
          var i7 = Math.pow(2, 8 * e9 - 1);
          C3(this, t8, r9, e9, i7 - 1, -i7);
        }
        var o8 = 0, f7 = 1, u7 = 0;
        for (this[r9] = 255 & t8; ++o8 < e9 && (f7 *= 256); ) t8 < 0 && 0 === u7 && 0 !== this[r9 + o8 - 1] && (u7 = 1), this[r9 + o8] = (t8 / f7 >> 0) - u7 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeIntBE = function(t8, r9, e9, n8) {
        if (t8 = +t8, r9 >>>= 0, !n8) {
          var i7 = Math.pow(2, 8 * e9 - 1);
          C3(this, t8, r9, e9, i7 - 1, -i7);
        }
        var o8 = e9 - 1, f7 = 1, u7 = 0;
        for (this[r9 + o8] = 255 & t8; --o8 >= 0 && (f7 *= 256); ) t8 < 0 && 0 === u7 && 0 !== this[r9 + o8 + 1] && (u7 = 1), this[r9 + o8] = (t8 / f7 >> 0) - u7 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeInt8 = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 1, 127, -128), t8 < 0 && (t8 = 255 + t8 + 1), this[r9] = 255 & t8, r9 + 1;
      }, u$1$1.prototype.writeInt16LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 2, 32767, -32768), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, r9 + 2;
      }, u$1$1.prototype.writeInt16BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 2, 32767, -32768), this[r9] = t8 >>> 8, this[r9 + 1] = 255 & t8, r9 + 2;
      }, u$1$1.prototype.writeInt32LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 4, 2147483647, -2147483648), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, this[r9 + 2] = t8 >>> 16, this[r9 + 3] = t8 >>> 24, r9 + 4;
      }, u$1$1.prototype.writeInt32BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 4, 2147483647, -2147483648), t8 < 0 && (t8 = 4294967295 + t8 + 1), this[r9] = t8 >>> 24, this[r9 + 1] = t8 >>> 16, this[r9 + 2] = t8 >>> 8, this[r9 + 3] = 255 & t8, r9 + 4;
      }, u$1$1.prototype.writeFloatLE = function(t8, r9, e9) {
        return k3(this, t8, r9, true, e9);
      }, u$1$1.prototype.writeFloatBE = function(t8, r9, e9) {
        return k3(this, t8, r9, false, e9);
      }, u$1$1.prototype.writeDoubleLE = function(t8, r9, e9) {
        return M3(this, t8, r9, true, e9);
      }, u$1$1.prototype.writeDoubleBE = function(t8, r9, e9) {
        return M3(this, t8, r9, false, e9);
      }, u$1$1.prototype.copy = function(t8, r9, e9, n8) {
        if (!u$1$1.isBuffer(t8)) throw new TypeError("argument should be a Buffer");
        if (e9 || (e9 = 0), n8 || 0 === n8 || (n8 = this.length), r9 >= t8.length && (r9 = t8.length), r9 || (r9 = 0), n8 > 0 && n8 < e9 && (n8 = e9), n8 === e9) return 0;
        if (0 === t8.length || 0 === this.length) return 0;
        if (r9 < 0) throw new RangeError("targetStart out of bounds");
        if (e9 < 0 || e9 >= this.length) throw new RangeError("Index out of range");
        if (n8 < 0) throw new RangeError("sourceEnd out of bounds");
        n8 > this.length && (n8 = this.length), t8.length - r9 < n8 - e9 && (n8 = t8.length - r9 + e9);
        var i7 = n8 - e9;
        if (this === t8 && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(r9, e9, n8);
        else if (this === t8 && e9 < r9 && r9 < n8) for (var o8 = i7 - 1; o8 >= 0; --o8) t8[o8 + r9] = this[o8 + e9];
        else Uint8Array.prototype.set.call(t8, this.subarray(e9, n8), r9);
        return i7;
      }, u$1$1.prototype.fill = function(t8, r9, e9, n8) {
        if ("string" == typeof t8) {
          if ("string" == typeof r9 ? (n8 = r9, r9 = 0, e9 = this.length) : "string" == typeof e9 && (n8 = e9, e9 = this.length), void 0 !== n8 && "string" != typeof n8) throw new TypeError("encoding must be a string");
          if ("string" == typeof n8 && !u$1$1.isEncoding(n8)) throw new TypeError("Unknown encoding: " + n8);
          if (1 === t8.length) {
            var i7 = t8.charCodeAt(0);
            ("utf8" === n8 && i7 < 128 || "latin1" === n8) && (t8 = i7);
          }
        } else "number" == typeof t8 ? t8 &= 255 : "boolean" == typeof t8 && (t8 = Number(t8));
        if (r9 < 0 || this.length < r9 || this.length < e9) throw new RangeError("Out of range index");
        if (e9 <= r9) return this;
        var o8;
        if (r9 >>>= 0, e9 = void 0 === e9 ? this.length : e9 >>> 0, t8 || (t8 = 0), "number" == typeof t8) for (o8 = r9; o8 < e9; ++o8) this[o8] = t8;
        else {
          var f7 = u$1$1.isBuffer(t8) ? t8 : u$1$1.from(t8, n8), s6 = f7.length;
          if (0 === s6) throw new TypeError('The value "' + t8 + '" is invalid for argument "value"');
          for (o8 = 0; o8 < e9 - r9; ++o8) this[o8 + r9] = f7[o8 % s6];
        }
        return this;
      };
      j3 = /[^+/0-9A-Za-z-_]/g;
      Y3 = function() {
        for (var t8 = new Array(256), r9 = 0; r9 < 16; ++r9) for (var e9 = 16 * r9, n8 = 0; n8 < 16; ++n8) t8[e9 + n8] = "0123456789abcdef"[r9] + "0123456789abcdef"[n8];
        return t8;
      }();
      e$1$1.Buffer;
      e$1$1.INSPECT_MAX_BYTES;
      e$1$1.kMaxLength;
      e5 = {};
      n4 = e$1$1;
      o4 = n4.Buffer;
      o4.from && o4.alloc && o4.allocUnsafe && o4.allocUnsafeSlow ? e5 = n4 : (t5(n4, e5), e5.Buffer = f4), f4.prototype = Object.create(o4.prototype), t5(o4, f4), f4.from = function(r9, e9, n8) {
        if ("number" == typeof r9) throw new TypeError("Argument must not be a number");
        return o4(r9, e9, n8);
      }, f4.alloc = function(r9, e9, n8) {
        if ("number" != typeof r9) throw new TypeError("Argument must be a number");
        var t8 = o4(r9);
        return void 0 !== e9 ? "string" == typeof n8 ? t8.fill(e9, n8) : t8.fill(e9) : t8.fill(0), t8;
      }, f4.allocUnsafe = function(r9) {
        if ("number" != typeof r9) throw new TypeError("Argument must be a number");
        return o4(r9);
      }, f4.allocUnsafeSlow = function(r9) {
        if ("number" != typeof r9) throw new TypeError("Argument must be a number");
        return n4.SlowBuffer(r9);
      };
      u4 = e5;
      e$13 = {};
      s4 = u4.Buffer;
      i4 = s4.isEncoding || function(t8) {
        switch ((t8 = "" + t8) && t8.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      e$13.StringDecoder = a4, a4.prototype.write = function(t8) {
        if (0 === t8.length) return "";
        var e9, s6;
        if (this.lastNeed) {
          if (void 0 === (e9 = this.fillLast(t8))) return "";
          s6 = this.lastNeed, this.lastNeed = 0;
        } else s6 = 0;
        return s6 < t8.length ? e9 ? e9 + this.text(t8, s6) : this.text(t8, s6) : e9 || "";
      }, a4.prototype.end = function(t8) {
        var e9 = t8 && t8.length ? this.write(t8) : "";
        return this.lastNeed ? e9 + "\uFFFD" : e9;
      }, a4.prototype.text = function(t8, e9) {
        var s6 = function(t9, e10, s7) {
          var i8 = e10.length - 1;
          if (i8 < s7) return 0;
          var a7 = r5(e10[i8]);
          if (a7 >= 0) return a7 > 0 && (t9.lastNeed = a7 - 1), a7;
          if (--i8 < s7 || -2 === a7) return 0;
          if ((a7 = r5(e10[i8])) >= 0) return a7 > 0 && (t9.lastNeed = a7 - 2), a7;
          if (--i8 < s7 || -2 === a7) return 0;
          if ((a7 = r5(e10[i8])) >= 0) return a7 > 0 && (2 === a7 ? a7 = 0 : t9.lastNeed = a7 - 3), a7;
          return 0;
        }(this, t8, e9);
        if (!this.lastNeed) return t8.toString("utf8", e9);
        this.lastTotal = s6;
        var i7 = t8.length - (s6 - this.lastNeed);
        return t8.copy(this.lastChar, 0, i7), t8.toString("utf8", e9, i7);
      }, a4.prototype.fillLast = function(t8) {
        if (this.lastNeed <= t8.length) return t8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t8.length), this.lastNeed -= t8.length;
      };
      e$13.StringDecoder;
      e$13.StringDecoder;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js
  function dew$2$1() {
    if (_dewExec$2$1) return exports$2$1;
    _dewExec$2$1 = true;
    exports$2$1.byteLength = byteLength;
    exports$2$1.toByteArray = toByteArray;
    exports$2$1.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i7 = 0, len = code9.length; i7 < len; ++i7) {
      lookup[i7] = code9[i7];
      revLookup[code9.charCodeAt(i7)] = i7;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i8;
      for (i8 = 0; i8 < len2; i8 += 4) {
        tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i8 = start; i8 < end; i8 += 3) {
        tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$2$1;
  }
  function dew$1$1() {
    if (_dewExec$1$1) return exports$1$1;
    _dewExec$1$1 = true;
    exports$1$1.read = function(buffer4, offset, isLE, mLen, nBytes) {
      var e9, m6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i7 = isLE ? nBytes - 1 : 0;
      var d6 = isLE ? -1 : 1;
      var s6 = buffer4[offset + i7];
      i7 += d6;
      e9 = s6 & (1 << -nBits) - 1;
      s6 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e9 = e9 * 256 + buffer4[offset + i7], i7 += d6, nBits -= 8) {
      }
      m6 = e9 & (1 << -nBits) - 1;
      e9 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m6 = m6 * 256 + buffer4[offset + i7], i7 += d6, nBits -= 8) {
      }
      if (e9 === 0) {
        e9 = 1 - eBias;
      } else if (e9 === eMax) {
        return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
      } else {
        m6 = m6 + Math.pow(2, mLen);
        e9 = e9 - eBias;
      }
      return (s6 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
    };
    exports$1$1.write = function(buffer4, value, offset, isLE, mLen, nBytes) {
      var e9, m6, c7;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i7 = isLE ? 0 : nBytes - 1;
      var d6 = isLE ? 1 : -1;
      var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m6 = isNaN(value) ? 1 : 0;
        e9 = eMax;
      } else {
        e9 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c7 = Math.pow(2, -e9)) < 1) {
          e9--;
          c7 *= 2;
        }
        if (e9 + eBias >= 1) {
          value += rt / c7;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c7 >= 2) {
          e9++;
          c7 /= 2;
        }
        if (e9 + eBias >= eMax) {
          m6 = 0;
          e9 = eMax;
        } else if (e9 + eBias >= 1) {
          m6 = (value * c7 - 1) * Math.pow(2, mLen);
          e9 = e9 + eBias;
        } else {
          m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e9 = 0;
        }
      }
      for (; mLen >= 8; buffer4[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
      }
      e9 = e9 << mLen | m6;
      eLen += mLen;
      for (; eLen > 0; buffer4[offset + i7] = e9 & 255, i7 += d6, e9 /= 256, eLen -= 8) {
      }
      buffer4[offset + i7 - d6] |= s6 * 128;
    };
    return exports$1$1;
  }
  function dew$g() {
    if (_dewExec$g) return exports$g;
    _dewExec$g = true;
    const base643 = dew$2$1();
    const ieee754 = dew$1$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports$g.Buffer = Buffer2;
    exports$g.SlowBuffer = SlowBuffer;
    exports$g.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports$g.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e9) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length4) {
      if (length4 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length4 + '" is invalid for option "size"');
      }
      const buf3 = new Uint8Array(length4);
      Object.setPrototypeOf(buf3, Buffer2.prototype);
      return buf3;
    }
    function Buffer2(arg, encodingOrOffset, length4) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe2(arg);
      }
      return from8(arg, encodingOrOffset, length4);
    }
    Buffer2.poolSize = 8192;
    function from8(value, encodingOrOffset, length4) {
      if (typeof value === "string") {
        return fromString6(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length4);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length4);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length4);
      }
      const b5 = fromObject(value);
      if (b5) return b5;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length4);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer2.from = function(value, encodingOrOffset, length4) {
      return from8(value, encodingOrOffset, length4);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc4(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc4(size, fill, encoding);
    };
    function allocUnsafe2(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe2(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe2(size);
    };
    function fromString6(string3, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length4 = byteLength(string3, encoding) | 0;
      let buf3 = createBuffer(length4);
      const actual = buf3.write(string3, encoding);
      if (actual !== length4) {
        buf3 = buf3.slice(0, actual);
      }
      return buf3;
    }
    function fromArrayLike(array) {
      const length4 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf3 = createBuffer(length4);
      for (let i7 = 0; i7 < length4; i7 += 1) {
        buf3[i7] = array[i7] & 255;
      }
      return buf3;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length4) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length4 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf3;
      if (byteOffset === void 0 && length4 === void 0) {
        buf3 = new Uint8Array(array);
      } else if (length4 === void 0) {
        buf3 = new Uint8Array(array, byteOffset);
      } else {
        buf3 = new Uint8Array(array, byteOffset, length4);
      }
      Object.setPrototypeOf(buf3, Buffer2.prototype);
      return buf3;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf3 = createBuffer(len);
        if (buf3.length === 0) {
          return buf3;
        }
        obj.copy(buf3, 0, 0, len);
        return buf3;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length4) {
      if (length4 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length4 | 0;
    }
    function SlowBuffer(length4) {
      if (+length4 != length4) {
        length4 = 0;
      }
      return Buffer2.alloc(+length4);
    }
    Buffer2.isBuffer = function isBuffer7(b5) {
      return b5 != null && b5._isBuffer === true && b5 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare5(a7, b5) {
      if (isInstance(a7, Uint8Array)) a7 = Buffer2.from(a7, a7.offset, a7.byteLength);
      if (isInstance(b5, Uint8Array)) b5 = Buffer2.from(b5, b5.offset, b5.byteLength);
      if (!Buffer2.isBuffer(a7) || !Buffer2.isBuffer(b5)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a7 === b5) return 0;
      let x4 = a7.length;
      let y6 = b5.length;
      for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
        if (a7[i7] !== b5[i7]) {
          x4 = a7[i7];
          y6 = b5[i7];
          break;
        }
      }
      if (x4 < y6) return -1;
      if (y6 < x4) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat4(list, length4) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i7;
      if (length4 === void 0) {
        length4 = 0;
        for (i7 = 0; i7 < list.length; ++i7) {
          length4 += list[i7].length;
        }
      }
      const buffer4 = Buffer2.allocUnsafe(length4);
      let pos = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        let buf3 = list[i7];
        if (isInstance(buf3, Uint8Array)) {
          if (pos + buf3.length > buffer4.length) {
            if (!Buffer2.isBuffer(buf3)) buf3 = Buffer2.from(buf3);
            buf3.copy(buffer4, pos);
          } else {
            Uint8Array.prototype.set.call(buffer4, buf3, pos);
          }
        } else if (!Buffer2.isBuffer(buf3)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf3.copy(buffer4, pos);
        }
        pos += buf3.length;
      }
      return buffer4;
    };
    function byteLength(string3, encoding) {
      if (Buffer2.isBuffer(string3)) {
        return string3.length;
      }
      if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
        return string3.byteLength;
      }
      if (typeof string3 !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3);
      }
      const len = string3.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes3(string3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string3).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes3(string3).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice3(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b5, n8, m6) {
      const i7 = b5[n8];
      b5[n8] = b5[m6];
      b5[m6] = i7;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 2) {
        swap(this, i7, i7 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 4) {
        swap(this, i7, i7 + 3);
        swap(this, i7 + 1, i7 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 8) {
        swap(this, i7, i7 + 7);
        swap(this, i7 + 1, i7 + 6);
        swap(this, i7 + 2, i7 + 5);
        swap(this, i7 + 3, i7 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString6() {
      const length4 = this.length;
      if (length4 === 0) return "";
      if (arguments.length === 0) return utf8Slice3(this, 0, length4);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals5(b5) {
      if (!Buffer2.isBuffer(b5)) throw new TypeError("Argument must be a Buffer");
      if (this === b5) return true;
      return Buffer2.compare(this, b5) === 0;
    };
    Buffer2.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports$g.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare5(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x4 = thisEnd - thisStart;
      let y6 = end - start;
      const len = Math.min(x4, y6);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i7 = 0; i7 < len; ++i7) {
        if (thisCopy[i7] !== targetCopy[i7]) {
          x4 = thisCopy[i7];
          y6 = targetCopy[i7];
          break;
        }
      }
      if (x4 < y6) return -1;
      if (y6 < x4) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer4, val, byteOffset, encoding, dir) {
      if (buffer4.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer4.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer4.length + byteOffset;
      if (byteOffset >= buffer4.length) {
        if (dir) return -1;
        else byteOffset = buffer4.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer4, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer4, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer4, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer4, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read6(buf3, i8) {
        if (indexSize === 1) {
          return buf3[i8];
        } else {
          return buf3.readUInt16BE(i8 * indexSize);
        }
      }
      let i7;
      if (dir) {
        let foundIndex = -1;
        for (i7 = byteOffset; i7 < arrLength; i7++) {
          if (read6(arr, i7) === read6(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i7;
            if (i7 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i7 -= i7 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i7 = byteOffset; i7 >= 0; i7--) {
          let found = true;
          for (let j4 = 0; j4 < valLength; j4++) {
            if (read6(arr, i7 + j4) !== read6(val, j4)) {
              found = false;
              break;
            }
          }
          if (found) return i7;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf3, string3, offset, length4) {
      offset = Number(offset) || 0;
      const remaining = buf3.length - offset;
      if (!length4) {
        length4 = remaining;
      } else {
        length4 = Number(length4);
        if (length4 > remaining) {
          length4 = remaining;
        }
      }
      const strLen = string3.length;
      if (length4 > strLen / 2) {
        length4 = strLen / 2;
      }
      let i7;
      for (i7 = 0; i7 < length4; ++i7) {
        const parsed = parseInt(string3.substr(i7 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i7;
        buf3[offset + i7] = parsed;
      }
      return i7;
    }
    function utf8Write(buf3, string3, offset, length4) {
      return blitBuffer(utf8ToBytes3(string3, buf3.length - offset), buf3, offset, length4);
    }
    function asciiWrite(buf3, string3, offset, length4) {
      return blitBuffer(asciiToBytes(string3), buf3, offset, length4);
    }
    function base64Write(buf3, string3, offset, length4) {
      return blitBuffer(base64ToBytes(string3), buf3, offset, length4);
    }
    function ucs2Write(buf3, string3, offset, length4) {
      return blitBuffer(utf16leToBytes(string3, buf3.length - offset), buf3, offset, length4);
    }
    Buffer2.prototype.write = function write7(string3, offset, length4, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length4 = this.length;
        offset = 0;
      } else if (length4 === void 0 && typeof offset === "string") {
        encoding = offset;
        length4 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length4)) {
          length4 = length4 >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length4;
          length4 = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length4 === void 0 || length4 > remaining) length4 = remaining;
      if (string3.length > 0 && (length4 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length4);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length4);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset, length4);
          case "base64":
            return base64Write(this, string3, offset, length4);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length4);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON3() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf3, start, end) {
      if (start === 0 && end === buf3.length) {
        return base643.fromByteArray(buf3);
      } else {
        return base643.fromByteArray(buf3.slice(start, end));
      }
    }
    function utf8Slice3(buf3, start, end) {
      end = Math.min(buf3.length, end);
      const res = [];
      let i7 = start;
      while (i7 < end) {
        const firstByte = buf3[i7];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i7 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf3[i7 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf3[i7 + 1];
              thirdByte = buf3[i7 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf3[i7 + 1];
              thirdByte = buf3[i7 + 2];
              fourthByte = buf3[i7 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i7 += bytesPerSequence;
      }
      return decodeCodePointsArray3(res);
    }
    const MAX_ARGUMENTS_LENGTH3 = 4096;
    function decodeCodePointsArray3(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH3) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i7 = 0;
      while (i7 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH3));
      }
      return res;
    }
    function asciiSlice(buf3, start, end) {
      let ret = "";
      end = Math.min(buf3.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf3[i7] & 127);
      }
      return ret;
    }
    function latin1Slice(buf3, start, end) {
      let ret = "";
      end = Math.min(buf3.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf3[i7]);
      }
      return ret;
    }
    function hexSlice(buf3, start, end) {
      const len = buf3.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i7 = start; i7 < end; ++i7) {
        out += hexSliceLookupTable[buf3[i7]];
      }
      return out;
    }
    function utf16leSlice(buf3, start, end) {
      const bytes = buf3.slice(start, end);
      let res = "";
      for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
        res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice4(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length4) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length4) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i7 = byteLength2;
      let mul = 1;
      let val = this[offset + --i7];
      while (i7 > 0 && (mul *= 256)) {
        val += this[offset + --i7] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE2(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE2(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf3, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf3)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf3.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i7 = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf3, value, offset, min, max) {
      checkIntBI(value, min, max, buf3, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf3, value, offset, min, max) {
      checkIntBI(value, min, max, buf3, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf3[offset + 7] = lo;
      lo = lo >> 8;
      buf3[offset + 6] = lo;
      lo = lo >> 8;
      buf3[offset + 5] = lo;
      lo = lo >> 8;
      buf3[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf3[offset + 3] = hi;
      hi = hi >> 8;
      buf3[offset + 2] = hi;
      hi = hi >> 8;
      buf3[offset + 1] = hi;
      hi = hi >> 8;
      buf3[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf3, value, offset, ext, max, min) {
      if (offset + ext > buf3.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf3, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf3, value, offset, 4);
      }
      ieee754.write(buf3, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE2(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf3, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf3, value, offset, 8);
      }
      ieee754.write(buf3, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE2(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code9 = val.charCodeAt(0);
          if (encoding === "utf8" && code9 < 128 || encoding === "latin1") {
            val = code9;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i7;
      if (typeof val === "number") {
        for (i7 = start; i7 < end; ++i7) {
          this[i7] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i7 = 0; i7 < end - start; ++i7) {
          this[i7 + start] = bytes[i7 % len];
        }
      }
      return this;
    };
    const errors = {};
    function E4(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name8) {
      if (name8) {
        return `${name8} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E4("ERR_INVALID_ARG_TYPE", function(name8, actual) {
      return `The "${name8}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E4("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i7 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i7 >= start + 4; i7 -= 3) {
        res = `_${val.slice(i7 - 3, i7)}${res}`;
      }
      return `${val.slice(0, i7)}${res}`;
    }
    function checkBounds(buf3, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf3[offset] === void 0 || buf3[offset + byteLength2] === void 0) {
        boundsError(offset, buf3.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf3, offset, byteLength2) {
      if (value > max || value < min) {
        const n8 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
          } else {
            range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
          }
        } else {
          range = `>= ${min}${n8} and <= ${max}${n8}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf3, offset, byteLength2);
    }
    function validateNumber(value, name8) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name8, "number", value);
      }
    }
    function boundsError(value, length4, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
      }
      if (length4 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length4}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes3(string3, units) {
      units = units || Infinity;
      let codePoint;
      const length4 = string3.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i7 = 0; i7 < length4; ++i7) {
        codePoint = string3.charCodeAt(i7);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i7 + 1 === length4) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        byteArray.push(str.charCodeAt(i7) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c7, hi, lo;
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        if ((units -= 2) < 0) break;
        c7 = str.charCodeAt(i7);
        hi = c7 >> 8;
        lo = c7 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base643.toByteArray(base64clean(str));
    }
    function blitBuffer(src3, dst, offset, length4) {
      let i7;
      for (i7 = 0; i7 < length4; ++i7) {
        if (i7 + offset >= dst.length || i7 >= src3.length) break;
        dst[i7 + offset] = src3[i7];
      }
      return i7;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet2 = "0123456789abcdef";
      const table = new Array(256);
      for (let i7 = 0; i7 < 16; ++i7) {
        const i16 = i7 * 16;
        for (let j4 = 0; j4 < 16; ++j4) {
          table[i16 + j4] = alphabet2[i7] + alphabet2[j4];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports$g;
  }
  function dew$f() {
    if (_dewExec$f) return exports$f;
    _dewExec$f = true;
    if (typeof Object.create === "function") {
      exports$f = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      exports$f = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    return exports$f;
  }
  function dew$e() {
    if (_dewExec$e) return exports$e;
    _dewExec$e = true;
    exports$e = y3.EventEmitter;
    return exports$e;
  }
  function dew$d() {
    if (_dewExec$d) return exports$d;
    _dewExec$d = true;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i7 = 1; i7 < arguments.length; i7++) {
        var source = arguments[i7] != null ? arguments[i7] : {};
        if (i7 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i7 = 0; i7 < props.length; i7++) {
        var descriptor = props[i7];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = buffer, Buffer2 = _require.Buffer;
    var _require2 = X, inspect3 = _require2.inspect;
    var custom = inspect3 && inspect3.custom || "inspect";
    function copyBuffer(src3, target, offset) {
      Buffer2.prototype.copy.call(src3, target, offset);
    }
    exports$d = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push2(v6) {
          var entry = {
            data: v6,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v6) {
          var entry = {
            data: v6,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join3(s6) {
          if (this.length === 0) return "";
          var p7 = this.head;
          var ret = "" + p7.data;
          while (p7 = p7.next) {
            ret += s6 + p7.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat4(n8) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n8 >>> 0);
          var p7 = this.head;
          var i7 = 0;
          while (p7) {
            copyBuffer(p7.data, ret, i7);
            i7 += p7.data.length;
            p7 = p7.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n8, hasStrings) {
          var ret;
          if (n8 < this.head.data.length) {
            ret = this.head.data.slice(0, n8);
            this.head.data = this.head.data.slice(n8);
          } else if (n8 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n8) : this._getBuffer(n8);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n8) {
          var p7 = this.head;
          var c7 = 1;
          var ret = p7.data;
          n8 -= ret.length;
          while (p7 = p7.next) {
            var str = p7.data;
            var nb = n8 > str.length ? str.length : n8;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n8);
            n8 -= nb;
            if (n8 === 0) {
              if (nb === str.length) {
                ++c7;
                if (p7.next) this.head = p7.next;
                else this.head = this.tail = null;
              } else {
                this.head = p7;
                p7.data = str.slice(nb);
              }
              break;
            }
            ++c7;
          }
          this.length -= c7;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n8) {
          var ret = Buffer2.allocUnsafe(n8);
          var p7 = this.head;
          var c7 = 1;
          p7.data.copy(ret);
          n8 -= p7.data.length;
          while (p7 = p7.next) {
            var buf3 = p7.data;
            var nb = n8 > buf3.length ? buf3.length : n8;
            buf3.copy(ret, ret.length - n8, 0, nb);
            n8 -= nb;
            if (n8 === 0) {
              if (nb === buf3.length) {
                ++c7;
                if (p7.next) this.head = p7.next;
                else this.head = this.tail = null;
              } else {
                this.head = p7;
                p7.data = buf3.slice(nb);
              }
              break;
            }
            ++c7;
          }
          this.length -= c7;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_4, options) {
          return inspect3(this, _objectSpread({}, options, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
    return exports$d;
  }
  function dew$c() {
    if (_dewExec$c) return exports$c;
    _dewExec$c = true;
    var process$1 = process3;
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process$1.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process$1.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process$1.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    exports$c = {
      destroy,
      undestroy,
      errorOrDestroy
    };
    return exports$c;
  }
  function dew$b() {
    if (_dewExec$b) return exports$b;
    _dewExec$b = true;
    const codes = {};
    function createErrorType(code9, message2, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message2 === "string") {
          return message2;
        } else {
          return message2(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code9;
      codes[code9] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i7) => String(i7));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name8, value) {
      return 'The value "' + value + '" is invalid for option "' + name8 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name8, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name8, " argument")) {
        msg = `The ${name8} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type2 = includes(name8, ".") ? "property" : "argument";
        msg = `The "${name8}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name8) {
      return "The " + name8 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name8) {
      return "Cannot call " + name8 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    exports$b.codes = codes;
    return exports$b;
  }
  function dew$a() {
    if (_dewExec$a) return exports$a;
    _dewExec$a = true;
    var ERR_INVALID_OPT_VALUE = dew$b().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex2, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex2 ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex2) {
      var hwm = highWaterMarkFrom(options, isDuplex2, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name8 = isDuplex2 ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name8, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    exports$a = {
      getHighWaterMark
    };
    return exports$a;
  }
  function dew$9() {
    if (_dewExec$9) return exports$9;
    _dewExec$9 = true;
    exports$9 = deprecate3;
    function deprecate3(fn, msg) {
      if (config3("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config3("throwDeprecation")) {
            throw new Error(msg);
          } else if (config3("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this || _global$2, arguments);
      }
      return deprecated;
    }
    function config3(name8) {
      try {
        if (!_global$2.localStorage) return false;
      } catch (_4) {
        return false;
      }
      var val = _global$2.localStorage[name8];
      if (null == val) return false;
      return String(val).toLowerCase() === "true";
    }
    return exports$9;
  }
  function dew$8() {
    if (_dewExec$8) return exports$8;
    _dewExec$8 = true;
    var process$1 = process3;
    exports$8 = Writable2;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable2.WritableState = WritableState;
    var internalUtil = {
      deprecate: dew$9()
    };
    var Stream2 = dew$e();
    var Buffer2 = buffer.Buffer;
    var OurUint8Array = _global$1.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = dew$c();
    var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    dew$f()(Writable2, Stream2);
    function nop() {
    }
    function WritableState(options, stream, isDuplex2) {
      Duplex2 = Duplex2 || dew$7();
      options = options || {};
      if (typeof isDuplex2 !== "boolean") isDuplex2 = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex2) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex2);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current2 = this.bufferedRequest;
      var out = [];
      while (current2) {
        out.push(current2);
        current2 = current2.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_4) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable2) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options) {
      Duplex2 = Duplex2 || dew$7();
      var isDuplex2 = this instanceof Duplex2;
      if (!isDuplex2 && !realHasInstance.call(Writable2, this)) return new Writable2(options);
      this._writableState = new WritableState(options, this, isDuplex2);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process$1.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev2, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev2) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process$1.nextTick(cb, er);
        process$1.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished2 = needFinish(state) || stream.destroyed;
        if (!finished2 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process$1.nextTick(afterWrite, stream, state, finished2, cb);
        } else {
          afterWrite(stream, state, finished2, cb);
        }
      }
    }
    function afterWrite(stream, state, finished2, cb) {
      if (!finished2) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l7 = state.bufferedRequestCount;
        var buffer4 = new Array(l7);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer4[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer4.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer4, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process$1.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process$1.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set4(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    return exports$8;
  }
  function dew$7() {
    if (_dewExec$7) return exports$7;
    _dewExec$7 = true;
    var process$1 = process3;
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    exports$7 = Duplex2;
    var Readable2 = dew$3();
    var Writable2 = dew$8();
    dew$f()(Duplex2, Readable2);
    {
      var keys = objectKeys(Writable2.prototype);
      for (var v6 = 0; v6 < keys.length; v6++) {
        var method = keys[v6];
        if (!Duplex2.prototype[method]) Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    function Duplex2(options) {
      if (!(this instanceof Duplex2)) return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process$1.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set4(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    return exports$7;
  }
  function dew$6() {
    if (_dewExec$6) return exports$6;
    _dewExec$6 = true;
    var ERR_STREAM_PREMATURE_CLOSE = dew$b().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once3(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop3() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once3(callback || noop3);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    exports$6 = eos;
    return exports$6;
  }
  function dew$5() {
    if (_dewExec$5) return exports$5;
    _dewExec$5 = true;
    var process$1 = process3;
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished2 = dew$6();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult2(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve9 = iter[kLastResolve];
      if (resolve9 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve9(createIterResult2(data, false));
        }
      }
    }
    function onReadable(iter) {
      process$1.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve9, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve9(createIterResult2(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve9, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult2(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve9, reject) {
            process$1.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve9(createIterResult2(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult2(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve9, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve9(createIterResult2(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve9, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve9(createIterResult2(data, false));
          } else {
            iterator[kLastResolve] = resolve9;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished2(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve9 = iterator[kLastResolve];
        if (resolve9 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve9(createIterResult2(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    exports$5 = createReadableStreamAsyncIterator;
    return exports$5;
  }
  function dew$4() {
    if (_dewExec$4) return exports$4;
    _dewExec$4 = true;
    exports$4 = function() {
      throw new Error("Readable.from is not available in the browser");
    };
    return exports$4;
  }
  function dew$3() {
    if (_dewExec$3) return exports$32;
    _dewExec$3 = true;
    var process$1 = process3;
    exports$32 = Readable2;
    var Duplex2;
    Readable2.ReadableState = ReadableState;
    y3.EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream2 = dew$e();
    var Buffer2 = buffer.Buffer;
    var OurUint8Array = _global2.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = X;
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = dew$d();
    var destroyImpl = dew$c();
    var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from8;
    dew$f()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener2(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex2) {
      Duplex2 = Duplex2 || dew$7();
      options = options || {};
      if (typeof isDuplex2 !== "boolean") isDuplex2 = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex2) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex2);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = e$13.StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex2 = Duplex2 || dew$7();
      if (!(this instanceof Readable2)) return new Readable2(options);
      var isDuplex2 = this instanceof Duplex2;
      this._readableState = new ReadableState(options, this, isDuplex2);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set4(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = e$13.StringDecoder;
      var decoder2 = new StringDecoder(enc);
      this._readableState.decoder = decoder2;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p7 = this._readableState.buffer.head;
      var content = "";
      while (p7 !== null) {
        content += decoder2.write(p7.data);
        p7 = p7.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n8) {
      if (n8 >= MAX_HWM) {
        n8 = MAX_HWM;
      } else {
        n8--;
        n8 |= n8 >>> 1;
        n8 |= n8 >>> 2;
        n8 |= n8 >>> 4;
        n8 |= n8 >>> 8;
        n8 |= n8 >>> 16;
        n8++;
      }
      return n8;
    }
    function howMuchToRead(n8, state) {
      if (n8 <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n8 !== n8) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n8 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n8);
      if (n8 <= state.length) return n8;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n8) {
      debug("read", n8);
      n8 = parseInt(n8, 10);
      var state = this._readableState;
      var nOrig = n8;
      if (n8 !== 0) state.emittedReadable = false;
      if (n8 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n8 = howMuchToRead(n8, state);
      if (n8 === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n8 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n8 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n8 > 0) ret = fromList(n8, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n8 = 0;
      } else {
        state.length -= n8;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n8 && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process$1.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process$1.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n8) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src3 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process$1.nextTick(endFn);
      else src3.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src3) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src3);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src3.removeListener("end", onend);
        src3.removeListener("end", unpipe);
        src3.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src3.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src3.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src3.unpipe(dest);
      }
      dest.emit("pipe", src3);
      if (!state.flowing) {
        debug("pipe resume");
        src3.resume();
      }
      return dest;
    };
    function pipeOnDrain(src3) {
      return function pipeOnDrainFunctionResult() {
        var state = src3._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src3, "data")) {
          state.flowing = true;
          flow(src3);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i7 = 0; i7 < len; i7++) {
          dests[i7].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index2 = indexOf(state.pipes, dest);
      if (index2 === -1) return this;
      state.pipes.splice(index2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process$1.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume2(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume2(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process$1.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i7 in stream) {
        if (this[i7] === void 0 && typeof stream[i7] === "function") {
          this[i7] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i7);
        }
      }
      for (var n8 = 0; n8 < kProxyEvents.length; n8++) {
        stream.on(kProxyEvents[n8], this.emit.bind(this, kProxyEvents[n8]));
      }
      this._read = function(n9) {
        debug("wrapped _read", n9);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = dew$5();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        return this._readableState.flowing;
      },
      set: function set4(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get8() {
        return this._readableState.length;
      }
    });
    function fromList(n8, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n8 || n8 >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n8, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process$1.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from8 === void 0) {
          from8 = dew$4();
        }
        return from8(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x4) {
      for (var i7 = 0, l7 = xs.length; i7 < l7; i7++) {
        if (xs[i7] === x4) return i7;
      }
      return -1;
    }
    return exports$32;
  }
  function dew$22() {
    if (_dewExec$22) return exports$22;
    _dewExec$22 = true;
    exports$22 = Transform2;
    var _require$codes = dew$b().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = dew$7();
    dew$f()(Transform2, Duplex2);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2)) return new Transform2(options);
      Duplex2.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n8) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    return exports$22;
  }
  function dew$12() {
    if (_dewExec$12) return exports$13;
    _dewExec$12 = true;
    exports$13 = PassThrough2;
    var Transform2 = dew$22();
    dew$f()(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2)) return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    return exports$13;
  }
  function dew4() {
    if (_dewExec4) return exports5;
    _dewExec4 = true;
    var eos;
    function once3(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = dew$b().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop3(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once3(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = dew$6();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe2(from8, to) {
      return from8.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop3;
      if (typeof streams[streams.length - 1] !== "function") return noop3;
      return streams.pop();
    }
    function pipeline2() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i7) {
        var reading = i7 < streams.length - 1;
        var writing = i7 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe2);
    }
    exports5 = pipeline2;
    return exports5;
  }
  var exports$2$1, _dewExec$2$1, exports$1$1, _dewExec$1$1, exports$g, _dewExec$g, buffer, exports$f, _dewExec$f, exports$e, _dewExec$e, exports$d, _dewExec$d, exports$c, _dewExec$c, exports$b, _dewExec$b, exports$a, _dewExec$a, exports$9, _dewExec$9, _global$2, exports$8, _dewExec$8, _global$1, exports$7, _dewExec$7, exports$6, _dewExec$6, exports$5, _dewExec$5, exports$4, _dewExec$4, exports$32, _dewExec$3, _global2, exports$22, _dewExec$22, exports$13, _dewExec$12, exports5, _dewExec4;
  var init_chunk_44e51b61 = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_4bd36a8f();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_2eac56ff();
      init_chunk_4ccc3a29();
      exports$2$1 = {};
      _dewExec$2$1 = false;
      exports$1$1 = {};
      _dewExec$1$1 = false;
      exports$g = {};
      _dewExec$g = false;
      buffer = dew$g();
      buffer.Buffer;
      buffer.INSPECT_MAX_BYTES;
      buffer.kMaxLength;
      exports$f = {};
      _dewExec$f = false;
      exports$e = {};
      _dewExec$e = false;
      exports$d = {};
      _dewExec$d = false;
      exports$c = {};
      _dewExec$c = false;
      exports$b = {};
      _dewExec$b = false;
      exports$a = {};
      _dewExec$a = false;
      exports$9 = {};
      _dewExec$9 = false;
      _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$8 = {};
      _dewExec$8 = false;
      _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$7 = {};
      _dewExec$7 = false;
      exports$6 = {};
      _dewExec$6 = false;
      exports$5 = {};
      _dewExec$5 = false;
      exports$4 = {};
      _dewExec$4 = false;
      exports$32 = {};
      _dewExec$3 = false;
      _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$22 = {};
      _dewExec$22 = false;
      exports$13 = {};
      _dewExec$12 = false;
      exports5 = {};
      _dewExec4 = false;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-6c718bbe.js
  function dew5() {
    if (_dewExec5) return exports$14;
    _dewExec5 = true;
    exports$14 = Stream2;
    var EE = y3.EventEmitter;
    var inherits3 = dew$f();
    inherits3(Stream2, EE);
    Stream2.Readable = dew$3();
    Stream2.Writable = dew$8();
    Stream2.Duplex = dew$7();
    Stream2.Transform = dew$22();
    Stream2.PassThrough = dew$12();
    Stream2.finished = dew$6();
    Stream2.pipeline = dew4();
    Stream2.Stream = Stream2;
    function Stream2() {
      EE.call(this || _global3);
    }
    Stream2.prototype.pipe = function(dest, options) {
      var source = this || _global3;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this || _global3, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    return exports$14;
  }
  var exports$14, _dewExec5, _global3, exports6;
  var init_chunk_6c718bbe = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-6c718bbe.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_events();
      init_chunk_44e51b61();
      init_chunk_4bd36a8f();
      exports$14 = {};
      _dewExec5 = false;
      _global3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports6 = dew5();
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/stream.js
  var stream_exports = {};
  __export(stream_exports, {
    Duplex: () => Duplex,
    PassThrough: () => PassThrough,
    Readable: () => Readable,
    Stream: () => Stream,
    Transform: () => Transform,
    Writable: () => Writable,
    default: () => exports6,
    finished: () => finished,
    pipeline: () => pipeline,
    promises: () => promises
  });
  var Readable, Writable, Duplex, Transform, PassThrough, finished, pipeline, Stream, promises;
  var init_stream = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/stream.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_6c718bbe();
      init_chunk_6c718bbe();
      init_util();
      init_events();
      init_chunk_4bd36a8f();
      init_chunk_44e51b61();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      init_chunk_2eac56ff();
      init_chunk_4ccc3a29();
      Readable = exports6.Readable;
      Readable.wrap = function(src3, options) {
        options = Object.assign({ objectMode: src3.readableObjectMode != null || src3.objectMode != null || true }, options);
        options.destroy = function(err, callback) {
          src3.destroy(err);
          callback(err);
        };
        return new Readable(options).wrap(src3);
      };
      Writable = exports6.Writable;
      Duplex = exports6.Duplex;
      Transform = exports6.Transform;
      PassThrough = exports6.PassThrough;
      finished = exports6.finished;
      pipeline = exports6.pipeline;
      Stream = exports6.Stream;
      promises = {
        finished: promisify2(exports6.finished),
        pipeline: promisify2(exports6.pipeline)
      };
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/constants.js
  var require_constants2 = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/constants.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.FLAGS = exports9.ERRSTR = void 0;
      var constants_1 = require_constants();
      exports9.ERRSTR = {
        PATH_STR: "path must be a string or Buffer",
        // FD:             'file descriptor must be a unsigned 32-bit integer',
        FD: "fd must be a file descriptor",
        MODE_INT: "mode must be an int",
        CB: "callback must be a function",
        UID: "uid must be an unsigned int",
        GID: "gid must be an unsigned int",
        LEN: "len must be an integer",
        ATIME: "atime must be an integer",
        MTIME: "mtime must be an integer",
        PREFIX: "filename prefix is required",
        BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
        OFFSET: "offset must be an integer",
        LENGTH: "length must be an integer",
        POSITION: "position must be an integer"
      };
      var { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_TRUNC, O_APPEND, O_SYNC } = constants_1.constants;
      var FLAGS;
      (function(FLAGS2) {
        FLAGS2[FLAGS2["r"] = O_RDONLY] = "r";
        FLAGS2[FLAGS2["r+"] = O_RDWR] = "r+";
        FLAGS2[FLAGS2["rs"] = O_RDONLY | O_SYNC] = "rs";
        FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
        FLAGS2[FLAGS2["rs+"] = O_RDWR | O_SYNC] = "rs+";
        FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
        FLAGS2[FLAGS2["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
        FLAGS2[FLAGS2["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
        FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
        FLAGS2[FLAGS2["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
        FLAGS2[FLAGS2["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
        FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
        FLAGS2[FLAGS2["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
        FLAGS2[FLAGS2["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
        FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
        FLAGS2[FLAGS2["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
        FLAGS2[FLAGS2["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
        FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
      })(FLAGS || (exports9.FLAGS = FLAGS = {}));
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js
  function i5(t8) {
    throw new RangeError(r6[t8]);
  }
  function f5(t8, o8) {
    const n8 = t8.split("@");
    let r9 = "";
    n8.length > 1 && (r9 = n8[0] + "@", t8 = n8[1]);
    const c7 = function(t9, o9) {
      const n9 = [];
      let e9 = t9.length;
      for (; e9--; ) n9[e9] = o9(t9[e9]);
      return n9;
    }((t8 = t8.replace(e6, ".")).split("."), o8).join(".");
    return r9 + c7;
  }
  function l5(t8) {
    const o8 = [];
    let n8 = 0;
    const e9 = t8.length;
    for (; n8 < e9; ) {
      const r9 = t8.charCodeAt(n8++);
      if (r9 >= 55296 && r9 <= 56319 && n8 < e9) {
        const e10 = t8.charCodeAt(n8++);
        56320 == (64512 & e10) ? o8.push(((1023 & r9) << 10) + (1023 & e10) + 65536) : (o8.push(r9), n8--);
      } else o8.push(r9);
    }
    return o8;
  }
  var t6, o5, n5, e6, r6, c5, s5, u5, a5, d5, h6, p5;
  var init_chunk_924bb2e1 = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      t6 = 2147483647;
      o5 = /^xn--/;
      n5 = /[^\0-\x7E]/;
      e6 = /[\x2E\u3002\uFF0E\uFF61]/g;
      r6 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
      c5 = Math.floor;
      s5 = String.fromCharCode;
      u5 = function(t8, o8) {
        return t8 + 22 + 75 * (t8 < 26) - ((0 != o8) << 5);
      };
      a5 = function(t8, o8, n8) {
        let e9 = 0;
        for (t8 = n8 ? c5(t8 / 700) : t8 >> 1, t8 += c5(t8 / o8); t8 > 455; e9 += 36) t8 = c5(t8 / 35);
        return c5(e9 + 36 * t8 / (t8 + 38));
      };
      d5 = function(o8) {
        const n8 = [], e9 = o8.length;
        let r9 = 0, s6 = 128, f7 = 72, l7 = o8.lastIndexOf("-");
        l7 < 0 && (l7 = 0);
        for (let t8 = 0; t8 < l7; ++t8) o8.charCodeAt(t8) >= 128 && i5("not-basic"), n8.push(o8.charCodeAt(t8));
        for (let d6 = l7 > 0 ? l7 + 1 : 0; d6 < e9; ) {
          let l8 = r9;
          for (let n9 = 1, s7 = 36; ; s7 += 36) {
            d6 >= e9 && i5("invalid-input");
            const l9 = (u7 = o8.charCodeAt(d6++)) - 48 < 10 ? u7 - 22 : u7 - 65 < 26 ? u7 - 65 : u7 - 97 < 26 ? u7 - 97 : 36;
            (l9 >= 36 || l9 > c5((t6 - r9) / n9)) && i5("overflow"), r9 += l9 * n9;
            const a7 = s7 <= f7 ? 1 : s7 >= f7 + 26 ? 26 : s7 - f7;
            if (l9 < a7) break;
            const h9 = 36 - a7;
            n9 > c5(t6 / h9) && i5("overflow"), n9 *= h9;
          }
          const h8 = n8.length + 1;
          f7 = a5(r9 - l8, h8, 0 == l8), c5(r9 / h8) > t6 - s6 && i5("overflow"), s6 += c5(r9 / h8), r9 %= h8, n8.splice(r9++, 0, s6);
        }
        var u7;
        return String.fromCodePoint(...n8);
      };
      h6 = function(o8) {
        const n8 = [];
        let e9 = (o8 = l5(o8)).length, r9 = 128, f7 = 0, d6 = 72;
        for (const t8 of o8) t8 < 128 && n8.push(s5(t8));
        let h8 = n8.length, p7 = h8;
        for (h8 && n8.push("-"); p7 < e9; ) {
          let e10 = t6;
          for (const t8 of o8) t8 >= r9 && t8 < e10 && (e10 = t8);
          const l7 = p7 + 1;
          e10 - r9 > c5((t6 - f7) / l7) && i5("overflow"), f7 += (e10 - r9) * l7, r9 = e10;
          for (const e11 of o8) if (e11 < r9 && ++f7 > t6 && i5("overflow"), e11 == r9) {
            let t8 = f7;
            for (let o9 = 36; ; o9 += 36) {
              const e12 = o9 <= d6 ? 1 : o9 >= d6 + 26 ? 26 : o9 - d6;
              if (t8 < e12) break;
              const r10 = t8 - e12, i7 = 36 - e12;
              n8.push(s5(u5(e12 + r10 % i7, 0))), t8 = c5(r10 / i7);
            }
            n8.push(s5(u5(t8, 0))), d6 = a5(f7, l7, p7 == h8), f7 = 0, ++p7;
          }
          ++f7, ++r9;
        }
        return n8.join("");
      };
      p5 = { version: "2.1.0", ucs2: { decode: l5, encode: (t8) => String.fromCodePoint(...t8) }, decode: d5, encode: h6, toASCII: function(t8) {
        return f5(t8, function(t9) {
          return n5.test(t9) ? "xn--" + h6(t9) : t9;
        });
      }, toUnicode: function(t8) {
        return f5(t8, function(t9) {
          return o5.test(t9) ? d5(t9.slice(4).toLowerCase()) : t9;
        });
      } };
      p5.decode;
      p5.encode;
      p5.toASCII;
      p5.toUnicode;
      p5.ucs2;
      p5.version;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js
  function e7(e9, n8) {
    return Object.prototype.hasOwnProperty.call(e9, n8);
  }
  var n6, r7, t7, o6;
  var init_chunk_b04e620d = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      n6 = function(n8, r9, t8, o8) {
        r9 = r9 || "&", t8 = t8 || "=";
        var a7 = {};
        if ("string" != typeof n8 || 0 === n8.length) return a7;
        var u7 = /\+/g;
        n8 = n8.split(r9);
        var c7 = 1e3;
        o8 && "number" == typeof o8.maxKeys && (c7 = o8.maxKeys);
        var i7 = n8.length;
        c7 > 0 && i7 > c7 && (i7 = c7);
        for (var s6 = 0; s6 < i7; ++s6) {
          var p7, f7, d6, y6, m6 = n8[s6].replace(u7, "%20"), l7 = m6.indexOf(t8);
          l7 >= 0 ? (p7 = m6.substr(0, l7), f7 = m6.substr(l7 + 1)) : (p7 = m6, f7 = ""), d6 = decodeURIComponent(p7), y6 = decodeURIComponent(f7), e7(a7, d6) ? Array.isArray(a7[d6]) ? a7[d6].push(y6) : a7[d6] = [a7[d6], y6] : a7[d6] = y6;
        }
        return a7;
      };
      r7 = function(e9) {
        switch (typeof e9) {
          case "string":
            return e9;
          case "boolean":
            return e9 ? "true" : "false";
          case "number":
            return isFinite(e9) ? e9 : "";
          default:
            return "";
        }
      };
      t7 = function(e9, n8, t8, o8) {
        return n8 = n8 || "&", t8 = t8 || "=", null === e9 && (e9 = void 0), "object" == typeof e9 ? Object.keys(e9).map(function(o9) {
          var a7 = encodeURIComponent(r7(o9)) + t8;
          return Array.isArray(e9[o9]) ? e9[o9].map(function(e10) {
            return a7 + encodeURIComponent(r7(e10));
          }).join(n8) : a7 + encodeURIComponent(r7(e9[o9]));
        }).join(n8) : o8 ? encodeURIComponent(r7(o8)) + t8 + encodeURIComponent(r7(e9)) : "";
      };
      o6 = {};
      o6.decode = o6.parse = n6, o6.encode = o6.stringify = t7;
      o6.decode;
      o6.encode;
      o6.parse;
      o6.stringify;
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/url.js
  var url_exports = {};
  __export(url_exports, {
    URL: () => _URL,
    Url: () => Url,
    default: () => h7,
    fileURLToPath: () => fileURLToPath,
    format: () => format4,
    parse: () => parse3,
    pathToFileURL: () => pathToFileURL,
    resolve: () => resolve2,
    resolveObject: () => resolveObject
  });
  function r8() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  function O4(t8, s6, h8) {
    if (t8 && a6.isObject(t8) && t8 instanceof r8) return t8;
    var e9 = new r8();
    return e9.parse(t8, s6, h8), e9;
  }
  function dew6() {
    if (_dewExec6) return exports7;
    _dewExec6 = true;
    var process4 = T;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code9;
      for (var i7 = 0; i7 <= path2.length; ++i7) {
        if (i7 < path2.length) code9 = path2.charCodeAt(i7);
        else if (code9 === 47) break;
        else code9 = 47;
        if (code9 === 47) {
          if (lastSlash === i7 - 1 || dots === 1) ;
          else if (lastSlash !== i7 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i7;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i7;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0) res += "/..";
              else res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0) res += "/" + path2.slice(lastSlash + 1, i7);
            else res = path2.slice(lastSlash + 1, i7);
            lastSegmentLength = i7 - lastSlash - 1;
          }
          lastSlash = i7;
          dots = 0;
        } else if (code9 === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep2, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base3 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base3;
      }
      if (dir === pathObject.root) {
        return dir + base3;
      }
      return dir + sep2 + base3;
    }
    var posix2 = {
      // path.resolve([from ...], to)
      resolve: function resolve9() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
          var path2;
          if (i7 >= 0) path2 = arguments[i7];
          else {
            if (cwd2 === void 0) cwd2 = process4.cwd();
            path2 = cwd2;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0) return "/" + resolvedPath;
          else return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize2(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var isAbsolute2 = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute2);
        if (path2.length === 0 && !isAbsolute2) path2 = ".";
        if (path2.length > 0 && trailingSeparator) path2 += "/";
        if (isAbsolute2) return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute2(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join3() {
        if (arguments.length === 0) return ".";
        var joined;
        for (var i7 = 0; i7 < arguments.length; ++i7) {
          var arg = arguments[i7];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0) joined = arg;
            else joined += "/" + arg;
          }
        }
        if (joined === void 0) return ".";
        return posix2.normalize(joined);
      },
      relative: function relative2(from8, to) {
        assertPath(from8);
        assertPath(to);
        if (from8 === to) return "";
        from8 = posix2.resolve(from8);
        to = posix2.resolve(to);
        if (from8 === to) return "";
        var fromStart = 1;
        for (; fromStart < from8.length; ++fromStart) {
          if (from8.charCodeAt(fromStart) !== 47) break;
        }
        var fromEnd = from8.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length4 = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i7 = 0;
        for (; i7 <= length4; ++i7) {
          if (i7 === length4) {
            if (toLen > length4) {
              if (to.charCodeAt(toStart + i7) === 47) {
                return to.slice(toStart + i7 + 1);
              } else if (i7 === 0) {
                return to.slice(toStart + i7);
              }
            } else if (fromLen > length4) {
              if (from8.charCodeAt(fromStart + i7) === 47) {
                lastCommonSep = i7;
              } else if (i7 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from8.charCodeAt(fromStart + i7);
          var toCode = to.charCodeAt(toStart + i7);
          if (fromCode !== toCode) break;
          else if (fromCode === 47) lastCommonSep = i7;
        }
        var out = "";
        for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
          if (i7 === fromEnd || from8.charCodeAt(i7) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
          }
        }
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47) ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong2(path2) {
        return path2;
      },
      dirname: function dirname2(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var code9 = path2.charCodeAt(0);
        var hasRoot = code9 === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i7 = path2.length - 1; i7 >= 1; --i7) {
          code9 = path2.charCodeAt(i7);
          if (code9 === 47) {
            if (!matchedSlash) {
              end = i7;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path2.slice(0, end);
      },
      basename: function basename2(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i7;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            var code9 = path2.charCodeAt(i7);
            if (code9 === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i7 + 1;
              }
              if (extIdx >= 0) {
                if (code9 === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i7;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            if (path2.charCodeAt(i7) === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i7 + 1;
            }
          }
          if (end === -1) return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname2(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i7 = path2.length - 1; i7 >= 0; --i7) {
          var code9 = path2.charCodeAt(i7);
          if (code9 === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code9 === 46) {
            if (startDot === -1) startDot = i7;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format8(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse7(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0) return ret;
        var code9 = path2.charCodeAt(0);
        var isAbsolute2 = code9 === 47;
        var start;
        if (isAbsolute2) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i7 = path2.length - 1;
        var preDotState = 0;
        for (; i7 >= start; --i7) {
          code9 = path2.charCodeAt(i7);
          if (code9 === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code9 === 46) {
            if (startDot === -1) startDot = i7;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute2) ret.base = ret.name = path2.slice(1, end);
            else ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute2) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute2) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix2.posix = posix2;
    exports7 = posix2;
    return exports7;
  }
  function fileURLToPath$1(path2) {
    if (typeof path2 === "string") path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows$1 ? getPathFromURLWin$1(path2) : getPathFromURLPosix$1(path2);
  }
  function getPathFromURLWin$1(url) {
    const hostname = url.hostname;
    let pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n8 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx$1, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname !== "") {
      return `\\\\${hostname}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep2 = pathname[2];
      if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
      sep2 !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix$1(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL$1(filepath) {
    let resolved = path.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%")) resolved = resolved.replace(percentRegEx$1, "%25");
    if (!isWindows$1 && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx$1, "%5C");
    }
    if (resolved.includes("\n")) resolved = resolved.replace(newlineRegEx$1, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
    }
    if (resolved.includes("	")) resolved = resolved.replace(tabRegEx$1, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  function fileURLToPath(path2) {
    if (typeof path2 === "string") path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows ? getPathFromURLWin(path2) : getPathFromURLPosix(path2);
  }
  function getPathFromURLWin(url) {
    const hostname = url.hostname;
    let pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n8 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname !== "") {
      return `\\\\${hostname}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep2 = pathname[2];
      if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
      sep2 !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL(filepath) {
    let resolved = exports4.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports4.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%")) resolved = resolved.replace(percentRegEx, "%25");
    if (!isWindows && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx, "%5C");
    }
    if (resolved.includes("\n")) resolved = resolved.replace(newlineRegEx, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx, "%0D");
    }
    if (resolved.includes("	")) resolved = resolved.replace(tabRegEx, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  var h7, e8, a6, o7, n7, i6, l6, p6, c6, u6, f6, m5, v5, g4, y5, b4, exports7, _dewExec6, path, processPlatform$1, CHAR_BACKWARD_SLASH$1, CHAR_FORWARD_SLASH$1, CHAR_LOWERCASE_A$1, CHAR_LOWERCASE_Z$1, isWindows$1, forwardSlashRegEx$1, percentRegEx$1, backslashRegEx$1, newlineRegEx$1, carriageReturnRegEx$1, tabRegEx$1, processPlatform, Url, format4, resolve2, resolveObject, parse3, _URL, CHAR_BACKWARD_SLASH, CHAR_FORWARD_SLASH, CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, isWindows, forwardSlashRegEx, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx;
  var init_url = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/url.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_924bb2e1();
      init_chunk_b04e620d();
      init_chunk_5decc758();
      init_chunk_23dbec7b();
      init_chunk_2eac56ff();
      h7 = {};
      e8 = p5;
      a6 = { isString: function(t8) {
        return "string" == typeof t8;
      }, isObject: function(t8) {
        return "object" == typeof t8 && null !== t8;
      }, isNull: function(t8) {
        return null === t8;
      }, isNullOrUndefined: function(t8) {
        return null == t8;
      } };
      h7.parse = O4, h7.resolve = function(t8, s6) {
        return O4(t8, false, true).resolve(s6);
      }, h7.resolveObject = function(t8, s6) {
        return t8 ? O4(t8, false, true).resolveObject(s6) : s6;
      }, h7.format = function(t8) {
        a6.isString(t8) && (t8 = O4(t8));
        return t8 instanceof r8 ? t8.format() : r8.prototype.format.call(t8);
      }, h7.Url = r8;
      o7 = /^([a-z0-9.+-]+:)/i;
      n7 = /:[0-9]*$/;
      i6 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
      l6 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
      p6 = ["'"].concat(l6);
      c6 = ["%", "/", "?", ";", "#"].concat(p6);
      u6 = ["/", "?", "#"];
      f6 = /^[+a-z0-9A-Z_-]{0,63}$/;
      m5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      v5 = { javascript: true, "javascript:": true };
      g4 = { javascript: true, "javascript:": true };
      y5 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
      b4 = o6;
      r8.prototype.parse = function(t8, s6, h8) {
        if (!a6.isString(t8)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t8);
        var r9 = t8.indexOf("?"), n8 = -1 !== r9 && r9 < t8.indexOf("#") ? "?" : "#", l7 = t8.split(n8);
        l7[0] = l7[0].replace(/\\/g, "/");
        var O5 = t8 = l7.join(n8);
        if (O5 = O5.trim(), !h8 && 1 === t8.split("#").length) {
          var d6 = i6.exec(O5);
          if (d6) return this.path = O5, this.href = O5, this.pathname = d6[1], d6[2] ? (this.search = d6[2], this.query = s6 ? b4.parse(this.search.substr(1)) : this.search.substr(1)) : s6 && (this.search = "", this.query = {}), this;
        }
        var j4 = o7.exec(O5);
        if (j4) {
          var q3 = (j4 = j4[0]).toLowerCase();
          this.protocol = q3, O5 = O5.substr(j4.length);
        }
        if (h8 || j4 || O5.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var x4 = "//" === O5.substr(0, 2);
          !x4 || j4 && g4[j4] || (O5 = O5.substr(2), this.slashes = true);
        }
        if (!g4[j4] && (x4 || j4 && !y5[j4])) {
          for (var A4, C4, I4 = -1, w4 = 0; w4 < u6.length; w4++) {
            -1 !== (N10 = O5.indexOf(u6[w4])) && (-1 === I4 || N10 < I4) && (I4 = N10);
          }
          -1 !== (C4 = -1 === I4 ? O5.lastIndexOf("@") : O5.lastIndexOf("@", I4)) && (A4 = O5.slice(0, C4), O5 = O5.slice(C4 + 1), this.auth = decodeURIComponent(A4)), I4 = -1;
          for (w4 = 0; w4 < c6.length; w4++) {
            var N10;
            -1 !== (N10 = O5.indexOf(c6[w4])) && (-1 === I4 || N10 < I4) && (I4 = N10);
          }
          -1 === I4 && (I4 = O5.length), this.host = O5.slice(0, I4), O5 = O5.slice(I4), this.parseHost(), this.hostname = this.hostname || "";
          var U4 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
          if (!U4) for (var k4 = this.hostname.split(/\./), S4 = (w4 = 0, k4.length); w4 < S4; w4++) {
            var R4 = k4[w4];
            if (R4 && !R4.match(f6)) {
              for (var $3 = "", z4 = 0, H3 = R4.length; z4 < H3; z4++) R4.charCodeAt(z4) > 127 ? $3 += "x" : $3 += R4[z4];
              if (!$3.match(f6)) {
                var L4 = k4.slice(0, w4), Z3 = k4.slice(w4 + 1), _4 = R4.match(m5);
                _4 && (L4.push(_4[1]), Z3.unshift(_4[2])), Z3.length && (O5 = "/" + Z3.join(".") + O5), this.hostname = L4.join(".");
                break;
              }
            }
          }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U4 || (this.hostname = e8.toASCII(this.hostname));
          var E4 = this.port ? ":" + this.port : "", P4 = this.hostname || "";
          this.host = P4 + E4, this.href += this.host, U4 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O5[0] && (O5 = "/" + O5));
        }
        if (!v5[q3]) for (w4 = 0, S4 = p6.length; w4 < S4; w4++) {
          var T5 = p6[w4];
          if (-1 !== O5.indexOf(T5)) {
            var B4 = encodeURIComponent(T5);
            B4 === T5 && (B4 = escape(T5)), O5 = O5.split(T5).join(B4);
          }
        }
        var D4 = O5.indexOf("#");
        -1 !== D4 && (this.hash = O5.substr(D4), O5 = O5.slice(0, D4));
        var F4 = O5.indexOf("?");
        if (-1 !== F4 ? (this.search = O5.substr(F4), this.query = O5.substr(F4 + 1), s6 && (this.query = b4.parse(this.query)), O5 = O5.slice(0, F4)) : s6 && (this.search = "", this.query = {}), O5 && (this.pathname = O5), y5[q3] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          E4 = this.pathname || "";
          var G3 = this.search || "";
          this.path = E4 + G3;
        }
        return this.href = this.format(), this;
      }, r8.prototype.format = function() {
        var t8 = this.auth || "";
        t8 && (t8 = (t8 = encodeURIComponent(t8)).replace(/%3A/i, ":"), t8 += "@");
        var s6 = this.protocol || "", h8 = this.pathname || "", e9 = this.hash || "", r9 = false, o8 = "";
        this.host ? r9 = t8 + this.host : this.hostname && (r9 = t8 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r9 += ":" + this.port)), this.query && a6.isObject(this.query) && Object.keys(this.query).length && (o8 = b4.stringify(this.query));
        var n8 = this.search || o8 && "?" + o8 || "";
        return s6 && ":" !== s6.substr(-1) && (s6 += ":"), this.slashes || (!s6 || y5[s6]) && false !== r9 ? (r9 = "//" + (r9 || ""), h8 && "/" !== h8.charAt(0) && (h8 = "/" + h8)) : r9 || (r9 = ""), e9 && "#" !== e9.charAt(0) && (e9 = "#" + e9), n8 && "?" !== n8.charAt(0) && (n8 = "?" + n8), s6 + r9 + (h8 = h8.replace(/[?#]/g, function(t9) {
          return encodeURIComponent(t9);
        })) + (n8 = n8.replace("#", "%23")) + e9;
      }, r8.prototype.resolve = function(t8) {
        return this.resolveObject(O4(t8, false, true)).format();
      }, r8.prototype.resolveObject = function(t8) {
        if (a6.isString(t8)) {
          var s6 = new r8();
          s6.parse(t8, false, true), t8 = s6;
        }
        for (var h8 = new r8(), e9 = Object.keys(this), o8 = 0; o8 < e9.length; o8++) {
          var n8 = e9[o8];
          h8[n8] = this[n8];
        }
        if (h8.hash = t8.hash, "" === t8.href) return h8.href = h8.format(), h8;
        if (t8.slashes && !t8.protocol) {
          for (var i7 = Object.keys(t8), l7 = 0; l7 < i7.length; l7++) {
            var p7 = i7[l7];
            "protocol" !== p7 && (h8[p7] = t8[p7]);
          }
          return y5[h8.protocol] && h8.hostname && !h8.pathname && (h8.path = h8.pathname = "/"), h8.href = h8.format(), h8;
        }
        if (t8.protocol && t8.protocol !== h8.protocol) {
          if (!y5[t8.protocol]) {
            for (var c7 = Object.keys(t8), u7 = 0; u7 < c7.length; u7++) {
              var f7 = c7[u7];
              h8[f7] = t8[f7];
            }
            return h8.href = h8.format(), h8;
          }
          if (h8.protocol = t8.protocol, t8.host || g4[t8.protocol]) h8.pathname = t8.pathname;
          else {
            for (var m6 = (t8.pathname || "").split("/"); m6.length && !(t8.host = m6.shift()); ) ;
            t8.host || (t8.host = ""), t8.hostname || (t8.hostname = ""), "" !== m6[0] && m6.unshift(""), m6.length < 2 && m6.unshift(""), h8.pathname = m6.join("/");
          }
          if (h8.search = t8.search, h8.query = t8.query, h8.host = t8.host || "", h8.auth = t8.auth, h8.hostname = t8.hostname || t8.host, h8.port = t8.port, h8.pathname || h8.search) {
            var v6 = h8.pathname || "", b5 = h8.search || "";
            h8.path = v6 + b5;
          }
          return h8.slashes = h8.slashes || t8.slashes, h8.href = h8.format(), h8;
        }
        var O5 = h8.pathname && "/" === h8.pathname.charAt(0), d6 = t8.host || t8.pathname && "/" === t8.pathname.charAt(0), j4 = d6 || O5 || h8.host && t8.pathname, q3 = j4, x4 = h8.pathname && h8.pathname.split("/") || [], A4 = (m6 = t8.pathname && t8.pathname.split("/") || [], h8.protocol && !y5[h8.protocol]);
        if (A4 && (h8.hostname = "", h8.port = null, h8.host && ("" === x4[0] ? x4[0] = h8.host : x4.unshift(h8.host)), h8.host = "", t8.protocol && (t8.hostname = null, t8.port = null, t8.host && ("" === m6[0] ? m6[0] = t8.host : m6.unshift(t8.host)), t8.host = null), j4 = j4 && ("" === m6[0] || "" === x4[0])), d6) h8.host = t8.host || "" === t8.host ? t8.host : h8.host, h8.hostname = t8.hostname || "" === t8.hostname ? t8.hostname : h8.hostname, h8.search = t8.search, h8.query = t8.query, x4 = m6;
        else if (m6.length) x4 || (x4 = []), x4.pop(), x4 = x4.concat(m6), h8.search = t8.search, h8.query = t8.query;
        else if (!a6.isNullOrUndefined(t8.search)) {
          if (A4) h8.hostname = h8.host = x4.shift(), (U4 = !!(h8.host && h8.host.indexOf("@") > 0) && h8.host.split("@")) && (h8.auth = U4.shift(), h8.host = h8.hostname = U4.shift());
          return h8.search = t8.search, h8.query = t8.query, a6.isNull(h8.pathname) && a6.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : "") + (h8.search ? h8.search : "")), h8.href = h8.format(), h8;
        }
        if (!x4.length) return h8.pathname = null, h8.search ? h8.path = "/" + h8.search : h8.path = null, h8.href = h8.format(), h8;
        for (var C4 = x4.slice(-1)[0], I4 = (h8.host || t8.host || x4.length > 1) && ("." === C4 || ".." === C4) || "" === C4, w4 = 0, N10 = x4.length; N10 >= 0; N10--) "." === (C4 = x4[N10]) ? x4.splice(N10, 1) : ".." === C4 ? (x4.splice(N10, 1), w4++) : w4 && (x4.splice(N10, 1), w4--);
        if (!j4 && !q3) for (; w4--; w4) x4.unshift("..");
        !j4 || "" === x4[0] || x4[0] && "/" === x4[0].charAt(0) || x4.unshift(""), I4 && "/" !== x4.join("/").substr(-1) && x4.push("");
        var U4, k4 = "" === x4[0] || x4[0] && "/" === x4[0].charAt(0);
        A4 && (h8.hostname = h8.host = k4 ? "" : x4.length ? x4.shift() : "", (U4 = !!(h8.host && h8.host.indexOf("@") > 0) && h8.host.split("@")) && (h8.auth = U4.shift(), h8.host = h8.hostname = U4.shift()));
        return (j4 = j4 || h8.host && x4.length) && !k4 && x4.unshift(""), x4.length ? h8.pathname = x4.join("/") : (h8.pathname = null, h8.path = null), a6.isNull(h8.pathname) && a6.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : "") + (h8.search ? h8.search : "")), h8.auth = t8.auth || h8.auth, h8.slashes = h8.slashes || t8.slashes, h8.href = h8.format(), h8;
      }, r8.prototype.parseHost = function() {
        var t8 = this.host, s6 = n7.exec(t8);
        s6 && (":" !== (s6 = s6[0]) && (this.port = s6.substr(1)), t8 = t8.substr(0, t8.length - s6.length)), t8 && (this.hostname = t8);
      };
      h7.Url;
      h7.format;
      h7.resolve;
      h7.resolveObject;
      exports7 = {};
      _dewExec6 = false;
      path = dew6();
      processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      h7.URL = typeof URL !== "undefined" ? URL : null;
      h7.pathToFileURL = pathToFileURL$1;
      h7.fileURLToPath = fileURLToPath$1;
      h7.Url;
      h7.format;
      h7.resolve;
      h7.resolveObject;
      h7.URL;
      CHAR_BACKWARD_SLASH$1 = 92;
      CHAR_FORWARD_SLASH$1 = 47;
      CHAR_LOWERCASE_A$1 = 97;
      CHAR_LOWERCASE_Z$1 = 122;
      isWindows$1 = processPlatform$1 === "win32";
      forwardSlashRegEx$1 = /\//g;
      percentRegEx$1 = /%/g;
      backslashRegEx$1 = /\\/g;
      newlineRegEx$1 = /\n/g;
      carriageReturnRegEx$1 = /\r/g;
      tabRegEx$1 = /\t/g;
      processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      h7.URL = typeof URL !== "undefined" ? URL : null;
      h7.pathToFileURL = pathToFileURL;
      h7.fileURLToPath = fileURLToPath;
      Url = h7.Url;
      format4 = h7.format;
      resolve2 = h7.resolve;
      resolveObject = h7.resolveObject;
      parse3 = h7.parse;
      _URL = h7.URL;
      CHAR_BACKWARD_SLASH = 92;
      CHAR_FORWARD_SLASH = 47;
      CHAR_LOWERCASE_A = 97;
      CHAR_LOWERCASE_Z = 122;
      isWindows = processPlatform === "win32";
      forwardSlashRegEx = /\//g;
      percentRegEx = /%/g;
      backslashRegEx = /\\/g;
      newlineRegEx = /\n/g;
      carriageReturnRegEx = /\r/g;
      tabRegEx = /\t/g;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/util.js
  var require_util = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/util.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.unixify = exports9.getWriteSyncArgs = exports9.getWriteArgs = exports9.bufToUint8 = exports9.isWin = void 0;
      exports9.promisify = promisify3;
      exports9.validateCallback = validateCallback;
      exports9.modeToNumber = modeToNumber;
      exports9.nullCheck = nullCheck;
      exports9.pathToFilename = pathToFilename;
      exports9.createError = createError;
      exports9.genRndStr6 = genRndStr6;
      exports9.flagsToNumber = flagsToNumber;
      exports9.isFd = isFd;
      exports9.validateFd = validateFd;
      exports9.dataToBuffer = dataToBuffer;
      exports9.bufferToEncoding = bufferToEncoding;
      var constants_1 = require_constants2();
      var errors = require_errors();
      var buffer_1 = require_buffer();
      var encoding_1 = require_encoding();
      var buffer_2 = require_buffer();
      var queueMicrotask_1 = require_queueMicrotask();
      exports9.isWin = process.platform === "win32";
      function promisify3(fs3, fn, getResult = (input) => input) {
        return (...args) => new Promise((resolve9, reject) => {
          fs3[fn].bind(fs3)(...args, (error, result) => {
            if (error)
              return reject(error);
            return resolve9(getResult(result));
          });
        });
      }
      function validateCallback(callback) {
        if (typeof callback !== "function")
          throw TypeError(constants_1.ERRSTR.CB);
        return callback;
      }
      function _modeToNumber(mode, def) {
        if (typeof mode === "number")
          return mode;
        if (typeof mode === "string")
          return parseInt(mode, 8);
        if (def)
          return modeToNumber(def);
        return void 0;
      }
      function modeToNumber(mode, def) {
        const result = _modeToNumber(mode, def);
        if (typeof result !== "number" || isNaN(result))
          throw new TypeError(constants_1.ERRSTR.MODE_INT);
        return result;
      }
      function nullCheck(path2, callback) {
        if (("" + path2).indexOf("\0") !== -1) {
          const er = new Error("Path must be a string without null bytes");
          er.code = "ENOENT";
          if (typeof callback !== "function")
            throw er;
          (0, queueMicrotask_1.default)(() => {
            callback(er);
          });
          return false;
        }
        return true;
      }
      function getPathFromURLPosix2(url) {
        if (url.hostname !== "") {
          throw new errors.TypeError("ERR_INVALID_FILE_URL_HOST", process.platform);
        }
        const pathname = url.pathname;
        for (let n8 = 0; n8 < pathname.length; n8++) {
          if (pathname[n8] === "%") {
            const third = pathname.codePointAt(n8 + 2) | 32;
            if (pathname[n8 + 1] === "2" && third === 102) {
              throw new errors.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
            }
          }
        }
        return decodeURIComponent(pathname);
      }
      function pathToFilename(path2) {
        if (typeof path2 !== "string" && !buffer_1.Buffer.isBuffer(path2)) {
          try {
            if (!(path2 instanceof (init_url(), __toCommonJS(url_exports)).URL))
              throw new TypeError(constants_1.ERRSTR.PATH_STR);
          } catch (err) {
            throw new TypeError(constants_1.ERRSTR.PATH_STR);
          }
          path2 = getPathFromURLPosix2(path2);
        }
        const pathString = String(path2);
        nullCheck(pathString);
        return pathString;
      }
      var ENOENT = "ENOENT";
      var EBADF = "EBADF";
      var EINVAL = "EINVAL";
      var EPERM = "EPERM";
      var EPROTO = "EPROTO";
      var EEXIST = "EEXIST";
      var ENOTDIR = "ENOTDIR";
      var EMFILE = "EMFILE";
      var EACCES = "EACCES";
      var EISDIR = "EISDIR";
      var ENOTEMPTY = "ENOTEMPTY";
      var ENOSYS = "ENOSYS";
      var ERR_FS_EISDIR = "ERR_FS_EISDIR";
      var ERR_OUT_OF_RANGE = "ERR_OUT_OF_RANGE";
      function formatError(errorCode, func = "", path2 = "", path22 = "") {
        let pathFormatted = "";
        if (path2)
          pathFormatted = ` '${path2}'`;
        if (path22)
          pathFormatted += ` -> '${path22}'`;
        switch (errorCode) {
          case ENOENT:
            return `ENOENT: no such file or directory, ${func}${pathFormatted}`;
          case EBADF:
            return `EBADF: bad file descriptor, ${func}${pathFormatted}`;
          case EINVAL:
            return `EINVAL: invalid argument, ${func}${pathFormatted}`;
          case EPERM:
            return `EPERM: operation not permitted, ${func}${pathFormatted}`;
          case EPROTO:
            return `EPROTO: protocol error, ${func}${pathFormatted}`;
          case EEXIST:
            return `EEXIST: file already exists, ${func}${pathFormatted}`;
          case ENOTDIR:
            return `ENOTDIR: not a directory, ${func}${pathFormatted}`;
          case EISDIR:
            return `EISDIR: illegal operation on a directory, ${func}${pathFormatted}`;
          case EACCES:
            return `EACCES: permission denied, ${func}${pathFormatted}`;
          case ENOTEMPTY:
            return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
          case EMFILE:
            return `EMFILE: too many open files, ${func}${pathFormatted}`;
          case ENOSYS:
            return `ENOSYS: function not implemented, ${func}${pathFormatted}`;
          case ERR_FS_EISDIR:
            return `[ERR_FS_EISDIR]: Path is a directory: ${func} returned EISDIR (is a directory) ${path2}`;
          case ERR_OUT_OF_RANGE:
            return `[ERR_OUT_OF_RANGE]: value out of range, ${func}${pathFormatted}`;
          default:
            return `${errorCode}: error occurred, ${func}${pathFormatted}`;
        }
      }
      function createError(errorCode, func = "", path2 = "", path22 = "", Constructor = Error) {
        const error = new Constructor(formatError(errorCode, func, path2, path22));
        error.code = errorCode;
        if (path2) {
          error.path = path2;
        }
        return error;
      }
      function genRndStr6() {
        const str = (Math.random() + 1).toString(36).substring(2, 8);
        if (str.length === 6)
          return str;
        else
          return genRndStr6();
      }
      function flagsToNumber(flags) {
        if (typeof flags === "number")
          return flags;
        if (typeof flags === "string") {
          const flagsNum = constants_1.FLAGS[flags];
          if (typeof flagsNum !== "undefined")
            return flagsNum;
        }
        throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
      }
      function isFd(path2) {
        return path2 >>> 0 === path2;
      }
      function validateFd(fd) {
        if (!isFd(fd))
          throw TypeError(constants_1.ERRSTR.FD);
      }
      function dataToBuffer(data, encoding = encoding_1.ENCODING_UTF8) {
        if (buffer_1.Buffer.isBuffer(data))
          return data;
        else if (data instanceof Uint8Array)
          return (0, buffer_2.bufferFrom)(data);
        else
          return (0, buffer_2.bufferFrom)(String(data), encoding);
      }
      var bufToUint8 = (buf3) => new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength);
      exports9.bufToUint8 = bufToUint8;
      var getWriteArgs = (fd, a7, b5, c7, d6, e9) => {
        validateFd(fd);
        let offset = 0;
        let length4;
        let position = null;
        let encoding;
        let callback;
        const tipa = typeof a7;
        const tipb = typeof b5;
        const tipc = typeof c7;
        const tipd = typeof d6;
        if (tipa !== "string") {
          if (tipb === "function") {
            callback = b5;
          } else if (tipc === "function") {
            offset = b5 | 0;
            callback = c7;
          } else if (tipd === "function") {
            offset = b5 | 0;
            length4 = c7;
            callback = d6;
          } else {
            offset = b5 | 0;
            length4 = c7;
            position = d6;
            callback = e9;
          }
        } else {
          if (tipb === "function") {
            callback = b5;
          } else if (tipc === "function") {
            position = b5;
            callback = c7;
          } else if (tipd === "function") {
            position = b5;
            encoding = c7;
            callback = d6;
          }
        }
        const buf3 = dataToBuffer(a7, encoding);
        if (tipa !== "string") {
          if (typeof length4 === "undefined")
            length4 = buf3.length;
        } else {
          offset = 0;
          length4 = buf3.length;
        }
        const cb = validateCallback(callback);
        return [fd, tipa === "string", buf3, offset, length4, position, cb];
      };
      exports9.getWriteArgs = getWriteArgs;
      var getWriteSyncArgs = (fd, a7, b5, c7, d6) => {
        validateFd(fd);
        let encoding;
        let offset;
        let length4;
        let position;
        const isBuffer7 = typeof a7 !== "string";
        if (isBuffer7) {
          offset = (b5 || 0) | 0;
          length4 = c7;
          position = d6;
        } else {
          position = b5;
          encoding = c7;
        }
        const buf3 = dataToBuffer(a7, encoding);
        if (isBuffer7) {
          if (typeof length4 === "undefined") {
            length4 = buf3.length;
          }
        } else {
          offset = 0;
          length4 = buf3.length;
        }
        return [fd, buf3, offset || 0, length4, position];
      };
      exports9.getWriteSyncArgs = getWriteSyncArgs;
      function bufferToEncoding(buffer4, encoding) {
        if (!encoding || encoding === "buffer")
          return buffer4;
        else
          return buffer4.toString(encoding);
      }
      var isSeparator = (str, i7) => {
        let char = str[i7];
        return i7 > 0 && (char === "/" || exports9.isWin && char === "\\");
      };
      var removeTrailingSeparator = (str) => {
        let i7 = str.length - 1;
        if (i7 < 2)
          return str;
        while (isSeparator(str, i7))
          i7--;
        return str.substr(0, i7 + 1);
      };
      var normalizePath = (str, stripTrailing) => {
        if (typeof str !== "string")
          throw new TypeError("expected a string");
        str = str.replace(/[\\\/]+/g, "/");
        if (stripTrailing !== false)
          str = removeTrailingSeparator(str);
        return str;
      };
      var unixify = (filepath, stripTrailing = true) => {
        if (exports9.isWin) {
          filepath = normalizePath(filepath, stripTrailing);
          return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
        }
        return filepath;
      };
      exports9.unixify = unixify;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/FileHandle.js
  var require_FileHandle = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/FileHandle.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.FileHandle = void 0;
      var util_1 = require_util();
      var FileHandle = class {
        constructor(fs3, fd) {
          this.fs = fs3;
          this.fd = fd;
        }
        appendFile(data, options) {
          return (0, util_1.promisify)(this.fs, "appendFile")(this.fd, data, options);
        }
        chmod(mode) {
          return (0, util_1.promisify)(this.fs, "fchmod")(this.fd, mode);
        }
        chown(uid, gid) {
          return (0, util_1.promisify)(this.fs, "fchown")(this.fd, uid, gid);
        }
        close() {
          return (0, util_1.promisify)(this.fs, "close")(this.fd);
        }
        datasync() {
          return (0, util_1.promisify)(this.fs, "fdatasync")(this.fd);
        }
        readableWebStream(options) {
          return new ReadableStream({
            pull: async (controller) => {
              const data = await this.readFile();
              controller.enqueue(data);
              controller.close();
            }
          });
        }
        read(buffer4, offset, length4, position) {
          return (0, util_1.promisify)(this.fs, "read", (bytesRead) => ({ bytesRead, buffer: buffer4 }))(this.fd, buffer4, offset, length4, position);
        }
        readv(buffers, position) {
          return (0, util_1.promisify)(this.fs, "readv", (bytesRead) => ({ bytesRead, buffers }))(this.fd, buffers, position);
        }
        readFile(options) {
          return (0, util_1.promisify)(this.fs, "readFile")(this.fd, options);
        }
        stat(options) {
          return (0, util_1.promisify)(this.fs, "fstat")(this.fd, options);
        }
        sync() {
          return (0, util_1.promisify)(this.fs, "fsync")(this.fd);
        }
        truncate(len) {
          return (0, util_1.promisify)(this.fs, "ftruncate")(this.fd, len);
        }
        utimes(atime, mtime) {
          return (0, util_1.promisify)(this.fs, "futimes")(this.fd, atime, mtime);
        }
        write(buffer4, offset, length4, position) {
          return (0, util_1.promisify)(this.fs, "write", (bytesWritten) => ({ bytesWritten, buffer: buffer4 }))(this.fd, buffer4, offset, length4, position);
        }
        writev(buffers, position) {
          return (0, util_1.promisify)(this.fs, "writev", (bytesWritten) => ({ bytesWritten, buffers }))(this.fd, buffers, position);
        }
        writeFile(data, options) {
          return (0, util_1.promisify)(this.fs, "writeFile")(this.fd, data, options);
        }
      };
      exports9.FileHandle = FileHandle;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/FsPromises.js
  var require_FsPromises = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/FsPromises.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.FsPromises = void 0;
      var util_1 = require_util();
      var constants_1 = require_constants();
      var FsPromises = class {
        constructor(fs3, FileHandle) {
          this.fs = fs3;
          this.FileHandle = FileHandle;
          this.constants = constants_1.constants;
          this.cp = (0, util_1.promisify)(this.fs, "cp");
          this.opendir = (0, util_1.promisify)(this.fs, "opendir");
          this.statfs = (0, util_1.promisify)(this.fs, "statfs");
          this.lutimes = (0, util_1.promisify)(this.fs, "lutimes");
          this.access = (0, util_1.promisify)(this.fs, "access");
          this.chmod = (0, util_1.promisify)(this.fs, "chmod");
          this.chown = (0, util_1.promisify)(this.fs, "chown");
          this.copyFile = (0, util_1.promisify)(this.fs, "copyFile");
          this.lchmod = (0, util_1.promisify)(this.fs, "lchmod");
          this.lchown = (0, util_1.promisify)(this.fs, "lchown");
          this.link = (0, util_1.promisify)(this.fs, "link");
          this.lstat = (0, util_1.promisify)(this.fs, "lstat");
          this.mkdir = (0, util_1.promisify)(this.fs, "mkdir");
          this.mkdtemp = (0, util_1.promisify)(this.fs, "mkdtemp");
          this.readdir = (0, util_1.promisify)(this.fs, "readdir");
          this.readlink = (0, util_1.promisify)(this.fs, "readlink");
          this.realpath = (0, util_1.promisify)(this.fs, "realpath");
          this.rename = (0, util_1.promisify)(this.fs, "rename");
          this.rmdir = (0, util_1.promisify)(this.fs, "rmdir");
          this.rm = (0, util_1.promisify)(this.fs, "rm");
          this.stat = (0, util_1.promisify)(this.fs, "stat");
          this.symlink = (0, util_1.promisify)(this.fs, "symlink");
          this.truncate = (0, util_1.promisify)(this.fs, "truncate");
          this.unlink = (0, util_1.promisify)(this.fs, "unlink");
          this.utimes = (0, util_1.promisify)(this.fs, "utimes");
          this.readFile = (id, options) => {
            return (0, util_1.promisify)(this.fs, "readFile")(id instanceof this.FileHandle ? id.fd : id, options);
          };
          this.appendFile = (path2, data, options) => {
            return (0, util_1.promisify)(this.fs, "appendFile")(path2 instanceof this.FileHandle ? path2.fd : path2, data, options);
          };
          this.open = (path2, flags = "r", mode) => {
            return (0, util_1.promisify)(this.fs, "open", (fd) => new this.FileHandle(this.fs, fd))(path2, flags, mode);
          };
          this.writeFile = (id, data, options) => {
            return (0, util_1.promisify)(this.fs, "writeFile")(id instanceof this.FileHandle ? id.fd : id, data, options);
          };
          this.watch = () => {
            throw new Error("Not implemented");
          };
        }
      };
      exports9.FsPromises = FsPromises;
    }
  });

  // node_modules/.pnpm/tslib@2.6.3/node_modules/tslib/tslib.es6.mjs
  var tslib_es6_exports = {};
  __export(tslib_es6_exports, {
    __addDisposableResource: () => __addDisposableResource,
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldIn: () => __classPrivateFieldIn,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __disposeResources: () => __disposeResources,
    __esDecorate: () => __esDecorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __propKey: () => __propKey,
    __read: () => __read,
    __rest: () => __rest,
    __runInitializers: () => __runInitializers,
    __setFunctionName: () => __setFunctionName,
    __spread: () => __spread,
    __spreadArray: () => __spreadArray,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values,
    default: () => tslib_es6_default
  });
  function __extends(d6, b5) {
    if (typeof b5 !== "function" && b5 !== null)
      throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
    extendStatics(d6, b5);
    function __() {
      this.constructor = d6;
    }
    d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
  }
  function __rest(s6, e9) {
    var t8 = {};
    for (var p7 in s6) if (Object.prototype.hasOwnProperty.call(s6, p7) && e9.indexOf(p7) < 0)
      t8[p7] = s6[p7];
    if (s6 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i7 = 0, p7 = Object.getOwnPropertySymbols(s6); i7 < p7.length; i7++) {
        if (e9.indexOf(p7[i7]) < 0 && Object.prototype.propertyIsEnumerable.call(s6, p7[i7]))
          t8[p7[i7]] = s6[p7[i7]];
      }
    return t8;
  }
  function __decorate(decorators, target, key, desc) {
    var c7 = arguments.length, r9 = c7 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d6;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
    else for (var i7 = decorators.length - 1; i7 >= 0; i7--) if (d6 = decorators[i7]) r9 = (c7 < 3 ? d6(r9) : c7 > 3 ? d6(target, key, r9) : d6(target, key)) || r9;
    return c7 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f7) {
      if (f7 !== void 0 && typeof f7 !== "function") throw new TypeError("Function expected");
      return f7;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _4, done = false;
    for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
      var context2 = {};
      for (var p7 in contextIn) context2[p7] = p7 === "access" ? {} : contextIn[p7];
      for (var p7 in contextIn.access) context2.access[p7] = contextIn.access[p7];
      context2.addInitializer = function(f7) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f7 || null));
      };
      var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_4 = accept(result.get)) descriptor.get = _4;
        if (_4 = accept(result.set)) descriptor.set = _4;
        if (_4 = accept(result.init)) initializers.unshift(_4);
      } else if (_4 = accept(result)) {
        if (kind === "field") initializers.unshift(_4);
        else descriptor[key] = _4;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }
  function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i7 = 0; i7 < initializers.length; i7++) {
      value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
    }
    return useValue ? value : void 0;
  }
  function __propKey(x4) {
    return typeof x4 === "symbol" ? x4 : "".concat(x4);
  }
  function __setFunctionName(f7, name8, prefix) {
    if (typeof name8 === "symbol") name8 = name8.description ? "[".concat(name8.description, "]") : "";
    return Object.defineProperty(f7, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name8) : name8 });
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve9) {
        resolve9(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve9, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step2(result) {
        result.done ? resolve9(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _4 = { label: 0, sent: function() {
      if (t8[0] & 1) throw t8[1];
      return t8[1];
    }, trys: [], ops: [] }, f7, y6, t8, g5;
    return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
      return this;
    }), g5;
    function verb(n8) {
      return function(v6) {
        return step2([n8, v6]);
      };
    }
    function step2(op) {
      if (f7) throw new TypeError("Generator is already executing.");
      while (g5 && (g5 = 0, op[0] && (_4 = 0)), _4) try {
        if (f7 = 1, y6 && (t8 = op[0] & 2 ? y6["return"] : op[0] ? y6["throw"] || ((t8 = y6["return"]) && t8.call(y6), 0) : y6.next) && !(t8 = t8.call(y6, op[1])).done) return t8;
        if (y6 = 0, t8) op = [op[0] & 2, t8.value];
        switch (op[0]) {
          case 0:
          case 1:
            t8 = op;
            break;
          case 4:
            _4.label++;
            return { value: op[1], done: false };
          case 5:
            _4.label++;
            y6 = op[1];
            op = [0];
            continue;
          case 7:
            op = _4.ops.pop();
            _4.trys.pop();
            continue;
          default:
            if (!(t8 = _4.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _4 = 0;
              continue;
            }
            if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
              _4.label = op[1];
              break;
            }
            if (op[0] === 6 && _4.label < t8[1]) {
              _4.label = t8[1];
              t8 = op;
              break;
            }
            if (t8 && _4.label < t8[2]) {
              _4.label = t8[2];
              _4.ops.push(op);
              break;
            }
            if (t8[2]) _4.ops.pop();
            _4.trys.pop();
            continue;
        }
        op = body.call(thisArg, _4);
      } catch (e9) {
        op = [6, e9];
        y6 = 0;
      } finally {
        f7 = t8 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __exportStar(m6, o8) {
    for (var p7 in m6) if (p7 !== "default" && !Object.prototype.hasOwnProperty.call(o8, p7)) __createBinding(o8, m6, p7);
  }
  function __values(o8) {
    var s6 = typeof Symbol === "function" && Symbol.iterator, m6 = s6 && o8[s6], i7 = 0;
    if (m6) return m6.call(o8);
    if (o8 && typeof o8.length === "number") return {
      next: function() {
        if (o8 && i7 >= o8.length) o8 = void 0;
        return { value: o8 && o8[i7++], done: !o8 };
      }
    };
    throw new TypeError(s6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o8, n8) {
    var m6 = typeof Symbol === "function" && o8[Symbol.iterator];
    if (!m6) return o8;
    var i7 = m6.call(o8), r9, ar = [], e9;
    try {
      while ((n8 === void 0 || n8-- > 0) && !(r9 = i7.next()).done) ar.push(r9.value);
    } catch (error) {
      e9 = { error };
    } finally {
      try {
        if (r9 && !r9.done && (m6 = i7["return"])) m6.call(i7);
      } finally {
        if (e9) throw e9.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i7 = 0; i7 < arguments.length; i7++)
      ar = ar.concat(__read(arguments[i7]));
    return ar;
  }
  function __spreadArrays() {
    for (var s6 = 0, i7 = 0, il = arguments.length; i7 < il; i7++) s6 += arguments[i7].length;
    for (var r9 = Array(s6), k4 = 0, i7 = 0; i7 < il; i7++)
      for (var a7 = arguments[i7], j4 = 0, jl = a7.length; j4 < jl; j4++, k4++)
        r9[k4] = a7[j4];
    return r9;
  }
  function __spreadArray(to, from8, pack) {
    if (pack || arguments.length === 2) for (var i7 = 0, l7 = from8.length, ar; i7 < l7; i7++) {
      if (ar || !(i7 in from8)) {
        if (!ar) ar = Array.prototype.slice.call(from8, 0, i7);
        ar[i7] = from8[i7];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from8));
  }
  function __await(v6) {
    return this instanceof __await ? (this.v = v6, this) : new __await(v6);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g5 = generator.apply(thisArg, _arguments || []), i7, q3 = [];
    return i7 = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i7[Symbol.asyncIterator] = function() {
      return this;
    }, i7;
    function awaitReturn(f7) {
      return function(v6) {
        return Promise.resolve(v6).then(f7, reject);
      };
    }
    function verb(n8, f7) {
      if (g5[n8]) {
        i7[n8] = function(v6) {
          return new Promise(function(a7, b5) {
            q3.push([n8, v6, a7, b5]) > 1 || resume2(n8, v6);
          });
        };
        if (f7) i7[n8] = f7(i7[n8]);
      }
    }
    function resume2(n8, v6) {
      try {
        step2(g5[n8](v6));
      } catch (e9) {
        settle(q3[0][3], e9);
      }
    }
    function step2(r9) {
      r9.value instanceof __await ? Promise.resolve(r9.value.v).then(fulfill, reject) : settle(q3[0][2], r9);
    }
    function fulfill(value) {
      resume2("next", value);
    }
    function reject(value) {
      resume2("throw", value);
    }
    function settle(f7, v6) {
      if (f7(v6), q3.shift(), q3.length) resume2(q3[0][0], q3[0][1]);
    }
  }
  function __asyncDelegator(o8) {
    var i7, p7;
    return i7 = {}, verb("next"), verb("throw", function(e9) {
      throw e9;
    }), verb("return"), i7[Symbol.iterator] = function() {
      return this;
    }, i7;
    function verb(n8, f7) {
      i7[n8] = o8[n8] ? function(v6) {
        return (p7 = !p7) ? { value: __await(o8[n8](v6)), done: false } : f7 ? f7(v6) : v6;
      } : f7;
    }
  }
  function __asyncValues(o8) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m6 = o8[Symbol.asyncIterator], i7;
    return m6 ? m6.call(o8) : (o8 = typeof __values === "function" ? __values(o8) : o8[Symbol.iterator](), i7 = {}, verb("next"), verb("throw"), verb("return"), i7[Symbol.asyncIterator] = function() {
      return this;
    }, i7);
    function verb(n8) {
      i7[n8] = o8[n8] && function(v6) {
        return new Promise(function(resolve9, reject) {
          v6 = o8[n8](v6), settle(resolve9, reject, v6.done, v6.value);
        });
      };
    }
    function settle(resolve9, reject, d6, v6) {
      Promise.resolve(v6).then(function(v7) {
        resolve9({ value: v7, done: d6 });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k4 in mod2) if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4)) __createBinding(result, mod2, k4);
    }
    __setModuleDefault(result, mod2);
    return result;
  }
  function __importDefault(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  }
  function __classPrivateFieldGet(receiver, state, kind, f7) {
    if (kind === "a" && !f7) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f7 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f7 : kind === "a" ? f7.call(receiver) : f7 ? f7.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f7) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f7) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f7 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f7.call(receiver, value) : f7 ? f7.value = value : state.set(receiver, value), value;
  }
  function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  }
  function __addDisposableResource(env2, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e9) {
          return Promise.reject(e9);
        }
      };
      env2.stack.push({ value, dispose, async });
    } else if (async) {
      env2.stack.push({ async: true });
    }
    return value;
  }
  function __disposeResources(env2) {
    function fail2(e9) {
      env2.error = env2.hasError ? new _SuppressedError(e9, env2.error, "An error was suppressed during disposal.") : e9;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next, function(e9) {
            fail2(e9);
            return next();
          });
        } catch (e9) {
          fail2(e9);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    return next();
  }
  var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
  var init_tslib_es6 = __esm({
    "node_modules/.pnpm/tslib@2.6.3/node_modules/tslib/tslib.es6.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      extendStatics = function(d6, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b6) {
          d7.__proto__ = b6;
        } || function(d7, b6) {
          for (var p7 in b6) if (Object.prototype.hasOwnProperty.call(b6, p7)) d7[p7] = b6[p7];
        };
        return extendStatics(d6, b5);
      };
      __assign = function() {
        __assign = Object.assign || function __assign2(t8) {
          for (var s6, i7 = 1, n8 = arguments.length; i7 < n8; i7++) {
            s6 = arguments[i7];
            for (var p7 in s6) if (Object.prototype.hasOwnProperty.call(s6, p7)) t8[p7] = s6[p7];
          }
          return t8;
        };
        return __assign.apply(this, arguments);
      };
      __createBinding = Object.create ? function(o8, m6, k4, k22) {
        if (k22 === void 0) k22 = k4;
        var desc = Object.getOwnPropertyDescriptor(m6, k4);
        if (!desc || ("get" in desc ? !m6.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m6[k4];
          } };
        }
        Object.defineProperty(o8, k22, desc);
      } : function(o8, m6, k4, k22) {
        if (k22 === void 0) k22 = k4;
        o8[k22] = m6[k4];
      };
      __setModuleDefault = Object.create ? function(o8, v6) {
        Object.defineProperty(o8, "default", { enumerable: true, value: v6 });
      } : function(o8, v6) {
        o8["default"] = v6;
      };
      _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
        var e9 = new Error(message2);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      };
      tslib_es6_default = {
        __extends,
        __assign,
        __rest,
        __decorate,
        __param,
        __metadata,
        __awaiter,
        __generator,
        __createBinding,
        __exportStar,
        __values,
        __read,
        __spread,
        __spreadArrays,
        __spreadArray,
        __await,
        __asyncGenerator,
        __asyncDelegator,
        __asyncValues,
        __makeTemplateObject,
        __importStar,
        __importDefault,
        __classPrivateFieldGet,
        __classPrivateFieldSet,
        __classPrivateFieldIn,
        __addDisposableResource,
        __disposeResources
      };
    }
  });

  // node_modules/.pnpm/tree-dump@1.0.2_tslib@2.6.3/node_modules/tree-dump/lib/printTree.js
  var require_printTree = __commonJS({
    "node_modules/.pnpm/tree-dump@1.0.2_tslib@2.6.3/node_modules/tree-dump/lib/printTree.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.printTree = void 0;
      var printTree = (tab = "", children) => {
        let str = "";
        let last2 = children.length - 1;
        for (; last2 >= 0; last2--)
          if (children[last2])
            break;
        for (let i7 = 0; i7 <= last2; i7++) {
          const fn = children[i7];
          if (!fn)
            continue;
          const isLast = i7 === last2;
          const child = fn(tab + (isLast ? " " : "\u2502") + "  ");
          const branch = child ? isLast ? "\u2514\u2500" : "\u251C\u2500" : "\u2502";
          str += "\n" + tab + branch + (child ? " " + child : "");
        }
        return str;
      };
      exports9.printTree = printTree;
    }
  });

  // node_modules/.pnpm/tree-dump@1.0.2_tslib@2.6.3/node_modules/tree-dump/lib/printBinary.js
  var require_printBinary = __commonJS({
    "node_modules/.pnpm/tree-dump@1.0.2_tslib@2.6.3/node_modules/tree-dump/lib/printBinary.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.printBinary = void 0;
      var printBinary = (tab = "", children) => {
        const left = children[0], right = children[1];
        let str = "";
        if (left)
          str += "\n" + tab + "\u2190 " + left(tab + "  ");
        if (right)
          str += "\n" + tab + "\u2192 " + right(tab + "  ");
        return str;
      };
      exports9.printBinary = printBinary;
    }
  });

  // node_modules/.pnpm/tree-dump@1.0.2_tslib@2.6.3/node_modules/tree-dump/lib/index.js
  var require_lib = __commonJS({
    "node_modules/.pnpm/tree-dump@1.0.2_tslib@2.6.3/node_modules/tree-dump/lib/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_printTree(), exports9);
      tslib_1.__exportStar(require_printBinary(), exports9);
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node-to-fsa/util.js
  var require_util2 = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node-to-fsa/util.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.newNotAllowedError = exports9.newTypeMismatchError = exports9.newNotFoundError = exports9.assertCanWrite = exports9.assertName = exports9.basename = exports9.ctx = void 0;
      var ctx = (partial = {}) => {
        return Object.assign({ separator: "/", syncHandleAllowed: false, mode: "read" }, partial);
      };
      exports9.ctx = ctx;
      var basename2 = (path2, separator) => {
        if (path2[path2.length - 1] === separator)
          path2 = path2.slice(0, -1);
        const lastSlashIndex = path2.lastIndexOf(separator);
        return lastSlashIndex === -1 ? path2 : path2.slice(lastSlashIndex + 1);
      };
      exports9.basename = basename2;
      var nameRegex = /^(\.{1,2})$|^(.*([\/\\]).*)$/;
      var assertName = (name8, method, klass) => {
        const isInvalid = !name8 || nameRegex.test(name8);
        if (isInvalid)
          throw new TypeError(`Failed to execute '${method}' on '${klass}': Name is not allowed.`);
      };
      exports9.assertName = assertName;
      var assertCanWrite = (mode) => {
        if (mode !== "readwrite")
          throw new DOMException("The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError");
      };
      exports9.assertCanWrite = assertCanWrite;
      var newNotFoundError = () => new DOMException("A requested file or directory could not be found at the time an operation was processed.", "NotFoundError");
      exports9.newNotFoundError = newNotFoundError;
      var newTypeMismatchError = () => new DOMException("The path supplied exists, but was not an entry of requested type.", "TypeMismatchError");
      exports9.newTypeMismatchError = newTypeMismatchError;
      var newNotAllowedError = () => new DOMException("Permission not granted.", "NotAllowedError");
      exports9.newNotAllowedError = newNotAllowedError;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/print/index.js
  var require_print = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/print/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.toTreeSync = void 0;
      var tree_dump_1 = require_lib();
      var util_1 = require_util2();
      var toTreeSync = (fs3, opts = {}) => {
        var _a;
        const separator = opts.separator || "/";
        let dir = opts.dir || separator;
        if (dir[dir.length - 1] !== separator)
          dir += separator;
        const tab = opts.tab || "";
        const depth = (_a = opts.depth) !== null && _a !== void 0 ? _a : 10;
        let subtree = " (...)";
        if (depth > 0) {
          const list = fs3.readdirSync(dir, { withFileTypes: true });
          subtree = (0, tree_dump_1.printTree)(tab, list.map((entry) => (tab2) => {
            if (entry.isDirectory()) {
              return (0, exports9.toTreeSync)(fs3, { dir: dir + entry.name, depth: depth - 1, tab: tab2 });
            } else if (entry.isSymbolicLink()) {
              return "" + entry.name + " \u2192 " + fs3.readlinkSync(dir + entry.name);
            } else {
              return "" + entry.name;
            }
          }));
        }
        const base3 = (0, util_1.basename)(dir, separator) + separator;
        return base3 + subtree;
      };
      exports9.toTreeSync = toTreeSync;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/options.js
  var require_options = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/options.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.getWriteFileOptions = exports9.writeFileDefaults = exports9.getRealpathOptsAndCb = exports9.getRealpathOptions = exports9.getStatOptsAndCb = exports9.getStatOptions = exports9.getAppendFileOptsAndCb = exports9.getAppendFileOpts = exports9.getOpendirOptsAndCb = exports9.getOpendirOptions = exports9.getReaddirOptsAndCb = exports9.getReaddirOptions = exports9.getReadFileOptions = exports9.getRmOptsAndCb = exports9.getRmdirOptions = exports9.getDefaultOptsAndCb = exports9.getDefaultOpts = exports9.optsDefaults = exports9.getMkdirOptions = void 0;
      exports9.getOptions = getOptions;
      exports9.optsGenerator = optsGenerator;
      exports9.optsAndCbGenerator = optsAndCbGenerator;
      var constants_1 = require_constants2();
      var encoding_1 = require_encoding();
      var util_1 = require_util();
      var mkdirDefaults = {
        mode: 511,
        recursive: false
      };
      var getMkdirOptions = (options) => {
        if (typeof options === "number")
          return Object.assign({}, mkdirDefaults, { mode: options });
        return Object.assign({}, mkdirDefaults, options);
      };
      exports9.getMkdirOptions = getMkdirOptions;
      var ERRSTR_OPTS = (tipeof) => `Expected options to be either an object or a string, but got ${tipeof} instead`;
      function getOptions(defaults5, options) {
        let opts;
        if (!options)
          return defaults5;
        else {
          const tipeof = typeof options;
          switch (tipeof) {
            case "string":
              opts = Object.assign({}, defaults5, { encoding: options });
              break;
            case "object":
              opts = Object.assign({}, defaults5, options);
              break;
            default:
              throw TypeError(ERRSTR_OPTS(tipeof));
          }
        }
        if (opts.encoding !== "buffer")
          (0, encoding_1.assertEncoding)(opts.encoding);
        return opts;
      }
      function optsGenerator(defaults5) {
        return (options) => getOptions(defaults5, options);
      }
      function optsAndCbGenerator(getOpts) {
        return (options, callback) => typeof options === "function" ? [getOpts(), options] : [getOpts(options), (0, util_1.validateCallback)(callback)];
      }
      exports9.optsDefaults = {
        encoding: "utf8"
      };
      exports9.getDefaultOpts = optsGenerator(exports9.optsDefaults);
      exports9.getDefaultOptsAndCb = optsAndCbGenerator(exports9.getDefaultOpts);
      var rmdirDefaults = {
        recursive: false
      };
      var getRmdirOptions = (options) => {
        return Object.assign({}, rmdirDefaults, options);
      };
      exports9.getRmdirOptions = getRmdirOptions;
      var getRmOpts = optsGenerator(exports9.optsDefaults);
      exports9.getRmOptsAndCb = optsAndCbGenerator(getRmOpts);
      var readFileOptsDefaults = {
        flag: "r"
      };
      exports9.getReadFileOptions = optsGenerator(readFileOptsDefaults);
      var readdirDefaults = {
        encoding: "utf8",
        recursive: false,
        withFileTypes: false
      };
      exports9.getReaddirOptions = optsGenerator(readdirDefaults);
      exports9.getReaddirOptsAndCb = optsAndCbGenerator(exports9.getReaddirOptions);
      var opendirDefaults = {
        encoding: "utf8",
        bufferSize: 32,
        recursive: false
      };
      exports9.getOpendirOptions = optsGenerator(opendirDefaults);
      exports9.getOpendirOptsAndCb = optsAndCbGenerator(exports9.getOpendirOptions);
      var appendFileDefaults = {
        encoding: "utf8",
        mode: 438,
        flag: constants_1.FLAGS[constants_1.FLAGS.a]
      };
      exports9.getAppendFileOpts = optsGenerator(appendFileDefaults);
      exports9.getAppendFileOptsAndCb = optsAndCbGenerator(exports9.getAppendFileOpts);
      var statDefaults = {
        bigint: false
      };
      var getStatOptions = (options = {}) => Object.assign({}, statDefaults, options);
      exports9.getStatOptions = getStatOptions;
      var getStatOptsAndCb = (options, callback) => typeof options === "function" ? [(0, exports9.getStatOptions)(), options] : [(0, exports9.getStatOptions)(options), (0, util_1.validateCallback)(callback)];
      exports9.getStatOptsAndCb = getStatOptsAndCb;
      var realpathDefaults = exports9.optsDefaults;
      exports9.getRealpathOptions = optsGenerator(realpathDefaults);
      exports9.getRealpathOptsAndCb = optsAndCbGenerator(exports9.getRealpathOptions);
      exports9.writeFileDefaults = {
        encoding: "utf8",
        mode: 438,
        flag: constants_1.FLAGS[constants_1.FLAGS.w]
      };
      exports9.getWriteFileOptions = optsGenerator(exports9.writeFileDefaults);
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/Dir.js
  var require_Dir = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/Dir.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.Dir = void 0;
      var util_1 = require_util();
      var Dirent_1 = require_Dirent();
      var Dir2 = class {
        constructor(link4, options) {
          this.link = link4;
          this.options = options;
          this.iteratorInfo = [];
          this.path = link4.getParentPath();
          this.iteratorInfo.push(link4.children[Symbol.iterator]());
        }
        wrapAsync(method, args, callback) {
          (0, util_1.validateCallback)(callback);
          setImmediate(() => {
            let result;
            try {
              result = method.apply(this, args);
            } catch (err) {
              callback(err);
              return;
            }
            callback(null, result);
          });
        }
        isFunction(x4) {
          return typeof x4 === "function";
        }
        promisify(obj, fn) {
          return (...args) => new Promise((resolve9, reject) => {
            if (this.isFunction(obj[fn])) {
              obj[fn].bind(obj)(...args, (error, result) => {
                if (error)
                  reject(error);
                resolve9(result);
              });
            } else {
              reject("Not a function");
            }
          });
        }
        closeBase() {
        }
        readBase(iteratorInfo) {
          let done;
          let value;
          let name8;
          let link4;
          do {
            do {
              ({ done, value } = iteratorInfo[iteratorInfo.length - 1].next());
              if (!done) {
                [name8, link4] = value;
              } else {
                break;
              }
            } while (name8 === "." || name8 === "..");
            if (done) {
              iteratorInfo.pop();
              if (iteratorInfo.length === 0) {
                break;
              } else {
                done = false;
              }
            } else {
              if (this.options.recursive && link4.children.size) {
                iteratorInfo.push(link4.children[Symbol.iterator]());
              }
              return Dirent_1.default.build(link4, this.options.encoding);
            }
          } while (!done);
          return null;
        }
        closeBaseAsync(callback) {
          this.wrapAsync(this.closeBase, [], callback);
        }
        close(callback) {
          if (typeof callback === "function") {
            this.closeBaseAsync(callback);
          } else {
            return this.promisify(this, "closeBaseAsync")();
          }
        }
        closeSync() {
          this.closeBase();
        }
        readBaseAsync(callback) {
          this.wrapAsync(this.readBase, [this.iteratorInfo], callback);
        }
        read(callback) {
          if (typeof callback === "function") {
            this.readBaseAsync(callback);
          } else {
            return this.promisify(this, "readBaseAsync")();
          }
        }
        readSync() {
          return this.readBase(this.iteratorInfo);
        }
        [Symbol.asyncIterator]() {
          const iteratorInfo = [];
          const _this = this;
          iteratorInfo.push(_this.link.children[Symbol.iterator]());
          const o8 = {
            readBaseAsync(callback) {
              _this.wrapAsync(_this.readBase, [iteratorInfo], callback);
            }
          };
          return {
            async next() {
              const dirEnt = await _this.promisify(o8, "readBaseAsync")();
              if (dirEnt !== null) {
                return { done: false, value: dirEnt };
              } else {
                return { done: true, value: void 0 };
              }
            },
            [Symbol.asyncIterator]() {
              throw new Error("Not implemented");
            }
          };
        }
      };
      exports9.Dir = Dir2;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/volume.js
  var require_volume = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/volume.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.FSWatcher = exports9.StatWatcher = exports9.Volume = void 0;
      exports9.filenameToSteps = filenameToSteps;
      exports9.pathToSteps = pathToSteps;
      exports9.dataToStr = dataToStr;
      exports9.toUnixTimestamp = toUnixTimestamp;
      var pathModule = (init_path(), __toCommonJS(path_exports));
      var node_1 = require_node();
      var Stats_1 = require_Stats();
      var Dirent_1 = require_Dirent();
      var buffer_1 = require_buffer();
      var setImmediate_1 = require_setImmediate();
      var queueMicrotask_1 = require_queueMicrotask();
      var process_1 = require_process();
      var setTimeoutUnref_1 = require_setTimeoutUnref();
      var stream_1 = (init_stream(), __toCommonJS(stream_exports));
      var constants_1 = require_constants();
      var events_1 = (init_events(), __toCommonJS(events_exports));
      var encoding_1 = require_encoding();
      var FileHandle_1 = require_FileHandle();
      var util = (init_util(), __toCommonJS(util_exports));
      var FsPromises_1 = require_FsPromises();
      var print_1 = require_print();
      var constants_2 = require_constants2();
      var options_1 = require_options();
      var util_1 = require_util();
      var Dir_1 = require_Dir();
      var resolveCrossPlatform = pathModule.resolve;
      var { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_TRUNC, O_APPEND, O_DIRECTORY, O_SYMLINK, F_OK: F_OK2, COPYFILE_EXCL, COPYFILE_FICLONE_FORCE } = constants_1.constants;
      var { sep: sep2, relative: relative2, join: join3, dirname: dirname2 } = pathModule.posix ? pathModule.posix : pathModule;
      var kMinPoolSpace = 128;
      var EPERM = "EPERM";
      var ENOENT = "ENOENT";
      var EBADF = "EBADF";
      var EINVAL = "EINVAL";
      var EEXIST = "EEXIST";
      var ENOTDIR = "ENOTDIR";
      var EMFILE = "EMFILE";
      var EACCES = "EACCES";
      var EISDIR = "EISDIR";
      var ENOTEMPTY = "ENOTEMPTY";
      var ENOSYS = "ENOSYS";
      var ERR_FS_EISDIR = "ERR_FS_EISDIR";
      var ERR_OUT_OF_RANGE = "ERR_OUT_OF_RANGE";
      var resolve9 = (filename, base3 = process_1.default.cwd()) => resolveCrossPlatform(base3, filename);
      if (util_1.isWin) {
        const _resolve = resolve9;
        resolve9 = (filename, base3) => (0, util_1.unixify)(_resolve(filename, base3));
      }
      function filenameToSteps(filename, base3) {
        const fullPath = resolve9(filename, base3);
        const fullPathSansSlash = fullPath.substring(1);
        if (!fullPathSansSlash)
          return [];
        return fullPathSansSlash.split(sep2);
      }
      function pathToSteps(path2) {
        return filenameToSteps((0, util_1.pathToFilename)(path2));
      }
      function dataToStr(data, encoding = encoding_1.ENCODING_UTF8) {
        if (buffer_1.Buffer.isBuffer(data))
          return data.toString(encoding);
        else if (data instanceof Uint8Array)
          return (0, buffer_1.bufferFrom)(data).toString(encoding);
        else
          return String(data);
      }
      function toUnixTimestamp(time2) {
        if (typeof time2 === "string" && +time2 == time2) {
          return +time2;
        }
        if (time2 instanceof Date) {
          return time2.getTime() / 1e3;
        }
        if (isFinite(time2)) {
          if (time2 < 0) {
            return Date.now() / 1e3;
          }
          return time2;
        }
        throw new Error("Cannot parse time: " + time2);
      }
      function validateUid(uid) {
        if (typeof uid !== "number")
          throw TypeError(constants_2.ERRSTR.UID);
      }
      function validateGid(gid) {
        if (typeof gid !== "number")
          throw TypeError(constants_2.ERRSTR.GID);
      }
      function flattenJSON(nestedJSON) {
        const flatJSON = {};
        function flatten(pathPrefix, node) {
          for (const path2 in node) {
            const contentOrNode = node[path2];
            const joinedPath = join3(pathPrefix, path2);
            if (typeof contentOrNode === "string" || contentOrNode instanceof buffer_1.Buffer) {
              flatJSON[joinedPath] = contentOrNode;
            } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
              flatten(joinedPath, contentOrNode);
            } else {
              flatJSON[joinedPath] = null;
            }
          }
        }
        flatten("", nestedJSON);
        return flatJSON;
      }
      var notImplemented = () => {
        throw new Error("Not implemented");
      };
      var Volume = class _Volume {
        static fromJSON(json, cwd2) {
          const vol2 = new _Volume();
          vol2.fromJSON(json, cwd2);
          return vol2;
        }
        static fromNestedJSON(json, cwd2) {
          const vol2 = new _Volume();
          vol2.fromNestedJSON(json, cwd2);
          return vol2;
        }
        get promises() {
          if (this.promisesApi === null)
            throw new Error("Promise is not supported in this environment.");
          return this.promisesApi;
        }
        constructor(props = {}) {
          this.ino = 0;
          this.inodes = {};
          this.releasedInos = [];
          this.fds = {};
          this.releasedFds = [];
          this.maxFiles = 1e4;
          this.openFiles = 0;
          this.promisesApi = new FsPromises_1.FsPromises(this, FileHandle_1.FileHandle);
          this.statWatchers = {};
          this.cpSync = notImplemented;
          this.lutimesSync = notImplemented;
          this.statfsSync = notImplemented;
          this.cp = notImplemented;
          this.lutimes = notImplemented;
          this.statfs = notImplemented;
          this.openAsBlob = notImplemented;
          this.props = Object.assign({ Node: node_1.Node, Link: node_1.Link, File: node_1.File }, props);
          const root2 = this.createLink();
          root2.setNode(this.createNode(true));
          const self2 = this;
          this.StatWatcher = class extends StatWatcher {
            constructor() {
              super(self2);
            }
          };
          const _ReadStream = FsReadStream;
          this.ReadStream = class extends _ReadStream {
            constructor(...args) {
              super(self2, ...args);
            }
          };
          const _WriteStream = FsWriteStream;
          this.WriteStream = class extends _WriteStream {
            constructor(...args) {
              super(self2, ...args);
            }
          };
          this.FSWatcher = class extends FSWatcher {
            constructor() {
              super(self2);
            }
          };
          root2.setChild(".", root2);
          root2.getNode().nlink++;
          root2.setChild("..", root2);
          root2.getNode().nlink++;
          this.root = root2;
        }
        createLink(parent, name8, isDirectory = false, perm) {
          if (!parent) {
            return new this.props.Link(this, null, "");
          }
          if (!name8) {
            throw new Error("createLink: name cannot be empty");
          }
          return parent.createChild(name8, this.createNode(isDirectory, perm));
        }
        deleteLink(link4) {
          const parent = link4.parent;
          if (parent) {
            parent.deleteChild(link4);
            return true;
          }
          return false;
        }
        newInoNumber() {
          const releasedFd = this.releasedInos.pop();
          if (releasedFd)
            return releasedFd;
          else {
            this.ino = (this.ino + 1) % 4294967295;
            return this.ino;
          }
        }
        newFdNumber() {
          const releasedFd = this.releasedFds.pop();
          return typeof releasedFd === "number" ? releasedFd : _Volume.fd--;
        }
        createNode(isDirectory = false, perm) {
          perm !== null && perm !== void 0 ? perm : perm = isDirectory ? 511 : 438;
          const node = new this.props.Node(this.newInoNumber(), perm);
          if (isDirectory)
            node.setIsDirectory();
          this.inodes[node.ino] = node;
          return node;
        }
        deleteNode(node) {
          node.del();
          delete this.inodes[node.ino];
          this.releasedInos.push(node.ino);
        }
        walk(stepsOrFilenameOrLink, resolveSymlinks = false, checkExistence = false, checkAccess = false, funcName) {
          var _a;
          let steps;
          let filename;
          if (stepsOrFilenameOrLink instanceof node_1.Link) {
            steps = stepsOrFilenameOrLink.steps;
            filename = sep2 + steps.join(sep2);
          } else if (typeof stepsOrFilenameOrLink === "string") {
            steps = filenameToSteps(stepsOrFilenameOrLink);
            filename = stepsOrFilenameOrLink;
          } else {
            steps = stepsOrFilenameOrLink;
            filename = sep2 + steps.join(sep2);
          }
          let curr = this.root;
          let i7 = 0;
          while (i7 < steps.length) {
            let node = curr.getNode();
            if (node.isDirectory()) {
              if (checkAccess && !node.canExecute()) {
                throw (0, util_1.createError)(EACCES, funcName, filename);
              }
            } else {
              if (i7 < steps.length - 1)
                throw (0, util_1.createError)(ENOTDIR, funcName, filename);
            }
            curr = (_a = curr.getChild(steps[i7])) !== null && _a !== void 0 ? _a : null;
            if (!curr)
              if (checkExistence)
                throw (0, util_1.createError)(ENOENT, funcName, filename);
              else
                return null;
            node = curr === null || curr === void 0 ? void 0 : curr.getNode();
            if (resolveSymlinks && node.isSymlink()) {
              steps = node.symlink.concat(steps.slice(i7 + 1));
              curr = this.root;
              i7 = 0;
              continue;
            }
            i7++;
          }
          return curr;
        }
        // Returns a `Link` (hard link) referenced by path "split" into steps.
        getLink(steps) {
          return this.walk(steps, false, false, false);
        }
        // Just link `getLink`, but throws a correct user error, if link to found.
        getLinkOrThrow(filename, funcName) {
          return this.walk(filename, false, true, true, funcName);
        }
        // Just like `getLink`, but also dereference/resolves symbolic links.
        getResolvedLink(filenameOrSteps) {
          return this.walk(filenameOrSteps, true, false, false);
        }
        // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.
        getResolvedLinkOrThrow(filename, funcName) {
          return this.walk(filename, true, true, true, funcName);
        }
        resolveSymlinks(link4) {
          return this.getResolvedLink(link4.steps.slice(1));
        }
        // Just like `getLinkOrThrow`, but also verifies that the link is a directory.
        getLinkAsDirOrThrow(filename, funcName) {
          const link4 = this.getLinkOrThrow(filename, funcName);
          if (!link4.getNode().isDirectory())
            throw (0, util_1.createError)(ENOTDIR, funcName, filename);
          return link4;
        }
        // Get the immediate parent directory of the link.
        getLinkParent(steps) {
          return this.getLink(steps.slice(0, -1));
        }
        getLinkParentAsDirOrThrow(filenameOrSteps, funcName) {
          const steps = (filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps)).slice(0, -1);
          const filename = sep2 + steps.join(sep2);
          const link4 = this.getLinkOrThrow(filename, funcName);
          if (!link4.getNode().isDirectory())
            throw (0, util_1.createError)(ENOTDIR, funcName, filename);
          return link4;
        }
        getFileByFd(fd) {
          return this.fds[String(fd)];
        }
        getFileByFdOrThrow(fd, funcName) {
          if (!(0, util_1.isFd)(fd))
            throw TypeError(constants_2.ERRSTR.FD);
          const file = this.getFileByFd(fd);
          if (!file)
            throw (0, util_1.createError)(EBADF, funcName);
          return file;
        }
        /**
         * @todo This is not used anymore. Remove.
         */
        /*
          private getNodeByIdOrCreate(id: TFileId, flags: number, perm: number): Node {
            if (typeof id === 'number') {
              const file = this.getFileByFd(id);
              if (!file) throw Error('File nto found');
              return file.node;
            } else {
              const steps = pathToSteps(id as PathLike);
              let link = this.getLink(steps);
              if (link) return link.getNode();
        
              // Try creating a node if not found.
              if (flags & O_CREAT) {
                const dirLink = this.getLinkParent(steps);
                if (dirLink) {
                  const name = steps[steps.length - 1];
                  link = this.createLink(dirLink, name, false, perm);
                  return link.getNode();
                }
              }
        
              throw createError(ENOENT, 'getNodeByIdOrCreate', pathToFilename(id));
            }
          }
          */
        wrapAsync(method, args, callback) {
          (0, util_1.validateCallback)(callback);
          (0, setImmediate_1.default)(() => {
            let result;
            try {
              result = method.apply(this, args);
            } catch (err) {
              callback(err);
              return;
            }
            callback(null, result);
          });
        }
        _toJSON(link4 = this.root, json = {}, path2, asBuffer) {
          let isEmpty2 = true;
          let children = link4.children;
          if (link4.getNode().isFile()) {
            children = /* @__PURE__ */ new Map([[link4.getName(), link4.parent.getChild(link4.getName())]]);
            link4 = link4.parent;
          }
          for (const name8 of children.keys()) {
            if (name8 === "." || name8 === "..") {
              continue;
            }
            isEmpty2 = false;
            const child = link4.getChild(name8);
            if (!child) {
              throw new Error("_toJSON: unexpected undefined");
            }
            const node = child.getNode();
            if (node.isFile()) {
              let filename = child.getPath();
              if (path2)
                filename = relative2(path2, filename);
              json[filename] = asBuffer ? node.getBuffer() : node.getString();
            } else if (node.isDirectory()) {
              this._toJSON(child, json, path2, asBuffer);
            }
          }
          let dirPath = link4.getPath();
          if (path2)
            dirPath = relative2(path2, dirPath);
          if (dirPath && isEmpty2) {
            json[dirPath] = null;
          }
          return json;
        }
        toJSON(paths, json = {}, isRelative = false, asBuffer = false) {
          const links4 = [];
          if (paths) {
            if (!Array.isArray(paths))
              paths = [paths];
            for (const path2 of paths) {
              const filename = (0, util_1.pathToFilename)(path2);
              const link4 = this.getResolvedLink(filename);
              if (!link4)
                continue;
              links4.push(link4);
            }
          } else {
            links4.push(this.root);
          }
          if (!links4.length)
            return json;
          for (const link4 of links4)
            this._toJSON(link4, json, isRelative ? link4.getPath() : "", asBuffer);
          return json;
        }
        // TODO: `cwd` should probably not invoke `process.cwd()`.
        fromJSON(json, cwd2 = process_1.default.cwd()) {
          for (let filename in json) {
            const data = json[filename];
            filename = resolve9(filename, cwd2);
            if (typeof data === "string" || data instanceof buffer_1.Buffer) {
              const dir = dirname2(filename);
              this.mkdirpBase(
                dir,
                511
                /* MODE.DIR */
              );
              this.writeFileSync(filename, data);
            } else {
              this.mkdirpBase(
                filename,
                511
                /* MODE.DIR */
              );
            }
          }
        }
        fromNestedJSON(json, cwd2) {
          this.fromJSON(flattenJSON(json), cwd2);
        }
        toTree(opts = { separator: sep2 }) {
          return (0, print_1.toTreeSync)(this, opts);
        }
        reset() {
          this.ino = 0;
          this.inodes = {};
          this.releasedInos = [];
          this.fds = {};
          this.releasedFds = [];
          this.openFiles = 0;
          this.root = this.createLink();
          this.root.setNode(this.createNode(true));
        }
        // Legacy interface
        mountSync(mountpoint, json) {
          this.fromJSON(json, mountpoint);
        }
        openLink(link4, flagsNum, resolveSymlinks = true) {
          if (this.openFiles >= this.maxFiles) {
            throw (0, util_1.createError)(EMFILE, "open", link4.getPath());
          }
          let realLink = link4;
          if (resolveSymlinks)
            realLink = this.getResolvedLinkOrThrow(link4.getPath(), "open");
          const node = realLink.getNode();
          if (node.isDirectory()) {
            if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)
              throw (0, util_1.createError)(EISDIR, "open", link4.getPath());
          } else {
            if (flagsNum & O_DIRECTORY)
              throw (0, util_1.createError)(ENOTDIR, "open", link4.getPath());
          }
          if (!(flagsNum & O_WRONLY)) {
            if (!node.canRead()) {
              throw (0, util_1.createError)(EACCES, "open", link4.getPath());
            }
          }
          if (!(flagsNum & O_RDONLY)) {
            if (!node.canWrite()) {
              throw (0, util_1.createError)(EACCES, "open", link4.getPath());
            }
          }
          const file = new this.props.File(link4, node, flagsNum, this.newFdNumber());
          this.fds[file.fd] = file;
          this.openFiles++;
          if (flagsNum & O_TRUNC)
            file.truncate();
          return file;
        }
        openFile(filename, flagsNum, modeNum, resolveSymlinks = true) {
          const steps = filenameToSteps(filename);
          let link4;
          try {
            link4 = resolveSymlinks ? this.getResolvedLinkOrThrow(filename, "open") : this.getLinkOrThrow(filename, "open");
            if (link4 && flagsNum & O_CREAT && flagsNum & O_EXCL)
              throw (0, util_1.createError)(EEXIST, "open", filename);
          } catch (err) {
            if (err.code === ENOENT && flagsNum & O_CREAT) {
              const dirname3 = pathModule.dirname(filename);
              const dirLink = this.getResolvedLinkOrThrow(dirname3);
              const dirNode = dirLink.getNode();
              if (!dirNode.isDirectory())
                throw (0, util_1.createError)(ENOTDIR, "open", filename);
              if (!dirNode.canExecute() || !dirNode.canWrite())
                throw (0, util_1.createError)(EACCES, "open", filename);
              modeNum !== null && modeNum !== void 0 ? modeNum : modeNum = 438;
              link4 = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
            } else
              throw err;
          }
          if (link4)
            return this.openLink(link4, flagsNum, resolveSymlinks);
          throw (0, util_1.createError)(ENOENT, "open", filename);
        }
        openBase(filename, flagsNum, modeNum, resolveSymlinks = true) {
          const file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
          if (!file)
            throw (0, util_1.createError)(ENOENT, "open", filename);
          return file.fd;
        }
        openSync(path2, flags, mode = 438) {
          const modeNum = (0, util_1.modeToNumber)(mode);
          const fileName = (0, util_1.pathToFilename)(path2);
          const flagsNum = (0, util_1.flagsToNumber)(flags);
          return this.openBase(fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK));
        }
        open(path2, flags, a7, b5) {
          let mode = a7;
          let callback = b5;
          if (typeof a7 === "function") {
            mode = 438;
            callback = a7;
          }
          mode = mode || 438;
          const modeNum = (0, util_1.modeToNumber)(mode);
          const fileName = (0, util_1.pathToFilename)(path2);
          const flagsNum = (0, util_1.flagsToNumber)(flags);
          this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK)], callback);
        }
        closeFile(file) {
          if (!this.fds[file.fd])
            return;
          this.openFiles--;
          delete this.fds[file.fd];
          this.releasedFds.push(file.fd);
        }
        closeSync(fd) {
          (0, util_1.validateFd)(fd);
          const file = this.getFileByFdOrThrow(fd, "close");
          this.closeFile(file);
        }
        close(fd, callback) {
          (0, util_1.validateFd)(fd);
          this.wrapAsync(this.closeSync, [fd], callback);
        }
        openFileOrGetById(id, flagsNum, modeNum) {
          if (typeof id === "number") {
            const file = this.fds[id];
            if (!file)
              throw (0, util_1.createError)(ENOENT);
            return file;
          } else {
            return this.openFile((0, util_1.pathToFilename)(id), flagsNum, modeNum);
          }
        }
        readBase(fd, buffer4, offset, length4, position) {
          if (buffer4.byteLength < length4) {
            throw (0, util_1.createError)(ERR_OUT_OF_RANGE, "read", void 0, void 0, RangeError);
          }
          const file = this.getFileByFdOrThrow(fd);
          if (file.node.isSymlink()) {
            throw (0, util_1.createError)(EPERM, "read", file.link.getPath());
          }
          return file.read(buffer4, Number(offset), Number(length4), position === -1 || typeof position !== "number" ? void 0 : position);
        }
        readSync(fd, buffer4, offset, length4, position) {
          (0, util_1.validateFd)(fd);
          return this.readBase(fd, buffer4, offset, length4, position);
        }
        read(fd, buffer4, offset, length4, position, callback) {
          (0, util_1.validateCallback)(callback);
          if (length4 === 0) {
            return (0, queueMicrotask_1.default)(() => {
              if (callback)
                callback(null, 0, buffer4);
            });
          }
          (0, setImmediate_1.default)(() => {
            try {
              const bytes = this.readBase(fd, buffer4, offset, length4, position);
              callback(null, bytes, buffer4);
            } catch (err) {
              callback(err);
            }
          });
        }
        readvBase(fd, buffers, position) {
          const file = this.getFileByFdOrThrow(fd);
          let p7 = position !== null && position !== void 0 ? position : void 0;
          if (p7 === -1) {
            p7 = void 0;
          }
          let bytesRead = 0;
          for (const buffer4 of buffers) {
            const bytes = file.read(buffer4, 0, buffer4.byteLength, p7);
            p7 = void 0;
            bytesRead += bytes;
            if (bytes < buffer4.byteLength)
              break;
          }
          return bytesRead;
        }
        readv(fd, buffers, a7, b5) {
          let position = a7;
          let callback = b5;
          if (typeof a7 === "function") {
            position = null;
            callback = a7;
          }
          (0, util_1.validateCallback)(callback);
          (0, setImmediate_1.default)(() => {
            try {
              const bytes = this.readvBase(fd, buffers, position);
              callback(null, bytes, buffers);
            } catch (err) {
              callback(err);
            }
          });
        }
        readvSync(fd, buffers, position) {
          (0, util_1.validateFd)(fd);
          return this.readvBase(fd, buffers, position);
        }
        readFileBase(id, flagsNum, encoding) {
          let result;
          const isUserFd = typeof id === "number";
          const userOwnsFd = isUserFd && (0, util_1.isFd)(id);
          let fd;
          if (userOwnsFd)
            fd = id;
          else {
            const filename = (0, util_1.pathToFilename)(id);
            const link4 = this.getResolvedLinkOrThrow(filename, "open");
            const node = link4.getNode();
            if (node.isDirectory())
              throw (0, util_1.createError)(EISDIR, "open", link4.getPath());
            fd = this.openSync(id, flagsNum);
          }
          try {
            result = (0, util_1.bufferToEncoding)(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
          } finally {
            if (!userOwnsFd) {
              this.closeSync(fd);
            }
          }
          return result;
        }
        readFileSync(file, options) {
          const opts = (0, options_1.getReadFileOptions)(options);
          const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
          return this.readFileBase(file, flagsNum, opts.encoding);
        }
        readFile(id, a7, b5) {
          const [opts, callback] = (0, options_1.optsAndCbGenerator)(options_1.getReadFileOptions)(a7, b5);
          const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
          this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
        }
        writeBase(fd, buf3, offset, length4, position) {
          const file = this.getFileByFdOrThrow(fd, "write");
          if (file.node.isSymlink()) {
            throw (0, util_1.createError)(EBADF, "write", file.link.getPath());
          }
          return file.write(buf3, offset, length4, position === -1 || typeof position !== "number" ? void 0 : position);
        }
        writeSync(fd, a7, b5, c7, d6) {
          const [, buf3, offset, length4, position] = (0, util_1.getWriteSyncArgs)(fd, a7, b5, c7, d6);
          return this.writeBase(fd, buf3, offset, length4, position);
        }
        write(fd, a7, b5, c7, d6, e9) {
          const [, asStr, buf3, offset, length4, position, cb] = (0, util_1.getWriteArgs)(fd, a7, b5, c7, d6, e9);
          (0, setImmediate_1.default)(() => {
            try {
              const bytes = this.writeBase(fd, buf3, offset, length4, position);
              if (!asStr) {
                cb(null, bytes, buf3);
              } else {
                cb(null, bytes, a7);
              }
            } catch (err) {
              cb(err);
            }
          });
        }
        writevBase(fd, buffers, position) {
          const file = this.getFileByFdOrThrow(fd);
          let p7 = position !== null && position !== void 0 ? position : void 0;
          if (p7 === -1) {
            p7 = void 0;
          }
          let bytesWritten = 0;
          for (const buffer4 of buffers) {
            const nodeBuf = buffer_1.Buffer.from(buffer4.buffer, buffer4.byteOffset, buffer4.byteLength);
            const bytes = file.write(nodeBuf, 0, nodeBuf.byteLength, p7);
            p7 = void 0;
            bytesWritten += bytes;
            if (bytes < nodeBuf.byteLength)
              break;
          }
          return bytesWritten;
        }
        writev(fd, buffers, a7, b5) {
          let position = a7;
          let callback = b5;
          if (typeof a7 === "function") {
            position = null;
            callback = a7;
          }
          (0, util_1.validateCallback)(callback);
          (0, setImmediate_1.default)(() => {
            try {
              const bytes = this.writevBase(fd, buffers, position);
              callback(null, bytes, buffers);
            } catch (err) {
              callback(err);
            }
          });
        }
        writevSync(fd, buffers, position) {
          (0, util_1.validateFd)(fd);
          return this.writevBase(fd, buffers, position);
        }
        writeFileBase(id, buf3, flagsNum, modeNum) {
          const isUserFd = typeof id === "number";
          let fd;
          if (isUserFd)
            fd = id;
          else {
            fd = this.openBase((0, util_1.pathToFilename)(id), flagsNum, modeNum);
          }
          let offset = 0;
          let length4 = buf3.length;
          let position = flagsNum & O_APPEND ? void 0 : 0;
          try {
            while (length4 > 0) {
              const written = this.writeSync(fd, buf3, offset, length4, position);
              offset += written;
              length4 -= written;
              if (position !== void 0)
                position += written;
            }
          } finally {
            if (!isUserFd)
              this.closeSync(fd);
          }
        }
        writeFileSync(id, data, options) {
          const opts = (0, options_1.getWriteFileOptions)(options);
          const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
          const modeNum = (0, util_1.modeToNumber)(opts.mode);
          const buf3 = (0, util_1.dataToBuffer)(data, opts.encoding);
          this.writeFileBase(id, buf3, flagsNum, modeNum);
        }
        writeFile(id, data, a7, b5) {
          let options = a7;
          let callback = b5;
          if (typeof a7 === "function") {
            options = options_1.writeFileDefaults;
            callback = a7;
          }
          const cb = (0, util_1.validateCallback)(callback);
          const opts = (0, options_1.getWriteFileOptions)(options);
          const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
          const modeNum = (0, util_1.modeToNumber)(opts.mode);
          const buf3 = (0, util_1.dataToBuffer)(data, opts.encoding);
          this.wrapAsync(this.writeFileBase, [id, buf3, flagsNum, modeNum], cb);
        }
        linkBase(filename1, filename2) {
          let link1;
          try {
            link1 = this.getLinkOrThrow(filename1, "link");
          } catch (err) {
            if (err.code)
              err = (0, util_1.createError)(err.code, "link", filename1, filename2);
            throw err;
          }
          const dirname22 = pathModule.dirname(filename2);
          let dir2;
          try {
            dir2 = this.getLinkOrThrow(dirname22, "link");
          } catch (err) {
            if (err.code)
              err = (0, util_1.createError)(err.code, "link", filename1, filename2);
            throw err;
          }
          const name8 = pathModule.basename(filename2);
          if (dir2.getChild(name8))
            throw (0, util_1.createError)(EEXIST, "link", filename1, filename2);
          const node = link1.getNode();
          node.nlink++;
          dir2.createChild(name8, node);
        }
        copyFileBase(src3, dest, flags) {
          const buf3 = this.readFileSync(src3);
          if (flags & COPYFILE_EXCL) {
            if (this.existsSync(dest)) {
              throw (0, util_1.createError)(EEXIST, "copyFile", src3, dest);
            }
          }
          if (flags & COPYFILE_FICLONE_FORCE) {
            throw (0, util_1.createError)(ENOSYS, "copyFile", src3, dest);
          }
          this.writeFileBase(
            dest,
            buf3,
            constants_2.FLAGS.w,
            438
            /* MODE.DEFAULT */
          );
        }
        copyFileSync(src3, dest, flags) {
          const srcFilename = (0, util_1.pathToFilename)(src3);
          const destFilename = (0, util_1.pathToFilename)(dest);
          return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
        }
        copyFile(src3, dest, a7, b5) {
          const srcFilename = (0, util_1.pathToFilename)(src3);
          const destFilename = (0, util_1.pathToFilename)(dest);
          let flags;
          let callback;
          if (typeof a7 === "function") {
            flags = 0;
            callback = a7;
          } else {
            flags = a7;
            callback = b5;
          }
          (0, util_1.validateCallback)(callback);
          this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
        }
        linkSync(existingPath, newPath) {
          const existingPathFilename = (0, util_1.pathToFilename)(existingPath);
          const newPathFilename = (0, util_1.pathToFilename)(newPath);
          this.linkBase(existingPathFilename, newPathFilename);
        }
        link(existingPath, newPath, callback) {
          const existingPathFilename = (0, util_1.pathToFilename)(existingPath);
          const newPathFilename = (0, util_1.pathToFilename)(newPath);
          this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
        }
        unlinkBase(filename) {
          const link4 = this.getLinkOrThrow(filename, "unlink");
          if (link4.length)
            throw Error("Dir not empty...");
          this.deleteLink(link4);
          const node = link4.getNode();
          node.nlink--;
          if (node.nlink <= 0) {
            this.deleteNode(node);
          }
        }
        unlinkSync(path2) {
          const filename = (0, util_1.pathToFilename)(path2);
          this.unlinkBase(filename);
        }
        unlink(path2, callback) {
          const filename = (0, util_1.pathToFilename)(path2);
          this.wrapAsync(this.unlinkBase, [filename], callback);
        }
        symlinkBase(targetFilename, pathFilename) {
          const pathSteps = filenameToSteps(pathFilename);
          let dirLink;
          try {
            dirLink = this.getLinkParentAsDirOrThrow(pathSteps);
          } catch (err) {
            if (err.code)
              err = (0, util_1.createError)(err.code, "symlink", targetFilename, pathFilename);
            throw err;
          }
          const name8 = pathSteps[pathSteps.length - 1];
          if (dirLink.getChild(name8))
            throw (0, util_1.createError)(EEXIST, "symlink", targetFilename, pathFilename);
          const node = dirLink.getNode();
          if (!node.canExecute() || !node.canWrite())
            throw (0, util_1.createError)(EACCES, "symlink", targetFilename, pathFilename);
          const symlink3 = dirLink.createChild(name8);
          symlink3.getNode().makeSymlink(filenameToSteps(targetFilename));
          return symlink3;
        }
        // `type` argument works only on Windows.
        symlinkSync(target, path2, type2) {
          const targetFilename = (0, util_1.pathToFilename)(target);
          const pathFilename = (0, util_1.pathToFilename)(path2);
          this.symlinkBase(targetFilename, pathFilename);
        }
        symlink(target, path2, a7, b5) {
          const callback = (0, util_1.validateCallback)(typeof a7 === "function" ? a7 : b5);
          const targetFilename = (0, util_1.pathToFilename)(target);
          const pathFilename = (0, util_1.pathToFilename)(path2);
          this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
        }
        realpathBase(filename, encoding) {
          debugger;
          const realLink = this.getResolvedLinkOrThrow(filename, "realpath");
          return (0, encoding_1.strToEncoding)(realLink.getPath() || "/", encoding);
        }
        realpathSync(path2, options) {
          return this.realpathBase((0, util_1.pathToFilename)(path2), (0, options_1.getRealpathOptions)(options).encoding);
        }
        realpath(path2, a7, b5) {
          const [opts, callback] = (0, options_1.getRealpathOptsAndCb)(a7, b5);
          const pathFilename = (0, util_1.pathToFilename)(path2);
          this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
        }
        lstatBase(filename, bigint = false, throwIfNoEntry = false) {
          let link4;
          try {
            link4 = this.getLinkOrThrow(filename, "lstat");
          } catch (err) {
            if (err.code === ENOENT && !throwIfNoEntry)
              return void 0;
            else
              throw err;
          }
          return Stats_1.default.build(link4.getNode(), bigint);
        }
        lstatSync(path2, options) {
          const { throwIfNoEntry = true, bigint = false } = (0, options_1.getStatOptions)(options);
          return this.lstatBase((0, util_1.pathToFilename)(path2), bigint, throwIfNoEntry);
        }
        lstat(path2, a7, b5) {
          const [{ throwIfNoEntry = true, bigint = false }, callback] = (0, options_1.getStatOptsAndCb)(a7, b5);
          this.wrapAsync(this.lstatBase, [(0, util_1.pathToFilename)(path2), bigint, throwIfNoEntry], callback);
        }
        statBase(filename, bigint = false, throwIfNoEntry = true) {
          let link4;
          try {
            link4 = this.getResolvedLinkOrThrow(filename, "stat");
          } catch (err) {
            if (err.code === ENOENT && !throwIfNoEntry)
              return void 0;
            else
              throw err;
          }
          return Stats_1.default.build(link4.getNode(), bigint);
        }
        statSync(path2, options) {
          const { bigint = true, throwIfNoEntry = true } = (0, options_1.getStatOptions)(options);
          return this.statBase((0, util_1.pathToFilename)(path2), bigint, throwIfNoEntry);
        }
        stat(path2, a7, b5) {
          const [{ bigint = false, throwIfNoEntry = true }, callback] = (0, options_1.getStatOptsAndCb)(a7, b5);
          this.wrapAsync(this.statBase, [(0, util_1.pathToFilename)(path2), bigint, throwIfNoEntry], callback);
        }
        fstatBase(fd, bigint = false) {
          const file = this.getFileByFd(fd);
          if (!file)
            throw (0, util_1.createError)(EBADF, "fstat");
          return Stats_1.default.build(file.node, bigint);
        }
        fstatSync(fd, options) {
          return this.fstatBase(fd, (0, options_1.getStatOptions)(options).bigint);
        }
        fstat(fd, a7, b5) {
          const [opts, callback] = (0, options_1.getStatOptsAndCb)(a7, b5);
          this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
        }
        renameBase(oldPathFilename, newPathFilename) {
          let link4;
          try {
            link4 = this.getResolvedLinkOrThrow(oldPathFilename);
          } catch (err) {
            if (err.code)
              err = (0, util_1.createError)(err.code, "rename", oldPathFilename, newPathFilename);
            throw err;
          }
          let newPathDirLink;
          try {
            newPathDirLink = this.getLinkParentAsDirOrThrow(newPathFilename);
          } catch (err) {
            if (err.code)
              err = (0, util_1.createError)(err.code, "rename", oldPathFilename, newPathFilename);
            throw err;
          }
          const oldLinkParent = link4.parent;
          const oldParentNode = oldLinkParent.getNode();
          const newPathDirNode = newPathDirLink.getNode();
          if (!oldParentNode.canExecute() || !oldParentNode.canWrite() || !newPathDirNode.canExecute() || !newPathDirNode.canWrite()) {
            throw (0, util_1.createError)(EACCES, "rename", oldPathFilename, newPathFilename);
          }
          oldLinkParent.deleteChild(link4);
          const name8 = pathModule.basename(newPathFilename);
          link4.name = name8;
          link4.steps = [...newPathDirLink.steps, name8];
          newPathDirLink.setChild(link4.getName(), link4);
        }
        renameSync(oldPath, newPath) {
          const oldPathFilename = (0, util_1.pathToFilename)(oldPath);
          const newPathFilename = (0, util_1.pathToFilename)(newPath);
          this.renameBase(oldPathFilename, newPathFilename);
        }
        rename(oldPath, newPath, callback) {
          const oldPathFilename = (0, util_1.pathToFilename)(oldPath);
          const newPathFilename = (0, util_1.pathToFilename)(newPath);
          this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
        }
        existsBase(filename) {
          return !!this.statBase(filename);
        }
        existsSync(path2) {
          try {
            return this.existsBase((0, util_1.pathToFilename)(path2));
          } catch (err) {
            return false;
          }
        }
        exists(path2, callback) {
          const filename = (0, util_1.pathToFilename)(path2);
          if (typeof callback !== "function")
            throw Error(constants_2.ERRSTR.CB);
          (0, setImmediate_1.default)(() => {
            try {
              callback(this.existsBase(filename));
            } catch (err) {
              callback(false);
            }
          });
        }
        accessBase(filename, mode) {
          const link4 = this.getLinkOrThrow(filename, "access");
        }
        accessSync(path2, mode = F_OK2) {
          const filename = (0, util_1.pathToFilename)(path2);
          mode = mode | 0;
          this.accessBase(filename, mode);
        }
        access(path2, a7, b5) {
          let mode = F_OK2;
          let callback;
          if (typeof a7 !== "function") {
            mode = a7 | 0;
            callback = (0, util_1.validateCallback)(b5);
          } else {
            callback = a7;
          }
          const filename = (0, util_1.pathToFilename)(path2);
          this.wrapAsync(this.accessBase, [filename, mode], callback);
        }
        appendFileSync(id, data, options) {
          const opts = (0, options_1.getAppendFileOpts)(options);
          if (!opts.flag || (0, util_1.isFd)(id))
            opts.flag = "a";
          this.writeFileSync(id, data, opts);
        }
        appendFile(id, data, a7, b5) {
          const [opts, callback] = (0, options_1.getAppendFileOptsAndCb)(a7, b5);
          if (!opts.flag || (0, util_1.isFd)(id))
            opts.flag = "a";
          this.writeFile(id, data, opts, callback);
        }
        readdirBase(filename, options) {
          const steps = filenameToSteps(filename);
          const link4 = this.getResolvedLinkOrThrow(filename, "scandir");
          const node = link4.getNode();
          if (!node.isDirectory())
            throw (0, util_1.createError)(ENOTDIR, "scandir", filename);
          if (!node.canRead())
            throw (0, util_1.createError)(EACCES, "scandir", filename);
          const list = [];
          for (const name8 of link4.children.keys()) {
            const child = link4.getChild(name8);
            if (!child || name8 === "." || name8 === "..")
              continue;
            list.push(Dirent_1.default.build(child, options.encoding));
            if (options.recursive && child.children.size) {
              const recurseOptions = Object.assign(Object.assign({}, options), { recursive: true, withFileTypes: true });
              const childList = this.readdirBase(child.getPath(), recurseOptions);
              list.push(...childList);
            }
          }
          if (!util_1.isWin && options.encoding !== "buffer")
            list.sort((a7, b5) => {
              if (a7.name < b5.name)
                return -1;
              if (a7.name > b5.name)
                return 1;
              return 0;
            });
          if (options.withFileTypes)
            return list;
          let filename2 = filename;
          if (util_1.isWin) {
            filename2 = filename2.replace(/\\/g, "/");
          }
          return list.map((dirent) => {
            if (options.recursive) {
              let fullPath = pathModule.join(dirent.parentPath, dirent.name.toString());
              if (util_1.isWin) {
                fullPath = fullPath.replace(/\\/g, "/");
              }
              return fullPath.replace(filename2 + pathModule.posix.sep, "");
            }
            return dirent.name;
          });
        }
        readdirSync(path2, options) {
          const opts = (0, options_1.getReaddirOptions)(options);
          const filename = (0, util_1.pathToFilename)(path2);
          return this.readdirBase(filename, opts);
        }
        readdir(path2, a7, b5) {
          const [options, callback] = (0, options_1.getReaddirOptsAndCb)(a7, b5);
          const filename = (0, util_1.pathToFilename)(path2);
          this.wrapAsync(this.readdirBase, [filename, options], callback);
        }
        readlinkBase(filename, encoding) {
          const link4 = this.getLinkOrThrow(filename, "readlink");
          const node = link4.getNode();
          if (!node.isSymlink())
            throw (0, util_1.createError)(EINVAL, "readlink", filename);
          const str = sep2 + node.symlink.join(sep2);
          return (0, encoding_1.strToEncoding)(str, encoding);
        }
        readlinkSync(path2, options) {
          const opts = (0, options_1.getDefaultOpts)(options);
          const filename = (0, util_1.pathToFilename)(path2);
          return this.readlinkBase(filename, opts.encoding);
        }
        readlink(path2, a7, b5) {
          const [opts, callback] = (0, options_1.getDefaultOptsAndCb)(a7, b5);
          const filename = (0, util_1.pathToFilename)(path2);
          this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
        }
        fsyncBase(fd) {
          this.getFileByFdOrThrow(fd, "fsync");
        }
        fsyncSync(fd) {
          this.fsyncBase(fd);
        }
        fsync(fd, callback) {
          this.wrapAsync(this.fsyncBase, [fd], callback);
        }
        fdatasyncBase(fd) {
          this.getFileByFdOrThrow(fd, "fdatasync");
        }
        fdatasyncSync(fd) {
          this.fdatasyncBase(fd);
        }
        fdatasync(fd, callback) {
          this.wrapAsync(this.fdatasyncBase, [fd], callback);
        }
        ftruncateBase(fd, len) {
          const file = this.getFileByFdOrThrow(fd, "ftruncate");
          file.truncate(len);
        }
        ftruncateSync(fd, len) {
          this.ftruncateBase(fd, len);
        }
        ftruncate(fd, a7, b5) {
          const len = typeof a7 === "number" ? a7 : 0;
          const callback = (0, util_1.validateCallback)(typeof a7 === "number" ? b5 : a7);
          this.wrapAsync(this.ftruncateBase, [fd, len], callback);
        }
        truncateBase(path2, len) {
          const fd = this.openSync(path2, "r+");
          try {
            this.ftruncateSync(fd, len);
          } finally {
            this.closeSync(fd);
          }
        }
        /**
         * `id` should be a file descriptor or a path. `id` as file descriptor will
         * not be supported soon.
         */
        truncateSync(id, len) {
          if ((0, util_1.isFd)(id))
            return this.ftruncateSync(id, len);
          this.truncateBase(id, len);
        }
        truncate(id, a7, b5) {
          const len = typeof a7 === "number" ? a7 : 0;
          const callback = (0, util_1.validateCallback)(typeof a7 === "number" ? b5 : a7);
          if ((0, util_1.isFd)(id))
            return this.ftruncate(id, len, callback);
          this.wrapAsync(this.truncateBase, [id, len], callback);
        }
        futimesBase(fd, atime, mtime) {
          const file = this.getFileByFdOrThrow(fd, "futimes");
          const node = file.node;
          node.atime = new Date(atime * 1e3);
          node.mtime = new Date(mtime * 1e3);
        }
        futimesSync(fd, atime, mtime) {
          this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
        }
        futimes(fd, atime, mtime, callback) {
          this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
        }
        utimesBase(filename, atime, mtime) {
          const link4 = this.getResolvedLinkOrThrow(filename, "utimes");
          const node = link4.getNode();
          node.atime = new Date(atime * 1e3);
          node.mtime = new Date(mtime * 1e3);
        }
        utimesSync(path2, atime, mtime) {
          this.utimesBase((0, util_1.pathToFilename)(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime));
        }
        utimes(path2, atime, mtime, callback) {
          this.wrapAsync(this.utimesBase, [(0, util_1.pathToFilename)(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
        }
        mkdirBase(filename, modeNum) {
          const steps = filenameToSteps(filename);
          if (!steps.length) {
            throw (0, util_1.createError)(EEXIST, "mkdir", filename);
          }
          const dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
          const name8 = steps[steps.length - 1];
          if (dir.getChild(name8))
            throw (0, util_1.createError)(EEXIST, "mkdir", filename);
          const node = dir.getNode();
          if (!node.canWrite() || !node.canExecute())
            throw (0, util_1.createError)(EACCES, "mkdir", filename);
          dir.createChild(name8, this.createNode(true, modeNum));
        }
        /**
         * Creates directory tree recursively.
         */
        mkdirpBase(filename, modeNum) {
          let created = false;
          const steps = filenameToSteps(filename);
          let curr = null;
          let i7 = steps.length;
          for (i7 = steps.length; i7 >= 0; i7--) {
            curr = this.getResolvedLink(steps.slice(0, i7));
            if (curr)
              break;
          }
          if (!curr) {
            curr = this.root;
            i7 = 0;
          }
          curr = this.getResolvedLinkOrThrow(sep2 + steps.slice(0, i7).join(sep2), "mkdir");
          for (i7; i7 < steps.length; i7++) {
            const node = curr.getNode();
            if (node.isDirectory()) {
              if (!node.canExecute() || !node.canWrite())
                throw (0, util_1.createError)(EACCES, "mkdir", filename);
            } else {
              throw (0, util_1.createError)(ENOTDIR, "mkdir", filename);
            }
            created = true;
            curr = curr.createChild(steps[i7], this.createNode(true, modeNum));
          }
          return created ? filename : void 0;
        }
        mkdirSync(path2, options) {
          const opts = (0, options_1.getMkdirOptions)(options);
          const modeNum = (0, util_1.modeToNumber)(opts.mode, 511);
          const filename = (0, util_1.pathToFilename)(path2);
          if (opts.recursive)
            return this.mkdirpBase(filename, modeNum);
          this.mkdirBase(filename, modeNum);
        }
        mkdir(path2, a7, b5) {
          const opts = (0, options_1.getMkdirOptions)(a7);
          const callback = (0, util_1.validateCallback)(typeof a7 === "function" ? a7 : b5);
          const modeNum = (0, util_1.modeToNumber)(opts.mode, 511);
          const filename = (0, util_1.pathToFilename)(path2);
          if (opts.recursive)
            this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
          else
            this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
        }
        mkdtempBase(prefix, encoding, retry = 5) {
          const filename = prefix + (0, util_1.genRndStr6)();
          try {
            this.mkdirBase(
              filename,
              511
              /* MODE.DIR */
            );
            return (0, encoding_1.strToEncoding)(filename, encoding);
          } catch (err) {
            if (err.code === EEXIST) {
              if (retry > 1)
                return this.mkdtempBase(prefix, encoding, retry - 1);
              else
                throw Error("Could not create temp dir.");
            } else
              throw err;
          }
        }
        mkdtempSync(prefix, options) {
          const { encoding } = (0, options_1.getDefaultOpts)(options);
          if (!prefix || typeof prefix !== "string")
            throw new TypeError("filename prefix is required");
          (0, util_1.nullCheck)(prefix);
          return this.mkdtempBase(prefix, encoding);
        }
        mkdtemp(prefix, a7, b5) {
          const [{ encoding }, callback] = (0, options_1.getDefaultOptsAndCb)(a7, b5);
          if (!prefix || typeof prefix !== "string")
            throw new TypeError("filename prefix is required");
          if (!(0, util_1.nullCheck)(prefix))
            return;
          this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
        }
        rmdirBase(filename, options) {
          const opts = (0, options_1.getRmdirOptions)(options);
          const link4 = this.getLinkAsDirOrThrow(filename, "rmdir");
          if (link4.length && !opts.recursive)
            throw (0, util_1.createError)(ENOTEMPTY, "rmdir", filename);
          this.deleteLink(link4);
        }
        rmdirSync(path2, options) {
          this.rmdirBase((0, util_1.pathToFilename)(path2), options);
        }
        rmdir(path2, a7, b5) {
          const opts = (0, options_1.getRmdirOptions)(a7);
          const callback = (0, util_1.validateCallback)(typeof a7 === "function" ? a7 : b5);
          this.wrapAsync(this.rmdirBase, [(0, util_1.pathToFilename)(path2), opts], callback);
        }
        rmBase(filename, options = {}) {
          let link4;
          try {
            link4 = this.getResolvedLinkOrThrow(filename, "stat");
          } catch (err) {
            if (err.code === ENOENT && options.force)
              return;
            else
              throw err;
          }
          if (link4.getNode().isDirectory() && !options.recursive)
            throw (0, util_1.createError)(ERR_FS_EISDIR, "rm", filename);
          if (!link4.parent.getNode().canWrite())
            throw (0, util_1.createError)(EACCES, "rm", filename);
          this.deleteLink(link4);
        }
        rmSync(path2, options) {
          this.rmBase((0, util_1.pathToFilename)(path2), options);
        }
        rm(path2, a7, b5) {
          const [opts, callback] = (0, options_1.getRmOptsAndCb)(a7, b5);
          this.wrapAsync(this.rmBase, [(0, util_1.pathToFilename)(path2), opts], callback);
        }
        fchmodBase(fd, modeNum) {
          const file = this.getFileByFdOrThrow(fd, "fchmod");
          file.chmod(modeNum);
        }
        fchmodSync(fd, mode) {
          this.fchmodBase(fd, (0, util_1.modeToNumber)(mode));
        }
        fchmod(fd, mode, callback) {
          this.wrapAsync(this.fchmodBase, [fd, (0, util_1.modeToNumber)(mode)], callback);
        }
        chmodBase(filename, modeNum, followSymlinks = true) {
          const link4 = followSymlinks ? this.getResolvedLinkOrThrow(filename, "chmod") : this.getLinkOrThrow(filename, "chmod");
          const node = link4.getNode();
          node.chmod(modeNum);
        }
        chmodSync(path2, mode) {
          const modeNum = (0, util_1.modeToNumber)(mode);
          const filename = (0, util_1.pathToFilename)(path2);
          this.chmodBase(filename, modeNum, true);
        }
        chmod(path2, mode, callback) {
          const modeNum = (0, util_1.modeToNumber)(mode);
          const filename = (0, util_1.pathToFilename)(path2);
          this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
        }
        lchmodBase(filename, modeNum) {
          this.chmodBase(filename, modeNum, false);
        }
        lchmodSync(path2, mode) {
          const modeNum = (0, util_1.modeToNumber)(mode);
          const filename = (0, util_1.pathToFilename)(path2);
          this.lchmodBase(filename, modeNum);
        }
        lchmod(path2, mode, callback) {
          const modeNum = (0, util_1.modeToNumber)(mode);
          const filename = (0, util_1.pathToFilename)(path2);
          this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
        }
        fchownBase(fd, uid, gid) {
          this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
        }
        fchownSync(fd, uid, gid) {
          validateUid(uid);
          validateGid(gid);
          this.fchownBase(fd, uid, gid);
        }
        fchown(fd, uid, gid, callback) {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
        }
        chownBase(filename, uid, gid) {
          const link4 = this.getResolvedLinkOrThrow(filename, "chown");
          const node = link4.getNode();
          node.chown(uid, gid);
        }
        chownSync(path2, uid, gid) {
          validateUid(uid);
          validateGid(gid);
          this.chownBase((0, util_1.pathToFilename)(path2), uid, gid);
        }
        chown(path2, uid, gid, callback) {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(this.chownBase, [(0, util_1.pathToFilename)(path2), uid, gid], callback);
        }
        lchownBase(filename, uid, gid) {
          this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
        }
        lchownSync(path2, uid, gid) {
          validateUid(uid);
          validateGid(gid);
          this.lchownBase((0, util_1.pathToFilename)(path2), uid, gid);
        }
        lchown(path2, uid, gid, callback) {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(this.lchownBase, [(0, util_1.pathToFilename)(path2), uid, gid], callback);
        }
        watchFile(path2, a7, b5) {
          const filename = (0, util_1.pathToFilename)(path2);
          let options = a7;
          let listener = b5;
          if (typeof options === "function") {
            listener = a7;
            options = null;
          }
          if (typeof listener !== "function") {
            throw Error('"watchFile()" requires a listener function');
          }
          let interval = 5007;
          let persistent = true;
          if (options && typeof options === "object") {
            if (typeof options.interval === "number")
              interval = options.interval;
            if (typeof options.persistent === "boolean")
              persistent = options.persistent;
          }
          let watcher = this.statWatchers[filename];
          if (!watcher) {
            watcher = new this.StatWatcher();
            watcher.start(filename, persistent, interval);
            this.statWatchers[filename] = watcher;
          }
          watcher.addListener("change", listener);
          return watcher;
        }
        unwatchFile(path2, listener) {
          const filename = (0, util_1.pathToFilename)(path2);
          const watcher = this.statWatchers[filename];
          if (!watcher)
            return;
          if (typeof listener === "function") {
            watcher.removeListener("change", listener);
          } else {
            watcher.removeAllListeners("change");
          }
          if (watcher.listenerCount("change") === 0) {
            watcher.stop();
            delete this.statWatchers[filename];
          }
        }
        createReadStream(path2, options) {
          return new this.ReadStream(path2, options);
        }
        createWriteStream(path2, options) {
          return new this.WriteStream(path2, options);
        }
        // watch(path: PathLike): FSWatcher;
        // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;
        watch(path2, options, listener) {
          const filename = (0, util_1.pathToFilename)(path2);
          let givenOptions = options;
          if (typeof options === "function") {
            listener = options;
            givenOptions = null;
          }
          let { persistent, recursive, encoding } = (0, options_1.getDefaultOpts)(givenOptions);
          if (persistent === void 0)
            persistent = true;
          if (recursive === void 0)
            recursive = false;
          const watcher = new this.FSWatcher();
          watcher.start(filename, persistent, recursive, encoding);
          if (listener) {
            watcher.addListener("change", listener);
          }
          return watcher;
        }
        opendirBase(filename, options) {
          const link4 = this.getResolvedLinkOrThrow(filename, "scandir");
          const node = link4.getNode();
          if (!node.isDirectory())
            throw (0, util_1.createError)(ENOTDIR, "scandir", filename);
          return new Dir_1.Dir(link4, options);
        }
        opendirSync(path2, options) {
          const opts = (0, options_1.getOpendirOptions)(options);
          const filename = (0, util_1.pathToFilename)(path2);
          return this.opendirBase(filename, opts);
        }
        opendir(path2, a7, b5) {
          const [options, callback] = (0, options_1.getOpendirOptsAndCb)(a7, b5);
          const filename = (0, util_1.pathToFilename)(path2);
          this.wrapAsync(this.opendirBase, [filename, options], callback);
        }
      };
      exports9.Volume = Volume;
      Volume.fd = 2147483647;
      function emitStop(self2) {
        self2.emit("stop");
      }
      var StatWatcher = class extends events_1.EventEmitter {
        constructor(vol2) {
          super();
          this.onInterval = () => {
            try {
              const stats = this.vol.statSync(this.filename);
              if (this.hasChanged(stats)) {
                this.emit("change", stats, this.prev);
                this.prev = stats;
              }
            } finally {
              this.loop();
            }
          };
          this.vol = vol2;
        }
        loop() {
          this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
        }
        hasChanged(stats) {
          if (stats.mtimeMs > this.prev.mtimeMs)
            return true;
          if (stats.nlink !== this.prev.nlink)
            return true;
          return false;
        }
        start(path2, persistent = true, interval = 5007) {
          this.filename = (0, util_1.pathToFilename)(path2);
          this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : global) : setTimeoutUnref_1.default;
          this.interval = interval;
          this.prev = this.vol.statSync(this.filename);
          this.loop();
        }
        stop() {
          clearTimeout(this.timeoutRef);
          (0, queueMicrotask_1.default)(() => {
            emitStop.call(this, this);
          });
        }
      };
      exports9.StatWatcher = StatWatcher;
      var pool2;
      function allocNewPool(poolSize) {
        pool2 = (0, buffer_1.bufferAllocUnsafe)(poolSize);
        pool2.used = 0;
      }
      util.inherits(FsReadStream, stream_1.Readable);
      exports9.ReadStream = FsReadStream;
      function FsReadStream(vol2, path2, options) {
        if (!(this instanceof FsReadStream))
          return new FsReadStream(vol2, path2, options);
        this._vol = vol2;
        options = Object.assign({}, (0, options_1.getOptions)(options, {}));
        if (options.highWaterMark === void 0)
          options.highWaterMark = 64 * 1024;
        stream_1.Readable.call(this, options);
        this.path = (0, util_1.pathToFilename)(path2);
        this.fd = options.fd === void 0 ? null : options.fd;
        this.flags = options.flags === void 0 ? "r" : options.flags;
        this.mode = options.mode === void 0 ? 438 : options.mode;
        this.start = options.start;
        this.end = options.end;
        this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
        this.pos = void 0;
        this.bytesRead = 0;
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw new TypeError('"start" option must be a Number');
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw new TypeError('"end" option must be a Number');
          }
          if (this.start > this.end) {
            throw new Error('"start" option must be <= "end" option');
          }
          this.pos = this.start;
        }
        if (typeof this.fd !== "number")
          this.open();
        this.on("end", function() {
          if (this.autoClose) {
            if (this.destroy)
              this.destroy();
          }
        });
      }
      FsReadStream.prototype.open = function() {
        var self2 = this;
        this._vol.open(this.path, this.flags, this.mode, (er, fd) => {
          if (er) {
            if (self2.autoClose) {
              if (self2.destroy)
                self2.destroy();
            }
            self2.emit("error", er);
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2.read();
        });
      };
      FsReadStream.prototype._read = function(n8) {
        if (typeof this.fd !== "number") {
          return this.once("open", function() {
            this._read(n8);
          });
        }
        if (this.destroyed)
          return;
        if (!pool2 || pool2.length - pool2.used < kMinPoolSpace) {
          allocNewPool(this._readableState.highWaterMark);
        }
        var thisPool = pool2;
        var toRead = Math.min(pool2.length - pool2.used, n8);
        var start = pool2.used;
        if (this.pos !== void 0)
          toRead = Math.min(this.end - this.pos + 1, toRead);
        if (toRead <= 0)
          return this.push(null);
        var self2 = this;
        this._vol.read(this.fd, pool2, pool2.used, toRead, this.pos, onread);
        if (this.pos !== void 0)
          this.pos += toRead;
        pool2.used += toRead;
        function onread(er, bytesRead) {
          if (er) {
            if (self2.autoClose && self2.destroy) {
              self2.destroy();
            }
            self2.emit("error", er);
          } else {
            var b5 = null;
            if (bytesRead > 0) {
              self2.bytesRead += bytesRead;
              b5 = thisPool.slice(start, start + bytesRead);
            }
            self2.push(b5);
          }
        }
      };
      FsReadStream.prototype._destroy = function(err, cb) {
        this.close((err2) => {
          cb(err || err2);
        });
      };
      FsReadStream.prototype.close = function(cb) {
        var _a;
        if (cb)
          this.once("close", cb);
        if (this.closed || typeof this.fd !== "number") {
          if (typeof this.fd !== "number") {
            this.once("open", closeOnOpen);
            return;
          }
          return (0, queueMicrotask_1.default)(() => this.emit("close"));
        }
        if (typeof ((_a = this._readableState) === null || _a === void 0 ? void 0 : _a.closed) === "boolean") {
          this._readableState.closed = true;
        } else {
          this.closed = true;
        }
        this._vol.close(this.fd, (er) => {
          if (er)
            this.emit("error", er);
          else
            this.emit("close");
        });
        this.fd = null;
      };
      function closeOnOpen(fd) {
        this.close();
      }
      util.inherits(FsWriteStream, stream_1.Writable);
      exports9.WriteStream = FsWriteStream;
      function FsWriteStream(vol2, path2, options) {
        if (!(this instanceof FsWriteStream))
          return new FsWriteStream(vol2, path2, options);
        this._vol = vol2;
        options = Object.assign({}, (0, options_1.getOptions)(options, {}));
        stream_1.Writable.call(this, options);
        this.path = (0, util_1.pathToFilename)(path2);
        this.fd = options.fd === void 0 ? null : options.fd;
        this.flags = options.flags === void 0 ? "w" : options.flags;
        this.mode = options.mode === void 0 ? 438 : options.mode;
        this.start = options.start;
        this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
        this.pos = void 0;
        this.bytesWritten = 0;
        this.pending = true;
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw new TypeError('"start" option must be a Number');
          }
          if (this.start < 0) {
            throw new Error('"start" must be >= zero');
          }
          this.pos = this.start;
        }
        if (options.encoding)
          this.setDefaultEncoding(options.encoding);
        if (typeof this.fd !== "number")
          this.open();
        this.once("finish", function() {
          if (this.autoClose) {
            this.close();
          }
        });
      }
      FsWriteStream.prototype.open = function() {
        this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
          if (er) {
            if (this.autoClose && this.destroy) {
              this.destroy();
            }
            this.emit("error", er);
            return;
          }
          this.fd = fd;
          this.pending = false;
          this.emit("open", fd);
        }.bind(this));
      };
      FsWriteStream.prototype._write = function(data, encoding, cb) {
        if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array))
          return this.emit("error", new Error("Invalid data"));
        if (typeof this.fd !== "number") {
          return this.once("open", function() {
            this._write(data, encoding, cb);
          });
        }
        var self2 = this;
        this._vol.write(this.fd, data, 0, data.length, this.pos, (er, bytes) => {
          if (er) {
            if (self2.autoClose && self2.destroy) {
              self2.destroy();
            }
            return cb(er);
          }
          self2.bytesWritten += bytes;
          cb();
        });
        if (this.pos !== void 0)
          this.pos += data.length;
      };
      FsWriteStream.prototype._writev = function(data, cb) {
        if (typeof this.fd !== "number") {
          return this.once("open", function() {
            this._writev(data, cb);
          });
        }
        const self2 = this;
        const len = data.length;
        const chunks = new Array(len);
        var size = 0;
        for (var i7 = 0; i7 < len; i7++) {
          var chunk = data[i7].chunk;
          chunks[i7] = chunk;
          size += chunk.length;
        }
        const buf3 = buffer_1.Buffer.concat(chunks);
        this._vol.write(this.fd, buf3, 0, buf3.length, this.pos, (er, bytes) => {
          if (er) {
            if (self2.destroy)
              self2.destroy();
            return cb(er);
          }
          self2.bytesWritten += bytes;
          cb();
        });
        if (this.pos !== void 0)
          this.pos += size;
      };
      FsWriteStream.prototype.close = function(cb) {
        var _a;
        if (cb)
          this.once("close", cb);
        if (this.closed || typeof this.fd !== "number") {
          if (typeof this.fd !== "number") {
            this.once("open", closeOnOpen);
            return;
          }
          return (0, queueMicrotask_1.default)(() => this.emit("close"));
        }
        if (typeof ((_a = this._writableState) === null || _a === void 0 ? void 0 : _a.closed) === "boolean") {
          this._writableState.closed = true;
        } else {
          this.closed = true;
        }
        this._vol.close(this.fd, (er) => {
          if (er)
            this.emit("error", er);
          else
            this.emit("close");
        });
        this.fd = null;
      };
      FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
      FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
      var FSWatcher = class extends events_1.EventEmitter {
        constructor(vol2) {
          super();
          this._filename = "";
          this._filenameEncoded = "";
          this._recursive = false;
          this._encoding = encoding_1.ENCODING_UTF8;
          this._listenerRemovers = /* @__PURE__ */ new Map();
          this._onParentChild = (link4) => {
            if (link4.getName() === this._getName()) {
              this._emit("rename");
            }
          };
          this._emit = (type2) => {
            this.emit("change", type2, this._filenameEncoded);
          };
          this._persist = () => {
            this._timer = setTimeout(this._persist, 1e6);
          };
          this._vol = vol2;
        }
        _getName() {
          return this._steps[this._steps.length - 1];
        }
        start(path2, persistent = true, recursive = false, encoding = encoding_1.ENCODING_UTF8) {
          this._filename = (0, util_1.pathToFilename)(path2);
          this._steps = filenameToSteps(this._filename);
          this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
          this._recursive = recursive;
          this._encoding = encoding;
          try {
            this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
          } catch (err) {
            const error = new Error(`watch ${this._filename} ${err.code}`);
            error.code = err.code;
            error.errno = err.code;
            throw error;
          }
          const watchLinkNodeChanged = (link4) => {
            var _a;
            const filepath = link4.getPath();
            const node = link4.getNode();
            const onNodeChange = () => {
              let filename = relative2(this._filename, filepath);
              if (!filename) {
                filename = this._getName();
              }
              return this.emit("change", "change", filename);
            };
            node.on("change", onNodeChange);
            const removers = (_a = this._listenerRemovers.get(node.ino)) !== null && _a !== void 0 ? _a : [];
            removers.push(() => node.removeListener("change", onNodeChange));
            this._listenerRemovers.set(node.ino, removers);
          };
          const watchLinkChildrenChanged = (link4) => {
            var _a;
            const node = link4.getNode();
            const onLinkChildAdd = (l7) => {
              this.emit("change", "rename", relative2(this._filename, l7.getPath()));
              setTimeout(() => {
                watchLinkNodeChanged(l7);
                watchLinkChildrenChanged(l7);
              });
            };
            const onLinkChildDelete = (l7) => {
              const removeLinkNodeListeners = (curLink) => {
                const ino = curLink.getNode().ino;
                const removers2 = this._listenerRemovers.get(ino);
                if (removers2) {
                  removers2.forEach((r9) => r9());
                  this._listenerRemovers.delete(ino);
                }
                for (const [name8, childLink] of curLink.children.entries()) {
                  if (childLink && name8 !== "." && name8 !== "..") {
                    removeLinkNodeListeners(childLink);
                  }
                }
              };
              removeLinkNodeListeners(l7);
              this.emit("change", "rename", relative2(this._filename, l7.getPath()));
            };
            for (const [name8, childLink] of link4.children.entries()) {
              if (childLink && name8 !== "." && name8 !== "..") {
                watchLinkNodeChanged(childLink);
              }
            }
            link4.on("child:add", onLinkChildAdd);
            link4.on("child:delete", onLinkChildDelete);
            const removers = (_a = this._listenerRemovers.get(node.ino)) !== null && _a !== void 0 ? _a : [];
            removers.push(() => {
              link4.removeListener("child:add", onLinkChildAdd);
              link4.removeListener("child:delete", onLinkChildDelete);
            });
            if (recursive) {
              for (const [name8, childLink] of link4.children.entries()) {
                if (childLink && name8 !== "." && name8 !== "..") {
                  watchLinkChildrenChanged(childLink);
                }
              }
            }
          };
          watchLinkNodeChanged(this._link);
          watchLinkChildrenChanged(this._link);
          const parent = this._link.parent;
          if (parent) {
            parent.setMaxListeners(parent.getMaxListeners() + 1);
            parent.on("child:delete", this._onParentChild);
          }
          if (persistent)
            this._persist();
        }
        close() {
          clearTimeout(this._timer);
          this._listenerRemovers.forEach((removers) => {
            removers.forEach((r9) => r9());
          });
          this._listenerRemovers.clear();
          const parent = this._link.parent;
          if (parent) {
            parent.removeListener("child:delete", this._onParentChild);
          }
        }
      };
      exports9.FSWatcher = FSWatcher;
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/lists/fsSynchronousApiList.js
  var require_fsSynchronousApiList = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/lists/fsSynchronousApiList.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.fsSynchronousApiList = void 0;
      exports9.fsSynchronousApiList = [
        "accessSync",
        "appendFileSync",
        "chmodSync",
        "chownSync",
        "closeSync",
        "copyFileSync",
        "existsSync",
        "fchmodSync",
        "fchownSync",
        "fdatasyncSync",
        "fstatSync",
        "fsyncSync",
        "ftruncateSync",
        "futimesSync",
        "lchmodSync",
        "lchownSync",
        "linkSync",
        "lstatSync",
        "mkdirSync",
        "mkdtempSync",
        "openSync",
        "readdirSync",
        "readFileSync",
        "readlinkSync",
        "readSync",
        "readvSync",
        "realpathSync",
        "renameSync",
        "rmdirSync",
        "rmSync",
        "statSync",
        "symlinkSync",
        "truncateSync",
        "unlinkSync",
        "utimesSync",
        "writeFileSync",
        "writeSync",
        "writevSync"
        // 'cpSync',
        // 'lutimesSync',
        // 'statfsSync',
      ];
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/lists/fsCallbackApiList.js
  var require_fsCallbackApiList = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/node/lists/fsCallbackApiList.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.fsCallbackApiList = void 0;
      exports9.fsCallbackApiList = [
        "access",
        "appendFile",
        "chmod",
        "chown",
        "close",
        "copyFile",
        "createReadStream",
        "createWriteStream",
        "exists",
        "fchmod",
        "fchown",
        "fdatasync",
        "fstat",
        "fsync",
        "ftruncate",
        "futimes",
        "lchmod",
        "lchown",
        "link",
        "lstat",
        "mkdir",
        "mkdtemp",
        "open",
        "read",
        "readv",
        "readdir",
        "readFile",
        "readlink",
        "realpath",
        "rename",
        "rm",
        "rmdir",
        "stat",
        "symlink",
        "truncate",
        "unlink",
        "unwatchFile",
        "utimes",
        "watch",
        "watchFile",
        "write",
        "writev",
        "writeFile"
      ];
    }
  });

  // node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/.pnpm/memfs@4.12.0/node_modules/memfs/lib/index.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports9, "__esModule", { value: true });
      exports9.memfs = exports9.fs = exports9.vol = exports9.Volume = void 0;
      exports9.createFsFromVolume = createFsFromVolume2;
      var Stats_1 = require_Stats();
      var Dirent_1 = require_Dirent();
      var volume_1 = require_volume();
      var constants_1 = require_constants();
      var fsSynchronousApiList_1 = require_fsSynchronousApiList();
      var fsCallbackApiList_1 = require_fsCallbackApiList();
      var { F_OK: F_OK2, R_OK: R_OK2, W_OK: W_OK2, X_OK: X_OK2 } = constants_1.constants;
      exports9.Volume = volume_1.Volume;
      exports9.vol = new volume_1.Volume();
      function createFsFromVolume2(vol2) {
        const fs3 = { F_OK: F_OK2, R_OK: R_OK2, W_OK: W_OK2, X_OK: X_OK2, constants: constants_1.constants, Stats: Stats_1.default, Dirent: Dirent_1.default };
        for (const method of fsSynchronousApiList_1.fsSynchronousApiList)
          if (typeof vol2[method] === "function")
            fs3[method] = vol2[method].bind(vol2);
        for (const method of fsCallbackApiList_1.fsCallbackApiList)
          if (typeof vol2[method] === "function")
            fs3[method] = vol2[method].bind(vol2);
        fs3.StatWatcher = vol2.StatWatcher;
        fs3.FSWatcher = vol2.FSWatcher;
        fs3.WriteStream = vol2.WriteStream;
        fs3.ReadStream = vol2.ReadStream;
        fs3.promises = vol2.promises;
        fs3._toUnixTimestamp = volume_1.toUnixTimestamp;
        fs3.__vol = vol2;
        return fs3;
      }
      exports9.fs = createFsFromVolume2(exports9.vol);
      var memfs = (json = {}, cwd2 = "/") => {
        const vol2 = exports9.Volume.fromNestedJSON(json, cwd2);
        const fs3 = createFsFromVolume2(vol2);
        return { fs: fs3, vol: vol2 };
      };
      exports9.memfs = memfs;
      module2.exports = Object.assign(Object.assign({}, module2.exports), exports9.fs);
      module2.exports.semantic = true;
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/mem-filesystem-BZQZLUR6.js
  var mem_filesystem_BZQZLUR6_exports = {};
  __export(mem_filesystem_BZQZLUR6_exports, {
    MemFileSystem: () => MemFileSystem
  });
  var import_memfs, MemFileSystem;
  var init_mem_filesystem_BZQZLUR6 = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/mem-filesystem-BZQZLUR6.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_XINRLWR3();
      init_chunk_MAK4D54P();
      import_memfs = __toESM(require_lib2(), 1);
      MemFileSystem = class {
        async start() {
          return this;
        }
        mkdir(path2, options) {
          return import_memfs.fs.promises.mkdir(path2, options);
        }
        readdir(path2, options) {
          return import_memfs.fs.promises.readdir(path2, options);
        }
        rm(path2, options) {
          return import_memfs.fs.promises.rm(path2, options);
        }
        copyFile(source, destination) {
          return import_memfs.fs.promises.copyFile(source, destination);
        }
        async readfile(path2, options) {
          const ret = await import_memfs.fs.promises.readFile(path2, options);
          return toArrayBuffer(ret);
        }
        stat(path2) {
          return import_memfs.fs.promises.stat(path2);
        }
        unlink(path2) {
          return import_memfs.fs.promises.unlink(path2);
        }
        writefile(path2, data) {
          return import_memfs.fs.promises.writeFile(path2, Buffer.from(data));
        }
      };
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/fs.js
  function dew$f2() {
    if (_dewExec$f2) return exports$h;
    _dewExec$f2 = true;
    Object.defineProperty(exports$h, "__esModule", {
      value: true
    });
    exports$h.constants = void 0;
    exports$h.constants = {
      O_RDONLY: 0,
      O_WRONLY: 1,
      O_RDWR: 2,
      S_IFMT: 61440,
      S_IFREG: 32768,
      S_IFDIR: 16384,
      S_IFCHR: 8192,
      S_IFBLK: 24576,
      S_IFIFO: 4096,
      S_IFLNK: 40960,
      S_IFSOCK: 49152,
      O_CREAT: 64,
      O_EXCL: 128,
      O_NOCTTY: 256,
      O_TRUNC: 512,
      O_APPEND: 1024,
      O_DIRECTORY: 65536,
      O_NOATIME: 262144,
      O_NOFOLLOW: 131072,
      O_SYNC: 1052672,
      O_DIRECT: 16384,
      O_NONBLOCK: 2048,
      S_IRWXU: 448,
      S_IRUSR: 256,
      S_IWUSR: 128,
      S_IXUSR: 64,
      S_IRWXG: 56,
      S_IRGRP: 32,
      S_IWGRP: 16,
      S_IXGRP: 8,
      S_IRWXO: 7,
      S_IROTH: 4,
      S_IWOTH: 2,
      S_IXOTH: 1,
      F_OK: 0,
      R_OK: 4,
      W_OK: 2,
      X_OK: 1,
      UV_FS_SYMLINK_DIR: 1,
      UV_FS_SYMLINK_JUNCTION: 2,
      UV_FS_COPYFILE_EXCL: 1,
      UV_FS_COPYFILE_FICLONE: 2,
      UV_FS_COPYFILE_FICLONE_FORCE: 4,
      COPYFILE_EXCL: 1,
      COPYFILE_FICLONE: 2,
      COPYFILE_FICLONE_FORCE: 4
    };
    return exports$h;
  }
  function dew$e2() {
    if (_dewExec$e2) return exports$g2;
    _dewExec$e2 = true;
    if (typeof BigInt === "function") exports$g2.default = BigInt;
    else exports$g2.default = function BigIntNotSupported() {
      throw new Error("BigInt is not supported in this environment.");
    };
    return exports$g2;
  }
  function dew$d2() {
    if (_dewExec$d2) return exports$f2;
    _dewExec$d2 = true;
    Object.defineProperty(exports$f2, "__esModule", {
      value: true
    });
    exports$f2.Stats = void 0;
    var constants_1 = dew$f2();
    var getBigInt_1 = dew$e2();
    var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
    var Stats2 = function() {
      function Stats3() {
      }
      Stats3.build = function(node, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var stats = new Stats3();
        var uid = node.uid, gid = node.gid, atime = node.atime, mtime = node.mtime, ctime = node.ctime;
        var getStatNumber = !bigint ? function(number) {
          return number;
        } : getBigInt_1.default;
        stats.uid = getStatNumber(uid);
        stats.gid = getStatNumber(gid);
        stats.rdev = getStatNumber(0);
        stats.blksize = getStatNumber(4096);
        stats.ino = getStatNumber(node.ino);
        stats.size = getStatNumber(node.getSize());
        stats.blocks = getStatNumber(1);
        stats.atime = atime;
        stats.mtime = mtime;
        stats.ctime = ctime;
        stats.birthtime = ctime;
        stats.atimeMs = getStatNumber(atime.getTime());
        stats.mtimeMs = getStatNumber(mtime.getTime());
        var ctimeMs = getStatNumber(ctime.getTime());
        stats.ctimeMs = ctimeMs;
        stats.birthtimeMs = ctimeMs;
        stats.dev = getStatNumber(0);
        stats.mode = getStatNumber(node.mode);
        stats.nlink = getStatNumber(node.nlink);
        return stats;
      };
      Stats3.prototype._checkModeProperty = function(property) {
        return (Number(this.mode) & S_IFMT) === property;
      };
      Stats3.prototype.isDirectory = function() {
        return this._checkModeProperty(S_IFDIR);
      };
      Stats3.prototype.isFile = function() {
        return this._checkModeProperty(S_IFREG);
      };
      Stats3.prototype.isBlockDevice = function() {
        return this._checkModeProperty(S_IFBLK);
      };
      Stats3.prototype.isCharacterDevice = function() {
        return this._checkModeProperty(S_IFCHR);
      };
      Stats3.prototype.isSymbolicLink = function() {
        return this._checkModeProperty(S_IFLNK);
      };
      Stats3.prototype.isFIFO = function() {
        return this._checkModeProperty(S_IFIFO);
      };
      Stats3.prototype.isSocket = function() {
        return this._checkModeProperty(S_IFSOCK);
      };
      return Stats3;
    }();
    exports$f2.Stats = Stats2;
    exports$f2.default = Stats2;
    return exports$f2;
  }
  function dew$c2() {
    if (_dewExec$c2) return exports$e2;
    _dewExec$c2 = true;
    var __spreadArray2 = exports$e2 && exports$e2.__spreadArray || function(to, from8, pack) {
      if (pack || arguments.length === 2) for (var i7 = 0, l7 = from8.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from8)) {
          if (!ar) ar = Array.prototype.slice.call(from8, 0, i7);
          ar[i7] = from8[i7];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from8));
    };
    Object.defineProperty(exports$e2, "__esModule", {
      value: true
    });
    exports$e2.bufferFrom = exports$e2.bufferAllocUnsafe = exports$e2.Buffer = void 0;
    var buffer_1 = buffer;
    Object.defineProperty(exports$e2, "Buffer", {
      enumerable: true,
      get: function() {
        return buffer_1.Buffer;
      }
    });
    function bufferV0P12Ponyfill(arg0) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray2([void 0, arg0], args, false)))();
    }
    var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
    exports$e2.bufferAllocUnsafe = bufferAllocUnsafe;
    var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
    exports$e2.bufferFrom = bufferFrom;
    return exports$e2;
  }
  function dew$b2() {
    if (_dewExec$b2) return exports$d2;
    _dewExec$b2 = true;
    var __extends2 = exports$d2 && exports$d2.__extends || /* @__PURE__ */ function() {
      var extendStatics2 = function(d6, b5) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d7, b6) {
          d7.__proto__ = b6;
        } || function(d7, b6) {
          for (var p7 in b6) if (Object.prototype.hasOwnProperty.call(b6, p7)) d7[p7] = b6[p7];
        };
        return extendStatics2(d6, b5);
      };
      return function(d6, b5) {
        if (typeof b5 !== "function" && b5 !== null) throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics2(d6, b5);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    Object.defineProperty(exports$d2, "__esModule", {
      value: true
    });
    exports$d2.E = exports$d2.AssertionError = exports$d2.message = exports$d2.RangeError = exports$d2.TypeError = exports$d2.Error = void 0;
    var assert3 = et;
    var util = X;
    var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
    var messages = {};
    function makeNodeError(Base) {
      return function(_super) {
        __extends2(NodeError, _super);
        function NodeError(key) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          var _this = _super.call(this, message2(key, args)) || this;
          _this.code = key;
          _this[kCode] = key;
          _this.name = _super.prototype.name + " [" + _this[kCode] + "]";
          return _this;
        }
        return NodeError;
      }(Base);
    }
    var g5 = typeof globalThis !== "undefined" ? globalThis : _global$3;
    var AssertionError2 = function(_super) {
      __extends2(AssertionError3, _super);
      function AssertionError3(options) {
        var _this = this;
        if (typeof options !== "object" || options === null) {
          throw new exports$d2.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
        }
        if (options.message) {
          _this = _super.call(this, options.message) || this;
        } else {
          _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + " " + (options.operator + " " + util.inspect(options.expected).slice(0, 128))) || this;
        }
        _this.generatedMessage = !options.message;
        _this.name = "AssertionError [ERR_ASSERTION]";
        _this.code = "ERR_ASSERTION";
        _this.actual = options.actual;
        _this.expected = options.expected;
        _this.operator = options.operator;
        exports$d2.Error.captureStackTrace(_this, options.stackStartFunction);
        return _this;
      }
      return AssertionError3;
    }(g5.Error);
    exports$d2.AssertionError = AssertionError2;
    function message2(key, args) {
      assert3.strictEqual(typeof key, "string");
      var msg = messages[key];
      assert3(msg, "An invalid error message key was used: " + key + ".");
      var fmt;
      if (typeof msg === "function") {
        fmt = msg;
      } else {
        fmt = util.format;
        if (args === void 0 || args.length === 0) return msg;
        args.unshift(msg);
      }
      return String(fmt.apply(null, args));
    }
    exports$d2.message = message2;
    function E4(sym, val) {
      messages[sym] = typeof val === "function" ? val : String(val);
    }
    exports$d2.E = E4;
    exports$d2.Error = makeNodeError(g5.Error);
    exports$d2.TypeError = makeNodeError(g5.TypeError);
    exports$d2.RangeError = makeNodeError(g5.RangeError);
    E4("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
    E4("ERR_ASSERTION", "%s");
    E4("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
    E4("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
    E4("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
    E4("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
    E4("ERR_DNS_SET_SERVERS_FAILED", function(err, servers) {
      return 'c-ares failed to set servers: "' + err + '" [' + servers + "]";
    });
    E4("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
    E4("ERR_ENCODING_NOT_SUPPORTED", function(enc) {
      return 'The "' + enc + '" encoding is not supported';
    });
    E4("ERR_ENCODING_INVALID_ENCODED_DATA", function(enc) {
      return "The encoded data was not valid for encoding " + enc;
    });
    E4("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
    E4("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
    E4("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
    E4("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
    E4("ERR_INVALID_ARG_TYPE", invalidArgType);
    E4("ERR_INVALID_ARRAY_LENGTH", function(name8, len, actual) {
      assert3.strictEqual(typeof actual, "number");
      return 'The array "' + name8 + '" (length ' + actual + ") must be of length " + len + ".";
    });
    E4("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
    E4("ERR_INVALID_CALLBACK", "Callback must be a function");
    E4("ERR_INVALID_CHAR", "Invalid character in %s");
    E4("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
    E4("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
    E4("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
    E4("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
    E4("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
    E4("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
    E4("ERR_INVALID_OPT_VALUE", function(name8, value) {
      return 'The value "' + String(value) + '" is invalid for option "' + name8 + '"';
    });
    E4("ERR_INVALID_OPT_VALUE_ENCODING", function(value) {
      return 'The value "' + String(value) + '" is invalid for option "encoding"';
    });
    E4("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
    E4("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
    E4("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
    E4("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
    E4("ERR_INVALID_URL", "Invalid URL: %s");
    E4("ERR_INVALID_URL_SCHEME", function(expected) {
      return "The URL must be " + oneOf(expected, "scheme");
    });
    E4("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
    E4("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
    E4("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
    E4("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
    E4("ERR_MISSING_ARGS", missingArgs);
    E4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    E4("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
    E4("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
    E4("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
    E4("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
    E4("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
    E4("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
    E4("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
    E4("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
    E4("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
    E4("ERR_SOCKET_CLOSED", "Socket is closed");
    E4("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
    E4("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
    E4("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
    E4("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
    E4("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
    E4("ERR_TLS_DH_PARAM_SIZE", function(size) {
      return "DH parameter size " + size + " is less than 2048";
    });
    E4("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
    E4("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
    E4("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
    E4("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
    E4("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
    E4("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
    E4("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
    E4("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
    E4("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
    E4("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
    E4("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
    function invalidArgType(name8, expected, actual) {
      assert3(name8, "name is required");
      var determiner;
      if (expected.includes("not ")) {
        determiner = "must not be";
        expected = expected.split("not ")[1];
      } else {
        determiner = "must be";
      }
      var msg;
      if (Array.isArray(name8)) {
        var names = name8.map(function(val) {
          return '"' + val + '"';
        }).join(", ");
        msg = "The " + names + " arguments " + determiner + " " + oneOf(expected, "type");
      } else if (name8.includes(" argument")) {
        msg = "The " + name8 + " " + determiner + " " + oneOf(expected, "type");
      } else {
        var type2 = name8.includes(".") ? "property" : "argument";
        msg = 'The "' + name8 + '" ' + type2 + " " + determiner + " " + oneOf(expected, "type");
      }
      if (arguments.length >= 3) {
        msg += ". Received type " + (actual !== null ? typeof actual : "null");
      }
      return msg;
    }
    function missingArgs() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      assert3(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len = args.length;
      args = args.map(function(a7) {
        return '"' + a7 + '"';
      });
      switch (len) {
        case 1:
          msg += args[0] + " argument";
          break;
        case 2:
          msg += args[0] + " and " + args[1] + " arguments";
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += ", and " + args[len - 1] + " arguments";
          break;
      }
      return msg + " must be specified";
    }
    function oneOf(expected, thing) {
      assert3(expected, "expected is required");
      assert3(typeof thing === "string", "thing is required");
      if (Array.isArray(expected)) {
        var len = expected.length;
        assert3(len > 0, "At least one expected value needs to be specified");
        expected = expected.map(function(i7) {
          return String(i7);
        });
        if (len > 2) {
          return "one of " + thing + " " + expected.slice(0, len - 1).join(", ") + ", or " + expected[len - 1];
        } else if (len === 2) {
          return "one of " + thing + " " + expected[0] + " or " + expected[1];
        } else {
          return "of " + thing + " " + expected[0];
        }
      } else {
        return "of " + thing + " " + String(expected);
      }
    }
    function bufferOutOfBounds(name8, isWriting) {
      if (isWriting) {
        return "Attempt to write outside buffer bounds";
      } else {
        return '"' + name8 + '" is outside of buffer bounds';
      }
    }
    return exports$d2;
  }
  function dew$a2() {
    if (_dewExec$a2) return exports$c2;
    _dewExec$a2 = true;
    Object.defineProperty(exports$c2, "__esModule", {
      value: true
    });
    exports$c2.strToEncoding = exports$c2.assertEncoding = exports$c2.ENCODING_UTF8 = void 0;
    var buffer_1 = dew$c2();
    var errors = dew$b2();
    exports$c2.ENCODING_UTF8 = "utf8";
    function assertEncoding(encoding) {
      if (encoding && !buffer_1.Buffer.isEncoding(encoding)) throw new errors.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
    }
    exports$c2.assertEncoding = assertEncoding;
    function strToEncoding(str, encoding) {
      if (!encoding || encoding === exports$c2.ENCODING_UTF8) return str;
      if (encoding === "buffer") return new buffer_1.Buffer(str);
      return new buffer_1.Buffer(str).toString(encoding);
    }
    exports$c2.strToEncoding = strToEncoding;
    return exports$c2;
  }
  function dew$92() {
    if (_dewExec$92) return exports$b2;
    _dewExec$92 = true;
    Object.defineProperty(exports$b2, "__esModule", {
      value: true
    });
    exports$b2.Dirent = void 0;
    var constants_1 = dew$f2();
    var encoding_1 = dew$a2();
    var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
    var Dirent2 = function() {
      function Dirent3() {
        this.name = "";
        this.mode = 0;
      }
      Dirent3.build = function(link4, encoding) {
        var dirent = new Dirent3();
        var mode = link4.getNode().mode;
        dirent.name = (0, encoding_1.strToEncoding)(link4.getName(), encoding);
        dirent.mode = mode;
        return dirent;
      };
      Dirent3.prototype._checkModeProperty = function(property) {
        return (this.mode & S_IFMT) === property;
      };
      Dirent3.prototype.isDirectory = function() {
        return this._checkModeProperty(S_IFDIR);
      };
      Dirent3.prototype.isFile = function() {
        return this._checkModeProperty(S_IFREG);
      };
      Dirent3.prototype.isBlockDevice = function() {
        return this._checkModeProperty(S_IFBLK);
      };
      Dirent3.prototype.isCharacterDevice = function() {
        return this._checkModeProperty(S_IFCHR);
      };
      Dirent3.prototype.isSymbolicLink = function() {
        return this._checkModeProperty(S_IFLNK);
      };
      Dirent3.prototype.isFIFO = function() {
        return this._checkModeProperty(S_IFIFO);
      };
      Dirent3.prototype.isSocket = function() {
        return this._checkModeProperty(S_IFSOCK);
      };
      return Dirent3;
    }();
    exports$b2.Dirent = Dirent2;
    exports$b2.default = Dirent2;
    return exports$b2;
  }
  function dew$82() {
    if (_dewExec$82) return exports$a2;
    _dewExec$82 = true;
    var process$1 = process3;
    Object.defineProperty(exports$a2, "__esModule", {
      value: true
    });
    var _setImmediate;
    if (typeof process$1.nextTick === "function") _setImmediate = process$1.nextTick.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
    else _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
    exports$a2.default = _setImmediate;
    return exports$a2;
  }
  function dew$72() {
    if (_dewExec$72) return exports$92;
    _dewExec$72 = true;
    var process$1 = process3;
    Object.defineProperty(exports$92, "__esModule", {
      value: true
    });
    exports$92.createProcess = void 0;
    var maybeReturnProcess = function() {
      if (typeof process$1 !== "undefined") {
        return process$1;
      }
      try {
        return process3;
      } catch (_a) {
        return void 0;
      }
    };
    function createProcess() {
      var p7 = maybeReturnProcess() || {};
      if (!p7.getuid) p7.getuid = function() {
        return 0;
      };
      if (!p7.getgid) p7.getgid = function() {
        return 0;
      };
      if (!p7.cwd) p7.cwd = function() {
        return "/";
      };
      if (!p7.nextTick) p7.nextTick = dew$82().default;
      if (!p7.emitWarning) p7.emitWarning = function(message2, type2) {
        console.warn("" + type2 + (type2 ? ": " : "") + message2);
      };
      if (!p7.env) p7.env = {};
      return p7;
    }
    exports$92.createProcess = createProcess;
    exports$92.default = createProcess();
    return exports$92;
  }
  function dew$62() {
    if (_dewExec$62) return exports$82;
    _dewExec$62 = true;
    var __extends2 = exports$82 && exports$82.__extends || /* @__PURE__ */ function() {
      var extendStatics2 = function(d6, b5) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d7, b6) {
          d7.__proto__ = b6;
        } || function(d7, b6) {
          for (var p7 in b6) if (Object.prototype.hasOwnProperty.call(b6, p7)) d7[p7] = b6[p7];
        };
        return extendStatics2(d6, b5);
      };
      return function(d6, b5) {
        if (typeof b5 !== "function" && b5 !== null) throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics2(d6, b5);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    Object.defineProperty(exports$82, "__esModule", {
      value: true
    });
    exports$82.File = exports$82.Link = exports$82.Node = exports$82.SEP = void 0;
    var process_1 = dew$72();
    var buffer_1 = dew$c2();
    var constants_1 = dew$f2();
    var events_1 = y3;
    var Stats_1 = dew$d2();
    var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFLNK = constants_1.constants.S_IFLNK, O_APPEND = constants_1.constants.O_APPEND;
    exports$82.SEP = "/";
    var Node4 = function(_super) {
      __extends2(Node5, _super);
      function Node5(ino, perm) {
        if (perm === void 0) {
          perm = 438;
        }
        var _this = _super.call(this) || this;
        _this.uid = process_1.default.getuid();
        _this.gid = process_1.default.getgid();
        _this.atime = /* @__PURE__ */ new Date();
        _this.mtime = /* @__PURE__ */ new Date();
        _this.ctime = /* @__PURE__ */ new Date();
        _this.perm = 438;
        _this.mode = S_IFREG;
        _this.nlink = 1;
        _this.perm = perm;
        _this.mode |= perm;
        _this.ino = ino;
        return _this;
      }
      Node5.prototype.getString = function(encoding) {
        if (encoding === void 0) {
          encoding = "utf8";
        }
        return this.getBuffer().toString(encoding);
      };
      Node5.prototype.setString = function(str) {
        this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
        this.touch();
      };
      Node5.prototype.getBuffer = function() {
        if (!this.buf) this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
        return (0, buffer_1.bufferFrom)(this.buf);
      };
      Node5.prototype.setBuffer = function(buf3) {
        this.buf = (0, buffer_1.bufferFrom)(buf3);
        this.touch();
      };
      Node5.prototype.getSize = function() {
        return this.buf ? this.buf.length : 0;
      };
      Node5.prototype.setModeProperty = function(property) {
        this.mode = this.mode & ~S_IFMT | property;
      };
      Node5.prototype.setIsFile = function() {
        this.setModeProperty(S_IFREG);
      };
      Node5.prototype.setIsDirectory = function() {
        this.setModeProperty(S_IFDIR);
      };
      Node5.prototype.setIsSymlink = function() {
        this.setModeProperty(S_IFLNK);
      };
      Node5.prototype.isFile = function() {
        return (this.mode & S_IFMT) === S_IFREG;
      };
      Node5.prototype.isDirectory = function() {
        return (this.mode & S_IFMT) === S_IFDIR;
      };
      Node5.prototype.isSymlink = function() {
        return (this.mode & S_IFMT) === S_IFLNK;
      };
      Node5.prototype.makeSymlink = function(steps) {
        this.symlink = steps;
        this.setIsSymlink();
      };
      Node5.prototype.write = function(buf3, off2, len, pos) {
        if (off2 === void 0) {
          off2 = 0;
        }
        if (len === void 0) {
          len = buf3.length;
        }
        if (pos === void 0) {
          pos = 0;
        }
        if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (pos + len > this.buf.length) {
          var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
          this.buf.copy(newBuf, 0, 0, this.buf.length);
          this.buf = newBuf;
        }
        buf3.copy(this.buf, pos, off2, off2 + len);
        this.touch();
        return len;
      };
      Node5.prototype.read = function(buf3, off2, len, pos) {
        if (off2 === void 0) {
          off2 = 0;
        }
        if (len === void 0) {
          len = buf3.byteLength;
        }
        if (pos === void 0) {
          pos = 0;
        }
        if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        var actualLen = len;
        if (actualLen > buf3.byteLength) {
          actualLen = buf3.byteLength;
        }
        if (actualLen + pos > this.buf.length) {
          actualLen = this.buf.length - pos;
        }
        this.buf.copy(buf3, off2, pos, pos + actualLen);
        return actualLen;
      };
      Node5.prototype.truncate = function(len) {
        if (len === void 0) {
          len = 0;
        }
        if (!len) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        else {
          if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          if (len <= this.buf.length) {
            this.buf = this.buf.slice(0, len);
          } else {
            var buf3 = (0, buffer_1.bufferAllocUnsafe)(0);
            this.buf.copy(buf3);
            buf3.fill(0, len);
          }
        }
        this.touch();
      };
      Node5.prototype.chmod = function(perm) {
        this.perm = perm;
        this.mode = this.mode & ~511 | perm;
        this.touch();
      };
      Node5.prototype.chown = function(uid, gid) {
        this.uid = uid;
        this.gid = gid;
        this.touch();
      };
      Node5.prototype.touch = function() {
        this.mtime = /* @__PURE__ */ new Date();
        this.emit("change", this);
      };
      Node5.prototype.canRead = function(uid, gid) {
        if (uid === void 0) {
          uid = process_1.default.getuid();
        }
        if (gid === void 0) {
          gid = process_1.default.getgid();
        }
        if (this.perm & 4) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 32) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 256) {
            return true;
          }
        }
        return false;
      };
      Node5.prototype.canWrite = function(uid, gid) {
        if (uid === void 0) {
          uid = process_1.default.getuid();
        }
        if (gid === void 0) {
          gid = process_1.default.getgid();
        }
        if (this.perm & 2) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 16) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 128) {
            return true;
          }
        }
        return false;
      };
      Node5.prototype.del = function() {
        this.emit("delete", this);
      };
      Node5.prototype.toJSON = function() {
        return {
          ino: this.ino,
          uid: this.uid,
          gid: this.gid,
          atime: this.atime.getTime(),
          mtime: this.mtime.getTime(),
          ctime: this.ctime.getTime(),
          perm: this.perm,
          mode: this.mode,
          nlink: this.nlink,
          symlink: this.symlink,
          data: this.getString()
        };
      };
      return Node5;
    }(events_1.EventEmitter);
    exports$82.Node = Node4;
    var Link = function(_super) {
      __extends2(Link2, _super);
      function Link2(vol2, parent, name8) {
        var _this = _super.call(this) || this;
        _this.children = {};
        _this.steps = [];
        _this.ino = 0;
        _this.length = 0;
        _this.vol = vol2;
        _this.parent = parent;
        _this.steps = parent ? parent.steps.concat([name8]) : [name8];
        return _this;
      }
      Link2.prototype.setNode = function(node) {
        this.node = node;
        this.ino = node.ino;
      };
      Link2.prototype.getNode = function() {
        return this.node;
      };
      Link2.prototype.createChild = function(name8, node) {
        if (node === void 0) {
          node = this.vol.createNode();
        }
        var link4 = new Link2(this.vol, this, name8);
        link4.setNode(node);
        if (node.isDirectory()) ;
        this.setChild(name8, link4);
        return link4;
      };
      Link2.prototype.setChild = function(name8, link4) {
        if (link4 === void 0) {
          link4 = new Link2(this.vol, this, name8);
        }
        this.children[name8] = link4;
        link4.parent = this;
        this.length++;
        this.emit("child:add", link4, this);
        return link4;
      };
      Link2.prototype.deleteChild = function(link4) {
        delete this.children[link4.getName()];
        this.length--;
        this.emit("child:delete", link4, this);
      };
      Link2.prototype.getChild = function(name8) {
        if (Object.hasOwnProperty.call(this.children, name8)) {
          return this.children[name8];
        }
      };
      Link2.prototype.getPath = function() {
        return this.steps.join(exports$82.SEP);
      };
      Link2.prototype.getName = function() {
        return this.steps[this.steps.length - 1];
      };
      Link2.prototype.walk = function(steps, stop, i7) {
        if (stop === void 0) {
          stop = steps.length;
        }
        if (i7 === void 0) {
          i7 = 0;
        }
        if (i7 >= steps.length) return this;
        if (i7 >= stop) return this;
        var step2 = steps[i7];
        var link4 = this.getChild(step2);
        if (!link4) return null;
        return link4.walk(steps, stop, i7 + 1);
      };
      Link2.prototype.toJSON = function() {
        return {
          steps: this.steps,
          ino: this.ino,
          children: Object.keys(this.children)
        };
      };
      return Link2;
    }(events_1.EventEmitter);
    exports$82.Link = Link;
    var File2 = function() {
      function File3(link4, node, flags, fd) {
        this.position = 0;
        this.link = link4;
        this.node = node;
        this.flags = flags;
        this.fd = fd;
      }
      File3.prototype.getString = function(encoding) {
        return this.node.getString();
      };
      File3.prototype.setString = function(str) {
        this.node.setString(str);
      };
      File3.prototype.getBuffer = function() {
        return this.node.getBuffer();
      };
      File3.prototype.setBuffer = function(buf3) {
        this.node.setBuffer(buf3);
      };
      File3.prototype.getSize = function() {
        return this.node.getSize();
      };
      File3.prototype.truncate = function(len) {
        this.node.truncate(len);
      };
      File3.prototype.seekTo = function(position) {
        this.position = position;
      };
      File3.prototype.stats = function() {
        return Stats_1.default.build(this.node);
      };
      File3.prototype.write = function(buf3, offset, length4, position) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length4 === void 0) {
          length4 = buf3.length;
        }
        if (typeof position !== "number") position = this.position;
        if (this.flags & O_APPEND) position = this.getSize();
        var bytes = this.node.write(buf3, offset, length4, position);
        this.position = position + bytes;
        return bytes;
      };
      File3.prototype.read = function(buf3, offset, length4, position) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length4 === void 0) {
          length4 = buf3.byteLength;
        }
        if (typeof position !== "number") position = this.position;
        var bytes = this.node.read(buf3, offset, length4, position);
        this.position = position + bytes;
        return bytes;
      };
      File3.prototype.chmod = function(perm) {
        this.node.chmod(perm);
      };
      File3.prototype.chown = function(uid, gid) {
        this.node.chown(uid, gid);
      };
      return File3;
    }();
    exports$82.File = File2;
    return exports$82;
  }
  function dew$52() {
    if (_dewExec$52) return exports$72;
    _dewExec$52 = true;
    Object.defineProperty(exports$72, "__esModule", {
      value: true
    });
    function setTimeoutUnref(callback, time2, args) {
      var ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : _global$12, arguments);
      if (ref && typeof ref === "object" && typeof ref.unref === "function") ref.unref();
      return ref;
    }
    exports$72.default = setTimeoutUnref;
    return exports$72;
  }
  function dew$42() {
    if (_dewExec$42) return exports$62;
    _dewExec$42 = true;
    var __spreadArray2 = exports$62 && exports$62.__spreadArray || function(to, from8, pack) {
      if (pack || arguments.length === 2) for (var i7 = 0, l7 = from8.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from8)) {
          if (!ar) ar = Array.prototype.slice.call(from8, 0, i7);
          ar[i7] = from8[i7];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from8));
    };
    Object.defineProperty(exports$62, "__esModule", {
      value: true
    });
    exports$62.FileHandle = void 0;
    function promisify3(vol2, fn, getResult) {
      if (getResult === void 0) {
        getResult = function(input) {
          return input;
        };
      }
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return new Promise(function(resolve9, reject) {
          vol2[fn].bind(vol2).apply(void 0, __spreadArray2(__spreadArray2([], args, false), [function(error, result) {
            if (error) return reject(error);
            return resolve9(getResult(result));
          }], false));
        });
      };
    }
    var FileHandle = function() {
      function FileHandle2(vol2, fd) {
        this.vol = vol2;
        this.fd = fd;
      }
      FileHandle2.prototype.appendFile = function(data, options) {
        return promisify3(this.vol, "appendFile")(this.fd, data, options);
      };
      FileHandle2.prototype.chmod = function(mode) {
        return promisify3(this.vol, "fchmod")(this.fd, mode);
      };
      FileHandle2.prototype.chown = function(uid, gid) {
        return promisify3(this.vol, "fchown")(this.fd, uid, gid);
      };
      FileHandle2.prototype.close = function() {
        return promisify3(this.vol, "close")(this.fd);
      };
      FileHandle2.prototype.datasync = function() {
        return promisify3(this.vol, "fdatasync")(this.fd);
      };
      FileHandle2.prototype.read = function(buffer4, offset, length4, position) {
        return promisify3(this.vol, "read", function(bytesRead) {
          return {
            bytesRead,
            buffer: buffer4
          };
        })(this.fd, buffer4, offset, length4, position);
      };
      FileHandle2.prototype.readFile = function(options) {
        return promisify3(this.vol, "readFile")(this.fd, options);
      };
      FileHandle2.prototype.stat = function(options) {
        return promisify3(this.vol, "fstat")(this.fd, options);
      };
      FileHandle2.prototype.sync = function() {
        return promisify3(this.vol, "fsync")(this.fd);
      };
      FileHandle2.prototype.truncate = function(len) {
        return promisify3(this.vol, "ftruncate")(this.fd, len);
      };
      FileHandle2.prototype.utimes = function(atime, mtime) {
        return promisify3(this.vol, "futimes")(this.fd, atime, mtime);
      };
      FileHandle2.prototype.write = function(buffer4, offset, length4, position) {
        return promisify3(this.vol, "write", function(bytesWritten) {
          return {
            bytesWritten,
            buffer: buffer4
          };
        })(this.fd, buffer4, offset, length4, position);
      };
      FileHandle2.prototype.writeFile = function(data, options) {
        return promisify3(this.vol, "writeFile")(this.fd, data, options);
      };
      return FileHandle2;
    }();
    exports$62.FileHandle = FileHandle;
    function createPromisesApi(vol2) {
      if (typeof Promise === "undefined") return null;
      return {
        FileHandle,
        access: function(path2, mode) {
          return promisify3(vol2, "access")(path2, mode);
        },
        appendFile: function(path2, data, options) {
          return promisify3(vol2, "appendFile")(path2 instanceof FileHandle ? path2.fd : path2, data, options);
        },
        chmod: function(path2, mode) {
          return promisify3(vol2, "chmod")(path2, mode);
        },
        chown: function(path2, uid, gid) {
          return promisify3(vol2, "chown")(path2, uid, gid);
        },
        copyFile: function(src3, dest, flags) {
          return promisify3(vol2, "copyFile")(src3, dest, flags);
        },
        lchmod: function(path2, mode) {
          return promisify3(vol2, "lchmod")(path2, mode);
        },
        lchown: function(path2, uid, gid) {
          return promisify3(vol2, "lchown")(path2, uid, gid);
        },
        link: function(existingPath, newPath) {
          return promisify3(vol2, "link")(existingPath, newPath);
        },
        lstat: function(path2, options) {
          return promisify3(vol2, "lstat")(path2, options);
        },
        mkdir: function(path2, options) {
          return promisify3(vol2, "mkdir")(path2, options);
        },
        mkdtemp: function(prefix, options) {
          return promisify3(vol2, "mkdtemp")(prefix, options);
        },
        open: function(path2, flags, mode) {
          return promisify3(vol2, "open", function(fd) {
            return new FileHandle(vol2, fd);
          })(path2, flags, mode);
        },
        readdir: function(path2, options) {
          return promisify3(vol2, "readdir")(path2, options);
        },
        readFile: function(id, options) {
          return promisify3(vol2, "readFile")(id instanceof FileHandle ? id.fd : id, options);
        },
        readlink: function(path2, options) {
          return promisify3(vol2, "readlink")(path2, options);
        },
        realpath: function(path2, options) {
          return promisify3(vol2, "realpath")(path2, options);
        },
        rename: function(oldPath, newPath) {
          return promisify3(vol2, "rename")(oldPath, newPath);
        },
        rmdir: function(path2) {
          return promisify3(vol2, "rmdir")(path2);
        },
        stat: function(path2, options) {
          return promisify3(vol2, "stat")(path2, options);
        },
        symlink: function(target, path2, type2) {
          return promisify3(vol2, "symlink")(target, path2, type2);
        },
        truncate: function(path2, len) {
          return promisify3(vol2, "truncate")(path2, len);
        },
        unlink: function(path2) {
          return promisify3(vol2, "unlink")(path2);
        },
        utimes: function(path2, atime, mtime) {
          return promisify3(vol2, "utimes")(path2, atime, mtime);
        },
        writeFile: function(id, data, options) {
          return promisify3(vol2, "writeFile")(id instanceof FileHandle ? id.fd : id, data, options);
        }
      };
    }
    exports$62.default = createPromisesApi;
    return exports$62;
  }
  function dew$32() {
    if (_dewExec$32) return exports$52;
    _dewExec$32 = true;
    var process$1 = process3;
    Object.defineProperty(exports$52, "__esModule", {
      value: true
    });
    exports$52.unixify = unixify;
    exports$52.correctPath = correctPath;
    var isWin = process$1.platform === "win32";
    function removeTrailingSeparator(str) {
      var i7 = str.length - 1;
      if (i7 < 2) {
        return str;
      }
      while (isSeparator(str, i7)) {
        i7--;
      }
      return str.substr(0, i7 + 1);
    }
    function isSeparator(str, i7) {
      var _char = str[i7];
      return i7 > 0 && (_char === "/" || isWin && _char === "\\");
    }
    function normalizePath(str, stripTrailing) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      str = str.replace(/[\\\/]+/g, "/");
      if (stripTrailing !== false) {
        str = removeTrailingSeparator(str);
      }
      return str;
    }
    function unixify(filepath) {
      var stripTrailing = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (isWin) {
        filepath = normalizePath(filepath, stripTrailing);
        return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
      }
      return filepath;
    }
    function correctPath(filepath) {
      return unixify(filepath.replace(/^\\\\\?\\.:\\/, "\\"));
    }
    return exports$52;
  }
  function dew$23() {
    if (_dewExec$23) return exports$42;
    _dewExec$23 = true;
    var __extends2 = exports$42 && exports$42.__extends || /* @__PURE__ */ function() {
      var extendStatics2 = function(d6, b5) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d7, b6) {
          d7.__proto__ = b6;
        } || function(d7, b6) {
          for (var p7 in b6) if (Object.prototype.hasOwnProperty.call(b6, p7)) d7[p7] = b6[p7];
        };
        return extendStatics2(d6, b5);
      };
      return function(d6, b5) {
        if (typeof b5 !== "function" && b5 !== null) throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics2(d6, b5);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __spreadArray2 = exports$42 && exports$42.__spreadArray || function(to, from8, pack) {
      if (pack || arguments.length === 2) for (var i7 = 0, l7 = from8.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from8)) {
          if (!ar) ar = Array.prototype.slice.call(from8, 0, i7);
          ar[i7] = from8[i7];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from8));
    };
    Object.defineProperty(exports$42, "__esModule", {
      value: true
    });
    exports$42.FSWatcher = exports$42.StatWatcher = exports$42.Volume = exports$42.toUnixTimestamp = exports$42.bufferToEncoding = exports$42.dataToBuffer = exports$42.dataToStr = exports$42.pathToSteps = exports$42.filenameToSteps = exports$42.pathToFilename = exports$42.flagsToNumber = exports$42.FLAGS = void 0;
    var pathModule = exports4;
    var node_1 = dew$62();
    var Stats_1 = dew$d2();
    var Dirent_1 = dew$92();
    var buffer_1 = dew$c2();
    var setImmediate_1 = dew$82();
    var process_1 = dew$72();
    var setTimeoutUnref_1 = dew$52();
    var stream_1 = exports6;
    var constants_1 = dew$f2();
    var events_1 = y3;
    var encoding_1 = dew$a2();
    var errors = dew$b2();
    var util = X;
    var promises_1 = dew$42();
    var resolveCrossPlatform = pathModule.resolve;
    var O_RDONLY = constants_1.constants.O_RDONLY, O_WRONLY = constants_1.constants.O_WRONLY, O_RDWR = constants_1.constants.O_RDWR, O_CREAT = constants_1.constants.O_CREAT, O_EXCL = constants_1.constants.O_EXCL, O_TRUNC = constants_1.constants.O_TRUNC, O_APPEND = constants_1.constants.O_APPEND, O_SYNC = constants_1.constants.O_SYNC, O_DIRECTORY = constants_1.constants.O_DIRECTORY, F_OK2 = constants_1.constants.F_OK, COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL, COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
    var _a = pathModule.posix ? pathModule.posix : pathModule, sep2 = _a.sep, relative2 = _a.relative, join3 = _a.join, dirname2 = _a.dirname;
    var isWin = process_1.default.platform === "win32";
    var kMinPoolSpace = 128;
    var ERRSTR = {
      PATH_STR: "path must be a string or Buffer",
      // FD:             'file descriptor must be a unsigned 32-bit integer',
      FD: "fd must be a file descriptor",
      MODE_INT: "mode must be an int",
      CB: "callback must be a function",
      UID: "uid must be an unsigned int",
      GID: "gid must be an unsigned int",
      LEN: "len must be an integer",
      ATIME: "atime must be an integer",
      MTIME: "mtime must be an integer",
      PREFIX: "filename prefix is required",
      BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
      OFFSET: "offset must be an integer",
      LENGTH: "length must be an integer",
      POSITION: "position must be an integer"
    };
    var ERRSTR_OPTS = function(tipeof) {
      return "Expected options to be either an object or a string, but got " + tipeof + " instead";
    };
    var ENOENT = "ENOENT";
    var EBADF = "EBADF";
    var EINVAL = "EINVAL";
    var EPERM = "EPERM";
    var EPROTO = "EPROTO";
    var EEXIST = "EEXIST";
    var ENOTDIR = "ENOTDIR";
    var EMFILE = "EMFILE";
    var EACCES = "EACCES";
    var EISDIR = "EISDIR";
    var ENOTEMPTY = "ENOTEMPTY";
    var ENOSYS = "ENOSYS";
    function formatError(errorCode, func, path2, path22) {
      if (func === void 0) {
        func = "";
      }
      if (path2 === void 0) {
        path2 = "";
      }
      if (path22 === void 0) {
        path22 = "";
      }
      var pathFormatted = "";
      if (path2) pathFormatted = " '" + path2 + "'";
      if (path22) pathFormatted += " -> '" + path22 + "'";
      switch (errorCode) {
        case ENOENT:
          return "ENOENT: no such file or directory, " + func + pathFormatted;
        case EBADF:
          return "EBADF: bad file descriptor, " + func + pathFormatted;
        case EINVAL:
          return "EINVAL: invalid argument, " + func + pathFormatted;
        case EPERM:
          return "EPERM: operation not permitted, " + func + pathFormatted;
        case EPROTO:
          return "EPROTO: protocol error, " + func + pathFormatted;
        case EEXIST:
          return "EEXIST: file already exists, " + func + pathFormatted;
        case ENOTDIR:
          return "ENOTDIR: not a directory, " + func + pathFormatted;
        case EISDIR:
          return "EISDIR: illegal operation on a directory, " + func + pathFormatted;
        case EACCES:
          return "EACCES: permission denied, " + func + pathFormatted;
        case ENOTEMPTY:
          return "ENOTEMPTY: directory not empty, " + func + pathFormatted;
        case EMFILE:
          return "EMFILE: too many open files, " + func + pathFormatted;
        case ENOSYS:
          return "ENOSYS: function not implemented, " + func + pathFormatted;
        default:
          return errorCode + ": error occurred, " + func + pathFormatted;
      }
    }
    function createError(errorCode, func, path2, path22, Constructor) {
      if (func === void 0) {
        func = "";
      }
      if (path2 === void 0) {
        path2 = "";
      }
      if (path22 === void 0) {
        path22 = "";
      }
      if (Constructor === void 0) {
        Constructor = Error;
      }
      var error = new Constructor(formatError(errorCode, func, path2, path22));
      error.code = errorCode;
      return error;
    }
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["r"] = O_RDONLY] = "r";
      FLAGS2[FLAGS2["r+"] = O_RDWR] = "r+";
      FLAGS2[FLAGS2["rs"] = O_RDONLY | O_SYNC] = "rs";
      FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
      FLAGS2[FLAGS2["rs+"] = O_RDWR | O_SYNC] = "rs+";
      FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
      FLAGS2[FLAGS2["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
      FLAGS2[FLAGS2["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
      FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
      FLAGS2[FLAGS2["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
      FLAGS2[FLAGS2["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
      FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
      FLAGS2[FLAGS2["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
      FLAGS2[FLAGS2["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
      FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
      FLAGS2[FLAGS2["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
      FLAGS2[FLAGS2["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
      FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
    })(FLAGS = exports$42.FLAGS || (exports$42.FLAGS = {}));
    function flagsToNumber(flags) {
      if (typeof flags === "number") return flags;
      if (typeof flags === "string") {
        var flagsNum = FLAGS[flags];
        if (typeof flagsNum !== "undefined") return flagsNum;
      }
      throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
    }
    exports$42.flagsToNumber = flagsToNumber;
    function getOptions(defaults5, options) {
      var opts;
      if (!options) return defaults5;
      else {
        var tipeof = typeof options;
        switch (tipeof) {
          case "string":
            opts = Object.assign({}, defaults5, {
              encoding: options
            });
            break;
          case "object":
            opts = Object.assign({}, defaults5, options);
            break;
          default:
            throw TypeError(ERRSTR_OPTS(tipeof));
        }
      }
      if (opts.encoding !== "buffer") (0, encoding_1.assertEncoding)(opts.encoding);
      return opts;
    }
    function optsGenerator(defaults5) {
      return function(options) {
        return getOptions(defaults5, options);
      };
    }
    function validateCallback(callback) {
      if (typeof callback !== "function") throw TypeError(ERRSTR.CB);
      return callback;
    }
    function optsAndCbGenerator(getOpts) {
      return function(options, callback) {
        return typeof options === "function" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
      };
    }
    var optsDefaults = {
      encoding: "utf8"
    };
    var getDefaultOpts = optsGenerator(optsDefaults);
    var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
    var readFileOptsDefaults = {
      flag: "r"
    };
    var getReadFileOptions = optsGenerator(readFileOptsDefaults);
    var writeFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: FLAGS[FLAGS.w]
    };
    var getWriteFileOptions = optsGenerator(writeFileDefaults);
    var appendFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: FLAGS[FLAGS.a]
    };
    var getAppendFileOpts = optsGenerator(appendFileDefaults);
    var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
    var realpathDefaults = optsDefaults;
    var getRealpathOptions = optsGenerator(realpathDefaults);
    var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
    var mkdirDefaults = {
      mode: 511,
      recursive: false
    };
    var getMkdirOptions = function(options) {
      if (typeof options === "number") return Object.assign({}, mkdirDefaults, {
        mode: options
      });
      return Object.assign({}, mkdirDefaults, options);
    };
    var rmdirDefaults = {
      recursive: false
    };
    var getRmdirOptions = function(options) {
      return Object.assign({}, rmdirDefaults, options);
    };
    var readdirDefaults = {
      encoding: "utf8",
      withFileTypes: false
    };
    var getReaddirOptions = optsGenerator(readdirDefaults);
    var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
    var statDefaults = {
      bigint: false
    };
    var getStatOptions = function(options) {
      if (options === void 0) {
        options = {};
      }
      return Object.assign({}, statDefaults, options);
    };
    var getStatOptsAndCb = function(options, callback) {
      return typeof options === "function" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
    };
    function getPathFromURLPosix2(url) {
      if (url.hostname !== "") {
        throw new errors.TypeError("ERR_INVALID_FILE_URL_HOST", process_1.default.platform);
      }
      var pathname = url.pathname;
      for (var n8 = 0; n8 < pathname.length; n8++) {
        if (pathname[n8] === "%") {
          var third = pathname.codePointAt(n8 + 2) | 32;
          if (pathname[n8 + 1] === "2" && third === 102) {
            throw new errors.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    function pathToFilename(path2) {
      if (typeof path2 !== "string" && !buffer_1.Buffer.isBuffer(path2)) {
        try {
          if (!(path2 instanceof h7.URL)) throw new TypeError(ERRSTR.PATH_STR);
        } catch (err) {
          throw new TypeError(ERRSTR.PATH_STR);
        }
        path2 = getPathFromURLPosix2(path2);
      }
      var pathString = String(path2);
      nullCheck(pathString);
      return pathString;
    }
    exports$42.pathToFilename = pathToFilename;
    var resolve9 = function(filename, base3) {
      if (base3 === void 0) {
        base3 = process_1.default.cwd();
      }
      return resolveCrossPlatform(base3, filename);
    };
    if (isWin) {
      var _resolve_1 = resolve9;
      var unixify_1 = dew$32().unixify;
      resolve9 = function(filename, base3) {
        return unixify_1(_resolve_1(filename, base3));
      };
    }
    function filenameToSteps(filename, base3) {
      var fullPath = resolve9(filename, base3);
      var fullPathSansSlash = fullPath.substr(1);
      if (!fullPathSansSlash) return [];
      return fullPathSansSlash.split(sep2);
    }
    exports$42.filenameToSteps = filenameToSteps;
    function pathToSteps(path2) {
      return filenameToSteps(pathToFilename(path2));
    }
    exports$42.pathToSteps = pathToSteps;
    function dataToStr(data, encoding) {
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      if (buffer_1.Buffer.isBuffer(data)) return data.toString(encoding);
      else if (data instanceof Uint8Array) return (0, buffer_1.bufferFrom)(data).toString(encoding);
      else return String(data);
    }
    exports$42.dataToStr = dataToStr;
    function dataToBuffer(data, encoding) {
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      if (buffer_1.Buffer.isBuffer(data)) return data;
      else if (data instanceof Uint8Array) return (0, buffer_1.bufferFrom)(data);
      else return (0, buffer_1.bufferFrom)(String(data), encoding);
    }
    exports$42.dataToBuffer = dataToBuffer;
    function bufferToEncoding(buffer4, encoding) {
      if (!encoding || encoding === "buffer") return buffer4;
      else return buffer4.toString(encoding);
    }
    exports$42.bufferToEncoding = bufferToEncoding;
    function nullCheck(path2, callback) {
      if (("" + path2).indexOf("\0") !== -1) {
        var er = new Error("Path must be a string without null bytes");
        er.code = ENOENT;
        if (typeof callback !== "function") throw er;
        process_1.default.nextTick(callback, er);
        return false;
      }
      return true;
    }
    function _modeToNumber(mode, def) {
      if (typeof mode === "number") return mode;
      if (typeof mode === "string") return parseInt(mode, 8);
      if (def) return modeToNumber(def);
      return void 0;
    }
    function modeToNumber(mode, def) {
      var result = _modeToNumber(mode, def);
      if (typeof result !== "number" || isNaN(result)) throw new TypeError(ERRSTR.MODE_INT);
      return result;
    }
    function isFd(path2) {
      return path2 >>> 0 === path2;
    }
    function validateFd(fd) {
      if (!isFd(fd)) throw TypeError(ERRSTR.FD);
    }
    function toUnixTimestamp(time2) {
      if (typeof time2 === "string" && +time2 == time2) {
        return +time2;
      }
      if (time2 instanceof Date) {
        return time2.getTime() / 1e3;
      }
      if (isFinite(time2)) {
        if (time2 < 0) {
          return Date.now() / 1e3;
        }
        return time2;
      }
      throw new Error("Cannot parse time: " + time2);
    }
    exports$42.toUnixTimestamp = toUnixTimestamp;
    function validateUid(uid) {
      if (typeof uid !== "number") throw TypeError(ERRSTR.UID);
    }
    function validateGid(gid) {
      if (typeof gid !== "number") throw TypeError(ERRSTR.GID);
    }
    function flattenJSON(nestedJSON) {
      var flatJSON = {};
      function flatten(pathPrefix, node) {
        for (var path2 in node) {
          var contentOrNode = node[path2];
          var joinedPath = join3(pathPrefix, path2);
          if (typeof contentOrNode === "string") {
            flatJSON[joinedPath] = contentOrNode;
          } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
            flatten(joinedPath, contentOrNode);
          } else {
            flatJSON[joinedPath] = null;
          }
        }
      }
      flatten("", nestedJSON);
      return flatJSON;
    }
    var Volume = function() {
      function Volume2(props) {
        if (props === void 0) {
          props = {};
        }
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.maxFiles = 1e4;
        this.openFiles = 0;
        this.promisesApi = (0, promises_1.default)(this);
        this.statWatchers = {};
        this.props = Object.assign({
          Node: node_1.Node,
          Link: node_1.Link,
          File: node_1.File
        }, props);
        var root2 = this.createLink();
        root2.setNode(this.createNode(true));
        var self2 = this;
        this.StatWatcher = function(_super) {
          __extends2(StatWatcher2, _super);
          function StatWatcher2() {
            return _super.call(this, self2) || this;
          }
          return StatWatcher2;
        }(StatWatcher);
        var _ReadStream = FsReadStream;
        this.ReadStream = function(_super) {
          __extends2(class_1, _super);
          function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return _super.apply(this, __spreadArray2([self2], args, false)) || this;
          }
          return class_1;
        }(_ReadStream);
        var _WriteStream = FsWriteStream;
        this.WriteStream = function(_super) {
          __extends2(class_2, _super);
          function class_2() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return _super.apply(this, __spreadArray2([self2], args, false)) || this;
          }
          return class_2;
        }(_WriteStream);
        this.FSWatcher = function(_super) {
          __extends2(FSWatcher2, _super);
          function FSWatcher2() {
            return _super.call(this, self2) || this;
          }
          return FSWatcher2;
        }(FSWatcher);
        this.root = root2;
      }
      Volume2.fromJSON = function(json, cwd2) {
        var vol2 = new Volume2();
        vol2.fromJSON(json, cwd2);
        return vol2;
      };
      Volume2.fromNestedJSON = function(json, cwd2) {
        var vol2 = new Volume2();
        vol2.fromNestedJSON(json, cwd2);
        return vol2;
      };
      Object.defineProperty(Volume2.prototype, "promises", {
        get: function() {
          if (this.promisesApi === null) throw new Error("Promise is not supported in this environment.");
          return this.promisesApi;
        },
        enumerable: false,
        configurable: true
      });
      Volume2.prototype.createLink = function(parent, name8, isDirectory, perm) {
        if (isDirectory === void 0) {
          isDirectory = false;
        }
        if (!parent) {
          return new this.props.Link(this, null, "");
        }
        if (!name8) {
          throw new Error("createLink: name cannot be empty");
        }
        return parent.createChild(name8, this.createNode(isDirectory, perm));
      };
      Volume2.prototype.deleteLink = function(link4) {
        var parent = link4.parent;
        if (parent) {
          parent.deleteChild(link4);
          return true;
        }
        return false;
      };
      Volume2.prototype.newInoNumber = function() {
        var releasedFd = this.releasedInos.pop();
        if (releasedFd) return releasedFd;
        else {
          this.ino = (this.ino + 1) % 4294967295;
          return this.ino;
        }
      };
      Volume2.prototype.newFdNumber = function() {
        var releasedFd = this.releasedFds.pop();
        return typeof releasedFd === "number" ? releasedFd : Volume2.fd--;
      };
      Volume2.prototype.createNode = function(isDirectory, perm) {
        if (isDirectory === void 0) {
          isDirectory = false;
        }
        var node = new this.props.Node(this.newInoNumber(), perm);
        if (isDirectory) node.setIsDirectory();
        this.inodes[node.ino] = node;
        return node;
      };
      Volume2.prototype.getNode = function(ino) {
        return this.inodes[ino];
      };
      Volume2.prototype.deleteNode = function(node) {
        node.del();
        delete this.inodes[node.ino];
        this.releasedInos.push(node.ino);
      };
      Volume2.prototype.genRndStr = function() {
        var str = (Math.random() + 1).toString(36).substr(2, 6);
        if (str.length === 6) return str;
        else return this.genRndStr();
      };
      Volume2.prototype.getLink = function(steps) {
        return this.root.walk(steps);
      };
      Volume2.prototype.getLinkOrThrow = function(filename, funcName) {
        var steps = filenameToSteps(filename);
        var link4 = this.getLink(steps);
        if (!link4) throw createError(ENOENT, funcName, filename);
        return link4;
      };
      Volume2.prototype.getResolvedLink = function(filenameOrSteps) {
        var steps = typeof filenameOrSteps === "string" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
        var link4 = this.root;
        var i7 = 0;
        while (i7 < steps.length) {
          var step2 = steps[i7];
          link4 = link4.getChild(step2);
          if (!link4) return null;
          var node = link4.getNode();
          if (node.isSymlink()) {
            steps = node.symlink.concat(steps.slice(i7 + 1));
            link4 = this.root;
            i7 = 0;
            continue;
          }
          i7++;
        }
        return link4;
      };
      Volume2.prototype.getResolvedLinkOrThrow = function(filename, funcName) {
        var link4 = this.getResolvedLink(filename);
        if (!link4) throw createError(ENOENT, funcName, filename);
        return link4;
      };
      Volume2.prototype.resolveSymlinks = function(link4) {
        return this.getResolvedLink(link4.steps.slice(1));
      };
      Volume2.prototype.getLinkAsDirOrThrow = function(filename, funcName) {
        var link4 = this.getLinkOrThrow(filename, funcName);
        if (!link4.getNode().isDirectory()) throw createError(ENOTDIR, funcName, filename);
        return link4;
      };
      Volume2.prototype.getLinkParent = function(steps) {
        return this.root.walk(steps, steps.length - 1);
      };
      Volume2.prototype.getLinkParentAsDirOrThrow = function(filenameOrSteps, funcName) {
        var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
        var link4 = this.getLinkParent(steps);
        if (!link4) throw createError(ENOENT, funcName, sep2 + steps.join(sep2));
        if (!link4.getNode().isDirectory()) throw createError(ENOTDIR, funcName, sep2 + steps.join(sep2));
        return link4;
      };
      Volume2.prototype.getFileByFd = function(fd) {
        return this.fds[String(fd)];
      };
      Volume2.prototype.getFileByFdOrThrow = function(fd, funcName) {
        if (!isFd(fd)) throw TypeError(ERRSTR.FD);
        var file = this.getFileByFd(fd);
        if (!file) throw createError(EBADF, funcName);
        return file;
      };
      Volume2.prototype.getNodeByIdOrCreate = function(id, flags, perm) {
        if (typeof id === "number") {
          var file = this.getFileByFd(id);
          if (!file) throw Error("File nto found");
          return file.node;
        } else {
          var steps = pathToSteps(id);
          var link4 = this.getLink(steps);
          if (link4) return link4.getNode();
          if (flags & O_CREAT) {
            var dirLink = this.getLinkParent(steps);
            if (dirLink) {
              var name_1 = steps[steps.length - 1];
              link4 = this.createLink(dirLink, name_1, false, perm);
              return link4.getNode();
            }
          }
          throw createError(ENOENT, "getNodeByIdOrCreate", pathToFilename(id));
        }
      };
      Volume2.prototype.wrapAsync = function(method, args, callback) {
        var _this = this;
        validateCallback(callback);
        (0, setImmediate_1.default)(function() {
          var result;
          try {
            result = method.apply(_this, args);
          } catch (err) {
            callback(err);
            return;
          }
          callback(null, result);
        });
      };
      Volume2.prototype._toJSON = function(link4, json, path2) {
        var _a2;
        if (link4 === void 0) {
          link4 = this.root;
        }
        if (json === void 0) {
          json = {};
        }
        var isEmpty2 = true;
        var children = link4.children;
        if (link4.getNode().isFile()) {
          children = (_a2 = {}, _a2[link4.getName()] = link4.parent.getChild(link4.getName()), _a2);
          link4 = link4.parent;
        }
        for (var name_2 in children) {
          isEmpty2 = false;
          var child = link4.getChild(name_2);
          if (!child) {
            throw new Error("_toJSON: unexpected undefined");
          }
          var node = child.getNode();
          if (node.isFile()) {
            var filename = child.getPath();
            if (path2) filename = relative2(path2, filename);
            json[filename] = node.getString();
          } else if (node.isDirectory()) {
            this._toJSON(child, json, path2);
          }
        }
        var dirPath = link4.getPath();
        if (path2) dirPath = relative2(path2, dirPath);
        if (dirPath && isEmpty2) {
          json[dirPath] = null;
        }
        return json;
      };
      Volume2.prototype.toJSON = function(paths, json, isRelative) {
        if (json === void 0) {
          json = {};
        }
        if (isRelative === void 0) {
          isRelative = false;
        }
        var links4 = [];
        if (paths) {
          if (!(paths instanceof Array)) paths = [paths];
          for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
            var path2 = paths_1[_i];
            var filename = pathToFilename(path2);
            var link4 = this.getResolvedLink(filename);
            if (!link4) continue;
            links4.push(link4);
          }
        } else {
          links4.push(this.root);
        }
        if (!links4.length) return json;
        for (var _a2 = 0, links_1 = links4; _a2 < links_1.length; _a2++) {
          var link4 = links_1[_a2];
          this._toJSON(link4, json, isRelative ? link4.getPath() : "");
        }
        return json;
      };
      Volume2.prototype.fromJSON = function(json, cwd2) {
        if (cwd2 === void 0) {
          cwd2 = process_1.default.cwd();
        }
        for (var filename in json) {
          var data = json[filename];
          filename = resolve9(filename, cwd2);
          if (typeof data === "string") {
            var dir = dirname2(filename);
            this.mkdirpBase(
              dir,
              511
              /* DIR */
            );
            this.writeFileSync(filename, data);
          } else {
            this.mkdirpBase(
              filename,
              511
              /* DIR */
            );
          }
        }
      };
      Volume2.prototype.fromNestedJSON = function(json, cwd2) {
        this.fromJSON(flattenJSON(json), cwd2);
      };
      Volume2.prototype.reset = function() {
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.openFiles = 0;
        this.root = this.createLink();
        this.root.setNode(this.createNode(true));
      };
      Volume2.prototype.mountSync = function(mountpoint, json) {
        this.fromJSON(json, mountpoint);
      };
      Volume2.prototype.openLink = function(link4, flagsNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        if (this.openFiles >= this.maxFiles) {
          throw createError(EMFILE, "open", link4.getPath());
        }
        var realLink = link4;
        if (resolveSymlinks) realLink = this.resolveSymlinks(link4);
        if (!realLink) throw createError(ENOENT, "open", link4.getPath());
        var node = realLink.getNode();
        if (node.isDirectory()) {
          if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY) throw createError(EISDIR, "open", link4.getPath());
        } else {
          if (flagsNum & O_DIRECTORY) throw createError(ENOTDIR, "open", link4.getPath());
        }
        if (!(flagsNum & O_WRONLY)) {
          if (!node.canRead()) {
            throw createError(EACCES, "open", link4.getPath());
          }
        }
        var file = new this.props.File(link4, node, flagsNum, this.newFdNumber());
        this.fds[file.fd] = file;
        this.openFiles++;
        if (flagsNum & O_TRUNC) file.truncate();
        return file;
      };
      Volume2.prototype.openFile = function(filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        var steps = filenameToSteps(filename);
        var link4 = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
        if (!link4 && flagsNum & O_CREAT) {
          var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
          if (!dirLink) throw createError(ENOENT, "open", sep2 + steps.join(sep2));
          if (flagsNum & O_CREAT && typeof modeNum === "number") {
            link4 = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
          }
        }
        if (link4) return this.openLink(link4, flagsNum, resolveSymlinks);
        throw createError(ENOENT, "open", filename);
      };
      Volume2.prototype.openBase = function(filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
        if (!file) throw createError(ENOENT, "open", filename);
        return file.fd;
      };
      Volume2.prototype.openSync = function(path2, flags, mode) {
        if (mode === void 0) {
          mode = 438;
        }
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path2);
        var flagsNum = flagsToNumber(flags);
        return this.openBase(fileName, flagsNum, modeNum);
      };
      Volume2.prototype.open = function(path2, flags, a7, b5) {
        var mode = a7;
        var callback = b5;
        if (typeof a7 === "function") {
          mode = 438;
          callback = a7;
        }
        mode = mode || 438;
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path2);
        var flagsNum = flagsToNumber(flags);
        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
      };
      Volume2.prototype.closeFile = function(file) {
        if (!this.fds[file.fd]) return;
        this.openFiles--;
        delete this.fds[file.fd];
        this.releasedFds.push(file.fd);
      };
      Volume2.prototype.closeSync = function(fd) {
        validateFd(fd);
        var file = this.getFileByFdOrThrow(fd, "close");
        this.closeFile(file);
      };
      Volume2.prototype.close = function(fd, callback) {
        validateFd(fd);
        this.wrapAsync(this.closeSync, [fd], callback);
      };
      Volume2.prototype.openFileOrGetById = function(id, flagsNum, modeNum) {
        if (typeof id === "number") {
          var file = this.fds[id];
          if (!file) throw createError(ENOENT);
          return file;
        } else {
          return this.openFile(pathToFilename(id), flagsNum, modeNum);
        }
      };
      Volume2.prototype.readBase = function(fd, buffer4, offset, length4, position) {
        var file = this.getFileByFdOrThrow(fd);
        return file.read(buffer4, Number(offset), Number(length4), position);
      };
      Volume2.prototype.readSync = function(fd, buffer4, offset, length4, position) {
        validateFd(fd);
        return this.readBase(fd, buffer4, offset, length4, position);
      };
      Volume2.prototype.read = function(fd, buffer4, offset, length4, position, callback) {
        var _this = this;
        validateCallback(callback);
        if (length4 === 0) {
          return process_1.default.nextTick(function() {
            if (callback) callback(null, 0, buffer4);
          });
        }
        (0, setImmediate_1.default)(function() {
          try {
            var bytes = _this.readBase(fd, buffer4, offset, length4, position);
            callback(null, bytes, buffer4);
          } catch (err) {
            callback(err);
          }
        });
      };
      Volume2.prototype.readFileBase = function(id, flagsNum, encoding) {
        var result;
        var isUserFd = typeof id === "number";
        var userOwnsFd = isUserFd && isFd(id);
        var fd;
        if (userOwnsFd) fd = id;
        else {
          var filename = pathToFilename(id);
          var steps = filenameToSteps(filename);
          var link4 = this.getResolvedLink(steps);
          if (link4) {
            var node = link4.getNode();
            if (node.isDirectory()) throw createError(EISDIR, "open", link4.getPath());
          }
          fd = this.openSync(id, flagsNum);
        }
        try {
          result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
        } finally {
          if (!userOwnsFd) {
            this.closeSync(fd);
          }
        }
        return result;
      };
      Volume2.prototype.readFileSync = function(file, options) {
        var opts = getReadFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        return this.readFileBase(file, flagsNum, opts.encoding);
      };
      Volume2.prototype.readFile = function(id, a7, b5) {
        var _a2 = optsAndCbGenerator(getReadFileOptions)(a7, b5), opts = _a2[0], callback = _a2[1];
        var flagsNum = flagsToNumber(opts.flag);
        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
      };
      Volume2.prototype.writeBase = function(fd, buf3, offset, length4, position) {
        var file = this.getFileByFdOrThrow(fd, "write");
        return file.write(buf3, offset, length4, position);
      };
      Volume2.prototype.writeSync = function(fd, a7, b5, c7, d6) {
        validateFd(fd);
        var encoding;
        var offset;
        var length4;
        var position;
        var isBuffer7 = typeof a7 !== "string";
        if (isBuffer7) {
          offset = (b5 || 0) | 0;
          length4 = c7;
          position = d6;
        } else {
          position = b5;
          encoding = c7;
        }
        var buf3 = dataToBuffer(a7, encoding);
        if (isBuffer7) {
          if (typeof length4 === "undefined") {
            length4 = buf3.length;
          }
        } else {
          offset = 0;
          length4 = buf3.length;
        }
        return this.writeBase(fd, buf3, offset, length4, position);
      };
      Volume2.prototype.write = function(fd, a7, b5, c7, d6, e9) {
        var _this = this;
        validateFd(fd);
        var offset;
        var length4;
        var position;
        var encoding;
        var callback;
        var tipa = typeof a7;
        var tipb = typeof b5;
        var tipc = typeof c7;
        var tipd = typeof d6;
        if (tipa !== "string") {
          if (tipb === "function") {
            callback = b5;
          } else if (tipc === "function") {
            offset = b5 | 0;
            callback = c7;
          } else if (tipd === "function") {
            offset = b5 | 0;
            length4 = c7;
            callback = d6;
          } else {
            offset = b5 | 0;
            length4 = c7;
            position = d6;
            callback = e9;
          }
        } else {
          if (tipb === "function") {
            callback = b5;
          } else if (tipc === "function") {
            position = b5;
            callback = c7;
          } else if (tipd === "function") {
            position = b5;
            encoding = c7;
            callback = d6;
          }
        }
        var buf3 = dataToBuffer(a7, encoding);
        if (tipa !== "string") {
          if (typeof length4 === "undefined") length4 = buf3.length;
        } else {
          offset = 0;
          length4 = buf3.length;
        }
        var cb = validateCallback(callback);
        (0, setImmediate_1.default)(function() {
          try {
            var bytes = _this.writeBase(fd, buf3, offset, length4, position);
            if (tipa !== "string") {
              cb(null, bytes, buf3);
            } else {
              cb(null, bytes, a7);
            }
          } catch (err) {
            cb(err);
          }
        });
      };
      Volume2.prototype.writeFileBase = function(id, buf3, flagsNum, modeNum) {
        var isUserFd = typeof id === "number";
        var fd;
        if (isUserFd) fd = id;
        else {
          fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
        }
        var offset = 0;
        var length4 = buf3.length;
        var position = flagsNum & O_APPEND ? void 0 : 0;
        try {
          while (length4 > 0) {
            var written = this.writeSync(fd, buf3, offset, length4, position);
            offset += written;
            length4 -= written;
            if (position !== void 0) position += written;
          }
        } finally {
          if (!isUserFd) this.closeSync(fd);
        }
      };
      Volume2.prototype.writeFileSync = function(id, data, options) {
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf3 = dataToBuffer(data, opts.encoding);
        this.writeFileBase(id, buf3, flagsNum, modeNum);
      };
      Volume2.prototype.writeFile = function(id, data, a7, b5) {
        var options = a7;
        var callback = b5;
        if (typeof a7 === "function") {
          options = writeFileDefaults;
          callback = a7;
        }
        var cb = validateCallback(callback);
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf3 = dataToBuffer(data, opts.encoding);
        this.wrapAsync(this.writeFileBase, [id, buf3, flagsNum, modeNum], cb);
      };
      Volume2.prototype.linkBase = function(filename1, filename2) {
        var steps1 = filenameToSteps(filename1);
        var link1 = this.getLink(steps1);
        if (!link1) throw createError(ENOENT, "link", filename1, filename2);
        var steps2 = filenameToSteps(filename2);
        var dir2 = this.getLinkParent(steps2);
        if (!dir2) throw createError(ENOENT, "link", filename1, filename2);
        var name8 = steps2[steps2.length - 1];
        if (dir2.getChild(name8)) throw createError(EEXIST, "link", filename1, filename2);
        var node = link1.getNode();
        node.nlink++;
        dir2.createChild(name8, node);
      };
      Volume2.prototype.copyFileBase = function(src3, dest, flags) {
        var buf3 = this.readFileSync(src3);
        if (flags & COPYFILE_EXCL) {
          if (this.existsSync(dest)) {
            throw createError(EEXIST, "copyFile", src3, dest);
          }
        }
        if (flags & COPYFILE_FICLONE_FORCE) {
          throw createError(ENOSYS, "copyFile", src3, dest);
        }
        this.writeFileBase(
          dest,
          buf3,
          FLAGS.w,
          438
          /* DEFAULT */
        );
      };
      Volume2.prototype.copyFileSync = function(src3, dest, flags) {
        var srcFilename = pathToFilename(src3);
        var destFilename = pathToFilename(dest);
        return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
      };
      Volume2.prototype.copyFile = function(src3, dest, a7, b5) {
        var srcFilename = pathToFilename(src3);
        var destFilename = pathToFilename(dest);
        var flags;
        var callback;
        if (typeof a7 === "function") {
          flags = 0;
          callback = a7;
        } else {
          flags = a7;
          callback = b5;
        }
        validateCallback(callback);
        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
      };
      Volume2.prototype.linkSync = function(existingPath, newPath) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.linkBase(existingPathFilename, newPathFilename);
      };
      Volume2.prototype.link = function(existingPath, newPath, callback) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
      };
      Volume2.prototype.unlinkBase = function(filename) {
        var steps = filenameToSteps(filename);
        var link4 = this.getLink(steps);
        if (!link4) throw createError(ENOENT, "unlink", filename);
        if (link4.length) throw Error("Dir not empty...");
        this.deleteLink(link4);
        var node = link4.getNode();
        node.nlink--;
        if (node.nlink <= 0) {
          this.deleteNode(node);
        }
      };
      Volume2.prototype.unlinkSync = function(path2) {
        var filename = pathToFilename(path2);
        this.unlinkBase(filename);
      };
      Volume2.prototype.unlink = function(path2, callback) {
        var filename = pathToFilename(path2);
        this.wrapAsync(this.unlinkBase, [filename], callback);
      };
      Volume2.prototype.symlinkBase = function(targetFilename, pathFilename) {
        var pathSteps = filenameToSteps(pathFilename);
        var dirLink = this.getLinkParent(pathSteps);
        if (!dirLink) throw createError(ENOENT, "symlink", targetFilename, pathFilename);
        var name8 = pathSteps[pathSteps.length - 1];
        if (dirLink.getChild(name8)) throw createError(EEXIST, "symlink", targetFilename, pathFilename);
        var symlink3 = dirLink.createChild(name8);
        symlink3.getNode().makeSymlink(filenameToSteps(targetFilename));
        return symlink3;
      };
      Volume2.prototype.symlinkSync = function(target, path2, type2) {
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path2);
        this.symlinkBase(targetFilename, pathFilename);
      };
      Volume2.prototype.symlink = function(target, path2, a7, b5) {
        var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path2);
        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
      };
      Volume2.prototype.realpathBase = function(filename, encoding) {
        var steps = filenameToSteps(filename);
        var realLink = this.getResolvedLink(steps);
        if (!realLink) throw createError(ENOENT, "realpath", filename);
        return (0, encoding_1.strToEncoding)(realLink.getPath(), encoding);
      };
      Volume2.prototype.realpathSync = function(path2, options) {
        return this.realpathBase(pathToFilename(path2), getRealpathOptions(options).encoding);
      };
      Volume2.prototype.realpath = function(path2, a7, b5) {
        var _a2 = getRealpathOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        var pathFilename = pathToFilename(path2);
        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
      };
      Volume2.prototype.lstatBase = function(filename, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var link4 = this.getLink(filenameToSteps(filename));
        if (!link4) throw createError(ENOENT, "lstat", filename);
        return Stats_1.default.build(link4.getNode(), bigint);
      };
      Volume2.prototype.lstatSync = function(path2, options) {
        return this.lstatBase(pathToFilename(path2), getStatOptions(options).bigint);
      };
      Volume2.prototype.lstat = function(path2, a7, b5) {
        var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.lstatBase, [pathToFilename(path2), opts.bigint], callback);
      };
      Volume2.prototype.statBase = function(filename, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var link4 = this.getResolvedLink(filenameToSteps(filename));
        if (!link4) throw createError(ENOENT, "stat", filename);
        return Stats_1.default.build(link4.getNode(), bigint);
      };
      Volume2.prototype.statSync = function(path2, options) {
        return this.statBase(pathToFilename(path2), getStatOptions(options).bigint);
      };
      Volume2.prototype.stat = function(path2, a7, b5) {
        var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.statBase, [pathToFilename(path2), opts.bigint], callback);
      };
      Volume2.prototype.fstatBase = function(fd, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var file = this.getFileByFd(fd);
        if (!file) throw createError(EBADF, "fstat");
        return Stats_1.default.build(file.node, bigint);
      };
      Volume2.prototype.fstatSync = function(fd, options) {
        return this.fstatBase(fd, getStatOptions(options).bigint);
      };
      Volume2.prototype.fstat = function(fd, a7, b5) {
        var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
      };
      Volume2.prototype.renameBase = function(oldPathFilename, newPathFilename) {
        var link4 = this.getLink(filenameToSteps(oldPathFilename));
        if (!link4) throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
        var newPathSteps = filenameToSteps(newPathFilename);
        var newPathDirLink = this.getLinkParent(newPathSteps);
        if (!newPathDirLink) throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
        var oldLinkParent = link4.parent;
        if (oldLinkParent) {
          oldLinkParent.deleteChild(link4);
        }
        var name8 = newPathSteps[newPathSteps.length - 1];
        link4.steps = __spreadArray2(__spreadArray2([], newPathDirLink.steps, true), [name8], false);
        newPathDirLink.setChild(link4.getName(), link4);
      };
      Volume2.prototype.renameSync = function(oldPath, newPath) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.renameBase(oldPathFilename, newPathFilename);
      };
      Volume2.prototype.rename = function(oldPath, newPath, callback) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
      };
      Volume2.prototype.existsBase = function(filename) {
        return !!this.statBase(filename);
      };
      Volume2.prototype.existsSync = function(path2) {
        try {
          return this.existsBase(pathToFilename(path2));
        } catch (err) {
          return false;
        }
      };
      Volume2.prototype.exists = function(path2, callback) {
        var _this = this;
        var filename = pathToFilename(path2);
        if (typeof callback !== "function") throw Error(ERRSTR.CB);
        (0, setImmediate_1.default)(function() {
          try {
            callback(_this.existsBase(filename));
          } catch (err) {
            callback(false);
          }
        });
      };
      Volume2.prototype.accessBase = function(filename, mode) {
        this.getLinkOrThrow(filename, "access");
      };
      Volume2.prototype.accessSync = function(path2, mode) {
        if (mode === void 0) {
          mode = F_OK2;
        }
        var filename = pathToFilename(path2);
        mode = mode | 0;
        this.accessBase(filename, mode);
      };
      Volume2.prototype.access = function(path2, a7, b5) {
        var mode = F_OK2;
        var callback;
        if (typeof a7 !== "function") {
          mode = a7 | 0;
          callback = validateCallback(b5);
        } else {
          callback = a7;
        }
        var filename = pathToFilename(path2);
        this.wrapAsync(this.accessBase, [filename, mode], callback);
      };
      Volume2.prototype.appendFileSync = function(id, data, options) {
        if (options === void 0) {
          options = appendFileDefaults;
        }
        var opts = getAppendFileOpts(options);
        if (!opts.flag || isFd(id)) opts.flag = "a";
        this.writeFileSync(id, data, opts);
      };
      Volume2.prototype.appendFile = function(id, data, a7, b5) {
        var _a2 = getAppendFileOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        if (!opts.flag || isFd(id)) opts.flag = "a";
        this.writeFile(id, data, opts, callback);
      };
      Volume2.prototype.readdirBase = function(filename, options) {
        var steps = filenameToSteps(filename);
        var link4 = this.getResolvedLink(steps);
        if (!link4) throw createError(ENOENT, "readdir", filename);
        var node = link4.getNode();
        if (!node.isDirectory()) throw createError(ENOTDIR, "scandir", filename);
        if (options.withFileTypes) {
          var list_1 = [];
          for (var name_3 in link4.children) {
            var child = link4.getChild(name_3);
            if (!child) {
              continue;
            }
            list_1.push(Dirent_1.default.build(child, options.encoding));
          }
          if (!isWin && options.encoding !== "buffer") list_1.sort(function(a7, b5) {
            if (a7.name < b5.name) return -1;
            if (a7.name > b5.name) return 1;
            return 0;
          });
          return list_1;
        }
        var list = [];
        for (var name_4 in link4.children) {
          list.push((0, encoding_1.strToEncoding)(name_4, options.encoding));
        }
        if (!isWin && options.encoding !== "buffer") list.sort();
        return list;
      };
      Volume2.prototype.readdirSync = function(path2, options) {
        var opts = getReaddirOptions(options);
        var filename = pathToFilename(path2);
        return this.readdirBase(filename, opts);
      };
      Volume2.prototype.readdir = function(path2, a7, b5) {
        var _a2 = getReaddirOptsAndCb(a7, b5), options = _a2[0], callback = _a2[1];
        var filename = pathToFilename(path2);
        this.wrapAsync(this.readdirBase, [filename, options], callback);
      };
      Volume2.prototype.readlinkBase = function(filename, encoding) {
        var link4 = this.getLinkOrThrow(filename, "readlink");
        var node = link4.getNode();
        if (!node.isSymlink()) throw createError(EINVAL, "readlink", filename);
        var str = sep2 + node.symlink.join(sep2);
        return (0, encoding_1.strToEncoding)(str, encoding);
      };
      Volume2.prototype.readlinkSync = function(path2, options) {
        var opts = getDefaultOpts(options);
        var filename = pathToFilename(path2);
        return this.readlinkBase(filename, opts.encoding);
      };
      Volume2.prototype.readlink = function(path2, a7, b5) {
        var _a2 = getDefaultOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        var filename = pathToFilename(path2);
        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
      };
      Volume2.prototype.fsyncBase = function(fd) {
        this.getFileByFdOrThrow(fd, "fsync");
      };
      Volume2.prototype.fsyncSync = function(fd) {
        this.fsyncBase(fd);
      };
      Volume2.prototype.fsync = function(fd, callback) {
        this.wrapAsync(this.fsyncBase, [fd], callback);
      };
      Volume2.prototype.fdatasyncBase = function(fd) {
        this.getFileByFdOrThrow(fd, "fdatasync");
      };
      Volume2.prototype.fdatasyncSync = function(fd) {
        this.fdatasyncBase(fd);
      };
      Volume2.prototype.fdatasync = function(fd, callback) {
        this.wrapAsync(this.fdatasyncBase, [fd], callback);
      };
      Volume2.prototype.ftruncateBase = function(fd, len) {
        var file = this.getFileByFdOrThrow(fd, "ftruncate");
        file.truncate(len);
      };
      Volume2.prototype.ftruncateSync = function(fd, len) {
        this.ftruncateBase(fd, len);
      };
      Volume2.prototype.ftruncate = function(fd, a7, b5) {
        var len = typeof a7 === "number" ? a7 : 0;
        var callback = validateCallback(typeof a7 === "number" ? b5 : a7);
        this.wrapAsync(this.ftruncateBase, [fd, len], callback);
      };
      Volume2.prototype.truncateBase = function(path2, len) {
        var fd = this.openSync(path2, "r+");
        try {
          this.ftruncateSync(fd, len);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.truncateSync = function(id, len) {
        if (isFd(id)) return this.ftruncateSync(id, len);
        this.truncateBase(id, len);
      };
      Volume2.prototype.truncate = function(id, a7, b5) {
        var len = typeof a7 === "number" ? a7 : 0;
        var callback = validateCallback(typeof a7 === "number" ? b5 : a7);
        if (isFd(id)) return this.ftruncate(id, len, callback);
        this.wrapAsync(this.truncateBase, [id, len], callback);
      };
      Volume2.prototype.futimesBase = function(fd, atime, mtime) {
        var file = this.getFileByFdOrThrow(fd, "futimes");
        var node = file.node;
        node.atime = new Date(atime * 1e3);
        node.mtime = new Date(mtime * 1e3);
      };
      Volume2.prototype.futimesSync = function(fd, atime, mtime) {
        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
      };
      Volume2.prototype.futimes = function(fd, atime, mtime, callback) {
        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
      };
      Volume2.prototype.utimesBase = function(filename, atime, mtime) {
        var fd = this.openSync(filename, "r+");
        try {
          this.futimesBase(fd, atime, mtime);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.utimesSync = function(path2, atime, mtime) {
        this.utimesBase(pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime));
      };
      Volume2.prototype.utimes = function(path2, atime, mtime, callback) {
        this.wrapAsync(this.utimesBase, [pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
      };
      Volume2.prototype.mkdirBase = function(filename, modeNum) {
        var steps = filenameToSteps(filename);
        if (!steps.length) {
          throw createError(EEXIST, "mkdir", filename);
        }
        var dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
        var name8 = steps[steps.length - 1];
        if (dir.getChild(name8)) throw createError(EEXIST, "mkdir", filename);
        dir.createChild(name8, this.createNode(true, modeNum));
      };
      Volume2.prototype.mkdirpBase = function(filename, modeNum) {
        var steps = filenameToSteps(filename);
        var link4 = this.root;
        for (var i7 = 0; i7 < steps.length; i7++) {
          var step2 = steps[i7];
          if (!link4.getNode().isDirectory()) throw createError(ENOTDIR, "mkdir", link4.getPath());
          var child = link4.getChild(step2);
          if (child) {
            if (child.getNode().isDirectory()) link4 = child;
            else throw createError(ENOTDIR, "mkdir", child.getPath());
          } else {
            link4 = link4.createChild(step2, this.createNode(true, modeNum));
          }
        }
      };
      Volume2.prototype.mkdirSync = function(path2, options) {
        var opts = getMkdirOptions(options);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path2);
        if (opts.recursive) this.mkdirpBase(filename, modeNum);
        else this.mkdirBase(filename, modeNum);
      };
      Volume2.prototype.mkdir = function(path2, a7, b5) {
        var opts = getMkdirOptions(a7);
        var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path2);
        if (opts.recursive) this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
        else this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
      };
      Volume2.prototype.mkdirpSync = function(path2, mode) {
        this.mkdirSync(path2, {
          mode,
          recursive: true
        });
      };
      Volume2.prototype.mkdirp = function(path2, a7, b5) {
        var mode = typeof a7 === "function" ? void 0 : a7;
        var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
        this.mkdir(path2, {
          mode,
          recursive: true
        }, callback);
      };
      Volume2.prototype.mkdtempBase = function(prefix, encoding, retry) {
        if (retry === void 0) {
          retry = 5;
        }
        var filename = prefix + this.genRndStr();
        try {
          this.mkdirBase(
            filename,
            511
            /* DIR */
          );
          return (0, encoding_1.strToEncoding)(filename, encoding);
        } catch (err) {
          if (err.code === EEXIST) {
            if (retry > 1) return this.mkdtempBase(prefix, encoding, retry - 1);
            else throw Error("Could not create temp dir.");
          } else throw err;
        }
      };
      Volume2.prototype.mkdtempSync = function(prefix, options) {
        var encoding = getDefaultOpts(options).encoding;
        if (!prefix || typeof prefix !== "string") throw new TypeError("filename prefix is required");
        nullCheck(prefix);
        return this.mkdtempBase(prefix, encoding);
      };
      Volume2.prototype.mkdtemp = function(prefix, a7, b5) {
        var _a2 = getDefaultOptsAndCb(a7, b5), encoding = _a2[0].encoding, callback = _a2[1];
        if (!prefix || typeof prefix !== "string") throw new TypeError("filename prefix is required");
        if (!nullCheck(prefix)) return;
        this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
      };
      Volume2.prototype.rmdirBase = function(filename, options) {
        var opts = getRmdirOptions(options);
        var link4 = this.getLinkAsDirOrThrow(filename, "rmdir");
        if (link4.length && !opts.recursive) throw createError(ENOTEMPTY, "rmdir", filename);
        this.deleteLink(link4);
      };
      Volume2.prototype.rmdirSync = function(path2, options) {
        this.rmdirBase(pathToFilename(path2), options);
      };
      Volume2.prototype.rmdir = function(path2, a7, b5) {
        var opts = getRmdirOptions(a7);
        var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
        this.wrapAsync(this.rmdirBase, [pathToFilename(path2), opts], callback);
      };
      Volume2.prototype.fchmodBase = function(fd, modeNum) {
        var file = this.getFileByFdOrThrow(fd, "fchmod");
        file.chmod(modeNum);
      };
      Volume2.prototype.fchmodSync = function(fd, mode) {
        this.fchmodBase(fd, modeToNumber(mode));
      };
      Volume2.prototype.fchmod = function(fd, mode, callback) {
        this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
      };
      Volume2.prototype.chmodBase = function(filename, modeNum) {
        var fd = this.openSync(filename, "r+");
        try {
          this.fchmodBase(fd, modeNum);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.chmodSync = function(path2, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.chmodBase(filename, modeNum);
      };
      Volume2.prototype.chmod = function(path2, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
      };
      Volume2.prototype.lchmodBase = function(filename, modeNum) {
        var fd = this.openBase(filename, O_RDWR, 0, false);
        try {
          this.fchmodBase(fd, modeNum);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.lchmodSync = function(path2, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.lchmodBase(filename, modeNum);
      };
      Volume2.prototype.lchmod = function(path2, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
      };
      Volume2.prototype.fchownBase = function(fd, uid, gid) {
        this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
      };
      Volume2.prototype.fchownSync = function(fd, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.fchownBase(fd, uid, gid);
      };
      Volume2.prototype.fchown = function(fd, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
      };
      Volume2.prototype.chownBase = function(filename, uid, gid) {
        var link4 = this.getResolvedLinkOrThrow(filename, "chown");
        var node = link4.getNode();
        node.chown(uid, gid);
      };
      Volume2.prototype.chownSync = function(path2, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.chownBase(pathToFilename(path2), uid, gid);
      };
      Volume2.prototype.chown = function(path2, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.chownBase, [pathToFilename(path2), uid, gid], callback);
      };
      Volume2.prototype.lchownBase = function(filename, uid, gid) {
        this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
      };
      Volume2.prototype.lchownSync = function(path2, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.lchownBase(pathToFilename(path2), uid, gid);
      };
      Volume2.prototype.lchown = function(path2, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.lchownBase, [pathToFilename(path2), uid, gid], callback);
      };
      Volume2.prototype.watchFile = function(path2, a7, b5) {
        var filename = pathToFilename(path2);
        var options = a7;
        var listener = b5;
        if (typeof options === "function") {
          listener = a7;
          options = null;
        }
        if (typeof listener !== "function") {
          throw Error('"watchFile()" requires a listener function');
        }
        var interval = 5007;
        var persistent = true;
        if (options && typeof options === "object") {
          if (typeof options.interval === "number") interval = options.interval;
          if (typeof options.persistent === "boolean") persistent = options.persistent;
        }
        var watcher = this.statWatchers[filename];
        if (!watcher) {
          watcher = new this.StatWatcher();
          watcher.start(filename, persistent, interval);
          this.statWatchers[filename] = watcher;
        }
        watcher.addListener("change", listener);
        return watcher;
      };
      Volume2.prototype.unwatchFile = function(path2, listener) {
        var filename = pathToFilename(path2);
        var watcher = this.statWatchers[filename];
        if (!watcher) return;
        if (typeof listener === "function") {
          watcher.removeListener("change", listener);
        } else {
          watcher.removeAllListeners("change");
        }
        if (watcher.listenerCount("change") === 0) {
          watcher.stop();
          delete this.statWatchers[filename];
        }
      };
      Volume2.prototype.createReadStream = function(path2, options) {
        return new this.ReadStream(path2, options);
      };
      Volume2.prototype.createWriteStream = function(path2, options) {
        return new this.WriteStream(path2, options);
      };
      Volume2.prototype.watch = function(path2, options, listener) {
        var filename = pathToFilename(path2);
        var givenOptions = options;
        if (typeof options === "function") {
          listener = options;
          givenOptions = null;
        }
        var _a2 = getDefaultOpts(givenOptions), persistent = _a2.persistent, recursive = _a2.recursive, encoding = _a2.encoding;
        if (persistent === void 0) persistent = true;
        if (recursive === void 0) recursive = false;
        var watcher = new this.FSWatcher();
        watcher.start(filename, persistent, recursive, encoding);
        if (listener) {
          watcher.addListener("change", listener);
        }
        return watcher;
      };
      Volume2.fd = 2147483647;
      return Volume2;
    }();
    exports$42.Volume = Volume;
    function emitStop(self2) {
      self2.emit("stop");
    }
    var StatWatcher = function(_super) {
      __extends2(StatWatcher2, _super);
      function StatWatcher2(vol2) {
        var _this = _super.call(this) || this;
        _this.onInterval = function() {
          try {
            var stats = _this.vol.statSync(_this.filename);
            if (_this.hasChanged(stats)) {
              _this.emit("change", stats, _this.prev);
              _this.prev = stats;
            }
          } finally {
            _this.loop();
          }
        };
        _this.vol = vol2;
        return _this;
      }
      StatWatcher2.prototype.loop = function() {
        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
      };
      StatWatcher2.prototype.hasChanged = function(stats) {
        if (stats.mtimeMs > this.prev.mtimeMs) return true;
        if (stats.nlink !== this.prev.nlink) return true;
        return false;
      };
      StatWatcher2.prototype.start = function(path2, persistent, interval) {
        if (persistent === void 0) {
          persistent = true;
        }
        if (interval === void 0) {
          interval = 5007;
        }
        this.filename = pathToFilename(path2);
        this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global4) : setTimeoutUnref_1.default;
        this.interval = interval;
        this.prev = this.vol.statSync(this.filename);
        this.loop();
      };
      StatWatcher2.prototype.stop = function() {
        clearTimeout(this.timeoutRef);
        process_1.default.nextTick(emitStop, this);
      };
      return StatWatcher2;
    }(events_1.EventEmitter);
    exports$42.StatWatcher = StatWatcher;
    var pool2;
    function allocNewPool(poolSize) {
      pool2 = (0, buffer_1.bufferAllocUnsafe)(poolSize);
      pool2.used = 0;
    }
    util.inherits(FsReadStream, stream_1.Readable);
    exports$42.ReadStream = FsReadStream;
    function FsReadStream(vol2, path2, options) {
      if (!(this instanceof FsReadStream)) return new FsReadStream(vol2, path2, options);
      this._vol = vol2;
      options = Object.assign({}, getOptions(options, {}));
      if (options.highWaterMark === void 0) options.highWaterMark = 64 * 1024;
      stream_1.Readable.call(this, options);
      this.path = pathToFilename(path2);
      this.fd = options.fd === void 0 ? null : options.fd;
      this.flags = options.flags === void 0 ? "r" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.end = options.end;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = void 0;
      this.bytesRead = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw new TypeError('"end" option must be a Number');
        }
        if (this.start > this.end) {
          throw new Error('"start" option must be <= "end" option');
        }
        this.pos = this.start;
      }
      if (typeof this.fd !== "number") this.open();
      this.on("end", function() {
        if (this.autoClose) {
          if (this.destroy) this.destroy();
        }
      });
    }
    FsReadStream.prototype.open = function() {
      var self2 = this;
      this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
        if (er) {
          if (self2.autoClose) {
            if (self2.destroy) self2.destroy();
          }
          self2.emit("error", er);
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2.read();
      });
    };
    FsReadStream.prototype._read = function(n8) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._read(n8);
        });
      }
      if (this.destroyed) return;
      if (!pool2 || pool2.length - pool2.used < kMinPoolSpace) {
        allocNewPool(this._readableState.highWaterMark);
      }
      var thisPool = pool2;
      var toRead = Math.min(pool2.length - pool2.used, n8);
      var start = pool2.used;
      if (this.pos !== void 0) toRead = Math.min(this.end - this.pos + 1, toRead);
      if (toRead <= 0) return this.push(null);
      var self2 = this;
      this._vol.read(this.fd, pool2, pool2.used, toRead, this.pos, onread);
      if (this.pos !== void 0) this.pos += toRead;
      pool2.used += toRead;
      function onread(er, bytesRead) {
        if (er) {
          if (self2.autoClose && self2.destroy) {
            self2.destroy();
          }
          self2.emit("error", er);
        } else {
          var b5 = null;
          if (bytesRead > 0) {
            self2.bytesRead += bytesRead;
            b5 = thisPool.slice(start, start + bytesRead);
          }
          self2.push(b5);
        }
      }
    };
    FsReadStream.prototype._destroy = function(err, cb) {
      this.close(function(err2) {
        cb(err || err2);
      });
    };
    FsReadStream.prototype.close = function(cb) {
      var _this = this;
      if (cb) this.once("close", cb);
      if (this.closed || typeof this.fd !== "number") {
        if (typeof this.fd !== "number") {
          this.once("open", closeOnOpen);
          return;
        }
        return process_1.default.nextTick(function() {
          return _this.emit("close");
        });
      }
      this.closed = true;
      this._vol.close(this.fd, function(er) {
        if (er) _this.emit("error", er);
        else _this.emit("close");
      });
      this.fd = null;
    };
    function closeOnOpen(fd) {
      this.close();
    }
    util.inherits(FsWriteStream, stream_1.Writable);
    exports$42.WriteStream = FsWriteStream;
    function FsWriteStream(vol2, path2, options) {
      if (!(this instanceof FsWriteStream)) return new FsWriteStream(vol2, path2, options);
      this._vol = vol2;
      options = Object.assign({}, getOptions(options, {}));
      stream_1.Writable.call(this, options);
      this.path = pathToFilename(path2);
      this.fd = options.fd === void 0 ? null : options.fd;
      this.flags = options.flags === void 0 ? "w" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
      this.pos = void 0;
      this.bytesWritten = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.start < 0) {
          throw new Error('"start" must be >= zero');
        }
        this.pos = this.start;
      }
      if (options.encoding) this.setDefaultEncoding(options.encoding);
      if (typeof this.fd !== "number") this.open();
      this.once("finish", function() {
        if (this.autoClose) {
          this.close();
        }
      });
    }
    FsWriteStream.prototype.open = function() {
      this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
        if (er) {
          if (this.autoClose && this.destroy) {
            this.destroy();
          }
          this.emit("error", er);
          return;
        }
        this.fd = fd;
        this.emit("open", fd);
      }.bind(this));
    };
    FsWriteStream.prototype._write = function(data, encoding, cb) {
      if (!(data instanceof buffer_1.Buffer)) return this.emit("error", new Error("Invalid data"));
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      }
      var self2 = this;
      this._vol.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
        if (er) {
          if (self2.autoClose && self2.destroy) {
            self2.destroy();
          }
          return cb(er);
        }
        self2.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0) this.pos += data.length;
    };
    FsWriteStream.prototype._writev = function(data, cb) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._writev(data, cb);
        });
      }
      var self2 = this;
      var len = data.length;
      var chunks = new Array(len);
      var size = 0;
      for (var i7 = 0; i7 < len; i7++) {
        var chunk = data[i7].chunk;
        chunks[i7] = chunk;
        size += chunk.length;
      }
      var buf3 = buffer_1.Buffer.concat(chunks);
      this._vol.write(this.fd, buf3, 0, buf3.length, this.pos, function(er, bytes) {
        if (er) {
          if (self2.destroy) self2.destroy();
          return cb(er);
        }
        self2.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0) this.pos += size;
    };
    FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
    FsWriteStream.prototype.close = FsReadStream.prototype.close;
    FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
    var FSWatcher = function(_super) {
      __extends2(FSWatcher2, _super);
      function FSWatcher2(vol2) {
        var _this = _super.call(this) || this;
        _this._filename = "";
        _this._filenameEncoded = "";
        _this._recursive = false;
        _this._encoding = encoding_1.ENCODING_UTF8;
        _this._onNodeChange = function() {
          _this._emit("change");
        };
        _this._onParentChild = function(link4) {
          if (link4.getName() === _this._getName()) {
            _this._emit("rename");
          }
        };
        _this._emit = function(type2) {
          _this.emit("change", type2, _this._filenameEncoded);
        };
        _this._persist = function() {
          _this._timer = setTimeout(_this._persist, 1e6);
        };
        _this._vol = vol2;
        return _this;
      }
      FSWatcher2.prototype._getName = function() {
        return this._steps[this._steps.length - 1];
      };
      FSWatcher2.prototype.start = function(path2, persistent, recursive, encoding) {
        if (persistent === void 0) {
          persistent = true;
        }
        if (recursive === void 0) {
          recursive = false;
        }
        if (encoding === void 0) {
          encoding = encoding_1.ENCODING_UTF8;
        }
        this._filename = pathToFilename(path2);
        this._steps = filenameToSteps(this._filename);
        this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
        this._recursive = recursive;
        this._encoding = encoding;
        try {
          this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
        } catch (err) {
          var error = new Error("watch " + this._filename + " " + err.code);
          error.code = err.code;
          error.errno = err.code;
          throw error;
        }
        this._link.getNode().on("change", this._onNodeChange);
        this._link.on("child:add", this._onNodeChange);
        this._link.on("child:delete", this._onNodeChange);
        var parent = this._link.parent;
        if (parent) {
          parent.setMaxListeners(parent.getMaxListeners() + 1);
          parent.on("child:delete", this._onParentChild);
        }
        if (persistent) this._persist();
      };
      FSWatcher2.prototype.close = function() {
        clearTimeout(this._timer);
        this._link.getNode().removeListener("change", this._onNodeChange);
        var parent = this._link.parent;
        if (parent) {
          parent.removeListener("child:delete", this._onParentChild);
        }
      };
      return FSWatcher2;
    }(events_1.EventEmitter);
    exports$42.FSWatcher = FSWatcher;
    return exports$42;
  }
  function dew$13() {
    if (_dewExec$13) return exports$33;
    _dewExec$13 = true;
    Object.defineProperty(exports$33, "__esModule", {
      value: true
    });
    exports$33.fsAsyncMethods = exports$33.fsSyncMethods = exports$33.fsProps = void 0;
    var fsProps = ["constants", "F_OK", "R_OK", "W_OK", "X_OK", "Stats"];
    exports$33.fsProps = fsProps;
    var fsSyncMethods = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "createReadStream", "createWriteStream"];
    exports$33.fsSyncMethods = fsSyncMethods;
    var fsAsyncMethods = ["rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "watchFile", "unwatchFile", "watch"];
    exports$33.fsAsyncMethods = fsAsyncMethods;
    return exports$33;
  }
  function dew7() {
    if (_dewExec7) return exports$23;
    _dewExec7 = true;
    var __assign2 = exports$23 && exports$23.__assign || function() {
      __assign2 = Object.assign || function(t8) {
        for (var s6, i7 = 1, n8 = arguments.length; i7 < n8; i7++) {
          s6 = arguments[i7];
          for (var p7 in s6) if (Object.prototype.hasOwnProperty.call(s6, p7)) t8[p7] = s6[p7];
        }
        return t8;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports$23, "__esModule", {
      value: true
    });
    exports$23.fs = exports$23.createFsFromVolume = exports$23.vol = exports$23.Volume = void 0;
    var Stats_1 = dew$d2();
    var Dirent_1 = dew$92();
    var volume_1 = dew$23();
    var _a = dew$13(), fsSyncMethods = _a.fsSyncMethods, fsAsyncMethods = _a.fsAsyncMethods;
    var constants_1 = dew$f2();
    var F_OK2 = constants_1.constants.F_OK, R_OK2 = constants_1.constants.R_OK, W_OK2 = constants_1.constants.W_OK, X_OK2 = constants_1.constants.X_OK;
    exports$23.Volume = volume_1.Volume;
    exports$23.vol = new volume_1.Volume();
    function createFsFromVolume2(vol2) {
      var fs3 = {
        F_OK: F_OK2,
        R_OK: R_OK2,
        W_OK: W_OK2,
        X_OK: X_OK2,
        constants: constants_1.constants,
        Stats: Stats_1.default,
        Dirent: Dirent_1.default
      };
      for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
        var method = fsSyncMethods_1[_i];
        if (typeof vol2[method] === "function") fs3[method] = vol2[method].bind(vol2);
      }
      for (var _a2 = 0, fsAsyncMethods_1 = fsAsyncMethods; _a2 < fsAsyncMethods_1.length; _a2++) {
        var method = fsAsyncMethods_1[_a2];
        if (typeof vol2[method] === "function") fs3[method] = vol2[method].bind(vol2);
      }
      fs3.StatWatcher = vol2.StatWatcher;
      fs3.FSWatcher = vol2.FSWatcher;
      fs3.WriteStream = vol2.WriteStream;
      fs3.ReadStream = vol2.ReadStream;
      fs3.promises = vol2.promises;
      fs3._toUnixTimestamp = volume_1.toUnixTimestamp;
      return fs3;
    }
    exports$23.createFsFromVolume = createFsFromVolume2;
    exports$23.fs = createFsFromVolume2(exports$23.vol);
    exports$23 = __assign2(__assign2({}, exports$23), exports$23.fs);
    exports$23.semantic = true;
    return exports$23;
  }
  function unimplemented2(name8) {
    throw new Error(`Node.js fs ${name8} is not supported by JSPM core in the browser`);
  }
  function watchStdo(path2, fd, listener) {
    let oldSize = 0;
    const decoder2 = new TextDecoder();
    vol.watch(path2, "utf8", () => {
      const { size } = vol.fstatSync(fd);
      const buf3 = Buffer.alloc(size - oldSize);
      vol.readSync(fd, buf3, 0, buf3.length, oldSize);
      oldSize = size;
      listener(decoder2.decode(buf3, { stream: true }));
    });
  }
  function handleFsUrl(url, isSync) {
    if (url.protocol === "file:")
      return fileURLToPath(url);
    if (url.protocol === "https:" || url.protocol === "http:") {
      const path2 = "\\\\url\\" + url.href.replaceAll(/\//g, "\\\\");
      if (existsSync(path2))
        return path2;
      if (isSync)
        throw new Error(`Cannot sync request URL ${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.`);
      return (async () => {
        const res = await fetch(url);
        if (!res.ok)
          throw new Error(`Unable to fetch ${url.href}, ${res.status}`);
        const buf3 = await res.arrayBuffer();
        writeFileSync(path2, Buffer.from(buf3));
        return path2;
      })();
    }
    throw new Error("URL " + url + " not supported in JSPM FS implementation.");
  }
  function wrapFsSync(fn) {
    return function(path2, ...args) {
      if (path2 instanceof URL)
        return fn(handleFsUrl(path2, true), ...args);
      return fn(path2, ...args);
    };
  }
  function wrapFsPromise(fn) {
    return async function(path2, ...args) {
      if (path2 instanceof URL)
        return fn(await handleFsUrl(path2), ...args);
      return fn(path2, ...args);
    };
  }
  function wrapFsCallback(fn) {
    return function(path2, ...args) {
      const cb = args[args.length - 1];
      if (path2 instanceof URL && typeof cb === "function") {
        handleFsUrl(path2).then((path3) => {
          fn(path3, ...args);
        }, cb);
      } else {
        fn(path2, ...args);
      }
    };
  }
  var exports$h, _dewExec$f2, exports$g2, _dewExec$e2, exports$f2, _dewExec$d2, exports$e2, _dewExec$c2, exports$d2, _dewExec$b2, _global$3, exports$c2, _dewExec$a2, exports$b2, _dewExec$92, exports$a2, _dewExec$82, _global$22, exports$92, _dewExec$72, exports$82, _dewExec$62, exports$72, _dewExec$52, _global$12, exports$62, _dewExec$42, exports$52, _dewExec$32, exports$42, _dewExec$23, _global4, exports$33, _dewExec$13, exports$23, _dewExec7, exports$15, exports8, vol, createFsFromVolume, fs2, appendFile, appendFileSync, access, accessSync, chown, chownSync, chmod, chmodSync, close, closeSync, copyFile, copyFileSync, cp, cpSync, createReadStream, createWriteStream, exists, existsSync, fchown, fchownSync, fchmod, fchmodSync, fdatasync, fdatasyncSync, fstat, fstatSync, fsync, fsyncSync, ftruncate, ftruncateSync, futimes, futimesSync, lchown, lchownSync, lchmod, lchmodSync, link, linkSync, lstat, lstatSync, mkdir, mkdirSync, mkdtemp, mkdtempSync, open, openSync, opendir, opendirSync, readdir, readdirSync, read, readSync, readv, readvSync, readFile, readFileSync, readlink, readlinkSync, realpath, realpathSync, rename, renameSync, rm, rmSync, rmdir, rmdirSync, stat, statSync, symlink, symlinkSync, truncate, truncateSync, unwatchFile, unlink, unlinkSync, utimes, utimesSync, watch, watchFile, writeFile, writeFileSync, write, writeSync, writev, writevSync, Dir, Dirent, Stats, ReadStream, WriteStream, FileReadStream, FileWriteStream, _toUnixTimestamp, F_OK, R_OK, W_OK, X_OK, constants, promises2;
  var init_fs = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/fs.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_44e51b61();
      init_assert();
      init_util();
      init_chunk_b4205b57();
      init_path();
      init_chunk_2eac56ff();
      init_events();
      init_chunk_4bd36a8f();
      init_stream();
      init_url();
      init_chunk_23dbec7b();
      init_chunk_6c718bbe();
      init_buffer();
      init_chunk_ce0fbc82();
      init_chunk_5decc758();
      init_chunk_4ccc3a29();
      init_chunk_924bb2e1();
      init_chunk_b04e620d();
      exports$h = {};
      _dewExec$f2 = false;
      exports$g2 = {};
      _dewExec$e2 = false;
      exports$f2 = {};
      _dewExec$d2 = false;
      exports$e2 = {};
      _dewExec$c2 = false;
      exports$d2 = {};
      _dewExec$b2 = false;
      _global$3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$c2 = {};
      _dewExec$a2 = false;
      exports$b2 = {};
      _dewExec$92 = false;
      exports$a2 = {};
      _dewExec$82 = false;
      _global$22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$92 = {};
      _dewExec$72 = false;
      exports$82 = {};
      _dewExec$62 = false;
      exports$72 = {};
      _dewExec$52 = false;
      _global$12 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$62 = {};
      _dewExec$42 = false;
      exports$52 = {};
      _dewExec$32 = false;
      exports$42 = {};
      _dewExec$23 = false;
      _global4 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$33 = {};
      _dewExec$13 = false;
      exports$23 = {};
      _dewExec7 = false;
      exports$15 = dew7();
      exports$15["__esModule"];
      exports$15["fs"];
      exports$15["createFsFromVolume"];
      exports$15["vol"];
      exports$15["Volume"];
      exports$15["semantic"];
      exports8 = dew$23();
      exports8["__esModule"];
      exports8["FSWatcher"];
      exports8["StatWatcher"];
      exports8["Volume"];
      exports8["toUnixTimestamp"];
      exports8["bufferToEncoding"];
      exports8["dataToBuffer"];
      exports8["dataToStr"];
      exports8["pathToSteps"];
      exports8["filenameToSteps"];
      exports8["pathToFilename"];
      exports8["flagsToNumber"];
      exports8["FLAGS"];
      exports8["ReadStream"];
      exports8["WriteStream"];
      ({ vol, createFsFromVolume } = exports$15);
      vol.fromNestedJSON({
        "/dev": { stdin: "", stdout: "", stderr: "" },
        "/usr/bin": {},
        "/home": {},
        "/tmp": {}
      });
      vol.releasedFds = [2, 1, 0];
      vol.openSync("/dev/stdin", "w");
      vol.openSync("/dev/stdout", "r");
      vol.openSync("/dev/stderr", "r");
      watchStdo("/dev/stdout", 1, console.log);
      watchStdo("/dev/stderr", 2, console.error);
      fs2 = createFsFromVolume(vol);
      fs2.opendir = () => unimplemented2("opendir");
      fs2.opendirSync = () => unimplemented2("opendirSync");
      fs2.promises.opendir = () => unimplemented2("promises.opendir");
      fs2.cp = () => unimplemented2("cp");
      fs2.cpSync = () => unimplemented2("cpSync");
      fs2.promises.cp = () => unimplemented2("promises.cp");
      fs2.readv = () => unimplemented2("readv");
      fs2.readvSync = () => unimplemented2("readvSync");
      fs2.rm = () => unimplemented2("rm");
      fs2.rmSync = () => unimplemented2("rmSync");
      fs2.promises.rm = () => unimplemented2("promises.rm");
      fs2.Dir = () => unimplemented2("Dir");
      fs2.promises.watch = () => unimplemented2("promises.watch");
      fs2.FileReadStream = fs2.ReadStream;
      fs2.FileWriteStream = fs2.WriteStream;
      fs2.promises.readFile = wrapFsPromise(fs2.promises.readFile);
      fs2.readFile = wrapFsCallback(fs2.readFile);
      fs2.readFileSync = wrapFsSync(fs2.readFileSync);
      ({
        appendFile,
        appendFileSync,
        access,
        accessSync,
        chown,
        chownSync,
        chmod,
        chmodSync,
        close,
        closeSync,
        copyFile,
        copyFileSync,
        cp,
        cpSync,
        createReadStream,
        createWriteStream,
        exists,
        existsSync,
        fchown,
        fchownSync,
        fchmod,
        fchmodSync,
        fdatasync,
        fdatasyncSync,
        fstat,
        fstatSync,
        fsync,
        fsyncSync,
        ftruncate,
        ftruncateSync,
        futimes,
        futimesSync,
        lchown,
        lchownSync,
        lchmod,
        lchmodSync,
        link,
        linkSync,
        lstat,
        lstatSync,
        mkdir,
        mkdirSync,
        mkdtemp,
        mkdtempSync,
        open,
        openSync,
        opendir,
        opendirSync,
        readdir,
        readdirSync,
        read,
        readSync,
        readv,
        readvSync,
        readFile,
        readFileSync,
        readlink,
        readlinkSync,
        realpath,
        realpathSync,
        rename,
        renameSync,
        rm,
        rmSync,
        rmdir,
        rmdirSync,
        stat,
        statSync,
        symlink,
        symlinkSync,
        truncate,
        truncateSync,
        unwatchFile,
        unlink,
        unlinkSync,
        utimes,
        utimesSync,
        watch,
        watchFile,
        writeFile,
        writeFileSync,
        write,
        writeSync,
        writev,
        writevSync,
        Dir,
        Dirent,
        Stats,
        ReadStream,
        WriteStream,
        FileReadStream,
        FileWriteStream,
        _toUnixTimestamp,
        constants: { F_OK, R_OK, W_OK, X_OK },
        constants,
        promises: promises2
      } = fs2);
    }
  });

  // node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/fs/promises.js
  var promises_exports = {};
  __export(promises_exports, {
    access: () => access2,
    appendFile: () => appendFile2,
    chmod: () => chmod2,
    chown: () => chown2,
    copyFile: () => copyFile2,
    cp: () => cp2,
    default: () => promises2,
    lchmod: () => lchmod2,
    lchown: () => lchown2,
    link: () => link2,
    lstat: () => lstat2,
    mkdir: () => mkdir2,
    mkdtemp: () => mkdtemp2,
    open: () => open2,
    opendir: () => opendir2,
    readFile: () => readFile2,
    readdir: () => readdir2,
    readlink: () => readlink2,
    realpath: () => realpath2,
    rename: () => rename2,
    rm: () => rm2,
    rmdir: () => rmdir2,
    stat: () => stat2,
    symlink: () => symlink2,
    truncate: () => truncate2,
    unlink: () => unlink2,
    utimes: () => utimes2,
    watch: () => watch2,
    writeFile: () => writeFile2
  });
  var access2, copyFile2, cp2, open2, opendir2, rename2, truncate2, rm2, rmdir2, mkdir2, readdir2, readlink2, symlink2, lstat2, stat2, link2, unlink2, chmod2, lchmod2, lchown2, chown2, utimes2, realpath2, mkdtemp2, writeFile2, appendFile2, readFile2, watch2;
  var init_promises = __esm({
    "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/fs/promises.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_fs();
      init_fs();
      init_chunk_44e51b61();
      init_chunk_4bd36a8f();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      init_chunk_2eac56ff();
      init_chunk_4ccc3a29();
      init_assert();
      init_util();
      init_path();
      init_chunk_23dbec7b();
      init_events();
      init_stream();
      init_chunk_6c718bbe();
      init_url();
      init_chunk_924bb2e1();
      init_chunk_b04e620d();
      init_buffer();
      ({
        access: access2,
        copyFile: copyFile2,
        cp: cp2,
        open: open2,
        opendir: opendir2,
        rename: rename2,
        truncate: truncate2,
        rm: rm2,
        rmdir: rmdir2,
        mkdir: mkdir2,
        readdir: readdir2,
        readlink: readlink2,
        symlink: symlink2,
        lstat: lstat2,
        stat: stat2,
        link: link2,
        unlink: unlink2,
        chmod: chmod2,
        lchmod: lchmod2,
        lchown: lchown2,
        chown: chown2,
        utimes: utimes2,
        realpath: realpath2,
        mkdtemp: mkdtemp2,
        writeFile: writeFile2,
        appendFile: appendFile2,
        readFile: readFile2,
        watch: watch2
      } = promises2);
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/node-filesystem-7YZR3POJ.js
  var node_filesystem_7YZR3POJ_exports = {};
  __export(node_filesystem_7YZR3POJ_exports, {
    NodeFileSystem: () => NodeFileSystem
  });
  var NodeFileSystem;
  var init_node_filesystem_7YZR3POJ = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/node-filesystem-7YZR3POJ.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_XINRLWR3();
      init_chunk_MAK4D54P();
      init_cement();
      NodeFileSystem = class {
        async start() {
          this.fs = await Promise.resolve().then(() => (init_promises(), promises_exports));
          return this;
        }
        async mkdir(path2, options) {
          return this.fs?.mkdir(path2, options);
        }
        async readdir(path2, options) {
          return this.fs?.readdir(path2, options);
        }
        async rm(path2, options) {
          return this.fs?.rm(path2, options);
        }
        async copyFile(source, destination) {
          return this.fs?.copyFile(source, destination);
        }
        async readfile(path2, options) {
          const ret = await this.fs?.readFile(path2, options);
          return toArrayBuffer(ret);
        }
        stat(path2) {
          return this.fs?.stat(path2);
        }
        async unlink(path2) {
          return this.fs?.unlink(path2);
        }
        async writefile(path2, data) {
          if (runtimeFn().isDeno) {
            return this.fs?.writeFile(path2, data);
          }
          return this.fs?.writeFile(path2, Buffer.from(data));
        }
      };
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/chunk-XINRLWR3.js
  async function getFileSystem(url) {
    const name8 = url.getParam("fs");
    let fs3;
    switch (name8) {
      case "mem":
        {
          const { MemFileSystem: MemFileSystem2 } = await Promise.resolve().then(() => (init_mem_filesystem_BZQZLUR6(), mem_filesystem_BZQZLUR6_exports));
          fs3 = new MemFileSystem2();
        }
        break;
      // case 'deno': {
      //   const { DenoFileSystem } = await import("./deno-filesystem.js");
      //   fs = new DenoFileSystem();
      //   break;
      // }
      case "node": {
        const { NodeFileSystem: NodeFileSystem2 } = await Promise.resolve().then(() => (init_node_filesystem_7YZR3POJ(), node_filesystem_7YZR3POJ_exports));
        fs3 = new NodeFileSystem2();
        break;
      }
      case "sys":
      default: {
        return getFileSystem(url.build().setParam("fs", "node").URI());
      }
    }
    return fs3.start();
  }
  function getPath(url, sthis) {
    const basePath = url.pathname;
    const name8 = url.getParam("name");
    if (name8) {
      const version2 = url.getParam("version");
      if (!version2) throw sthis.logger.Error().Url(url).Msg(`version not found`).AsError();
      return sthis.pathOps.join(basePath, version2, name8);
    }
    return sthis.pathOps.join(basePath);
  }
  function getFileName(url, sthis) {
    const key = url.getParam("key");
    if (!key) throw sthis.logger.Error().Url(url).Msg(`key not found`).AsError();
    const res = getStore(url, sthis, (...a7) => a7.join("-"));
    switch (res.store) {
      case "data":
        return sthis.pathOps.join(res.name, key + ".car");
      case "wal":
      case "meta":
        return sthis.pathOps.join(res.name, key + ".json");
      default:
        throw sthis.logger.Error().Url(url).Msg(`unsupported store type`).AsError();
    }
  }
  function toArrayBuffer(buffer4) {
    if (typeof buffer4 === "string") {
      buffer4 = Buffer.from(buffer4);
    }
    const ab = new ArrayBuffer(buffer4.length);
    const view = new Uint8Array(ab);
    for (let i7 = 0; i7 < buffer4.length; ++i7) {
      view[i7] = buffer4[i7];
    }
    return view;
  }
  var init_chunk_XINRLWR3 = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/chunk-XINRLWR3.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_MAK4D54P();
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/chunk-PB4BKL4O.js
  var INDEXDB_VERSION;
  var init_chunk_PB4BKL4O = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/chunk-PB4BKL4O.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      INDEXDB_VERSION = "v0.19-indexdb";
    }
  });

  // node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js
  var require_aspromise = __commonJS({
    "node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = asPromise;
      function asPromise(fn, ctx) {
        var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
        while (index2 < arguments.length)
          params[offset++] = arguments[index2++];
        return new Promise(function executor(resolve9, reject) {
          params[offset] = function callback(err) {
            if (pending) {
              pending = false;
              if (err)
                reject(err);
              else {
                var params2 = new Array(arguments.length - 1), offset2 = 0;
                while (offset2 < params2.length)
                  params2[offset2++] = arguments[offset2];
                resolve9.apply(null, params2);
              }
            }
          };
          try {
            fn.apply(ctx || null, params);
          } catch (err) {
            if (pending) {
              pending = false;
              reject(err);
            }
          }
        });
      }
    }
  });

  // node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js
  var require_base64 = __commonJS({
    "node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var base643 = exports9;
      base643.length = function length4(string3) {
        var p7 = string3.length;
        if (!p7)
          return 0;
        var n8 = 0;
        while (--p7 % 4 > 1 && string3.charAt(p7) === "=")
          ++n8;
        return Math.ceil(string3.length * 3) / 4 - n8;
      };
      var b64 = new Array(64);
      var s64 = new Array(123);
      for (i7 = 0; i7 < 64; )
        s64[b64[i7] = i7 < 26 ? i7 + 65 : i7 < 52 ? i7 + 71 : i7 < 62 ? i7 - 4 : i7 - 59 | 43] = i7++;
      var i7;
      base643.encode = function encode18(buffer4, start, end) {
        var parts = null, chunk = [];
        var i8 = 0, j4 = 0, t8;
        while (start < end) {
          var b5 = buffer4[start++];
          switch (j4) {
            case 0:
              chunk[i8++] = b64[b5 >> 2];
              t8 = (b5 & 3) << 4;
              j4 = 1;
              break;
            case 1:
              chunk[i8++] = b64[t8 | b5 >> 4];
              t8 = (b5 & 15) << 2;
              j4 = 2;
              break;
            case 2:
              chunk[i8++] = b64[t8 | b5 >> 6];
              chunk[i8++] = b64[b5 & 63];
              j4 = 0;
              break;
          }
          if (i8 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i8 = 0;
          }
        }
        if (j4) {
          chunk[i8++] = b64[t8];
          chunk[i8++] = 61;
          if (j4 === 1)
            chunk[i8++] = 61;
        }
        if (parts) {
          if (i8)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i8)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i8));
      };
      var invalidEncoding = "invalid encoding";
      base643.decode = function decode21(string3, buffer4, offset) {
        var start = offset;
        var j4 = 0, t8;
        for (var i8 = 0; i8 < string3.length; ) {
          var c7 = string3.charCodeAt(i8++);
          if (c7 === 61 && j4 > 1)
            break;
          if ((c7 = s64[c7]) === void 0)
            throw Error(invalidEncoding);
          switch (j4) {
            case 0:
              t8 = c7;
              j4 = 1;
              break;
            case 1:
              buffer4[offset++] = t8 << 2 | (c7 & 48) >> 4;
              t8 = c7;
              j4 = 2;
              break;
            case 2:
              buffer4[offset++] = (t8 & 15) << 4 | (c7 & 60) >> 2;
              t8 = c7;
              j4 = 3;
              break;
            case 3:
              buffer4[offset++] = (t8 & 3) << 6 | c7;
              j4 = 0;
              break;
          }
        }
        if (j4 === 1)
          throw Error(invalidEncoding);
        return offset - start;
      };
      base643.test = function test(string3) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string3);
      };
    }
  });

  // node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js
  var require_eventemitter = __commonJS({
    "node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = EventEmitter3;
      function EventEmitter3() {
        this._listeners = {};
      }
      EventEmitter3.prototype.on = function on3(evt, fn, ctx) {
        (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn,
          ctx: ctx || this
        });
        return this;
      };
      EventEmitter3.prototype.off = function off2(evt, fn) {
        if (evt === void 0)
          this._listeners = {};
        else {
          if (fn === void 0)
            this._listeners[evt] = [];
          else {
            var listeners2 = this._listeners[evt];
            for (var i7 = 0; i7 < listeners2.length; )
              if (listeners2[i7].fn === fn)
                listeners2.splice(i7, 1);
              else
                ++i7;
          }
        }
        return this;
      };
      EventEmitter3.prototype.emit = function emit2(evt) {
        var listeners2 = this._listeners[evt];
        if (listeners2) {
          var args = [], i7 = 1;
          for (; i7 < arguments.length; )
            args.push(arguments[i7++]);
          for (i7 = 0; i7 < listeners2.length; )
            listeners2[i7].fn.apply(listeners2[i7++].ctx, args);
        }
        return this;
      };
    }
  });

  // node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js
  var require_float = __commonJS({
    "node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = factory(factory);
      function factory(exports10) {
        if (typeof Float32Array !== "undefined") (function() {
          var f322 = new Float32Array([-0]), f8b2 = new Uint8Array(f322.buffer), le2 = f8b2[3] === 128;
          function writeFloat_f32_cpy(val, buf3, pos) {
            f322[0] = val;
            buf3[pos] = f8b2[0];
            buf3[pos + 1] = f8b2[1];
            buf3[pos + 2] = f8b2[2];
            buf3[pos + 3] = f8b2[3];
          }
          function writeFloat_f32_rev(val, buf3, pos) {
            f322[0] = val;
            buf3[pos] = f8b2[3];
            buf3[pos + 1] = f8b2[2];
            buf3[pos + 2] = f8b2[1];
            buf3[pos + 3] = f8b2[0];
          }
          exports10.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports10.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf3, pos) {
            f8b2[0] = buf3[pos];
            f8b2[1] = buf3[pos + 1];
            f8b2[2] = buf3[pos + 2];
            f8b2[3] = buf3[pos + 3];
            return f322[0];
          }
          function readFloat_f32_rev(buf3, pos) {
            f8b2[3] = buf3[pos];
            f8b2[2] = buf3[pos + 1];
            f8b2[1] = buf3[pos + 2];
            f8b2[0] = buf3[pos + 3];
            return f322[0];
          }
          exports10.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
          exports10.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
        else (function() {
          function writeFloat_ieee754(writeUint, val, buf3, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf3, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf3, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf3, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf3, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf3, pos);
            }
          }
          exports10.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports10.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf3, pos) {
            var uint = readUint(buf3, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports10.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports10.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
        if (typeof Float64Array !== "undefined") (function() {
          var f642 = new Float64Array([-0]), f8b2 = new Uint8Array(f642.buffer), le2 = f8b2[7] === 128;
          function writeDouble_f64_cpy(val, buf3, pos) {
            f642[0] = val;
            buf3[pos] = f8b2[0];
            buf3[pos + 1] = f8b2[1];
            buf3[pos + 2] = f8b2[2];
            buf3[pos + 3] = f8b2[3];
            buf3[pos + 4] = f8b2[4];
            buf3[pos + 5] = f8b2[5];
            buf3[pos + 6] = f8b2[6];
            buf3[pos + 7] = f8b2[7];
          }
          function writeDouble_f64_rev(val, buf3, pos) {
            f642[0] = val;
            buf3[pos] = f8b2[7];
            buf3[pos + 1] = f8b2[6];
            buf3[pos + 2] = f8b2[5];
            buf3[pos + 3] = f8b2[4];
            buf3[pos + 4] = f8b2[3];
            buf3[pos + 5] = f8b2[2];
            buf3[pos + 6] = f8b2[1];
            buf3[pos + 7] = f8b2[0];
          }
          exports10.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports10.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf3, pos) {
            f8b2[0] = buf3[pos];
            f8b2[1] = buf3[pos + 1];
            f8b2[2] = buf3[pos + 2];
            f8b2[3] = buf3[pos + 3];
            f8b2[4] = buf3[pos + 4];
            f8b2[5] = buf3[pos + 5];
            f8b2[6] = buf3[pos + 6];
            f8b2[7] = buf3[pos + 7];
            return f642[0];
          }
          function readDouble_f64_rev(buf3, pos) {
            f8b2[7] = buf3[pos];
            f8b2[6] = buf3[pos + 1];
            f8b2[5] = buf3[pos + 2];
            f8b2[4] = buf3[pos + 3];
            f8b2[3] = buf3[pos + 4];
            f8b2[2] = buf3[pos + 5];
            f8b2[1] = buf3[pos + 6];
            f8b2[0] = buf3[pos + 7];
            return f642[0];
          }
          exports10.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
          exports10.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
        else (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf3, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf3, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf3, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf3, pos + off0);
              writeUint(2146959360, buf3, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf3, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf3, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf3, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf3, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf3, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf3, pos + off1);
              }
            }
          }
          exports10.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports10.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf3, pos) {
            var lo = readUint(buf3, pos + off0), hi = readUint(buf3, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports10.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports10.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
        return exports10;
      }
      function writeUintLE(val, buf3, pos) {
        buf3[pos] = val & 255;
        buf3[pos + 1] = val >>> 8 & 255;
        buf3[pos + 2] = val >>> 16 & 255;
        buf3[pos + 3] = val >>> 24;
      }
      function writeUintBE(val, buf3, pos) {
        buf3[pos] = val >>> 24;
        buf3[pos + 1] = val >>> 16 & 255;
        buf3[pos + 2] = val >>> 8 & 255;
        buf3[pos + 3] = val & 255;
      }
      function readUintLE(buf3, pos) {
        return (buf3[pos] | buf3[pos + 1] << 8 | buf3[pos + 2] << 16 | buf3[pos + 3] << 24) >>> 0;
      }
      function readUintBE(buf3, pos) {
        return (buf3[pos] << 24 | buf3[pos + 1] << 16 | buf3[pos + 2] << 8 | buf3[pos + 3]) >>> 0;
      }
    }
  });

  // node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js
  var require_inquire = __commonJS({
    "node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js"(exports, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module.exports = inquire;
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length))
            return mod;
        } catch (e9) {
        }
        return null;
      }
    }
  });

  // node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js
  var require_utf8 = __commonJS({
    "node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var utf84 = exports9;
      utf84.length = function utf8_length(string3) {
        var len = 0, c7 = 0;
        for (var i7 = 0; i7 < string3.length; ++i7) {
          c7 = string3.charCodeAt(i7);
          if (c7 < 128)
            len += 1;
          else if (c7 < 2048)
            len += 2;
          else if ((c7 & 64512) === 55296 && (string3.charCodeAt(i7 + 1) & 64512) === 56320) {
            ++i7;
            len += 4;
          } else
            len += 3;
        }
        return len;
      };
      utf84.read = function utf8_read(buffer4, start, end) {
        var len = end - start;
        if (len < 1)
          return "";
        var parts = null, chunk = [], i7 = 0, t8;
        while (start < end) {
          t8 = buffer4[start++];
          if (t8 < 128)
            chunk[i7++] = t8;
          else if (t8 > 191 && t8 < 224)
            chunk[i7++] = (t8 & 31) << 6 | buffer4[start++] & 63;
          else if (t8 > 239 && t8 < 365) {
            t8 = ((t8 & 7) << 18 | (buffer4[start++] & 63) << 12 | (buffer4[start++] & 63) << 6 | buffer4[start++] & 63) - 65536;
            chunk[i7++] = 55296 + (t8 >> 10);
            chunk[i7++] = 56320 + (t8 & 1023);
          } else
            chunk[i7++] = (t8 & 15) << 12 | (buffer4[start++] & 63) << 6 | buffer4[start++] & 63;
          if (i7 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i7 = 0;
          }
        }
        if (parts) {
          if (i7)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i7)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i7));
      };
      utf84.write = function utf8_write(string3, buffer4, offset) {
        var start = offset, c1, c22;
        for (var i7 = 0; i7 < string3.length; ++i7) {
          c1 = string3.charCodeAt(i7);
          if (c1 < 128) {
            buffer4[offset++] = c1;
          } else if (c1 < 2048) {
            buffer4[offset++] = c1 >> 6 | 192;
            buffer4[offset++] = c1 & 63 | 128;
          } else if ((c1 & 64512) === 55296 && ((c22 = string3.charCodeAt(i7 + 1)) & 64512) === 56320) {
            c1 = 65536 + ((c1 & 1023) << 10) + (c22 & 1023);
            ++i7;
            buffer4[offset++] = c1 >> 18 | 240;
            buffer4[offset++] = c1 >> 12 & 63 | 128;
            buffer4[offset++] = c1 >> 6 & 63 | 128;
            buffer4[offset++] = c1 & 63 | 128;
          } else {
            buffer4[offset++] = c1 >> 12 | 224;
            buffer4[offset++] = c1 >> 6 & 63 | 128;
            buffer4[offset++] = c1 & 63 | 128;
          }
        }
        return offset - start;
      };
    }
  });

  // node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js
  var require_pool = __commonJS({
    "node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = pool2;
      function pool2(alloc4, slice4, size) {
        var SIZE = size || 8192;
        var MAX = SIZE >>> 1;
        var slab = null;
        var offset = SIZE;
        return function pool_alloc(size2) {
          if (size2 < 1 || size2 > MAX)
            return alloc4(size2);
          if (offset + size2 > SIZE) {
            slab = alloc4(SIZE);
            offset = 0;
          }
          var buf3 = slice4.call(slab, offset, offset += size2);
          if (offset & 7)
            offset = (offset | 7) + 1;
          return buf3;
        };
      }
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/util/longbits.js
  var require_longbits = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/util/longbits.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = LongBits2;
      var util = require_minimal();
      function LongBits2(lo, hi) {
        this.lo = lo >>> 0;
        this.hi = hi >>> 0;
      }
      var zero2 = LongBits2.zero = new LongBits2(0, 0);
      zero2.toNumber = function() {
        return 0;
      };
      zero2.zzEncode = zero2.zzDecode = function() {
        return this;
      };
      zero2.length = function() {
        return 1;
      };
      var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
      LongBits2.fromNumber = function fromNumber(value) {
        if (value === 0)
          return zero2;
        var sign = value < 0;
        if (sign)
          value = -value;
        var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
        if (sign) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
              hi = 0;
          }
        }
        return new LongBits2(lo, hi);
      };
      LongBits2.from = function from8(value) {
        if (typeof value === "number")
          return LongBits2.fromNumber(value);
        if (util.isString(value)) {
          if (util.Long)
            value = util.Long.fromString(value);
          else
            return LongBits2.fromNumber(parseInt(value, 10));
        }
        return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero2;
      };
      LongBits2.prototype.toNumber = function toNumber(unsigned) {
        if (!unsigned && this.hi >>> 31) {
          var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
          if (!lo)
            hi = hi + 1 >>> 0;
          return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      };
      LongBits2.prototype.toLong = function toLong(unsigned) {
        return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
      };
      var charCodeAt = String.prototype.charCodeAt;
      LongBits2.fromHash = function fromHash(hash2) {
        if (hash2 === zeroHash)
          return zero2;
        return new LongBits2(
          (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
          (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
        );
      };
      LongBits2.prototype.toHash = function toHash() {
        return String.fromCharCode(
          this.lo & 255,
          this.lo >>> 8 & 255,
          this.lo >>> 16 & 255,
          this.lo >>> 24,
          this.hi & 255,
          this.hi >>> 8 & 255,
          this.hi >>> 16 & 255,
          this.hi >>> 24
        );
      };
      LongBits2.prototype.zzEncode = function zzEncode() {
        var mask = this.hi >> 31;
        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        this.lo = (this.lo << 1 ^ mask) >>> 0;
        return this;
      };
      LongBits2.prototype.zzDecode = function zzDecode() {
        var mask = -(this.lo & 1);
        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        this.hi = (this.hi >>> 1 ^ mask) >>> 0;
        return this;
      };
      LongBits2.prototype.length = function length4() {
        var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
        return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
      };
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/util/minimal.js
  var require_minimal = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/util/minimal.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var util = exports9;
      util.asPromise = require_aspromise();
      util.base64 = require_base64();
      util.EventEmitter = require_eventemitter();
      util.float = require_float();
      util.inquire = require_inquire();
      util.utf8 = require_utf8();
      util.pool = require_pool();
      util.LongBits = require_longbits();
      util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
      util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports9;
      util.emptyArray = Object.freeze ? Object.freeze([]) : (
        /* istanbul ignore next */
        []
      );
      util.emptyObject = Object.freeze ? Object.freeze({}) : (
        /* istanbul ignore next */
        {}
      );
      util.isInteger = Number.isInteger || /* istanbul ignore next */
      function isInteger(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
      util.isString = function isString3(value) {
        return typeof value === "string" || value instanceof String;
      };
      util.isObject = function isObject3(value) {
        return value && typeof value === "object";
      };
      util.isset = /**
       * Checks if a property on a message is considered to be present.
       * @param {Object} obj Plain object or message instance
       * @param {string} prop Property name
       * @returns {boolean} `true` if considered to be present, otherwise `false`
       */
      util.isSet = function isSet2(obj, prop) {
        var value = obj[prop];
        if (value != null && obj.hasOwnProperty(prop))
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
        return false;
      };
      util.Buffer = function() {
        try {
          var Buffer2 = util.inquire("buffer").Buffer;
          return Buffer2.prototype.utf8Write ? Buffer2 : (
            /* istanbul ignore next */
            null
          );
        } catch (e9) {
          return null;
        }
      }();
      util._Buffer_from = null;
      util._Buffer_allocUnsafe = null;
      util.newBuffer = function newBuffer(sizeOrArray) {
        return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
      };
      util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      util.Long = /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long");
      util.key2Re = /^true|false|0|1$/;
      util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
      util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
      util.longToHash = function longToHash(value) {
        return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
      };
      util.longFromHash = function longFromHash(hash2, unsigned) {
        var bits = util.LongBits.fromHash(hash2);
        if (util.Long)
          return util.Long.fromBits(bits.lo, bits.hi, unsigned);
        return bits.toNumber(Boolean(unsigned));
      };
      function merge2(dst, src3, ifNotSet) {
        for (var keys = Object.keys(src3), i7 = 0; i7 < keys.length; ++i7)
          if (dst[keys[i7]] === void 0 || !ifNotSet)
            dst[keys[i7]] = src3[keys[i7]];
        return dst;
      }
      util.merge = merge2;
      util.lcFirst = function lcFirst(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
      };
      function newError(name8) {
        function CustomError(message2, properties) {
          if (!(this instanceof CustomError))
            return new CustomError(message2, properties);
          Object.defineProperty(this, "message", { get: function() {
            return message2;
          } });
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, CustomError);
          else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });
          if (properties)
            merge2(this, properties);
        }
        CustomError.prototype = Object.create(Error.prototype, {
          constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
          },
          name: {
            get: function get8() {
              return name8;
            },
            set: void 0,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true
          },
          toString: {
            value: function value() {
              return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
          }
        });
        return CustomError;
      }
      util.newError = newError;
      util.ProtocolError = newError("ProtocolError");
      util.oneOfGetter = function getOneOf(fieldNames) {
        var fieldMap = {};
        for (var i7 = 0; i7 < fieldNames.length; ++i7)
          fieldMap[fieldNames[i7]] = 1;
        return function() {
          for (var keys = Object.keys(this), i8 = keys.length - 1; i8 > -1; --i8)
            if (fieldMap[keys[i8]] === 1 && this[keys[i8]] !== void 0 && this[keys[i8]] !== null)
              return keys[i8];
        };
      };
      util.oneOfSetter = function setOneOf(fieldNames) {
        return function(name8) {
          for (var i7 = 0; i7 < fieldNames.length; ++i7)
            if (fieldNames[i7] !== name8)
              delete this[fieldNames[i7]];
        };
      };
      util.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: true
      };
      util._configure = function() {
        var Buffer2 = util.Buffer;
        if (!Buffer2) {
          util._Buffer_from = util._Buffer_allocUnsafe = null;
          return;
        }
        util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
        function Buffer_from(value, encoding) {
          return new Buffer2(value, encoding);
        };
        util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
          return new Buffer2(size);
        };
      };
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/writer.js
  var require_writer = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/writer.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = Writer;
      var util = require_minimal();
      var BufferWriter;
      var LongBits2 = util.LongBits;
      var base643 = util.base64;
      var utf84 = util.utf8;
      function Op2(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      function noop3() {
      }
      function State2(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
      function Writer() {
        this.len = 0;
        this.head = new Op2(noop3, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      var create16 = function create17() {
        return util.Buffer ? function create_buffer_setup() {
          return (Writer.create = function create_buffer() {
            return new BufferWriter();
          })();
        } : function create_array() {
          return new Writer();
        };
      };
      Writer.create = create16();
      Writer.alloc = function alloc4(size) {
        return new util.Array(size);
      };
      if (util.Array !== Array)
        Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
      Writer.prototype._push = function push2(fn, len, val) {
        this.tail = this.tail.next = new Op2(fn, len, val);
        this.len += len;
        return this;
      };
      function writeByte2(val, buf3, pos) {
        buf3[pos] = val & 255;
      }
      function writeVarint322(val, buf3, pos) {
        while (val > 127) {
          buf3[pos++] = val & 127 | 128;
          val >>>= 7;
        }
        buf3[pos] = val;
      }
      function VarintOp2(len, val) {
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      VarintOp2.prototype = Object.create(Op2.prototype);
      VarintOp2.prototype.fn = writeVarint322;
      Writer.prototype.uint32 = function write_uint32(value) {
        this.len += (this.tail = this.tail.next = new VarintOp2(
          (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
          value
        )).len;
        return this;
      };
      Writer.prototype.int32 = function write_int32(value) {
        return value < 0 ? this._push(writeVarint642, 10, LongBits2.fromNumber(value)) : this.uint32(value);
      };
      Writer.prototype.sint32 = function write_sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      };
      function writeVarint642(val, buf3, pos) {
        while (val.hi) {
          buf3[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
        }
        while (val.lo > 127) {
          buf3[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
        }
        buf3[pos++] = val.lo;
      }
      Writer.prototype.uint64 = function write_uint64(value) {
        var bits = LongBits2.from(value);
        return this._push(writeVarint642, bits.length(), bits);
      };
      Writer.prototype.int64 = Writer.prototype.uint64;
      Writer.prototype.sint64 = function write_sint64(value) {
        var bits = LongBits2.from(value).zzEncode();
        return this._push(writeVarint642, bits.length(), bits);
      };
      Writer.prototype.bool = function write_bool(value) {
        return this._push(writeByte2, 1, value ? 1 : 0);
      };
      function writeFixed322(val, buf3, pos) {
        buf3[pos] = val & 255;
        buf3[pos + 1] = val >>> 8 & 255;
        buf3[pos + 2] = val >>> 16 & 255;
        buf3[pos + 3] = val >>> 24;
      }
      Writer.prototype.fixed32 = function write_fixed32(value) {
        return this._push(writeFixed322, 4, value >>> 0);
      };
      Writer.prototype.sfixed32 = Writer.prototype.fixed32;
      Writer.prototype.fixed64 = function write_fixed64(value) {
        var bits = LongBits2.from(value);
        return this._push(writeFixed322, 4, bits.lo)._push(writeFixed322, 4, bits.hi);
      };
      Writer.prototype.sfixed64 = Writer.prototype.fixed64;
      Writer.prototype.float = function write_float(value) {
        return this._push(util.float.writeFloatLE, 4, value);
      };
      Writer.prototype.double = function write_double(value) {
        return this._push(util.float.writeDoubleLE, 8, value);
      };
      var writeBytes3 = util.Array.prototype.set ? function writeBytes_set(val, buf3, pos) {
        buf3.set(val, pos);
      } : function writeBytes_for(val, buf3, pos) {
        for (var i7 = 0; i7 < val.length; ++i7)
          buf3[pos + i7] = val[i7];
      };
      Writer.prototype.bytes = function write_bytes(value) {
        var len = value.length >>> 0;
        if (!len)
          return this._push(writeByte2, 1, 0);
        if (util.isString(value)) {
          var buf3 = Writer.alloc(len = base643.length(value));
          base643.decode(value, buf3, 0);
          value = buf3;
        }
        return this.uint32(len)._push(writeBytes3, len, value);
      };
      Writer.prototype.string = function write_string(value) {
        var len = utf84.length(value);
        return len ? this.uint32(len)._push(utf84.write, len, value) : this._push(writeByte2, 1, 0);
      };
      Writer.prototype.fork = function fork4() {
        this.states = new State2(this);
        this.head = this.tail = new Op2(noop3, 0, 0);
        this.len = 0;
        return this;
      };
      Writer.prototype.reset = function reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op2(noop3, 0, 0);
          this.len = 0;
        }
        return this;
      };
      Writer.prototype.ldelim = function ldelim() {
        var head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail;
          this.len += len;
        }
        return this;
      };
      Writer.prototype.finish = function finish() {
        var head = this.head.next, buf3 = this.constructor.alloc(this.len), pos = 0;
        while (head) {
          head.fn(head.val, buf3, pos);
          pos += head.len;
          head = head.next;
        }
        return buf3;
      };
      Writer._configure = function(BufferWriter_) {
        BufferWriter = BufferWriter_;
        Writer.create = create16();
        BufferWriter._configure();
      };
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/writer_buffer.js
  var require_writer_buffer = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/writer_buffer.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = BufferWriter;
      var Writer = require_writer();
      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
      var util = require_minimal();
      function BufferWriter() {
        Writer.call(this);
      }
      BufferWriter._configure = function() {
        BufferWriter.alloc = util._Buffer_allocUnsafe;
        BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf3, pos) {
          buf3.set(val, pos);
        } : function writeBytesBuffer_copy(val, buf3, pos) {
          if (val.copy)
            val.copy(buf3, pos, 0, val.length);
          else for (var i7 = 0; i7 < val.length; )
            buf3[pos++] = val[i7++];
        };
      };
      BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
        if (util.isString(value))
          value = util._Buffer_from(value, "base64");
        var len = value.length >>> 0;
        this.uint32(len);
        if (len)
          this._push(BufferWriter.writeBytesBuffer, len, value);
        return this;
      };
      function writeStringBuffer2(val, buf3, pos) {
        if (val.length < 40)
          util.utf8.write(val, buf3, pos);
        else if (buf3.utf8Write)
          buf3.utf8Write(val, pos);
        else
          buf3.write(val, pos);
      }
      BufferWriter.prototype.string = function write_string_buffer(value) {
        var len = util.Buffer.byteLength(value);
        this.uint32(len);
        if (len)
          this._push(writeStringBuffer2, len, value);
        return this;
      };
      BufferWriter._configure();
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/reader.js
  var require_reader = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/reader.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = Reader;
      var util = require_minimal();
      var BufferReader;
      var LongBits2 = util.LongBits;
      var utf84 = util.utf8;
      function indexOutOfRange2(reader, writeLength) {
        return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
      }
      function Reader(buffer4) {
        this.buf = buffer4;
        this.pos = 0;
        this.len = buffer4.length;
      }
      var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer4) {
        if (buffer4 instanceof Uint8Array || Array.isArray(buffer4))
          return new Reader(buffer4);
        throw Error("illegal buffer");
      } : function create_array2(buffer4) {
        if (Array.isArray(buffer4))
          return new Reader(buffer4);
        throw Error("illegal buffer");
      };
      var create16 = function create17() {
        return util.Buffer ? function create_buffer_setup(buffer4) {
          return (Reader.create = function create_buffer(buffer5) {
            return util.Buffer.isBuffer(buffer5) ? new BufferReader(buffer5) : create_array(buffer5);
          })(buffer4);
        } : create_array;
      };
      Reader.create = create16();
      Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
      util.Array.prototype.slice;
      Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
        var value = 4294967295;
        return function read_uint32() {
          value = (this.buf[this.pos] & 127) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange2(this, 10);
          }
          return value;
        };
      }();
      Reader.prototype.int32 = function read_int32() {
        return this.uint32() | 0;
      };
      Reader.prototype.sint32 = function read_sint32() {
        var value = this.uint32();
        return value >>> 1 ^ -(value & 1) | 0;
      };
      function readLongVarint() {
        var bits = new LongBits2(0, 0);
        var i7 = 0;
        if (this.len - this.pos > 4) {
          for (; i7 < 4; ++i7) {
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i7 * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
          i7 = 0;
        } else {
          for (; i7 < 3; ++i7) {
            if (this.pos >= this.len)
              throw indexOutOfRange2(this);
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i7 * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i7 * 7) >>> 0;
          return bits;
        }
        if (this.len - this.pos > 4) {
          for (; i7 < 5; ++i7) {
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i7 * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        } else {
          for (; i7 < 5; ++i7) {
            if (this.pos >= this.len)
              throw indexOutOfRange2(this);
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i7 * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        }
        throw Error("invalid varint encoding");
      }
      Reader.prototype.bool = function read_bool() {
        return this.uint32() !== 0;
      };
      function readFixed32_end(buf3, end) {
        return (buf3[end - 4] | buf3[end - 3] << 8 | buf3[end - 2] << 16 | buf3[end - 1] << 24) >>> 0;
      }
      Reader.prototype.fixed32 = function read_fixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange2(this, 4);
        return readFixed32_end(this.buf, this.pos += 4);
      };
      Reader.prototype.sfixed32 = function read_sfixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange2(this, 4);
        return readFixed32_end(this.buf, this.pos += 4) | 0;
      };
      function readFixed64() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange2(this, 8);
        return new LongBits2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
      }
      Reader.prototype.float = function read_float() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange2(this, 4);
        var value = util.float.readFloatLE(this.buf, this.pos);
        this.pos += 4;
        return value;
      };
      Reader.prototype.double = function read_double() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange2(this, 4);
        var value = util.float.readDoubleLE(this.buf, this.pos);
        this.pos += 8;
        return value;
      };
      Reader.prototype.bytes = function read_bytes() {
        var length4 = this.uint32(), start = this.pos, end = this.pos + length4;
        if (end > this.len)
          throw indexOutOfRange2(this, length4);
        this.pos += length4;
        if (Array.isArray(this.buf))
          return this.buf.slice(start, end);
        if (start === end) {
          var nativeBuffer = util.Buffer;
          return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
        }
        return this._slice.call(this.buf, start, end);
      };
      Reader.prototype.string = function read_string() {
        var bytes = this.bytes();
        return utf84.read(bytes, 0, bytes.length);
      };
      Reader.prototype.skip = function skip(length4) {
        if (typeof length4 === "number") {
          if (this.pos + length4 > this.len)
            throw indexOutOfRange2(this, length4);
          this.pos += length4;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange2(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      };
      Reader.prototype.skipType = function(wireType) {
        switch (wireType) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case 5:
            this.skip(4);
            break;
          /* istanbul ignore next */
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      };
      Reader._configure = function(BufferReader_) {
        BufferReader = BufferReader_;
        Reader.create = create16();
        BufferReader._configure();
        var fn = util.Long ? "toLong" : (
          /* istanbul ignore next */
          "toNumber"
        );
        util.merge(Reader.prototype, {
          int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
          },
          uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
          },
          sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
          },
          fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
          },
          sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
          }
        });
      };
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/reader_buffer.js
  var require_reader_buffer = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/reader_buffer.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = BufferReader;
      var Reader = require_reader();
      (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
      var util = require_minimal();
      function BufferReader(buffer4) {
        Reader.call(this, buffer4);
      }
      BufferReader._configure = function() {
        if (util.Buffer)
          BufferReader.prototype._slice = util.Buffer.prototype.slice;
      };
      BufferReader.prototype.string = function read_string_buffer() {
        var len = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
      };
      BufferReader._configure();
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/rpc/service.js
  var require_service = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/rpc/service.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = Service;
      var util = require_minimal();
      (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
      function Service(rpcImpl, requestDelimited, responseDelimited) {
        if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");
        util.EventEmitter.call(this);
        this.rpcImpl = rpcImpl;
        this.requestDelimited = Boolean(requestDelimited);
        this.responseDelimited = Boolean(responseDelimited);
      }
      Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
        if (!request)
          throw TypeError("request must be specified");
        var self2 = this;
        if (!callback)
          return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
        if (!self2.rpcImpl) {
          setTimeout(function() {
            callback(Error("already ended"));
          }, 0);
          return void 0;
        }
        try {
          return self2.rpcImpl(
            method,
            requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {
              if (err) {
                self2.emit("error", err, method);
                return callback(err);
              }
              if (response === null) {
                self2.end(
                  /* endedByRPC */
                  true
                );
                return void 0;
              }
              if (!(response instanceof responseCtor)) {
                try {
                  response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err2) {
                  self2.emit("error", err2, method);
                  return callback(err2);
                }
              }
              self2.emit("data", response, method);
              return callback(null, response);
            }
          );
        } catch (err) {
          self2.emit("error", err, method);
          setTimeout(function() {
            callback(err);
          }, 0);
          return void 0;
        }
      };
      Service.prototype.end = function end(endedByRPC) {
        if (this.rpcImpl) {
          if (!endedByRPC)
            this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
        }
        return this;
      };
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/rpc.js
  var require_rpc = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/rpc.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var rpc = exports9;
      rpc.Service = require_service();
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/roots.js
  var require_roots = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/roots.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = {};
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/index-minimal.js
  var require_index_minimal = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/src/index-minimal.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var protobuf = exports9;
      protobuf.build = "minimal";
      protobuf.Writer = require_writer();
      protobuf.BufferWriter = require_writer_buffer();
      protobuf.Reader = require_reader();
      protobuf.BufferReader = require_reader_buffer();
      protobuf.util = require_minimal();
      protobuf.rpc = require_rpc();
      protobuf.roots = require_roots();
      protobuf.configure = configure6;
      function configure6() {
        protobuf.util._configure();
        protobuf.Writer._configure(protobuf.BufferWriter);
        protobuf.Reader._configure(protobuf.BufferReader);
      }
      configure6();
    }
  });

  // node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/minimal.js
  var require_minimal2 = __commonJS({
    "node_modules/.pnpm/protobufjs@7.3.2/node_modules/protobufjs/minimal.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = require_index_minimal();
    }
  });

  // node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
  var require_murmurHash3js = __commonJS({
    "node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      (function(root2, undefined2) {
        "use strict";
        var library = {
          "version": "3.0.0",
          "x86": {},
          "x64": {},
          "inputValidation": true
        };
        function _validBytes(bytes) {
          if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
            return false;
          }
          for (var i7 = 0; i7 < bytes.length; i7++) {
            if (!Number.isInteger(bytes[i7]) || bytes[i7] < 0 || bytes[i7] > 255) {
              return false;
            }
          }
          return true;
        }
        function _x86Multiply(m6, n8) {
          return (m6 & 65535) * n8 + (((m6 >>> 16) * n8 & 65535) << 16);
        }
        function _x86Rotl(m6, n8) {
          return m6 << n8 | m6 >>> 32 - n8;
        }
        function _x86Fmix(h8) {
          h8 ^= h8 >>> 16;
          h8 = _x86Multiply(h8, 2246822507);
          h8 ^= h8 >>> 13;
          h8 = _x86Multiply(h8, 3266489909);
          h8 ^= h8 >>> 16;
          return h8;
        }
        function _x64Add(m6, n8) {
          m6 = [m6[0] >>> 16, m6[0] & 65535, m6[1] >>> 16, m6[1] & 65535];
          n8 = [n8[0] >>> 16, n8[0] & 65535, n8[1] >>> 16, n8[1] & 65535];
          var o8 = [0, 0, 0, 0];
          o8[3] += m6[3] + n8[3];
          o8[2] += o8[3] >>> 16;
          o8[3] &= 65535;
          o8[2] += m6[2] + n8[2];
          o8[1] += o8[2] >>> 16;
          o8[2] &= 65535;
          o8[1] += m6[1] + n8[1];
          o8[0] += o8[1] >>> 16;
          o8[1] &= 65535;
          o8[0] += m6[0] + n8[0];
          o8[0] &= 65535;
          return [o8[0] << 16 | o8[1], o8[2] << 16 | o8[3]];
        }
        function _x64Multiply(m6, n8) {
          m6 = [m6[0] >>> 16, m6[0] & 65535, m6[1] >>> 16, m6[1] & 65535];
          n8 = [n8[0] >>> 16, n8[0] & 65535, n8[1] >>> 16, n8[1] & 65535];
          var o8 = [0, 0, 0, 0];
          o8[3] += m6[3] * n8[3];
          o8[2] += o8[3] >>> 16;
          o8[3] &= 65535;
          o8[2] += m6[2] * n8[3];
          o8[1] += o8[2] >>> 16;
          o8[2] &= 65535;
          o8[2] += m6[3] * n8[2];
          o8[1] += o8[2] >>> 16;
          o8[2] &= 65535;
          o8[1] += m6[1] * n8[3];
          o8[0] += o8[1] >>> 16;
          o8[1] &= 65535;
          o8[1] += m6[2] * n8[2];
          o8[0] += o8[1] >>> 16;
          o8[1] &= 65535;
          o8[1] += m6[3] * n8[1];
          o8[0] += o8[1] >>> 16;
          o8[1] &= 65535;
          o8[0] += m6[0] * n8[3] + m6[1] * n8[2] + m6[2] * n8[1] + m6[3] * n8[0];
          o8[0] &= 65535;
          return [o8[0] << 16 | o8[1], o8[2] << 16 | o8[3]];
        }
        function _x64Rotl(m6, n8) {
          n8 %= 64;
          if (n8 === 32) {
            return [m6[1], m6[0]];
          } else if (n8 < 32) {
            return [m6[0] << n8 | m6[1] >>> 32 - n8, m6[1] << n8 | m6[0] >>> 32 - n8];
          } else {
            n8 -= 32;
            return [m6[1] << n8 | m6[0] >>> 32 - n8, m6[0] << n8 | m6[1] >>> 32 - n8];
          }
        }
        function _x64LeftShift(m6, n8) {
          n8 %= 64;
          if (n8 === 0) {
            return m6;
          } else if (n8 < 32) {
            return [m6[0] << n8 | m6[1] >>> 32 - n8, m6[1] << n8];
          } else {
            return [m6[1] << n8 - 32, 0];
          }
        }
        function _x64Xor(m6, n8) {
          return [m6[0] ^ n8[0], m6[1] ^ n8[1]];
        }
        function _x64Fmix(h8) {
          h8 = _x64Xor(h8, [0, h8[0] >>> 1]);
          h8 = _x64Multiply(h8, [4283543511, 3981806797]);
          h8 = _x64Xor(h8, [0, h8[0] >>> 1]);
          h8 = _x64Multiply(h8, [3301882366, 444984403]);
          h8 = _x64Xor(h8, [0, h8[0] >>> 1]);
          return h8;
        }
        library.x86.hash32 = function(bytes, seed) {
          if (library.inputValidation && !_validBytes(bytes)) {
            return undefined2;
          }
          seed = seed || 0;
          var remainder = bytes.length % 4;
          var blocks = bytes.length - remainder;
          var h1 = seed;
          var k1 = 0;
          var c1 = 3432918353;
          var c22 = 461845907;
          for (var i7 = 0; i7 < blocks; i7 = i7 + 4) {
            k1 = bytes[i7] | bytes[i7 + 1] << 8 | bytes[i7 + 2] << 16 | bytes[i7 + 3] << 24;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c22);
            h1 ^= k1;
            h1 = _x86Rotl(h1, 13);
            h1 = _x86Multiply(h1, 5) + 3864292196;
          }
          k1 = 0;
          switch (remainder) {
            case 3:
              k1 ^= bytes[i7 + 2] << 16;
            case 2:
              k1 ^= bytes[i7 + 1] << 8;
            case 1:
              k1 ^= bytes[i7];
              k1 = _x86Multiply(k1, c1);
              k1 = _x86Rotl(k1, 15);
              k1 = _x86Multiply(k1, c22);
              h1 ^= k1;
          }
          h1 ^= bytes.length;
          h1 = _x86Fmix(h1);
          return h1 >>> 0;
        };
        library.x86.hash128 = function(bytes, seed) {
          if (library.inputValidation && !_validBytes(bytes)) {
            return undefined2;
          }
          seed = seed || 0;
          var remainder = bytes.length % 16;
          var blocks = bytes.length - remainder;
          var h1 = seed;
          var h22 = seed;
          var h32 = seed;
          var h42 = seed;
          var k1 = 0;
          var k22 = 0;
          var k32 = 0;
          var k4 = 0;
          var c1 = 597399067;
          var c22 = 2869860233;
          var c32 = 951274213;
          var c42 = 2716044179;
          for (var i7 = 0; i7 < blocks; i7 = i7 + 16) {
            k1 = bytes[i7] | bytes[i7 + 1] << 8 | bytes[i7 + 2] << 16 | bytes[i7 + 3] << 24;
            k22 = bytes[i7 + 4] | bytes[i7 + 5] << 8 | bytes[i7 + 6] << 16 | bytes[i7 + 7] << 24;
            k32 = bytes[i7 + 8] | bytes[i7 + 9] << 8 | bytes[i7 + 10] << 16 | bytes[i7 + 11] << 24;
            k4 = bytes[i7 + 12] | bytes[i7 + 13] << 8 | bytes[i7 + 14] << 16 | bytes[i7 + 15] << 24;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c22);
            h1 ^= k1;
            h1 = _x86Rotl(h1, 19);
            h1 += h22;
            h1 = _x86Multiply(h1, 5) + 1444728091;
            k22 = _x86Multiply(k22, c22);
            k22 = _x86Rotl(k22, 16);
            k22 = _x86Multiply(k22, c32);
            h22 ^= k22;
            h22 = _x86Rotl(h22, 17);
            h22 += h32;
            h22 = _x86Multiply(h22, 5) + 197830471;
            k32 = _x86Multiply(k32, c32);
            k32 = _x86Rotl(k32, 17);
            k32 = _x86Multiply(k32, c42);
            h32 ^= k32;
            h32 = _x86Rotl(h32, 15);
            h32 += h42;
            h32 = _x86Multiply(h32, 5) + 2530024501;
            k4 = _x86Multiply(k4, c42);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h42 ^= k4;
            h42 = _x86Rotl(h42, 13);
            h42 += h1;
            h42 = _x86Multiply(h42, 5) + 850148119;
          }
          k1 = 0;
          k22 = 0;
          k32 = 0;
          k4 = 0;
          switch (remainder) {
            case 15:
              k4 ^= bytes[i7 + 14] << 16;
            case 14:
              k4 ^= bytes[i7 + 13] << 8;
            case 13:
              k4 ^= bytes[i7 + 12];
              k4 = _x86Multiply(k4, c42);
              k4 = _x86Rotl(k4, 18);
              k4 = _x86Multiply(k4, c1);
              h42 ^= k4;
            case 12:
              k32 ^= bytes[i7 + 11] << 24;
            case 11:
              k32 ^= bytes[i7 + 10] << 16;
            case 10:
              k32 ^= bytes[i7 + 9] << 8;
            case 9:
              k32 ^= bytes[i7 + 8];
              k32 = _x86Multiply(k32, c32);
              k32 = _x86Rotl(k32, 17);
              k32 = _x86Multiply(k32, c42);
              h32 ^= k32;
            case 8:
              k22 ^= bytes[i7 + 7] << 24;
            case 7:
              k22 ^= bytes[i7 + 6] << 16;
            case 6:
              k22 ^= bytes[i7 + 5] << 8;
            case 5:
              k22 ^= bytes[i7 + 4];
              k22 = _x86Multiply(k22, c22);
              k22 = _x86Rotl(k22, 16);
              k22 = _x86Multiply(k22, c32);
              h22 ^= k22;
            case 4:
              k1 ^= bytes[i7 + 3] << 24;
            case 3:
              k1 ^= bytes[i7 + 2] << 16;
            case 2:
              k1 ^= bytes[i7 + 1] << 8;
            case 1:
              k1 ^= bytes[i7];
              k1 = _x86Multiply(k1, c1);
              k1 = _x86Rotl(k1, 15);
              k1 = _x86Multiply(k1, c22);
              h1 ^= k1;
          }
          h1 ^= bytes.length;
          h22 ^= bytes.length;
          h32 ^= bytes.length;
          h42 ^= bytes.length;
          h1 += h22;
          h1 += h32;
          h1 += h42;
          h22 += h1;
          h32 += h1;
          h42 += h1;
          h1 = _x86Fmix(h1);
          h22 = _x86Fmix(h22);
          h32 = _x86Fmix(h32);
          h42 = _x86Fmix(h42);
          h1 += h22;
          h1 += h32;
          h1 += h42;
          h22 += h1;
          h32 += h1;
          h42 += h1;
          return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h22 >>> 0).toString(16)).slice(-8) + ("00000000" + (h32 >>> 0).toString(16)).slice(-8) + ("00000000" + (h42 >>> 0).toString(16)).slice(-8);
        };
        library.x64.hash128 = function(bytes, seed) {
          if (library.inputValidation && !_validBytes(bytes)) {
            return undefined2;
          }
          seed = seed || 0;
          var remainder = bytes.length % 16;
          var blocks = bytes.length - remainder;
          var h1 = [0, seed];
          var h22 = [0, seed];
          var k1 = [0, 0];
          var k22 = [0, 0];
          var c1 = [2277735313, 289559509];
          var c22 = [1291169091, 658871167];
          for (var i7 = 0; i7 < blocks; i7 = i7 + 16) {
            k1 = [bytes[i7 + 4] | bytes[i7 + 5] << 8 | bytes[i7 + 6] << 16 | bytes[i7 + 7] << 24, bytes[i7] | bytes[i7 + 1] << 8 | bytes[i7 + 2] << 16 | bytes[i7 + 3] << 24];
            k22 = [bytes[i7 + 12] | bytes[i7 + 13] << 8 | bytes[i7 + 14] << 16 | bytes[i7 + 15] << 24, bytes[i7 + 8] | bytes[i7 + 9] << 8 | bytes[i7 + 10] << 16 | bytes[i7 + 11] << 24];
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c22);
            h1 = _x64Xor(h1, k1);
            h1 = _x64Rotl(h1, 27);
            h1 = _x64Add(h1, h22);
            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
            k22 = _x64Multiply(k22, c22);
            k22 = _x64Rotl(k22, 33);
            k22 = _x64Multiply(k22, c1);
            h22 = _x64Xor(h22, k22);
            h22 = _x64Rotl(h22, 31);
            h22 = _x64Add(h22, h1);
            h22 = _x64Add(_x64Multiply(h22, [0, 5]), [0, 944331445]);
          }
          k1 = [0, 0];
          k22 = [0, 0];
          switch (remainder) {
            case 15:
              k22 = _x64Xor(k22, _x64LeftShift([0, bytes[i7 + 14]], 48));
            case 14:
              k22 = _x64Xor(k22, _x64LeftShift([0, bytes[i7 + 13]], 40));
            case 13:
              k22 = _x64Xor(k22, _x64LeftShift([0, bytes[i7 + 12]], 32));
            case 12:
              k22 = _x64Xor(k22, _x64LeftShift([0, bytes[i7 + 11]], 24));
            case 11:
              k22 = _x64Xor(k22, _x64LeftShift([0, bytes[i7 + 10]], 16));
            case 10:
              k22 = _x64Xor(k22, _x64LeftShift([0, bytes[i7 + 9]], 8));
            case 9:
              k22 = _x64Xor(k22, [0, bytes[i7 + 8]]);
              k22 = _x64Multiply(k22, c22);
              k22 = _x64Rotl(k22, 33);
              k22 = _x64Multiply(k22, c1);
              h22 = _x64Xor(h22, k22);
            case 8:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i7 + 7]], 56));
            case 7:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i7 + 6]], 48));
            case 6:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i7 + 5]], 40));
            case 5:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i7 + 4]], 32));
            case 4:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i7 + 3]], 24));
            case 3:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i7 + 2]], 16));
            case 2:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i7 + 1]], 8));
            case 1:
              k1 = _x64Xor(k1, [0, bytes[i7]]);
              k1 = _x64Multiply(k1, c1);
              k1 = _x64Rotl(k1, 31);
              k1 = _x64Multiply(k1, c22);
              h1 = _x64Xor(h1, k1);
          }
          h1 = _x64Xor(h1, [0, bytes.length]);
          h22 = _x64Xor(h22, [0, bytes.length]);
          h1 = _x64Add(h1, h22);
          h22 = _x64Add(h22, h1);
          h1 = _x64Fmix(h1);
          h22 = _x64Fmix(h22);
          h1 = _x64Add(h1, h22);
          h22 = _x64Add(h22, h1);
          return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h22[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h22[1] >>> 0).toString(16)).slice(-8);
        };
        if (typeof exports9 !== "undefined") {
          if (typeof module2 !== "undefined" && module2.exports) {
            exports9 = module2.exports = library;
          }
          exports9.murmurHash3 = library;
        } else if (typeof define === "function" && define.amd) {
          define([], function() {
            return library;
          });
        } else {
          library._murmurHash3 = root2.murmurHash3;
          library.noConflict = function() {
            root2.murmurHash3 = library._murmurHash3;
            library._murmurHash3 = undefined2;
            library.noConflict = undefined2;
            return library;
          };
          root2.murmurHash3 = library;
        }
      })(exports9);
    }
  });

  // node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js
  var require_murmurhash3js_revisited = __commonJS({
    "node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = require_murmurHash3js();
    }
  });

  // node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js
  var require_err_code = __commonJS({
    "node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      function assign2(obj, props) {
        for (const key in props) {
          Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true
          });
        }
        return obj;
      }
      function createError(err, code9, props) {
        if (!err || typeof err === "string") {
          throw new TypeError("Please pass an Error to err-code");
        }
        if (!props) {
          props = {};
        }
        if (typeof code9 === "object") {
          props = code9;
          code9 = "";
        }
        if (code9) {
          props.code = code9;
        }
        try {
          return assign2(err, props);
        } catch (_4) {
          props.message = err.message;
          props.stack = err.stack;
          const ErrClass = function() {
          };
          ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
          const output = assign2(new ErrClass(), props);
          return output;
        }
      }
      module2.exports = createError;
    }
  });

  // node_modules/.pnpm/sparse-array@1.3.2/node_modules/sparse-array/index.js
  var require_sparse_array = __commonJS({
    "node_modules/.pnpm/sparse-array@1.3.2/node_modules/sparse-array/index.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var BITS_PER_BYTE = 7;
      module2.exports = class SparseArray {
        constructor() {
          this._bitArrays = [];
          this._data = [];
          this._length = 0;
          this._changedLength = false;
          this._changedData = false;
        }
        set(index2, value) {
          let pos = this._internalPositionFor(index2, false);
          if (value === void 0) {
            if (pos !== -1) {
              this._unsetInternalPos(pos);
              this._unsetBit(index2);
              this._changedLength = true;
              this._changedData = true;
            }
          } else {
            let needsSort = false;
            if (pos === -1) {
              pos = this._data.length;
              this._setBit(index2);
              this._changedData = true;
            } else {
              needsSort = true;
            }
            this._setInternalPos(pos, index2, value, needsSort);
            this._changedLength = true;
          }
        }
        unset(index2) {
          this.set(index2, void 0);
        }
        get(index2) {
          this._sortData();
          const pos = this._internalPositionFor(index2, true);
          if (pos === -1) {
            return void 0;
          }
          return this._data[pos][1];
        }
        push(value) {
          this.set(this.length, value);
          return this.length;
        }
        get length() {
          this._sortData();
          if (this._changedLength) {
            const last2 = this._data[this._data.length - 1];
            this._length = last2 ? last2[0] + 1 : 0;
            this._changedLength = false;
          }
          return this._length;
        }
        forEach(iterator) {
          let i7 = 0;
          while (i7 < this.length) {
            iterator(this.get(i7), i7, this);
            i7++;
          }
        }
        map(iterator) {
          let i7 = 0;
          let mapped = new Array(this.length);
          while (i7 < this.length) {
            mapped[i7] = iterator(this.get(i7), i7, this);
            i7++;
          }
          return mapped;
        }
        reduce(reducer, initialValue) {
          let i7 = 0;
          let acc = initialValue;
          while (i7 < this.length) {
            const value = this.get(i7);
            acc = reducer(acc, value, i7);
            i7++;
          }
          return acc;
        }
        find(finder) {
          let i7 = 0, found, last2;
          while (i7 < this.length && !found) {
            last2 = this.get(i7);
            found = finder(last2);
            i7++;
          }
          return found ? last2 : void 0;
        }
        _internalPositionFor(index2, noCreate) {
          const bytePos = this._bytePosFor(index2, noCreate);
          if (bytePos >= this._bitArrays.length) {
            return -1;
          }
          const byte = this._bitArrays[bytePos];
          const bitPos = index2 - bytePos * BITS_PER_BYTE;
          const exists3 = (byte & 1 << bitPos) > 0;
          if (!exists3) {
            return -1;
          }
          const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
          const mask = ~(4294967295 << bitPos + 1);
          const bytePopCount = popCount(byte & mask);
          const arrayPos = previousPopCount + bytePopCount - 1;
          return arrayPos;
        }
        _bytePosFor(index2, noCreate) {
          const bytePos = Math.floor(index2 / BITS_PER_BYTE);
          const targetLength = bytePos + 1;
          while (!noCreate && this._bitArrays.length < targetLength) {
            this._bitArrays.push(0);
          }
          return bytePos;
        }
        _setBit(index2) {
          const bytePos = this._bytePosFor(index2, false);
          this._bitArrays[bytePos] |= 1 << index2 - bytePos * BITS_PER_BYTE;
        }
        _unsetBit(index2) {
          const bytePos = this._bytePosFor(index2, false);
          this._bitArrays[bytePos] &= ~(1 << index2 - bytePos * BITS_PER_BYTE);
        }
        _setInternalPos(pos, index2, value, needsSort) {
          const data = this._data;
          const elem = [index2, value];
          if (needsSort) {
            this._sortData();
            data[pos] = elem;
          } else {
            if (data.length) {
              if (data[data.length - 1][0] >= index2) {
                data.push(elem);
              } else if (data[0][0] <= index2) {
                data.unshift(elem);
              } else {
                const randomIndex = Math.round(data.length / 2);
                this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
              }
            } else {
              this._data.push(elem);
            }
            this._changedData = true;
            this._changedLength = true;
          }
        }
        _unsetInternalPos(pos) {
          this._data.splice(pos, 1);
        }
        _sortData() {
          if (this._changedData) {
            this._data.sort(sortInternal);
          }
          this._changedData = false;
        }
        bitField() {
          const bytes = [];
          let pendingBitsForResultingByte = 8;
          let pendingBitsForNewByte = 0;
          let resultingByte = 0;
          let newByte;
          const pending = this._bitArrays.slice();
          while (pending.length || pendingBitsForNewByte) {
            if (pendingBitsForNewByte === 0) {
              newByte = pending.shift();
              pendingBitsForNewByte = 7;
            }
            const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
            const mask = ~(255 << usingBits);
            const masked = newByte & mask;
            resultingByte |= masked << 8 - pendingBitsForResultingByte;
            newByte = newByte >>> usingBits;
            pendingBitsForNewByte -= usingBits;
            pendingBitsForResultingByte -= usingBits;
            if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
              bytes.push(resultingByte);
              resultingByte = 0;
              pendingBitsForResultingByte = 8;
            }
          }
          for (var i7 = bytes.length - 1; i7 > 0; i7--) {
            const value = bytes[i7];
            if (value === 0) {
              bytes.pop();
            } else {
              break;
            }
          }
          return bytes;
        }
        compactArray() {
          this._sortData();
          return this._data.map(valueOnly);
        }
      };
      function popCountReduce(count, byte) {
        return count + popCount(byte);
      }
      function popCount(_v) {
        let v6 = _v;
        v6 = v6 - (v6 >> 1 & 1431655765);
        v6 = (v6 & 858993459) + (v6 >> 2 & 858993459);
        return (v6 + (v6 >> 4) & 252645135) * 16843009 >> 24;
      }
      function sortInternal(a7, b5) {
        return a7[0] - b5[0];
      }
      function valueOnly(elem) {
        return elem[1];
      }
    }
  });

  // node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var has2 = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events2() {
      }
      if (Object.create) {
        Events2.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events2().__proto__) prefix = false;
      }
      function EE(fn, context2, once3) {
        this.fn = fn;
        this.context = context2;
        this.once = once3 || false;
      }
      function addListener2(emitter, event, fn, context2, once3) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context2 || emitter, once3), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events2();
        else delete emitter._events[evt];
      }
      function EventEmitter3() {
        this._events = new Events2();
        this._eventsCount = 0;
      }
      EventEmitter3.prototype.eventNames = function eventNames() {
        var names = [], events, name8;
        if (this._eventsCount === 0) return names;
        for (name8 in events = this._events) {
          if (has2.call(events, name8)) names.push(prefix ? name8.slice(1) : name8);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter3.prototype.listeners = function listeners2(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i7 = 0, l7 = handlers.length, ee2 = new Array(l7); i7 < l7; i7++) {
          ee2[i7] = handlers[i7].fn;
        }
        return ee2;
      };
      EventEmitter3.prototype.listenerCount = function listenerCount2(event) {
        var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
        if (!listeners2) return 0;
        if (listeners2.fn) return 1;
        return listeners2.length;
      };
      EventEmitter3.prototype.emit = function emit2(event, a1, a22, a32, a42, a52) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners2 = this._events[evt], len = arguments.length, args, i7;
        if (listeners2.fn) {
          if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners2.fn.call(listeners2.context), true;
            case 2:
              return listeners2.fn.call(listeners2.context, a1), true;
            case 3:
              return listeners2.fn.call(listeners2.context, a1, a22), true;
            case 4:
              return listeners2.fn.call(listeners2.context, a1, a22, a32), true;
            case 5:
              return listeners2.fn.call(listeners2.context, a1, a22, a32, a42), true;
            case 6:
              return listeners2.fn.call(listeners2.context, a1, a22, a32, a42, a52), true;
          }
          for (i7 = 1, args = new Array(len - 1); i7 < len; i7++) {
            args[i7 - 1] = arguments[i7];
          }
          listeners2.fn.apply(listeners2.context, args);
        } else {
          var length4 = listeners2.length, j4;
          for (i7 = 0; i7 < length4; i7++) {
            if (listeners2[i7].once) this.removeListener(event, listeners2[i7].fn, void 0, true);
            switch (len) {
              case 1:
                listeners2[i7].fn.call(listeners2[i7].context);
                break;
              case 2:
                listeners2[i7].fn.call(listeners2[i7].context, a1);
                break;
              case 3:
                listeners2[i7].fn.call(listeners2[i7].context, a1, a22);
                break;
              case 4:
                listeners2[i7].fn.call(listeners2[i7].context, a1, a22, a32);
                break;
              default:
                if (!args) for (j4 = 1, args = new Array(len - 1); j4 < len; j4++) {
                  args[j4 - 1] = arguments[j4];
                }
                listeners2[i7].fn.apply(listeners2[i7].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter3.prototype.on = function on3(event, fn, context2) {
        return addListener2(this, event, fn, context2, false);
      };
      EventEmitter3.prototype.once = function once3(event, fn, context2) {
        return addListener2(this, event, fn, context2, true);
      };
      EventEmitter3.prototype.removeListener = function removeListener2(event, fn, context2, once3) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners2 = this._events[evt];
        if (listeners2.fn) {
          if (listeners2.fn === fn && (!once3 || listeners2.once) && (!context2 || listeners2.context === context2)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i7 = 0, events = [], length4 = listeners2.length; i7 < length4; i7++) {
            if (listeners2[i7].fn !== fn || once3 && !listeners2[i7].once || context2 && listeners2[i7].context !== context2) {
              events.push(listeners2[i7]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter3.prototype.removeAllListeners = function removeAllListeners2(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events2();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
      EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
      EventEmitter3.prefixed = prefix;
      EventEmitter3.EventEmitter = EventEmitter3;
      if ("undefined" !== typeof module2) {
        module2.exports = EventEmitter3;
      }
    }
  });

  // node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js
  var require_encode = __commonJS({
    "node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = encode18;
      var MSB4 = 128;
      var REST4 = 127;
      var MSBALL3 = ~REST4;
      var INT3 = Math.pow(2, 31);
      function encode18(num, out, offset) {
        if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
          encode18.bytes = 0;
          throw new RangeError("Could not encode varint");
        }
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT3) {
          out[offset++] = num & 255 | MSB4;
          num /= 128;
        }
        while (num & MSBALL3) {
          out[offset++] = num & 255 | MSB4;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode18.bytes = offset - oldOffset + 1;
        return out;
      }
    }
  });

  // node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js
  var require_decode = __commonJS({
    "node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = read6;
      var MSB4 = 128;
      var REST4 = 127;
      function read6(buf3, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b5, l7 = buf3.length;
        do {
          if (counter >= l7 || shift > 49) {
            read6.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b5 = buf3[counter++];
          res += shift < 28 ? (b5 & REST4) << shift : (b5 & REST4) * Math.pow(2, shift);
          shift += 7;
        } while (b5 >= MSB4);
        read6.bytes = counter - offset;
        return res;
      }
    }
  });

  // node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js
  var require_length = __commonJS({
    "node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var N14 = Math.pow(2, 7);
      var N25 = Math.pow(2, 14);
      var N35 = Math.pow(2, 21);
      var N44 = Math.pow(2, 28);
      var N54 = Math.pow(2, 35);
      var N64 = Math.pow(2, 42);
      var N74 = Math.pow(2, 49);
      var N83 = Math.pow(2, 56);
      var N93 = Math.pow(2, 63);
      module2.exports = function(value) {
        return value < N14 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
      };
    }
  });

  // node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js
  var require_varint = __commonJS({
    "node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = {
        encode: require_encode(),
        decode: require_decode(),
        encodingLength: require_length()
      };
    }
  });

  // node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/number.js
  var require_number = __commonJS({
    "node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/number.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      exports9.encode = function(number) {
        if (isNaN(number)) {
          return "DaN";
        }
        if (number === 0) {
          return "FE  0M0";
        }
        if (number === Infinity) {
          return "FF";
        }
        if (number === -Infinity) {
          return "DD";
        }
        var splitScientificNotation = number.toExponential().split("e");
        var exponent = Number(splitScientificNotation[1]) + 500;
        var mantissa = splitScientificNotation[0] + (splitScientificNotation[0].indexOf(".") === -1 ? "." : "") + "0".repeat(20);
        var encoded = "E" + padStart(String(exponent), 3) + "M" + String(mantissa);
        if (number > 0) {
          return "F" + encoded;
        } else {
          return "D" + flip(encoded);
        }
      };
      exports9.decode = function(encoded) {
        if (encoded === "DaN") {
          return NaN;
        }
        if (encoded === "FF") {
          return Infinity;
        }
        if (encoded === "DD") {
          return -Infinity;
        }
        var isNegative = encoded[0] === "D";
        var splitEncoded = (isNegative ? flip(encoded) : encoded).slice(2).split("M");
        return Number((isNegative ? "-" : "") + splitEncoded[1] + "e" + String(Number(splitEncoded[0]) - 500));
      };
      function flip(number) {
        var flipped = "";
        for (var i7 = 0; i7 < number.length; i7++) {
          var digit = number[i7];
          if (isNaN(Number(digit)) || digit === " ") {
            if (digit !== "-") {
              flipped += digit;
            }
          } else {
            flipped += String(9 - Number(digit));
          }
        }
        return flipped;
      }
      function padStart(str, count) {
        return " ".repeat(count - str.length).substr(0, count) + str;
      }
    }
  });

  // node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/object.js
  var require_object = __commonJS({
    "node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/object.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var dictEscape = { "?": "?@", "!": "??", '"': "?%" };
      function escape2(str) {
        if (!/[!"]/.test(str)) {
          return str;
        }
        return str.replace(/[\?!"]/g, function(match) {
          return dictEscape[match];
        });
      }
      var dictUnescape = { "?@": "?", "??": "!", "?%": '"' };
      function unescape(str) {
        if (!/\?[%\?@]/.test(str)) {
          return str;
        }
        return str.replace(/\?[%\?@]/g, function(match) {
          return dictUnescape[match];
        });
      }
      exports9.factory = function(codec) {
        return {
          encode: encode18,
          decode: decode21
        };
        function encode18(array) {
          if (array === null) {
            return "A";
          }
          if (!Array.isArray(array)) {
            throw new Error("can only encode arrays");
          }
          var l7 = array.length;
          if (l7 == 0) {
            return "K!";
          }
          var s6 = encodeItem(array[0]);
          for (var i7 = 1; i7 < l7; i7++) {
            s6 += '"' + encodeItem(array[i7]);
          }
          return "K" + s6 + "!";
        }
        function encodeItem(item) {
          if (typeof item === "object") {
            return encode18(item);
          }
          return escape2(codec.encode(item));
        }
        function decode21(encoded) {
          if (encoded === "A") {
            return null;
          }
          if (encoded === "K!") {
            return [];
          }
          var items = encoded.split('"');
          var pointers = [[]];
          var array;
          var depth = 0;
          var l7 = items.length;
          for (var i7 = 0; i7 < l7; i7++) {
            var item = items[i7];
            var itemLength = item.length;
            var open5 = 0;
            while (item[open5] == "K") {
              open5++;
            }
            var close10 = 0;
            while (item[itemLength - close10 - 1] == "!") {
              close10++;
            }
            var content = item.slice(open5, itemLength - close10);
            var newdepth = depth + open5;
            for (var j4 = depth; j4 < newdepth; j4++) {
              pointers[j4 + 1] = [];
              pointers[j4].push(pointers[j4 + 1]);
              depth = newdepth;
              array = pointers[depth];
            }
            if (content.length !== 0) {
              array.push(codec.decode(unescape(content)));
            }
            var newdepth = depth - close10;
            for (var j4 = newdepth; j4 < depth; j4++) {
              pointers[j4 + 1] = [];
              depth = newdepth;
              array = pointers[depth];
            }
          }
          return pointers[0][0];
        }
      };
    }
  });

  // node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/index.js
  var require_charwise = __commonJS({
    "node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/index.js"(exports9) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var number = require_number();
      var object = require_object();
      var flip = exports9.flip = function(n8) {
        var s6 = n8.toString();
        var f7 = "";
        for (var i7 in s6) {
          f7 += s6[i7] == "." ? "." : 9 - +s6[i7];
        }
        return f7;
      };
      exports9.number = number;
      exports9.string = {
        encode: function(s6) {
          if (!/\x00|\x01/.test(s6))
            return "J" + s6;
          else {
            return "J" + s6.replace(/\x01/g, "").replace(/\x00/g, "");
          }
        },
        decode: function(s6) {
          if ("J" === s6[0])
            return s6.substring(1);
        }
      };
      exports9.encode = function(t8) {
        return exports9[typeof t8].encode(t8);
      };
      exports9.decode = function(s6) {
        if (s6 === "") return s6;
        if (!decoders[s6[0]])
          throw new Error("no decoder for:" + JSON.stringify(s6));
        return decoders[s6[0]](s6);
      };
      exports9.object = object.factory(exports9);
      exports9.boolean = {
        encode: function(b5) {
          return b5 ? "C" : "B";
        },
        decode: function(b5) {
          return "C" === b5;
        }
      };
      exports9.undefined = {
        encode: function(b5) {
          return "L";
        },
        decode: function() {
          return void 0;
        }
      };
      var decoders = {
        A: exports9.object.decode,
        //null
        B: exports9.boolean.decode,
        // false
        C: exports9.boolean.decode,
        // true
        D: exports9.number.decode,
        // number
        F: exports9.number.decode,
        // number
        // G Date
        // H Date
        // I Buffer
        J: exports9.string.decode,
        // String
        K: exports9.object.decode,
        // Array
        L: exports9.undefined.decode
        // undefined
      };
      exports9.buffer = false;
      exports9.type = "charwise";
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/utils-AISQB3PB.js
  var utils_AISQB3PB_exports = {};
  __export(utils_AISQB3PB_exports, {
    getFileName: () => getFileName,
    getFileSystem: () => getFileSystem,
    getPath: () => getPath,
    toArrayBuffer: () => toArrayBuffer
  });
  var init_utils_AISQB3PB = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/utils-AISQB3PB.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_XINRLWR3();
      init_chunk_MAK4D54P();
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/key-bag-file-DFMW6ZM6.js
  var key_bag_file_DFMW6ZM6_exports = {};
  __export(key_bag_file_DFMW6ZM6_exports, {
    KeyBagProviderFile: () => KeyBagProviderFile
  });
  var KeyBagProviderFile;
  var init_key_bag_file_DFMW6ZM6 = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/key-bag-file-DFMW6ZM6.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_MAK4D54P();
      KeyBagProviderFile = class {
        async _prepare(id) {
          await this.sthis.start();
          let sysFS;
          switch (this.url.protocol) {
            case "file:": {
              const { getFileSystem: getFileSystem2 } = await Promise.resolve().then(() => (init_utils_AISQB3PB(), utils_AISQB3PB_exports));
              sysFS = await getFileSystem2(this.url);
              break;
            }
            default:
              throw this.logger.Error().Url(this.url).Msg("unsupported protocol").AsError();
          }
          const dirName = this.url.pathname;
          await sysFS.mkdir(dirName, { recursive: true });
          return {
            dirName,
            sysFS,
            fName: this.sthis.pathOps.join(dirName, `${id.replace(/[^a-zA-Z0-9]/g, "_")}.json`)
          };
        }
        constructor(url, sthis) {
          this.url = url;
          this.sthis = sthis;
          this.logger = sthis.logger;
        }
        async get(id) {
          const ctx = await this._prepare(id);
          try {
            const p7 = await ctx.sysFS.readfile(ctx.fName);
            const ki = JSON.parse(this.sthis.txt.decode(p7));
            return ki;
          } catch (e9) {
            if (isNotFoundError(e9)) {
              return void 0;
            }
            throw this.logger.Error().Err(e9).Str("file", ctx.dirName).Msg("read bag failed").AsError();
          }
        }
        async set(id, item) {
          const ctx = await this._prepare(id);
          const p7 = this.sthis.txt.encode(JSON.stringify(item, null, 2));
          await ctx.sysFS.writefile(ctx.fName, p7);
        }
      };
    }
  });

  // node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js
  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
      IDBDatabase,
      IDBObjectStore,
      IDBIndex,
      IDBCursor,
      IDBTransaction
    ]);
  }
  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ]);
  }
  function promisifyRequest(request) {
    const promise = new Promise((resolve9, reject) => {
      const unlisten = () => {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      };
      const success = () => {
        resolve9(wrap(request.result));
        unlisten();
      };
      const error = () => {
        reject(request.error);
        unlisten();
      };
      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    reverseTransformCache.set(promise, request);
    return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx))
      return;
    const done = new Promise((resolve9, reject) => {
      const unlisten = () => {
        tx.removeEventListener("complete", complete);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      };
      const complete = () => {
        resolve9();
        unlisten();
      };
      const error = () => {
        reject(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      };
      tx.addEventListener("complete", complete);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }
  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
    if (getCursorAdvanceMethods().includes(func)) {
      return function(...args) {
        func.apply(unwrap(this), args);
        return wrap(this.request);
      };
    }
    return function(...args) {
      return wrap(func.apply(unwrap(this), args));
    };
  }
  function transformCachableValue(value) {
    if (typeof value === "function")
      return wrapFunction(value);
    if (value instanceof IDBTransaction)
      cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
      return new Proxy(value, idbProxyTraps);
    return value;
  }
  function wrap(value) {
    if (value instanceof IDBRequest)
      return promisifyRequest(value);
    if (transformCache.has(value))
      return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }
    return newValue;
  }
  function openDB(name8, version2, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name8, version2);
    const openPromise = wrap(request);
    if (upgrade) {
      request.addEventListener("upgradeneeded", (event) => {
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
      });
    }
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion,
        event.newVersion,
        event
      ));
    }
    openPromise.then((db) => {
      if (terminated)
        db.addEventListener("close", () => terminated());
      if (blocking) {
        db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
      }
    }).catch(() => {
    });
    return openPromise;
  }
  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }
    if (cachedMethods.get(prop))
      return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
    ) {
      return;
    }
    const method = async function(storeName, ...args) {
      const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
      let target2 = tx.store;
      if (useIndex)
        target2 = target2.index(args.shift());
      return (await Promise.all([
        target2[targetFuncName](...args),
        isWrite && tx.done
      ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
  }
  async function* iterate3(...args) {
    let cursor = this;
    if (!(cursor instanceof IDBCursor)) {
      cursor = await cursor.openCursor(...args);
    }
    if (!cursor)
      return;
    cursor = cursor;
    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
    reverseTransformCache.set(proxiedCursor, unwrap(cursor));
    while (cursor) {
      yield proxiedCursor;
      cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
      advanceResults.delete(proxiedCursor);
    }
  }
  function isIteratorProp(target, prop) {
    return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
  }
  var instanceOfAny, idbProxyableTypes, cursorAdvanceMethods, transactionDoneMap, transformCache, reverseTransformCache, idbProxyTraps, unwrap, readMethods, writeMethods, cachedMethods, advanceMethodProps, methodMap, advanceResults, ittrProxiedCursorToOriginalProxy, cursorIteratorTraps;
  var init_build = __esm({
    "node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      instanceOfAny = (object, constructors) => constructors.some((c7) => object instanceof c7);
      transactionDoneMap = /* @__PURE__ */ new WeakMap();
      transformCache = /* @__PURE__ */ new WeakMap();
      reverseTransformCache = /* @__PURE__ */ new WeakMap();
      idbProxyTraps = {
        get(target, prop, receiver) {
          if (target instanceof IDBTransaction) {
            if (prop === "done")
              return transactionDoneMap.get(target);
            if (prop === "store") {
              return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
            }
          }
          return wrap(target[prop]);
        },
        set(target, prop, value) {
          target[prop] = value;
          return true;
        },
        has(target, prop) {
          if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
            return true;
          }
          return prop in target;
        }
      };
      unwrap = (value) => reverseTransformCache.get(value);
      readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
      writeMethods = ["put", "add", "delete", "clear"];
      cachedMethods = /* @__PURE__ */ new Map();
      replaceTraps((oldTraps) => ({
        ...oldTraps,
        get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
        has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
      }));
      advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
      methodMap = {};
      advanceResults = /* @__PURE__ */ new WeakMap();
      ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
      cursorIteratorTraps = {
        get(target, prop) {
          if (!advanceMethodProps.includes(prop))
            return target[prop];
          let cachedFunc = methodMap[prop];
          if (!cachedFunc) {
            cachedFunc = methodMap[prop] = function(...args) {
              advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
            };
          }
          return cachedFunc;
        }
      };
      replaceTraps((oldTraps) => ({
        ...oldTraps,
        get(target, prop, receiver) {
          if (isIteratorProp(target, prop))
            return iterate3;
          return oldTraps.get(target, prop, receiver);
        },
        has(target, prop) {
          return isIteratorProp(target, prop) || oldTraps.has(target, prop);
        }
      }));
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/key-bag-indexdb-R2RWGSQ4.js
  var key_bag_indexdb_R2RWGSQ4_exports = {};
  __export(key_bag_indexdb_R2RWGSQ4_exports, {
    KeyBagProviderIndexDB: () => KeyBagProviderIndexDB
  });
  var KeyBagProviderIndexDB;
  var init_key_bag_indexdb_R2RWGSQ4 = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/key-bag-indexdb-R2RWGSQ4.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_XINRLWR3();
      init_chunk_MAK4D54P();
      init_build();
      init_cement();
      KeyBagProviderIndexDB = class {
        constructor(url, sthis) {
          this._db = new ResolveOnce();
          this.sthis = sthis;
          this.logger = sthis.logger;
          this.url = url;
          this.dbName = getPath(this.url, this.sthis);
        }
        async _prepare() {
          return this._db.once(async () => {
            return await openDB(this.dbName, 1, {
              upgrade(db) {
                ["bag"].map((store) => {
                  db.createObjectStore(store, {
                    autoIncrement: false
                  });
                });
              }
            });
          });
        }
        async get(id) {
          const db = await this._prepare();
          const tx = db.transaction(["bag"], "readonly");
          const keyItem = await tx.objectStore("bag").get(id);
          await tx.done;
          if (!keyItem) {
            return void 0;
          }
          return keyItem;
        }
        async set(id, item) {
          const db = await this._prepare();
          const tx = db.transaction(["bag"], "readwrite");
          await tx.objectStore("bag").put(item, id);
          await tx.done;
        }
      };
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/gateway-VWWKLHUI.js
  var gateway_VWWKLHUI_exports = {};
  __export(gateway_VWWKLHUI_exports, {
    FileGateway: () => FileGateway,
    FileTestStore: () => FileTestStore
  });
  var versionFiles, FileGateway, FileTestStore;
  var init_gateway_VWWKLHUI = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/gateway-VWWKLHUI.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_7EWIAXTM();
      init_chunk_XINRLWR3();
      init_chunk_MAK4D54P();
      init_cement();
      versionFiles = new KeyedResolvOnce();
      FileGateway = class {
        get fs() {
          if (!this._fs) throw this.logger.Error().Msg("fs not initialized").AsError();
          return this._fs;
        }
        constructor(sthis) {
          this.sthis = sthis;
          this.logger = sthis.logger;
        }
        async getVersionFromFile(path2, logger) {
          return versionFiles.get(path2).once(async () => {
            await this.fs.mkdir(path2, { recursive: true });
            const vFile = this.sthis.pathOps.join(path2, "version");
            const vFileStat = await this.fs.stat(vFile).catch(() => void 0);
            if (!vFileStat) {
              await this.fs.writefile(this.sthis.pathOps.join(path2, "version"), FILESTORE_VERSION);
              return FILESTORE_VERSION;
            } else if (!vFileStat.isFile()) {
              throw logger.Error().Str("file", vFile).Msg(`version file is a directory`).AsError();
            }
            const v6 = await this.fs.readfile(vFile);
            const vStr = new TextDecoder().decode(v6);
            if (vStr !== FILESTORE_VERSION) {
              logger.Warn().Str("file", vFile).Str("from", vStr).Str("expected", FILESTORE_VERSION).Msg(`version mismatch`);
            }
            return vStr;
          });
        }
        start(baseURL) {
          return exception2Result(async () => {
            this._fs = await getFileSystem(baseURL);
            await this.fs.start();
            const url = baseURL.build();
            url.defParam("version", FILESTORE_VERSION);
            const dbUrl = await this.buildUrl(url.URI(), "dummy");
            const dbdirFile = this.getFilePath(dbUrl.Ok());
            await this.fs.mkdir(this.sthis.pathOps.dirname(dbdirFile), { recursive: true });
            const dbroot = this.sthis.pathOps.dirname(dbdirFile);
            this.logger.Debug().Url(url.URI()).Str("dbroot", dbroot).Msg("start");
            url.setParam("version", await this.getVersionFromFile(dbroot, this.logger));
            return url.URI();
          });
        }
        async buildUrl(baseUrl, key) {
          return Result.Ok(baseUrl.build().setParam("key", key).URI());
        }
        async close() {
          return Result.Ok(void 0);
        }
        // abstract buildUrl(baseUrl: URL, key: string): Promise<Result<URL>>;
        getFilePath(url) {
          const key = url.getParam("key");
          if (!key) throw this.logger.Error().Url(url).Msg(`key not found`).AsError();
          return this.sthis.pathOps.join(getPath(url, this.sthis), getFileName(url, this.sthis));
        }
        async put(url, body) {
          return exception2Result(async () => {
            const file = await this.getFilePath(url);
            this.logger.Debug().Str("url", url.toString()).Str("file", file).Msg("put");
            await this.fs.writefile(file, body);
          });
        }
        async get(url) {
          return exceptionWrapper(async () => {
            const file = this.getFilePath(url);
            try {
              const res = await this.fs.readfile(file);
              this.logger.Debug().Url(url.asURL()).Str("file", file).Msg("get");
              return Result.Ok(new Uint8Array(res));
            } catch (e9) {
              if (isNotFoundError(e9)) {
                return Result.Err(new NotFoundError(`file not found: ${file}`));
              }
              return Result.Err(e9);
            }
          });
        }
        async delete(url) {
          return exception2Result(async () => {
            await this.fs.unlink(this.getFilePath(url));
          });
        }
        async destroy(baseURL) {
          const url = await this.buildUrl(baseURL, "x");
          if (url.isErr()) return url;
          const filepath = this.sthis.pathOps.dirname(this.getFilePath(url.Ok()));
          let files = [];
          try {
            files = await this.fs.readdir(filepath);
          } catch (e9) {
            if (!isNotFoundError(e9)) {
              throw this.logger.Error().Err(e9).Str("dir", filepath).Msg("destroy:readdir").AsError();
            }
          }
          for (const file of files) {
            const pathed = this.sthis.pathOps.join(filepath, file);
            try {
              await this.fs.unlink(pathed);
            } catch (e9) {
              if (!isNotFoundError(e9)) {
                throw this.logger.Error().Err(e9).Str("file", pathed).Msg("destroy:unlink").AsError();
              }
            }
          }
          return Result.Ok(void 0);
        }
      };
      FileTestStore = class {
        constructor(sthis) {
          this.logger = ensureLogger(sthis, "FileTestStore");
          this.sthis = sthis;
        }
        async get(iurl, key) {
          const url = iurl.build().setParam("key", key).URI();
          const dbFile = this.sthis.pathOps.join(getPath(url, this.sthis), getFileName(url, this.sthis));
          this.logger.Debug().Url(url).Str("dbFile", dbFile).Msg("get");
          const buffer4 = await (await getFileSystem(url)).readfile(dbFile);
          this.logger.Debug().Url(url).Str("dbFile", dbFile).Len(buffer4).Msg("got");
          return buffer4;
        }
      };
    }
  });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/gateway-7OM6OSYK.js
  var gateway_7OM6OSYK_exports = {};
  __export(gateway_7OM6OSYK_exports, {
    IndexDBGateway: () => IndexDBGateway,
    IndexDBTestStore: () => IndexDBTestStore,
    getIndexDBName: () => getIndexDBName
  });
  function ensureVersion(url) {
    return url.build().defParam("version", INDEXDB_VERSION).URI();
  }
  function sanitzeKey(key) {
    if (key.length === 1) {
      key = key[0];
    }
    return key;
  }
  async function connectIdb(url, sthis) {
    const dbName = getIndexDBName(url, sthis);
    const once3 = await onceIndexDB.get(dbName.fullDb).once(async () => {
      const db = await openDB(dbName.fullDb, 1, {
        upgrade(db2) {
          ["version", "data", "wal", "meta", "idx.data", "idx.wal", "idx.meta"].map((store) => {
            db2.createObjectStore(store, {
              autoIncrement: false
            });
          });
        }
      });
      const found = await db.get("version", "version");
      const version2 = ensureVersion(url).getParam("version");
      if (!found) {
        await db.put("version", { version: version2 }, "version");
      } else if (found.version !== version2) {
        sthis.logger.Warn().Str("url", url.toString()).Str("version", version2).Str("found", found.version).Msg("version mismatch");
      }
      return { db, dbName, version: version2, url };
    });
    return {
      ...once3,
      url: url.build().setParam("version", once3.version).URI()
    };
  }
  function joinDBName(...names) {
    return names.map((i7) => i7.replace(/^[^a-zA-Z0-9]+/g, "").replace(/[^a-zA-Z0-9]+/g, "_")).filter((i7) => i7.length).join(".");
  }
  function getIndexDBName(iurl, sthis) {
    const url = ensureVersion(iurl);
    const fullDb = url.pathname.replace(/^\/+/, "").replace(/\?.*$/, "");
    const dbName = url.getParam("name");
    if (!dbName) throw sthis.logger.Error().Str("url", url.toString()).Msg(`name not found`).AsError();
    const result = joinDBName(fullDb, dbName);
    const objStore = getStore(url, sthis, joinDBName).name;
    const connectionKey = [result, objStore].join(":");
    return {
      fullDb: result,
      objStore,
      connectionKey,
      dbName
    };
  }
  var onceIndexDB, IndexDBGateway, IndexDBTestStore;
  var init_gateway_7OM6OSYK = __esm({
    "node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/gateway-7OM6OSYK.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_PB4BKL4O();
      init_chunk_MAK4D54P();
      init_build();
      init_cement();
      onceIndexDB = new KeyedResolvOnce();
      IndexDBGateway = class {
        constructor(sthis) {
          this._db = {};
          this.logger = ensureLogger(sthis, "IndexDBGateway");
          this.sthis = sthis;
        }
        async start(baseURL) {
          return exception2Result(async () => {
            this.logger.Debug().Url(baseURL).Msg("starting");
            await this.sthis.start();
            const ic = await connectIdb(baseURL, this.sthis);
            this._db = ic.db;
            this.logger.Debug().Url(ic.url).Msg("started");
            return ic.url;
          });
        }
        async close() {
          return Result.Ok(void 0);
        }
        async destroy(baseUrl) {
          return exception2Result(async () => {
            const type2 = getStore(baseUrl, this.sthis, joinDBName).name;
            const idb = this._db;
            const trans = idb.transaction(type2, "readwrite");
            const object_store = trans.objectStore(type2);
            const toDelete = [];
            for (let cursor = await object_store.openCursor(); cursor; cursor = await cursor.continue()) {
              toDelete.push(cursor.primaryKey);
            }
            for (const key of toDelete) {
              await trans.db.delete(type2, key);
            }
            await trans.done;
          });
        }
        buildUrl(baseUrl, key) {
          return Promise.resolve(Result.Ok(baseUrl.build().setParam("key", key).URI()));
        }
        async get(url) {
          return exceptionWrapper(async () => {
            const key = getKey(url, this.logger);
            const store = getStore(url, this.sthis, joinDBName).name;
            this.logger.Debug().Url(url).Str("key", key).Str("store", store).Msg("getting");
            const tx = this._db.transaction([store], "readonly");
            const bytes = await tx.objectStore(store).get(sanitzeKey(key));
            await tx.done;
            if (!bytes) {
              return Result.Err(new NotFoundError(`missing ${key}`));
            }
            return Result.Ok(bytes);
          });
        }
        async put(url, value) {
          return exception2Result(async () => {
            const key = getKey(url, this.logger);
            const store = getStore(url, this.sthis, joinDBName).name;
            this.logger.Debug().Url(url).Str("key", key).Str("store", store).Msg("putting");
            const tx = this._db.transaction([store], "readwrite");
            await tx.objectStore(store).put(value, sanitzeKey(key));
            await tx.done;
          });
        }
        async delete(url) {
          return exception2Result(async () => {
            const key = getKey(url, this.logger);
            const store = getStore(url, this.sthis, joinDBName).name;
            this.logger.Debug().Url(url).Str("key", key).Str("store", store).Msg("deleting");
            const tx = this._db.transaction([store], "readwrite");
            await tx.objectStore(store).delete(sanitzeKey(key));
            await tx.done;
            return Result.Ok(void 0);
          });
        }
      };
      IndexDBTestStore = class {
        constructor(sthis) {
          this.sthis = sthis;
          this.logger = ensureLogger(sthis, "IndexDBTestStore", {});
        }
        async get(url, key) {
          const ic = await connectIdb(url, this.sthis);
          const store = getStore(ic.url, this.sthis, joinDBName).name;
          this.logger.Debug().Str("key", key).Str("store", store).Msg("getting");
          let bytes = await ic.db.get(store, sanitzeKey(key));
          this.logger.Debug().Str("key", key).Str("store", store).Int("len", bytes.length).Msg("got");
          if (typeof bytes === "string") {
            bytes = this.sthis.txt.encode(bytes);
          }
          return bytes;
        }
      };
    }
  });

  // node_modules/.pnpm/ws@8.18.0/node_modules/ws/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/ws@8.18.0/node_modules/ws/browser.js"(exports9, module2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module2.exports = function() {
        throw new Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    }
  });

  // src/partykit/index.ts
  var partykit_exports = {};
  __export(partykit_exports, {
    connect: () => connect
  });
  init_dirname();
  init_buffer2();
  init_process2();

  // src/connection-from-store.ts
  init_dirname();
  init_buffer2();
  init_process2();
  init_cement();

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_chunk_7EWIAXTM();
  init_chunk_XINRLWR3();
  init_chunk_PB4BKL4O();
  init_chunk_MAK4D54P();
  init_cement();
  init_cement();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_bytes();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/cid.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/bases/base32.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_base();
  var base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper = rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad = rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper = rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex = rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper = rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad = rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper = rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z = rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/bases/base36.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_base();
  var base36 = baseX({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper = baseX({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/cid.js
  init_base58();
  init_bytes();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/hashes/digest.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_bytes();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/varint.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/vendor/varint.js
  init_dirname();
  init_buffer2();
  init_process2();
  var encode_1 = encode2;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode2(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode2.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode2 = read2;
  var MSB$1 = 128;
  var REST$1 = 127;
  function read2(buf3, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b5, l7 = buf3.length;
    do {
      if (counter >= l7) {
        read2.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b5 = buf3[counter++];
      res += shift < 28 ? (b5 & REST$1) << shift : (b5 & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b5 >= MSB$1);
    read2.bytes = counter - offset;
    return res;
  }
  var N1 = Math.pow(2, 7);
  var N22 = Math.pow(2, 14);
  var N32 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  var length = function(value) {
    return value < N1 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
  var varint = {
    encode: encode_1,
    decode: decode2,
    encodingLength: length
  };
  var _brrp_varint = varint;
  var varint_default = _brrp_varint;

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/varint.js
  function decode3(data, offset = 0) {
    const code9 = varint_default.decode(data, offset);
    return [code9, varint_default.decode.bytes];
  }
  function encodeTo(int3, target, offset = 0) {
    varint_default.encode(int3, target, offset);
    return target;
  }
  function encodingLength(int3) {
    return varint_default.encodingLength(int3);
  }

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/hashes/digest.js
  function create(code9, digest3) {
    const size = digest3.byteLength;
    const sizeOffset = encodingLength(code9);
    const digestOffset = sizeOffset + encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo(code9, bytes, 0);
    encodeTo(size, bytes, sizeOffset);
    bytes.set(digest3, digestOffset);
    return new Digest(code9, size, digest3, bytes);
  }
  function decode4(multihash) {
    const bytes = coerce(multihash);
    const [code9, sizeOffset] = decode3(bytes);
    const [size, digestOffset] = decode3(bytes.subarray(sizeOffset));
    const digest3 = bytes.subarray(sizeOffset + digestOffset);
    if (digest3.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest(code9, size, digest3, bytes);
  }
  function equals2(a7, b5) {
    if (a7 === b5) {
      return true;
    } else {
      const data = b5;
      return a7.code === data.code && a7.size === data.size && data.bytes instanceof Uint8Array && equals(a7.bytes, data.bytes);
    }
  }
  var Digest = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code9, size, digest3, bytes) {
      this.code = code9;
      this.size = size;
      this.digest = digest3;
      this.bytes = bytes;
    }
  };

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/link/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/cid.js
  function format5(link4, base3) {
    const { bytes, version: version2 } = link4;
    switch (version2) {
      case 0:
        return toStringV0(bytes, baseCache(link4), base3 ?? base58btc.encoder);
      default:
        return toStringV1(bytes, baseCache(link4), base3 ?? base32.encoder);
    }
  }
  var cache = /* @__PURE__ */ new WeakMap();
  function baseCache(cid) {
    const baseCache3 = cache.get(cid);
    if (baseCache3 == null) {
      const baseCache4 = /* @__PURE__ */ new Map();
      cache.set(cid, baseCache4);
      return baseCache4;
    }
    return baseCache3;
  }
  var CID = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version2, code9, multihash, bytes) {
      this.code = code9;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes;
      this["/"] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code9, multihash } = this;
          if (code9 !== DAG_PB_CODE) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code9, digest: digest3 } = this.multihash;
          const multihash = create(code9, digest3);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
    }
    toString(base3) {
      return format5(this, base3);
    }
    toJSON() {
      return { "/": format5(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version2, code: code9, multihash, bytes } = value;
        return new _CID(version2, code9, multihash, bytes ?? encodeCID(version2, code9, multihash.bytes));
      } else if (value[cidSymbol] === true) {
        const { version: version2, multihash, code: code9 } = value;
        const digest3 = decode4(multihash);
        return _CID.create(version2, code9, digest3);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version2, code9, digest3) {
      if (typeof code9 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest3.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version2) {
        case 0: {
          if (code9 !== DAG_PB_CODE) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
          } else {
            return new _CID(version2, code9, digest3, digest3.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID(version2, code9, digest3.bytes);
          return new _CID(version2, code9, digest3, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest3) {
      return _CID.create(0, DAG_PB_CODE, digest3);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code9, digest3) {
      return _CID.create(1, code9, digest3);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes) {
      const [cid, remainder] = _CID.decodeFirst(bytes);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes) {
      const specs = _CID.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest3 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest3) : _CID.createV1(specs.codec, digest3);
      return [cid, bytes.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i7, length4] = decode3(initialBytes.subarray(offset));
        offset += length4;
        return i7;
      };
      let version2 = next();
      let codec = DAG_PB_CODE;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version2, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base3) {
      const [prefix, bytes] = parseCIDtoBytes(source, base3);
      const cid = _CID.decode(bytes);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes(source, base3) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder2 = base3 ?? base58btc;
        return [
          base58btc.prefix,
          decoder2.decode(`${base58btc.prefix}${source}`)
        ];
      }
      case base58btc.prefix: {
        const decoder2 = base3 ?? base58btc;
        return [base58btc.prefix, decoder2.decode(source)];
      }
      case base32.prefix: {
        const decoder2 = base3 ?? base32;
        return [base32.prefix, decoder2.decode(source)];
      }
      case base36.prefix: {
        const decoder2 = base3 ?? base36;
        return [base36.prefix, decoder2.decode(source)];
      }
      default: {
        if (base3 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base3.decode(source)];
      }
    }
  }
  function toStringV0(bytes, cache3, base3) {
    const { prefix } = base3;
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
    }
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes).slice(1);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV1(bytes, cache3, base3) {
    const { prefix } = base3;
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE = 112;
  var SHA_256_CODE = 18;
  function encodeCID(version2, code9, multihash) {
    const codeOffset = encodingLength(version2);
    const hashOffset = codeOffset + encodingLength(code9);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo(version2, bytes, 0);
    encodeTo(code9, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  }
  var cidSymbol = Symbol.for("@ipld/js-cid/CID");

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/hashes/hasher.js
  init_dirname();
  init_buffer2();
  init_process2();
  function from3({ name: name8, code: code9, encode: encode18 }) {
    return new Hasher(name8, code9, encode18);
  }
  var Hasher = class {
    name;
    code;
    encode;
    constructor(name8, code9, encode18) {
      this.name = name8;
      this.code = code9;
      this.encode = encode18;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create(this.code, result) : result.then((digest3) => create(this.code, digest3));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/bases/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/hashes/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/codecs/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/block/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/block.js
  init_dirname();
  init_buffer2();
  init_process2();
  function readonly({ enumerable = true, configurable = false } = {}) {
    return { enumerable, configurable, writable: false };
  }
  function* linksWithin(path2, value) {
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index2, element] of value.entries()) {
          const elementPath = [...path2, index2];
          const cid = CID.asCID(element);
          if (cid != null) {
            yield [elementPath.join("/"), cid];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid != null) {
          yield [path2.join("/"), cid];
        } else {
          yield* links(value, path2);
        }
      }
    }
  }
  function* links(source, base3) {
    if (source == null || source instanceof Uint8Array) {
      return;
    }
    const cid = CID.asCID(source);
    if (cid != null) {
      yield [base3.join("/"), cid];
    }
    for (const [key, value] of Object.entries(source)) {
      const path2 = [...base3, key];
      yield* linksWithin(path2, value);
    }
  }
  function* treeWithin(path2, value) {
    if (Array.isArray(value)) {
      for (const [index2, element] of value.entries()) {
        const elementPath = [...path2, index2];
        yield elementPath.join("/");
        if (typeof element === "object" && CID.asCID(element) == null) {
          yield* tree(element, elementPath);
        }
      }
    } else {
      yield* tree(value, path2);
    }
  }
  function* tree(source, base3) {
    if (source == null || typeof source !== "object") {
      return;
    }
    for (const [key, value] of Object.entries(source)) {
      const path2 = [...base3, key];
      yield path2.join("/");
      if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && CID.asCID(value) == null) {
        yield* treeWithin(path2, value);
      }
    }
  }
  function get(source, path2) {
    let node = source;
    for (const [index2, key] of path2.entries()) {
      node = node[key];
      if (node == null) {
        throw new Error(`Object has no property at ${path2.slice(0, index2 + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
      }
      const cid = CID.asCID(node);
      if (cid != null) {
        return { value: cid, remaining: path2.slice(index2 + 1).join("/") };
      }
    }
    return { value: node };
  }
  var Block = class {
    cid;
    bytes;
    value;
    asBlock;
    constructor({ cid, bytes, value }) {
      if (cid == null || bytes == null || typeof value === "undefined") {
        throw new Error("Missing required argument");
      }
      this.cid = cid;
      this.bytes = bytes;
      this.value = value;
      this.asBlock = this;
      Object.defineProperties(this, {
        cid: readonly(),
        bytes: readonly(),
        value: readonly(),
        asBlock: readonly()
      });
    }
    links() {
      return links(this.value, []);
    }
    tree() {
      return tree(this.value, []);
    }
    get(path2 = "/") {
      return get(this.value, path2.split("/").filter(Boolean));
    }
  };

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/link.js
  init_dirname();
  init_buffer2();
  init_process2();
  function parse4(source, base3) {
    return CID.parse(source, base3);
  }

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  init_dirname();
  init_buffer2();
  init_process2();
  function sha(name8) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name8, data));
  }
  var sha256 = from3({
    name: "sha2-256",
    code: 18,
    encode: sha("SHA-256")
  });
  var sha512 = from3({
    name: "sha2-512",
    code: 19,
    encode: sha("SHA-512")
  });

  // node_modules/.pnpm/@ipld+dag-cbor@9.2.1/node_modules/@ipld/dag-cbor/src/index.js
  var src_exports = {};
  __export(src_exports, {
    code: () => code,
    decode: () => decode10,
    decodeOptions: () => decodeOptions,
    encode: () => encode6,
    encodeOptions: () => encodeOptions,
    name: () => name2,
    toByteView: () => toByteView
  });
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/cborg.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/encode.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/is.js
  init_dirname();
  init_buffer2();
  init_process2();
  var typeofs = [
    "string",
    "number",
    "bigint",
    "symbol"
  ];
  var objectTypeNames = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "HTMLElement",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  function is(value) {
    if (value === null) {
      return "null";
    }
    if (value === void 0) {
      return "undefined";
    }
    if (value === true || value === false) {
      return "boolean";
    }
    const typeOf = typeof value;
    if (typeofs.includes(typeOf)) {
      return typeOf;
    }
    if (typeOf === "function") {
      return "Function";
    }
    if (Array.isArray(value)) {
      return "Array";
    }
    if (isBuffer3(value)) {
      return "Buffer";
    }
    const objectType = getObjectType(value);
    if (objectType) {
      return objectType;
    }
    return "Object";
  }
  function isBuffer3(value) {
    return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
  }
  function getObjectType(value) {
    const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
    if (objectTypeNames.includes(objectTypeName)) {
      return objectTypeName;
    }
    return void 0;
  }

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/token.js
  init_dirname();
  init_buffer2();
  init_process2();
  var Type = class {
    /**
     * @param {number} major
     * @param {string} name
     * @param {boolean} terminal
     */
    constructor(major, name8, terminal) {
      this.major = major;
      this.majorEncoded = major << 5;
      this.name = name8;
      this.terminal = terminal;
    }
    /* c8 ignore next 3 */
    toString() {
      return `Type[${this.major}].${this.name}`;
    }
    /**
     * @param {Type} typ
     * @returns {number}
     */
    compare(typ) {
      return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
    }
  };
  Type.uint = new Type(0, "uint", true);
  Type.negint = new Type(1, "negint", true);
  Type.bytes = new Type(2, "bytes", true);
  Type.string = new Type(3, "string", true);
  Type.array = new Type(4, "array", false);
  Type.map = new Type(5, "map", false);
  Type.tag = new Type(6, "tag", false);
  Type.float = new Type(7, "float", true);
  Type.false = new Type(7, "false", true);
  Type.true = new Type(7, "true", true);
  Type.null = new Type(7, "null", true);
  Type.undefined = new Type(7, "undefined", true);
  Type.break = new Type(7, "break", true);
  var Token = class {
    /**
     * @param {Type} type
     * @param {any} [value]
     * @param {number} [encodedLength]
     */
    constructor(type2, value, encodedLength) {
      this.type = type2;
      this.value = value;
      this.encodedLength = encodedLength;
      this.encodedBytes = void 0;
      this.byteValue = void 0;
    }
    /* c8 ignore next 3 */
    toString() {
      return `Token[${this.type}].${this.value}`;
    }
  };

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/bl.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/byte-utils.js
  init_dirname();
  init_buffer2();
  init_process2();
  var useBuffer = globalThis.process && // @ts-ignore
  !globalThis.process.browser && // @ts-ignore
  globalThis.Buffer && // @ts-ignore
  typeof globalThis.Buffer.isBuffer === "function";
  var textDecoder = new TextDecoder();
  var textEncoder = new TextEncoder();
  function isBuffer4(buf3) {
    return useBuffer && globalThis.Buffer.isBuffer(buf3);
  }
  function asU8A(buf3) {
    if (!(buf3 instanceof Uint8Array)) {
      return Uint8Array.from(buf3);
    }
    return isBuffer4(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
  }
  var toString2 = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      return end - start > 64 ? (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8")
      ) : utf8Slice(bytes, start, end);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
    }
  );
  var fromString2 = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {string} string
     */
    (string3) => {
      return string3.length > 64 ? (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(string3)
      ) : utf8ToBytes(string3);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {string} string
     */
    (string3) => {
      return string3.length > 64 ? textEncoder.encode(string3) : utf8ToBytes(string3);
    }
  );
  var fromArray = (arr) => {
    return Uint8Array.from(arr);
  };
  var slice = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      if (isBuffer4(bytes)) {
        return new Uint8Array(bytes.subarray(start, end));
      }
      return bytes.slice(start, end);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      return bytes.slice(start, end);
    }
  );
  var concat = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array[]} chunks
     * @param {number} length
     * @returns {Uint8Array}
     */
    (chunks, length4) => {
      chunks = chunks.map((c7) => c7 instanceof Uint8Array ? c7 : (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(c7)
      ));
      return asU8A(globalThis.Buffer.concat(chunks, length4));
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array[]} chunks
     * @param {number} length
     * @returns {Uint8Array}
     */
    (chunks, length4) => {
      const out = new Uint8Array(length4);
      let off2 = 0;
      for (let b5 of chunks) {
        if (off2 + b5.length > out.length) {
          b5 = b5.subarray(0, out.length - off2);
        }
        out.set(b5, off2);
        off2 += b5.length;
      }
      return out;
    }
  );
  var alloc = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {number} size
     * @returns {Uint8Array}
     */
    (size) => {
      return globalThis.Buffer.allocUnsafe(size);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {number} size
     * @returns {Uint8Array}
     */
    (size) => {
      return new Uint8Array(size);
    }
  );
  function compare(b1, b22) {
    if (isBuffer4(b1) && isBuffer4(b22)) {
      return b1.compare(b22);
    }
    for (let i7 = 0; i7 < b1.length; i7++) {
      if (b1[i7] === b22[i7]) {
        continue;
      }
      return b1[i7] < b22[i7] ? -1 : 1;
    }
    return 0;
  }
  function utf8ToBytes(str) {
    const out = [];
    let p7 = 0;
    for (let i7 = 0; i7 < str.length; i7++) {
      let c7 = str.charCodeAt(i7);
      if (c7 < 128) {
        out[p7++] = c7;
      } else if (c7 < 2048) {
        out[p7++] = c7 >> 6 | 192;
        out[p7++] = c7 & 63 | 128;
      } else if ((c7 & 64512) === 55296 && i7 + 1 < str.length && (str.charCodeAt(i7 + 1) & 64512) === 56320) {
        c7 = 65536 + ((c7 & 1023) << 10) + (str.charCodeAt(++i7) & 1023);
        out[p7++] = c7 >> 18 | 240;
        out[p7++] = c7 >> 12 & 63 | 128;
        out[p7++] = c7 >> 6 & 63 | 128;
        out[p7++] = c7 & 63 | 128;
      } else {
        out[p7++] = c7 >> 12 | 224;
        out[p7++] = c7 >> 6 & 63 | 128;
        out[p7++] = c7 & 63 | 128;
      }
    }
    return out;
  }
  function utf8Slice(buf3, offset, end) {
    const res = [];
    while (offset < end) {
      const firstByte = buf3[offset];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (offset + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf3[offset + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf3[offset + 1];
            thirdByte = buf3[offset + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf3[offset + 1];
            thirdByte = buf3[offset + 2];
            fourthByte = buf3[offset + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      offset += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i7 = 0;
    while (i7 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/bl.js
  var defaultChunkSize = 256;
  var Bl = class {
    /**
     * @param {number} [chunkSize]
     */
    constructor(chunkSize = defaultChunkSize) {
      this.chunkSize = chunkSize;
      this.cursor = 0;
      this.maxCursor = -1;
      this.chunks = [];
      this._initReuseChunk = null;
    }
    reset() {
      this.cursor = 0;
      this.maxCursor = -1;
      if (this.chunks.length) {
        this.chunks = [];
      }
      if (this._initReuseChunk !== null) {
        this.chunks.push(this._initReuseChunk);
        this.maxCursor = this._initReuseChunk.length - 1;
      }
    }
    /**
     * @param {Uint8Array|number[]} bytes
     */
    push(bytes) {
      let topChunk = this.chunks[this.chunks.length - 1];
      const newMax = this.cursor + bytes.length;
      if (newMax <= this.maxCursor + 1) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        topChunk.set(bytes, chunkPos);
      } else {
        if (topChunk) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          if (chunkPos < topChunk.length) {
            this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
            this.maxCursor = this.cursor - 1;
          }
        }
        if (bytes.length < 64 && bytes.length < this.chunkSize) {
          topChunk = alloc(this.chunkSize);
          this.chunks.push(topChunk);
          this.maxCursor += topChunk.length;
          if (this._initReuseChunk === null) {
            this._initReuseChunk = topChunk;
          }
          topChunk.set(bytes, 0);
        } else {
          this.chunks.push(bytes);
          this.maxCursor += bytes.length;
        }
      }
      this.cursor += bytes.length;
    }
    /**
     * @param {boolean} [reset]
     * @returns {Uint8Array}
     */
    toBytes(reset = false) {
      let byts;
      if (this.chunks.length === 1) {
        const chunk = this.chunks[0];
        if (reset && this.cursor > chunk.length / 2) {
          byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
          this._initReuseChunk = null;
          this.chunks = [];
        } else {
          byts = slice(chunk, 0, this.cursor);
        }
      } else {
        byts = concat(this.chunks, this.cursor);
      }
      if (reset) {
        this.reset();
      }
      return byts;
    }
  };

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/common.js
  init_dirname();
  init_buffer2();
  init_process2();
  var decodeErrPrefix = "CBOR decode error:";
  var encodeErrPrefix = "CBOR encode error:";
  var uintMinorPrefixBytes = [];
  uintMinorPrefixBytes[23] = 1;
  uintMinorPrefixBytes[24] = 2;
  uintMinorPrefixBytes[25] = 3;
  uintMinorPrefixBytes[26] = 5;
  uintMinorPrefixBytes[27] = 9;
  function assertEnoughData(data, pos, need) {
    if (data.length - pos < need) {
      throw new Error(`${decodeErrPrefix} not enough data for type`);
    }
  }

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/jump.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/0uint.js
  init_dirname();
  init_buffer2();
  init_process2();
  var uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
  function readUint8(data, offset, options) {
    assertEnoughData(data, offset, 1);
    const value = data[offset];
    if (options.strict === true && value < uintBoundaries[0]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint16(data, offset, options) {
    assertEnoughData(data, offset, 2);
    const value = data[offset] << 8 | data[offset + 1];
    if (options.strict === true && value < uintBoundaries[1]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint32(data, offset, options) {
    assertEnoughData(data, offset, 4);
    const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    if (options.strict === true && value < uintBoundaries[2]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint64(data, offset, options) {
    assertEnoughData(data, offset, 8);
    const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
    const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
    if (options.strict === true && value < uintBoundaries[3]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    if (value <= Number.MAX_SAFE_INTEGER) {
      return Number(value);
    }
    if (options.allowBigInt === true) {
      return value;
    }
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  function decodeUint8(data, pos, _minor, options) {
    return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
  }
  function decodeUint16(data, pos, _minor, options) {
    return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
  }
  function decodeUint32(data, pos, _minor, options) {
    return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
  }
  function decodeUint64(data, pos, _minor, options) {
    return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
  }
  function encodeUint(buf3, token) {
    return encodeUintValue(buf3, 0, token.value);
  }
  function encodeUintValue(buf3, major, uint) {
    if (uint < uintBoundaries[0]) {
      const nuint = Number(uint);
      buf3.push([major | nuint]);
    } else if (uint < uintBoundaries[1]) {
      const nuint = Number(uint);
      buf3.push([major | 24, nuint]);
    } else if (uint < uintBoundaries[2]) {
      const nuint = Number(uint);
      buf3.push([major | 25, nuint >>> 8, nuint & 255]);
    } else if (uint < uintBoundaries[3]) {
      const nuint = Number(uint);
      buf3.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
    } else {
      const buint = BigInt(uint);
      if (buint < uintBoundaries[4]) {
        const set4 = [major | 27, 0, 0, 0, 0, 0, 0, 0];
        let lo = Number(buint & BigInt(4294967295));
        let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
        set4[8] = lo & 255;
        lo = lo >> 8;
        set4[7] = lo & 255;
        lo = lo >> 8;
        set4[6] = lo & 255;
        lo = lo >> 8;
        set4[5] = lo & 255;
        set4[4] = hi & 255;
        hi = hi >> 8;
        set4[3] = hi & 255;
        hi = hi >> 8;
        set4[2] = hi & 255;
        hi = hi >> 8;
        set4[1] = hi & 255;
        buf3.push(set4);
      } else {
        throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
      }
    }
  }
  encodeUint.encodedSize = function encodedSize(token) {
    return encodeUintValue.encodedSize(token.value);
  };
  encodeUintValue.encodedSize = function encodedSize2(uint) {
    if (uint < uintBoundaries[0]) {
      return 1;
    }
    if (uint < uintBoundaries[1]) {
      return 2;
    }
    if (uint < uintBoundaries[2]) {
      return 3;
    }
    if (uint < uintBoundaries[3]) {
      return 5;
    }
    return 9;
  };
  encodeUint.compareTokens = function compareTokens(tok1, tok2) {
    return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
      /* c8 ignore next */
      0
    );
  };

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/1negint.js
  init_dirname();
  init_buffer2();
  init_process2();
  function decodeNegint8(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
  }
  function decodeNegint16(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
  }
  function decodeNegint32(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
  }
  var neg1b = BigInt(-1);
  var pos1b = BigInt(1);
  function decodeNegint64(data, pos, _minor, options) {
    const int3 = readUint64(data, pos + 1, options);
    if (typeof int3 !== "bigint") {
      const value = -1 - int3;
      if (value >= Number.MIN_SAFE_INTEGER) {
        return new Token(Type.negint, value, 9);
      }
    }
    if (options.allowBigInt !== true) {
      throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
    }
    return new Token(Type.negint, neg1b - BigInt(int3), 9);
  }
  function encodeNegint(buf3, token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
    encodeUintValue(buf3, token.type.majorEncoded, unsigned);
  }
  encodeNegint.encodedSize = function encodedSize3(token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
    if (unsigned < uintBoundaries[0]) {
      return 1;
    }
    if (unsigned < uintBoundaries[1]) {
      return 2;
    }
    if (unsigned < uintBoundaries[2]) {
      return 3;
    }
    if (unsigned < uintBoundaries[3]) {
      return 5;
    }
    return 9;
  };
  encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
    return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
      /* c8 ignore next */
      0
    );
  };

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/2bytes.js
  init_dirname();
  init_buffer2();
  init_process2();
  function toToken(data, pos, prefix, length4) {
    assertEnoughData(data, pos, prefix + length4);
    const buf3 = slice(data, pos + prefix, pos + prefix + length4);
    return new Token(Type.bytes, buf3, prefix + length4);
  }
  function decodeBytesCompact(data, pos, minor, _options) {
    return toToken(data, pos, 1, minor);
  }
  function decodeBytes8(data, pos, _minor, options) {
    return toToken(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeBytes16(data, pos, _minor, options) {
    return toToken(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeBytes32(data, pos, _minor, options) {
    return toToken(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeBytes64(data, pos, _minor, options) {
    const l7 = readUint64(data, pos + 1, options);
    if (typeof l7 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
    }
    return toToken(data, pos, 9, l7);
  }
  function tokenBytes(token) {
    if (token.encodedBytes === void 0) {
      token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
    }
    return token.encodedBytes;
  }
  function encodeBytes(buf3, token) {
    const bytes = tokenBytes(token);
    encodeUintValue(buf3, token.type.majorEncoded, bytes.length);
    buf3.push(bytes);
  }
  encodeBytes.encodedSize = function encodedSize4(token) {
    const bytes = tokenBytes(token);
    return encodeUintValue.encodedSize(bytes.length) + bytes.length;
  };
  encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
    return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
  };
  function compareBytes(b1, b22) {
    return b1.length < b22.length ? -1 : b1.length > b22.length ? 1 : compare(b1, b22);
  }

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/3string.js
  init_dirname();
  init_buffer2();
  init_process2();
  function toToken2(data, pos, prefix, length4, options) {
    const totLength = prefix + length4;
    assertEnoughData(data, pos, totLength);
    const tok = new Token(Type.string, toString2(data, pos + prefix, pos + totLength), totLength);
    if (options.retainStringBytes === true) {
      tok.byteValue = slice(data, pos + prefix, pos + totLength);
    }
    return tok;
  }
  function decodeStringCompact(data, pos, minor, options) {
    return toToken2(data, pos, 1, minor, options);
  }
  function decodeString8(data, pos, _minor, options) {
    return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
  }
  function decodeString16(data, pos, _minor, options) {
    return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
  }
  function decodeString32(data, pos, _minor, options) {
    return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
  }
  function decodeString64(data, pos, _minor, options) {
    const l7 = readUint64(data, pos + 1, options);
    if (typeof l7 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
    }
    return toToken2(data, pos, 9, l7, options);
  }
  var encodeString = encodeBytes;

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/4array.js
  init_dirname();
  init_buffer2();
  init_process2();
  function toToken3(_data, _pos, prefix, length4) {
    return new Token(Type.array, length4, prefix);
  }
  function decodeArrayCompact(data, pos, minor, _options) {
    return toToken3(data, pos, 1, minor);
  }
  function decodeArray8(data, pos, _minor, options) {
    return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeArray16(data, pos, _minor, options) {
    return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeArray32(data, pos, _minor, options) {
    return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeArray64(data, pos, _minor, options) {
    const l7 = readUint64(data, pos + 1, options);
    if (typeof l7 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
    }
    return toToken3(data, pos, 9, l7);
  }
  function decodeArrayIndefinite(data, pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return toToken3(data, pos, 1, Infinity);
  }
  function encodeArray(buf3, token) {
    encodeUintValue(buf3, Type.array.majorEncoded, token.value);
  }
  encodeArray.compareTokens = encodeUint.compareTokens;
  encodeArray.encodedSize = function encodedSize5(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/5map.js
  init_dirname();
  init_buffer2();
  init_process2();
  function toToken4(_data, _pos, prefix, length4) {
    return new Token(Type.map, length4, prefix);
  }
  function decodeMapCompact(data, pos, minor, _options) {
    return toToken4(data, pos, 1, minor);
  }
  function decodeMap8(data, pos, _minor, options) {
    return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeMap16(data, pos, _minor, options) {
    return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeMap32(data, pos, _minor, options) {
    return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeMap64(data, pos, _minor, options) {
    const l7 = readUint64(data, pos + 1, options);
    if (typeof l7 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
    }
    return toToken4(data, pos, 9, l7);
  }
  function decodeMapIndefinite(data, pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return toToken4(data, pos, 1, Infinity);
  }
  function encodeMap(buf3, token) {
    encodeUintValue(buf3, Type.map.majorEncoded, token.value);
  }
  encodeMap.compareTokens = encodeUint.compareTokens;
  encodeMap.encodedSize = function encodedSize6(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/6tag.js
  init_dirname();
  init_buffer2();
  init_process2();
  function decodeTagCompact(_data, _pos, minor, _options) {
    return new Token(Type.tag, minor, 1);
  }
  function decodeTag8(data, pos, _minor, options) {
    return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
  }
  function decodeTag16(data, pos, _minor, options) {
    return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
  }
  function decodeTag32(data, pos, _minor, options) {
    return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
  }
  function decodeTag64(data, pos, _minor, options) {
    return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
  }
  function encodeTag(buf3, token) {
    encodeUintValue(buf3, Type.tag.majorEncoded, token.value);
  }
  encodeTag.compareTokens = encodeUint.compareTokens;
  encodeTag.encodedSize = function encodedSize7(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/7float.js
  init_dirname();
  init_buffer2();
  init_process2();
  var MINOR_FALSE = 20;
  var MINOR_TRUE = 21;
  var MINOR_NULL = 22;
  var MINOR_UNDEFINED = 23;
  function decodeUndefined(_data, _pos, _minor, options) {
    if (options.allowUndefined === false) {
      throw new Error(`${decodeErrPrefix} undefined values are not supported`);
    } else if (options.coerceUndefinedToNull === true) {
      return new Token(Type.null, null, 1);
    }
    return new Token(Type.undefined, void 0, 1);
  }
  function decodeBreak(_data, _pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return new Token(Type.break, void 0, 1);
  }
  function createToken(value, bytes, options) {
    if (options) {
      if (options.allowNaN === false && Number.isNaN(value)) {
        throw new Error(`${decodeErrPrefix} NaN values are not supported`);
      }
      if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
        throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
      }
    }
    return new Token(Type.float, value, bytes);
  }
  function decodeFloat16(data, pos, _minor, options) {
    return createToken(readFloat16(data, pos + 1), 3, options);
  }
  function decodeFloat32(data, pos, _minor, options) {
    return createToken(readFloat32(data, pos + 1), 5, options);
  }
  function decodeFloat64(data, pos, _minor, options) {
    return createToken(readFloat64(data, pos + 1), 9, options);
  }
  function encodeFloat(buf3, token, options) {
    const float3 = token.value;
    if (float3 === false) {
      buf3.push([Type.float.majorEncoded | MINOR_FALSE]);
    } else if (float3 === true) {
      buf3.push([Type.float.majorEncoded | MINOR_TRUE]);
    } else if (float3 === null) {
      buf3.push([Type.float.majorEncoded | MINOR_NULL]);
    } else if (float3 === void 0) {
      buf3.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
    } else {
      let decoded;
      let success = false;
      if (!options || options.float64 !== true) {
        encodeFloat16(float3);
        decoded = readFloat16(ui8a, 1);
        if (float3 === decoded || Number.isNaN(float3)) {
          ui8a[0] = 249;
          buf3.push(ui8a.slice(0, 3));
          success = true;
        } else {
          encodeFloat32(float3);
          decoded = readFloat32(ui8a, 1);
          if (float3 === decoded) {
            ui8a[0] = 250;
            buf3.push(ui8a.slice(0, 5));
            success = true;
          }
        }
      }
      if (!success) {
        encodeFloat64(float3);
        decoded = readFloat64(ui8a, 1);
        ui8a[0] = 251;
        buf3.push(ui8a.slice(0, 9));
      }
    }
  }
  encodeFloat.encodedSize = function encodedSize8(token, options) {
    const float3 = token.value;
    if (float3 === false || float3 === true || float3 === null || float3 === void 0) {
      return 1;
    }
    if (!options || options.float64 !== true) {
      encodeFloat16(float3);
      let decoded = readFloat16(ui8a, 1);
      if (float3 === decoded || Number.isNaN(float3)) {
        return 3;
      }
      encodeFloat32(float3);
      decoded = readFloat32(ui8a, 1);
      if (float3 === decoded) {
        return 5;
      }
    }
    return 9;
  };
  var buffer2 = new ArrayBuffer(9);
  var dataView = new DataView(buffer2, 1);
  var ui8a = new Uint8Array(buffer2, 0);
  function encodeFloat16(inp) {
    if (inp === Infinity) {
      dataView.setUint16(0, 31744, false);
    } else if (inp === -Infinity) {
      dataView.setUint16(0, 64512, false);
    } else if (Number.isNaN(inp)) {
      dataView.setUint16(0, 32256, false);
    } else {
      dataView.setFloat32(0, inp);
      const valu32 = dataView.getUint32(0);
      const exponent = (valu32 & 2139095040) >> 23;
      const mantissa = valu32 & 8388607;
      if (exponent === 255) {
        dataView.setUint16(0, 31744, false);
      } else if (exponent === 0) {
        dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
      } else {
        const logicalExponent = exponent - 127;
        if (logicalExponent < -24) {
          dataView.setUint16(0, 0);
        } else if (logicalExponent < -14) {
          dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
          1 << 24 + logicalExponent, false);
        } else {
          dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
        }
      }
    }
  }
  function readFloat16(ui8a3, pos) {
    if (ui8a3.length - pos < 2) {
      throw new Error(`${decodeErrPrefix} not enough data for float16`);
    }
    const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
    if (half === 31744) {
      return Infinity;
    }
    if (half === 64512) {
      return -Infinity;
    }
    if (half === 32256) {
      return NaN;
    }
    const exp = half >> 10 & 31;
    const mant = half & 1023;
    let val;
    if (exp === 0) {
      val = mant * 2 ** -24;
    } else if (exp !== 31) {
      val = (mant + 1024) * 2 ** (exp - 25);
    } else {
      val = mant === 0 ? Infinity : NaN;
    }
    return half & 32768 ? -val : val;
  }
  function encodeFloat32(inp) {
    dataView.setFloat32(0, inp, false);
  }
  function readFloat32(ui8a3, pos) {
    if (ui8a3.length - pos < 4) {
      throw new Error(`${decodeErrPrefix} not enough data for float32`);
    }
    const offset = (ui8a3.byteOffset || 0) + pos;
    return new DataView(ui8a3.buffer, offset, 4).getFloat32(0, false);
  }
  function encodeFloat64(inp) {
    dataView.setFloat64(0, inp, false);
  }
  function readFloat64(ui8a3, pos) {
    if (ui8a3.length - pos < 8) {
      throw new Error(`${decodeErrPrefix} not enough data for float64`);
    }
    const offset = (ui8a3.byteOffset || 0) + pos;
    return new DataView(ui8a3.buffer, offset, 8).getFloat64(0, false);
  }
  encodeFloat.compareTokens = encodeUint.compareTokens;

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/jump.js
  function invalidMinor(data, pos, minor) {
    throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
  }
  function errorer(msg) {
    return () => {
      throw new Error(`${decodeErrPrefix} ${msg}`);
    };
  }
  var jump = [];
  for (let i7 = 0; i7 <= 23; i7++) {
    jump[i7] = invalidMinor;
  }
  jump[24] = decodeUint8;
  jump[25] = decodeUint16;
  jump[26] = decodeUint32;
  jump[27] = decodeUint64;
  jump[28] = invalidMinor;
  jump[29] = invalidMinor;
  jump[30] = invalidMinor;
  jump[31] = invalidMinor;
  for (let i7 = 32; i7 <= 55; i7++) {
    jump[i7] = invalidMinor;
  }
  jump[56] = decodeNegint8;
  jump[57] = decodeNegint16;
  jump[58] = decodeNegint32;
  jump[59] = decodeNegint64;
  jump[60] = invalidMinor;
  jump[61] = invalidMinor;
  jump[62] = invalidMinor;
  jump[63] = invalidMinor;
  for (let i7 = 64; i7 <= 87; i7++) {
    jump[i7] = decodeBytesCompact;
  }
  jump[88] = decodeBytes8;
  jump[89] = decodeBytes16;
  jump[90] = decodeBytes32;
  jump[91] = decodeBytes64;
  jump[92] = invalidMinor;
  jump[93] = invalidMinor;
  jump[94] = invalidMinor;
  jump[95] = errorer("indefinite length bytes/strings are not supported");
  for (let i7 = 96; i7 <= 119; i7++) {
    jump[i7] = decodeStringCompact;
  }
  jump[120] = decodeString8;
  jump[121] = decodeString16;
  jump[122] = decodeString32;
  jump[123] = decodeString64;
  jump[124] = invalidMinor;
  jump[125] = invalidMinor;
  jump[126] = invalidMinor;
  jump[127] = errorer("indefinite length bytes/strings are not supported");
  for (let i7 = 128; i7 <= 151; i7++) {
    jump[i7] = decodeArrayCompact;
  }
  jump[152] = decodeArray8;
  jump[153] = decodeArray16;
  jump[154] = decodeArray32;
  jump[155] = decodeArray64;
  jump[156] = invalidMinor;
  jump[157] = invalidMinor;
  jump[158] = invalidMinor;
  jump[159] = decodeArrayIndefinite;
  for (let i7 = 160; i7 <= 183; i7++) {
    jump[i7] = decodeMapCompact;
  }
  jump[184] = decodeMap8;
  jump[185] = decodeMap16;
  jump[186] = decodeMap32;
  jump[187] = decodeMap64;
  jump[188] = invalidMinor;
  jump[189] = invalidMinor;
  jump[190] = invalidMinor;
  jump[191] = decodeMapIndefinite;
  for (let i7 = 192; i7 <= 215; i7++) {
    jump[i7] = decodeTagCompact;
  }
  jump[216] = decodeTag8;
  jump[217] = decodeTag16;
  jump[218] = decodeTag32;
  jump[219] = decodeTag64;
  jump[220] = invalidMinor;
  jump[221] = invalidMinor;
  jump[222] = invalidMinor;
  jump[223] = invalidMinor;
  for (let i7 = 224; i7 <= 243; i7++) {
    jump[i7] = errorer("simple values are not supported");
  }
  jump[244] = invalidMinor;
  jump[245] = invalidMinor;
  jump[246] = invalidMinor;
  jump[247] = decodeUndefined;
  jump[248] = errorer("simple values are not supported");
  jump[249] = decodeFloat16;
  jump[250] = decodeFloat32;
  jump[251] = decodeFloat64;
  jump[252] = invalidMinor;
  jump[253] = invalidMinor;
  jump[254] = invalidMinor;
  jump[255] = decodeBreak;
  var quick = [];
  for (let i7 = 0; i7 < 24; i7++) {
    quick[i7] = new Token(Type.uint, i7, 1);
  }
  for (let i7 = -1; i7 >= -24; i7--) {
    quick[31 - i7] = new Token(Type.negint, i7, 1);
  }
  quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
  quick[96] = new Token(Type.string, "", 1);
  quick[128] = new Token(Type.array, 0, 1);
  quick[160] = new Token(Type.map, 0, 1);
  quick[244] = new Token(Type.false, false, 1);
  quick[245] = new Token(Type.true, true, 1);
  quick[246] = new Token(Type.null, null, 1);
  function quickEncodeToken(token) {
    switch (token.type) {
      case Type.false:
        return fromArray([244]);
      case Type.true:
        return fromArray([245]);
      case Type.null:
        return fromArray([246]);
      case Type.bytes:
        if (!token.value.length) {
          return fromArray([64]);
        }
        return;
      case Type.string:
        if (token.value === "") {
          return fromArray([96]);
        }
        return;
      case Type.array:
        if (token.value === 0) {
          return fromArray([128]);
        }
        return;
      case Type.map:
        if (token.value === 0) {
          return fromArray([160]);
        }
        return;
      case Type.uint:
        if (token.value < 24) {
          return fromArray([Number(token.value)]);
        }
        return;
      case Type.negint:
        if (token.value >= -24) {
          return fromArray([31 - Number(token.value)]);
        }
    }
  }

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/encode.js
  var defaultEncodeOptions = {
    float64: false,
    mapSorter,
    quickEncodeToken
  };
  function makeCborEncoders() {
    const encoders = [];
    encoders[Type.uint.major] = encodeUint;
    encoders[Type.negint.major] = encodeNegint;
    encoders[Type.bytes.major] = encodeBytes;
    encoders[Type.string.major] = encodeString;
    encoders[Type.array.major] = encodeArray;
    encoders[Type.map.major] = encodeMap;
    encoders[Type.tag.major] = encodeTag;
    encoders[Type.float.major] = encodeFloat;
    return encoders;
  }
  var cborEncoders = makeCborEncoders();
  var buf = new Bl();
  var Ref = class _Ref {
    /**
     * @param {object|any[]} obj
     * @param {Reference|undefined} parent
     */
    constructor(obj, parent) {
      this.obj = obj;
      this.parent = parent;
    }
    /**
     * @param {object|any[]} obj
     * @returns {boolean}
     */
    includes(obj) {
      let p7 = this;
      do {
        if (p7.obj === obj) {
          return true;
        }
      } while (p7 = p7.parent);
      return false;
    }
    /**
     * @param {Reference|undefined} stack
     * @param {object|any[]} obj
     * @returns {Reference}
     */
    static createCheck(stack, obj) {
      if (stack && stack.includes(obj)) {
        throw new Error(`${encodeErrPrefix} object contains circular references`);
      }
      return new _Ref(obj, stack);
    }
  };
  var simpleTokens = {
    null: new Token(Type.null, null),
    undefined: new Token(Type.undefined, void 0),
    true: new Token(Type.true, true),
    false: new Token(Type.false, false),
    emptyArray: new Token(Type.array, 0),
    emptyMap: new Token(Type.map, 0)
  };
  var typeEncoders = {
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    number(obj, _typ, _options, _refStack) {
      if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
        return new Token(Type.float, obj);
      } else if (obj >= 0) {
        return new Token(Type.uint, obj);
      } else {
        return new Token(Type.negint, obj);
      }
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    bigint(obj, _typ, _options, _refStack) {
      if (obj >= BigInt(0)) {
        return new Token(Type.uint, obj);
      } else {
        return new Token(Type.negint, obj);
      }
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    Uint8Array(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, obj);
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    string(obj, _typ, _options, _refStack) {
      return new Token(Type.string, obj);
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    boolean(obj, _typ, _options, _refStack) {
      return obj ? simpleTokens.true : simpleTokens.false;
    },
    /**
     * @param {any} _obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    null(_obj, _typ, _options, _refStack) {
      return simpleTokens.null;
    },
    /**
     * @param {any} _obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    undefined(_obj, _typ, _options, _refStack) {
      return simpleTokens.undefined;
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    ArrayBuffer(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, new Uint8Array(obj));
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    DataView(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} options
     * @param {Reference} [refStack]
     * @returns {TokenOrNestedTokens}
     */
    Array(obj, _typ, options, refStack) {
      if (!obj.length) {
        if (options.addBreakTokens === true) {
          return [simpleTokens.emptyArray, new Token(Type.break)];
        }
        return simpleTokens.emptyArray;
      }
      refStack = Ref.createCheck(refStack, obj);
      const entries3 = [];
      let i7 = 0;
      for (const e9 of obj) {
        entries3[i7++] = objectToTokens(e9, options, refStack);
      }
      if (options.addBreakTokens) {
        return [new Token(Type.array, obj.length), entries3, new Token(Type.break)];
      }
      return [new Token(Type.array, obj.length), entries3];
    },
    /**
     * @param {any} obj
     * @param {string} typ
     * @param {EncodeOptions} options
     * @param {Reference} [refStack]
     * @returns {TokenOrNestedTokens}
     */
    Object(obj, typ, options, refStack) {
      const isMap2 = typ !== "Object";
      const keys = isMap2 ? obj.keys() : Object.keys(obj);
      const length4 = isMap2 ? obj.size : keys.length;
      if (!length4) {
        if (options.addBreakTokens === true) {
          return [simpleTokens.emptyMap, new Token(Type.break)];
        }
        return simpleTokens.emptyMap;
      }
      refStack = Ref.createCheck(refStack, obj);
      const entries3 = [];
      let i7 = 0;
      for (const key of keys) {
        entries3[i7++] = [
          objectToTokens(key, options, refStack),
          objectToTokens(isMap2 ? obj.get(key) : obj[key], options, refStack)
        ];
      }
      sortMapEntries(entries3, options);
      if (options.addBreakTokens) {
        return [new Token(Type.map, length4), entries3, new Token(Type.break)];
      }
      return [new Token(Type.map, length4), entries3];
    }
  };
  typeEncoders.Map = typeEncoders.Object;
  typeEncoders.Buffer = typeEncoders.Uint8Array;
  for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
    typeEncoders[`${typ}Array`] = typeEncoders.DataView;
  }
  function objectToTokens(obj, options = {}, refStack) {
    const typ = is(obj);
    const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
    options.typeEncoders[typ] || typeEncoders[typ];
    if (typeof customTypeEncoder === "function") {
      const tokens = customTypeEncoder(obj, typ, options, refStack);
      if (tokens != null) {
        return tokens;
      }
    }
    const typeEncoder = typeEncoders[typ];
    if (!typeEncoder) {
      throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
    }
    return typeEncoder(obj, typ, options, refStack);
  }
  function sortMapEntries(entries3, options) {
    if (options.mapSorter) {
      entries3.sort(options.mapSorter);
    }
  }
  function mapSorter(e1, e22) {
    const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
    const keyToken2 = Array.isArray(e22[0]) ? e22[0][0] : e22[0];
    if (keyToken1.type !== keyToken2.type) {
      return keyToken1.type.compare(keyToken2.type);
    }
    const major = keyToken1.type.major;
    const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
    if (tcmp === 0) {
      console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
    }
    return tcmp;
  }
  function tokensToEncoded(buf3, tokens, encoders, options) {
    if (Array.isArray(tokens)) {
      for (const token of tokens) {
        tokensToEncoded(buf3, token, encoders, options);
      }
    } else {
      encoders[tokens.type.major](buf3, tokens, options);
    }
  }
  function encodeCustom(data, encoders, options) {
    const tokens = objectToTokens(data, options);
    if (!Array.isArray(tokens) && options.quickEncodeToken) {
      const quickBytes = options.quickEncodeToken(tokens);
      if (quickBytes) {
        return quickBytes;
      }
      const encoder2 = encoders[tokens.type.major];
      if (encoder2.encodedSize) {
        const size = encoder2.encodedSize(tokens, options);
        const buf3 = new Bl(size);
        encoder2(buf3, tokens, options);
        if (buf3.chunks.length !== 1) {
          throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
        }
        return asU8A(buf3.chunks[0]);
      }
    }
    buf.reset();
    tokensToEncoded(buf, tokens, encoders, options);
    return buf.toBytes(true);
  }
  function encode3(data, options) {
    options = Object.assign({}, defaultEncodeOptions, options);
    return encodeCustom(data, cborEncoders, options);
  }

  // node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/decode.js
  init_dirname();
  init_buffer2();
  init_process2();
  var defaultDecodeOptions = {
    strict: false,
    allowIndefinite: true,
    allowUndefined: true,
    allowBigInt: true
  };
  var Tokeniser = class {
    /**
     * @param {Uint8Array} data
     * @param {DecodeOptions} options
     */
    constructor(data, options = {}) {
      this._pos = 0;
      this.data = data;
      this.options = options;
    }
    pos() {
      return this._pos;
    }
    done() {
      return this._pos >= this.data.length;
    }
    next() {
      const byt = this.data[this._pos];
      let token = quick[byt];
      if (token === void 0) {
        const decoder2 = jump[byt];
        if (!decoder2) {
          throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
        }
        const minor = byt & 31;
        token = decoder2(this.data, this._pos, minor, this.options);
      }
      this._pos += token.encodedLength;
      return token;
    }
  };
  var DONE = Symbol.for("DONE");
  var BREAK3 = Symbol.for("BREAK");
  function tokenToArray(token, tokeniser, options) {
    const arr = [];
    for (let i7 = 0; i7 < token.value; i7++) {
      const value = tokensToObject(tokeniser, options);
      if (value === BREAK3) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
      }
      if (value === DONE) {
        throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i7}, expected ${token.value})`);
      }
      arr[i7] = value;
    }
    return arr;
  }
  function tokenToMap(token, tokeniser, options) {
    const useMaps = options.useMaps === true;
    const obj = useMaps ? void 0 : {};
    const m6 = useMaps ? /* @__PURE__ */ new Map() : void 0;
    for (let i7 = 0; i7 < token.value; i7++) {
      const key = tokensToObject(tokeniser, options);
      if (key === BREAK3) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
      }
      if (key === DONE) {
        throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i7} [no key], expected ${token.value})`);
      }
      if (useMaps !== true && typeof key !== "string") {
        throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
      }
      if (options.rejectDuplicateMapKeys === true) {
        if (useMaps && m6.has(key) || !useMaps && key in obj) {
          throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
        }
      }
      const value = tokensToObject(tokeniser, options);
      if (value === DONE) {
        throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i7} [no value], expected ${token.value})`);
      }
      if (useMaps) {
        m6.set(key, value);
      } else {
        obj[key] = value;
      }
    }
    return useMaps ? m6 : obj;
  }
  function tokensToObject(tokeniser, options) {
    if (tokeniser.done()) {
      return DONE;
    }
    const token = tokeniser.next();
    if (token.type === Type.break) {
      return BREAK3;
    }
    if (token.type.terminal) {
      return token.value;
    }
    if (token.type === Type.array) {
      return tokenToArray(token, tokeniser, options);
    }
    if (token.type === Type.map) {
      return tokenToMap(token, tokeniser, options);
    }
    if (token.type === Type.tag) {
      if (options.tags && typeof options.tags[token.value] === "function") {
        const tagged = tokensToObject(tokeniser, options);
        return options.tags[token.value](tagged);
      }
      throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
    }
    throw new Error("unsupported");
  }
  function decodeFirst(data, options) {
    if (!(data instanceof Uint8Array)) {
      throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
    }
    options = Object.assign({}, defaultDecodeOptions, options);
    const tokeniser = options.tokenizer || new Tokeniser(data, options);
    const decoded = tokensToObject(tokeniser, options);
    if (decoded === DONE) {
      throw new Error(`${decodeErrPrefix} did not find any content to decode`);
    }
    if (decoded === BREAK3) {
      throw new Error(`${decodeErrPrefix} got unexpected break`);
    }
    return [decoded, data.subarray(tokeniser.pos())];
  }
  function decode5(data, options) {
    const [decoded, remainder] = decodeFirst(data, options);
    if (remainder.length > 0) {
      throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
    }
    return decoded;
  }

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/cid.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports = {};
  __export(base32_exports, {
    base32: () => base322,
    base32hex: () => base32hex2,
    base32hexpad: () => base32hexpad2,
    base32hexpadupper: () => base32hexpadupper2,
    base32hexupper: () => base32hexupper2,
    base32pad: () => base32pad2,
    base32padupper: () => base32padupper2,
    base32upper: () => base32upper2,
    base32z: () => base32z2
  });
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bytes.js
  var bytes_exports3 = {};
  __export(bytes_exports3, {
    coerce: () => coerce2,
    empty: () => empty2,
    equals: () => equals3,
    fromHex: () => fromHex2,
    fromString: () => fromString3,
    isBinary: () => isBinary2,
    toHex: () => toHex2,
    toString: () => toString3
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var empty2 = new Uint8Array(0);
  function toHex2(d6) {
    return d6.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
  }
  function fromHex2(hex) {
    const hexes = hex.match(/../g);
    return hexes != null ? new Uint8Array(hexes.map((b5) => parseInt(b5, 16))) : empty2;
  }
  function equals3(aa, bb) {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce2(o8) {
    if (o8 instanceof Uint8Array && o8.constructor.name === "Uint8Array")
      return o8;
    if (o8 instanceof ArrayBuffer)
      return new Uint8Array(o8);
    if (ArrayBuffer.isView(o8)) {
      return new Uint8Array(o8.buffer, o8.byteOffset, o8.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function isBinary2(o8) {
    return o8 instanceof ArrayBuffer || ArrayBuffer.isView(o8);
  }
  function fromString3(str) {
    return new TextEncoder().encode(str);
  }
  function toString3(b5) {
    return new TextDecoder().decode(b5);
  }

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/vendor/base-x.js
  init_dirname();
  init_buffer2();
  init_process2();
  function base2(ALPHABET, name8) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j4 = 0; j4 < BASE_MAP.length; j4++) {
      BASE_MAP[j4] = 255;
    }
    for (var i7 = 0; i7 < ALPHABET.length; i7++) {
      var x4 = ALPHABET.charAt(i7);
      var xc = x4.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x4 + " is ambiguous");
      }
      BASE_MAP[xc] = i7;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode18(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length4 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i8 = 0;
        for (var it1 = size - 1; (carry !== 0 || i8 < length4) && it1 !== -1; it1--, i8++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i8;
        pbegin++;
      }
      var it2 = size - length4;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length4 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i8 = 0;
        for (var it3 = size - 1; (carry !== 0 || i8 < length4) && it3 !== -1; it3--, i8++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i8;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length4;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j5 = zeroes;
      while (it4 !== size) {
        vch[j5++] = b256[it4++];
      }
      return vch;
    }
    function decode21(string3) {
      var buffer4 = decodeUnsafe(string3);
      if (buffer4) {
        return buffer4;
      }
      throw new Error(`Non-${name8} character`);
    }
    return {
      encode: encode18,
      decodeUnsafe,
      decode: decode21
    };
  }
  var src2 = base2;
  var _brrp__multiformats_scope_baseX2 = src2;
  var base_x_default2 = _brrp__multiformats_scope_baseX2;

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base.js
  var Encoder2 = class {
    name;
    prefix;
    baseEncode;
    constructor(name8, prefix, baseEncode) {
      this.name = name8;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder2 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name8, prefix, baseDecode) {
      this.name = name8;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder2) {
      return or2(this, decoder2);
    }
  };
  var ComposedDecoder2 = class {
    decoders;
    constructor(decoders) {
      this.decoders = decoders;
    }
    or(decoder2) {
      return or2(this, decoder2);
    }
    decode(input) {
      const prefix = input[0];
      const decoder2 = this.decoders[prefix];
      if (decoder2 != null) {
        return decoder2.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or2(left, right) {
    return new ComposedDecoder2({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec2 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name8, prefix, baseEncode, baseDecode) {
      this.name = name8;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder2(name8, prefix, baseEncode);
      this.decoder = new Decoder2(name8, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from4({ name: name8, prefix, encode: encode18, decode: decode21 }) {
    return new Codec2(name8, prefix, encode18, decode21);
  }
  function baseX2({ name: name8, prefix, alphabet: alphabet2 }) {
    const { encode: encode18, decode: decode21 } = base_x_default2(alphabet2, name8);
    return from4({
      prefix,
      name: name8,
      encode: encode18,
      decode: (text) => coerce2(decode21(text))
    });
  }
  function decode6(string3, alphabet2, bitsPerChar, name8) {
    const codes = {};
    for (let i7 = 0; i7 < alphabet2.length; ++i7) {
      codes[alphabet2[i7]] = i7;
    }
    let end = string3.length;
    while (string3[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer4 = 0;
    let written = 0;
    for (let i7 = 0; i7 < end; ++i7) {
      const value = codes[string3[i7]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name8} character`);
      }
      buffer4 = buffer4 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer4 >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer4 << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode4(data, alphabet2, bitsPerChar) {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer4 = 0;
    for (let i7 = 0; i7 < data.length; ++i7) {
      buffer4 = buffer4 << 8 | data[i7];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet2[mask & buffer4 >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet2[mask & buffer4 << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function rfc46482({ name: name8, prefix, bitsPerChar, alphabet: alphabet2 }) {
    return from4({
      prefix,
      name: name8,
      encode(input) {
        return encode4(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode6(input, alphabet2, bitsPerChar, name8);
      }
    });
  }

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base32.js
  var base322 = rfc46482({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper2 = rfc46482({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad2 = rfc46482({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper2 = rfc46482({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex2 = rfc46482({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper2 = rfc46482({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad2 = rfc46482({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper2 = rfc46482({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z2 = rfc46482({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports = {};
  __export(base58_exports, {
    base58btc: () => base58btc2,
    base58flickr: () => base58flickr2
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var base58btc2 = baseX2({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr2 = baseX2({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/digest.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/varint.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/vendor/varint.js
  init_dirname();
  init_buffer2();
  init_process2();
  var encode_12 = encode5;
  var MSB2 = 128;
  var REST2 = 127;
  var MSBALL2 = ~REST2;
  var INT2 = Math.pow(2, 31);
  function encode5(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT2) {
      out[offset++] = num & 255 | MSB2;
      num /= 128;
    }
    while (num & MSBALL2) {
      out[offset++] = num & 255 | MSB2;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode5.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode7 = read3;
  var MSB$12 = 128;
  var REST$12 = 127;
  function read3(buf3, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b5, l7 = buf3.length;
    do {
      if (counter >= l7) {
        read3.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b5 = buf3[counter++];
      res += shift < 28 ? (b5 & REST$12) << shift : (b5 & REST$12) * Math.pow(2, shift);
      shift += 7;
    } while (b5 >= MSB$12);
    read3.bytes = counter - offset;
    return res;
  }
  var N12 = Math.pow(2, 7);
  var N23 = Math.pow(2, 14);
  var N33 = Math.pow(2, 21);
  var N42 = Math.pow(2, 28);
  var N52 = Math.pow(2, 35);
  var N62 = Math.pow(2, 42);
  var N72 = Math.pow(2, 49);
  var N82 = Math.pow(2, 56);
  var N92 = Math.pow(2, 63);
  var length2 = function(value) {
    return value < N12 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
  };
  var varint2 = {
    encode: encode_12,
    decode: decode7,
    encodingLength: length2
  };
  var _brrp_varint2 = varint2;
  var varint_default2 = _brrp_varint2;

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/varint.js
  function decode8(data, offset = 0) {
    const code9 = varint_default2.decode(data, offset);
    return [code9, varint_default2.decode.bytes];
  }
  function encodeTo2(int3, target, offset = 0) {
    varint_default2.encode(int3, target, offset);
    return target;
  }
  function encodingLength2(int3) {
    return varint_default2.encodingLength(int3);
  }

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/digest.js
  function create2(code9, digest3) {
    const size = digest3.byteLength;
    const sizeOffset = encodingLength2(code9);
    const digestOffset = sizeOffset + encodingLength2(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo2(code9, bytes, 0);
    encodeTo2(size, bytes, sizeOffset);
    bytes.set(digest3, digestOffset);
    return new Digest2(code9, size, digest3, bytes);
  }
  function decode9(multihash) {
    const bytes = coerce2(multihash);
    const [code9, sizeOffset] = decode8(bytes);
    const [size, digestOffset] = decode8(bytes.subarray(sizeOffset));
    const digest3 = bytes.subarray(sizeOffset + digestOffset);
    if (digest3.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest2(code9, size, digest3, bytes);
  }
  function equals4(a7, b5) {
    if (a7 === b5) {
      return true;
    } else {
      const data = b5;
      return a7.code === data.code && a7.size === data.size && data.bytes instanceof Uint8Array && equals3(a7.bytes, data.bytes);
    }
  }
  var Digest2 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code9, size, digest3, bytes) {
      this.code = code9;
      this.size = size;
      this.digest = digest3;
      this.bytes = bytes;
    }
  };

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/link/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/cid.js
  function format6(link4, base3) {
    const { bytes, version: version2 } = link4;
    switch (version2) {
      case 0:
        return toStringV02(bytes, baseCache2(link4), base3 ?? base58btc2.encoder);
      default:
        return toStringV12(bytes, baseCache2(link4), base3 ?? base322.encoder);
    }
  }
  var cache2 = /* @__PURE__ */ new WeakMap();
  function baseCache2(cid) {
    const baseCache3 = cache2.get(cid);
    if (baseCache3 == null) {
      const baseCache4 = /* @__PURE__ */ new Map();
      cache2.set(cid, baseCache4);
      return baseCache4;
    }
    return baseCache3;
  }
  var CID2 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version2, code9, multihash, bytes) {
      this.code = code9;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes;
      this["/"] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code9, multihash } = this;
          if (code9 !== DAG_PB_CODE2) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE2) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code9, digest: digest3 } = this.multihash;
          const multihash = create2(code9, digest3);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals4(self2.multihash, unknown.multihash);
    }
    toString(base3) {
      return format6(this, base3);
    }
    toJSON() {
      return { "/": format6(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version2, code: code9, multihash, bytes } = value;
        return new _CID(version2, code9, multihash, bytes ?? encodeCID2(version2, code9, multihash.bytes));
      } else if (value[cidSymbol2] === true) {
        const { version: version2, multihash, code: code9 } = value;
        const digest3 = decode9(multihash);
        return _CID.create(version2, code9, digest3);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version2, code9, digest3) {
      if (typeof code9 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest3.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version2) {
        case 0: {
          if (code9 !== DAG_PB_CODE2) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
          } else {
            return new _CID(version2, code9, digest3, digest3.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID2(version2, code9, digest3.bytes);
          return new _CID(version2, code9, digest3, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest3) {
      return _CID.create(0, DAG_PB_CODE2, digest3);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code9, digest3) {
      return _CID.create(1, code9, digest3);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes) {
      const [cid, remainder] = _CID.decodeFirst(bytes);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes) {
      const specs = _CID.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce2(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest3 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest3) : _CID.createV1(specs.codec, digest3);
      return [cid, bytes.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i7, length4] = decode8(initialBytes.subarray(offset));
        offset += length4;
        return i7;
      };
      let version2 = next();
      let codec = DAG_PB_CODE2;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version2, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base3) {
      const [prefix, bytes] = parseCIDtoBytes2(source, base3);
      const cid = _CID.decode(bytes);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache2(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes2(source, base3) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder2 = base3 ?? base58btc2;
        return [
          base58btc2.prefix,
          decoder2.decode(`${base58btc2.prefix}${source}`)
        ];
      }
      case base58btc2.prefix: {
        const decoder2 = base3 ?? base58btc2;
        return [base58btc2.prefix, decoder2.decode(source)];
      }
      case base322.prefix: {
        const decoder2 = base3 ?? base322;
        return [base322.prefix, decoder2.decode(source)];
      }
      default: {
        if (base3 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base3.decode(source)];
      }
    }
  }
  function toStringV02(bytes, cache3, base3) {
    const { prefix } = base3;
    if (prefix !== base58btc2.prefix) {
      throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
    }
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes).slice(1);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV12(bytes, cache3, base3) {
    const { prefix } = base3;
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE2 = 112;
  var SHA_256_CODE2 = 18;
  function encodeCID2(version2, code9, multihash) {
    const codeOffset = encodingLength2(version2);
    const hashOffset = codeOffset + encodingLength2(code9);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo2(version2, bytes, 0);
    encodeTo2(code9, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  }
  var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

  // node_modules/.pnpm/@ipld+dag-cbor@9.2.1/node_modules/@ipld/dag-cbor/src/index.js
  var CID_CBOR_TAG = 42;
  function toByteView(buf3) {
    if (buf3 instanceof ArrayBuffer) {
      return new Uint8Array(buf3, 0, buf3.byteLength);
    }
    return buf3;
  }
  function cidEncoder(obj) {
    if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
      return null;
    }
    const cid = CID2.asCID(obj);
    if (!cid) {
      return null;
    }
    const bytes = new Uint8Array(cid.bytes.byteLength + 1);
    bytes.set(cid.bytes, 1);
    return [
      new Token(Type.tag, CID_CBOR_TAG),
      new Token(Type.bytes, bytes)
    ];
  }
  function undefinedEncoder() {
    throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
  }
  function numberEncoder(num) {
    if (Number.isNaN(num)) {
      throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
    }
    if (num === Infinity || num === -Infinity) {
      throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
    }
    return null;
  }
  var _encodeOptions = {
    float64: true,
    typeEncoders: {
      Object: cidEncoder,
      undefined: undefinedEncoder,
      number: numberEncoder
    }
  };
  var encodeOptions = {
    ..._encodeOptions,
    typeEncoders: {
      ..._encodeOptions.typeEncoders
    }
  };
  function cidDecoder(bytes) {
    if (bytes[0] !== 0) {
      throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
    }
    return CID2.decode(bytes.subarray(1));
  }
  var _decodeOptions = {
    allowIndefinite: false,
    coerceUndefinedToNull: true,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // this will lead to BigInt for ints outside of
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */
    tags: []
  };
  _decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
  var decodeOptions = {
    ..._decodeOptions,
    tags: _decodeOptions.tags.slice()
  };
  var name2 = "dag-cbor";
  var code = 113;
  var encode6 = (node) => encode3(node, _encodeOptions);
  var decode10 = (data) => decode5(toByteView(data), _decodeOptions);

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/crdt/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/crdt/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/clock/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/block.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/hasher.js
  init_dirname();
  init_buffer2();
  init_process2();
  function from5({ name: name8, code: code9, encode: encode18 }) {
    return new Hasher2(name8, code9, encode18);
  }
  var Hasher2 = class {
    name;
    code;
    encode;
    constructor(name8, code9, encode18) {
      this.name = name8;
      this.code = code9;
      this.encode = encode18;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest3) => create2(this.code, digest3));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/codecs/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/block/interface.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/block.js
  function readonly2({ enumerable = true, configurable = false } = {}) {
    return { enumerable, configurable, writable: false };
  }
  function* linksWithin2(path2, value) {
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index2, element] of value.entries()) {
          const elementPath = [...path2, index2];
          const cid = CID2.asCID(element);
          if (cid != null) {
            yield [elementPath.join("/"), cid];
          } else if (typeof element === "object") {
            yield* links2(element, elementPath);
          }
        }
      } else {
        const cid = CID2.asCID(value);
        if (cid != null) {
          yield [path2.join("/"), cid];
        } else {
          yield* links2(value, path2);
        }
      }
    }
  }
  function* links2(source, base3) {
    if (source == null || source instanceof Uint8Array) {
      return;
    }
    const cid = CID2.asCID(source);
    if (cid != null) {
      yield [base3.join("/"), cid];
    }
    for (const [key, value] of Object.entries(source)) {
      const path2 = [...base3, key];
      yield* linksWithin2(path2, value);
    }
  }
  function* treeWithin2(path2, value) {
    if (Array.isArray(value)) {
      for (const [index2, element] of value.entries()) {
        const elementPath = [...path2, index2];
        yield elementPath.join("/");
        if (typeof element === "object" && CID2.asCID(element) == null) {
          yield* tree2(element, elementPath);
        }
      }
    } else {
      yield* tree2(value, path2);
    }
  }
  function* tree2(source, base3) {
    if (source == null || typeof source !== "object") {
      return;
    }
    for (const [key, value] of Object.entries(source)) {
      const path2 = [...base3, key];
      yield path2.join("/");
      if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && CID2.asCID(value) == null) {
        yield* treeWithin2(path2, value);
      }
    }
  }
  function get2(source, path2) {
    let node = source;
    for (const [index2, key] of path2.entries()) {
      node = node[key];
      if (node == null) {
        throw new Error(`Object has no property at ${path2.slice(0, index2 + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
      }
      const cid = CID2.asCID(node);
      if (cid != null) {
        return { value: cid, remaining: path2.slice(index2 + 1).join("/") };
      }
    }
    return { value: node };
  }
  var Block2 = class {
    cid;
    bytes;
    value;
    asBlock;
    constructor({ cid, bytes, value }) {
      if (cid == null || bytes == null || typeof value === "undefined") {
        throw new Error("Missing required argument");
      }
      this.cid = cid;
      this.bytes = bytes;
      this.value = value;
      this.asBlock = this;
      Object.defineProperties(this, {
        cid: readonly2(),
        bytes: readonly2(),
        value: readonly2(),
        asBlock: readonly2()
      });
    }
    links() {
      return links2(this.value, []);
    }
    tree() {
      return tree2(this.value, []);
    }
    get(path2 = "/") {
      return get2(this.value, path2.split("/").filter(Boolean));
    }
  };
  async function encode7({ value, codec, hasher }) {
    if (typeof value === "undefined")
      throw new Error('Missing required argument "value"');
    if (codec == null || hasher == null)
      throw new Error("Missing required argument: codec or hasher");
    const bytes = codec.encode(value);
    const hash2 = await hasher.digest(bytes);
    const cid = CID2.create(1, codec.code, hash2);
    return new Block2({ value, bytes, cid });
  }
  async function decode11({ bytes, codec, hasher }) {
    if (bytes == null)
      throw new Error('Missing required argument "bytes"');
    if (codec == null || hasher == null)
      throw new Error("Missing required argument: codec or hasher");
    const value = codec.decode(bytes);
    const hash2 = await hasher.digest(bytes);
    const cid = CID2.create(1, codec.code, hash2);
    return new Block2({ value, bytes, cid });
  }

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports = {};
  __export(sha2_browser_exports, {
    sha256: () => sha2562,
    sha512: () => sha5122
  });
  init_dirname();
  init_buffer2();
  init_process2();
  function sha2(name8) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name8, data));
  }
  var sha2562 = from5({
    name: "sha2-256",
    code: 18,
    encode: sha2("SHA-256")
  });
  var sha5122 = from5({
    name: "sha2-512",
    code: 19,
    encode: sha2("SHA-512")
  });

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/clock/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/clock/index.js
  var advance = async (blocks, head, event) => {
    const events = new EventFetcher(blocks);
    const headmap = new Map(head.map((cid) => [cid.toString(), cid]));
    if (headmap.has(event.toString())) return head;
    let changed = false;
    for (const cid of head) {
      if (await contains(events, event, cid)) {
        headmap.delete(cid.toString());
        headmap.set(event.toString(), event);
        changed = true;
      }
    }
    if (changed) {
      return [...headmap.values()];
    }
    for (const p7 of head) {
      if (await contains(events, p7, event)) {
        return head;
      }
    }
    return head.concat(event);
  };
  var EventBlock = class extends Block2 {
    /**
     * @param {object} config
     * @param {API.EventLink<T>} config.cid
     * @param {Event} config.value
     * @param {Uint8Array} config.bytes
     * @param {string} config.prefix
     */
    constructor({ cid, value, bytes, prefix }) {
      super({ cid, value, bytes });
      this.prefix = prefix;
    }
    /**
     * @template T
     * @param {T} data
     * @param {API.EventLink<T>[]} [parents]
     */
    static create(data, parents) {
      return encodeEventBlock({ data, parents: parents ?? [] });
    }
  };
  var EventFetcher = class {
    /** @param {API.BlockFetcher} blocks */
    constructor(blocks) {
      this._blocks = blocks;
    }
    /**
     * @param {API.EventLink<T>} link
     * @returns {Promise<API.EventBlockView<T>>}
     */
    async get(link4) {
      const block = await this._blocks.get(link4);
      if (!block) throw new Error(`missing block: ${link4}`);
      return decodeEventBlock(block.bytes);
    }
  };
  var encodeEventBlock = async (value) => {
    const { cid, bytes } = await encode7({ value, codec: src_exports, hasher: sha2562 });
    return new Block2({ cid, value, bytes });
  };
  var decodeEventBlock = async (bytes) => {
    const { cid, value } = await decode11({ bytes, codec: src_exports, hasher: sha2562 });
    return new Block2({ cid, value, bytes });
  };
  var contains = async (events, a7, b5) => {
    if (a7.toString() === b5.toString()) return true;
    const [{ value: aevent }, { value: bevent }] = await Promise.all([events.get(a7), events.get(b5)]);
    const links4 = [...aevent.parents];
    const seen = /* @__PURE__ */ new Set();
    while (links4.length) {
      const link4 = links4.shift();
      if (!link4) break;
      if (link4.toString() === b5.toString()) return true;
      if (bevent.parents.some((p7) => link4.toString() === p7.toString())) continue;
      if (seen.has(link4.toString())) continue;
      seen.add(link4.toString());
      const { value: event } = await events.get(link4);
      links4.push(...event.parents);
    }
    return false;
  };
  var vis = async function* (blocks, head, options = {}) {
    const renderNodeLabel = options.renderNodeLabel ?? ((b5) => shortLink(b5.cid));
    const events = new EventFetcher(blocks);
    yield "digraph clock {";
    yield '  node [shape=point fontname="Courier"]; head;';
    const hevents = await Promise.all(head.map((link4) => events.get(link4)));
    const links4 = [];
    const nodes = /* @__PURE__ */ new Set();
    for (const e9 of hevents) {
      nodes.add(e9.cid.toString());
      yield `  node [shape=oval fontname="Courier"]; ${e9.cid} [label="${renderNodeLabel(e9)}"];`;
      yield `  head -> ${e9.cid};`;
      for (const p7 of e9.value.parents) {
        yield `  ${e9.cid} -> ${p7};`;
      }
      links4.push(...e9.value.parents);
    }
    while (links4.length) {
      const link4 = links4.shift();
      if (!link4) break;
      if (nodes.has(link4.toString())) continue;
      nodes.add(link4.toString());
      const block = await events.get(link4);
      yield `  node [shape=oval]; ${link4} [label="${renderNodeLabel(block)}" fontname="Courier"];`;
      for (const p7 of block.value.parents) {
        yield `  ${link4} -> ${p7};`;
      }
      links4.push(...block.value.parents);
    }
    yield "}";
  };
  var shortLink = (l7) => `${String(l7).slice(0, 4)}..${String(l7).slice(-4)}`;

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/shard.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/link.js
  init_dirname();
  init_buffer2();
  init_process2();
  function isLink(value) {
    if (value == null) {
      return false;
    }
    const withSlash = value;
    if (withSlash["/"] != null && withSlash["/"] === withSlash.bytes) {
      return true;
    }
    const withAsCID = value;
    if (withAsCID.asCID === value) {
      return true;
    }
    return false;
  }
  function parse5(source, base3) {
    return CID2.parse(source, base3);
  }

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/shard.js
  var KeyCharsASCII = "ascii";
  var MaxKeySize = 4096;
  var ShardBlock = class extends Block2 {
    /**
     * @param {object} config
     * @param {API.ShardLink} config.cid
     * @param {API.Shard} config.value
     * @param {Uint8Array} config.bytes
     */
    constructor({ cid, value, bytes }) {
      super({ cid, value, bytes });
    }
    /** @param {API.ShardOptions} [options] */
    static create(options) {
      return encodeBlock(create3(options));
    }
  };
  var create3 = (options) => ({ entries: [], ...configure(options) });
  var configure = (options) => ({
    version: 1,
    keyChars: options?.keyChars ?? KeyCharsASCII,
    maxKeySize: options?.maxKeySize ?? MaxKeySize,
    prefix: options?.prefix ?? ""
  });
  var withEntries = (entries3, options) => ({ ...create3(options), entries: entries3 });
  var decodeCache = /* @__PURE__ */ new WeakMap();
  var encodeBlock = async (value) => {
    const { cid, bytes } = await encode7({ value, codec: src_exports, hasher: sha2562 });
    const block = new ShardBlock({ cid, value, bytes });
    decodeCache.set(block.bytes, block);
    return block;
  };
  var decodeBlock = async (bytes) => {
    const block = decodeCache.get(bytes);
    if (block) return block;
    const { cid, value } = await decode11({ bytes, codec: src_exports, hasher: sha2562 });
    if (!isShard(value)) throw new Error(`invalid shard: ${cid}`);
    return new ShardBlock({ cid, value, bytes });
  };
  var isShard = (value) => value != null && typeof value === "object" && Array.isArray(value.entries) && value.version === 1 && typeof value.maxKeySize === "number" && typeof value.keyChars === "string" && typeof value.prefix === "string";
  var isShardLink = (value) => isLink(value) && value.code === code;
  var ShardFetcher = class {
    /** @param {API.BlockFetcher} blocks */
    constructor(blocks) {
      this._blocks = blocks;
    }
    /**
     * @param {API.ShardLink} link
     * @returns {Promise<API.ShardBlockView>}
     */
    async get(link4) {
      const block = await this._blocks.get(link4);
      if (!block) throw new Error(`missing block: ${link4}`);
      return decodeBlock(block.bytes);
    }
  };
  var putEntry = (target, newEntry) => {
    const entries3 = [];
    for (const [i7, entry] of target.entries()) {
      const [k4, v6] = entry;
      if (newEntry[0] === k4) {
        if (Array.isArray(newEntry[1])) {
          if (Array.isArray(v6) && v6[1] != null && newEntry[1][1] == null) {
            entries3.push([k4, [newEntry[1][0], v6[1]]]);
          } else {
            entries3.push(newEntry);
          }
        } else {
          if (Array.isArray(v6)) {
            entries3.push([k4, [v6[0], newEntry[1]]]);
          } else {
            entries3.push(newEntry);
          }
        }
        for (let j4 = i7 + 1; j4 < target.length; j4++) {
          entries3.push(target[j4]);
        }
        return entries3;
      }
      if (i7 === 0 && newEntry[0] < k4) {
        entries3.push(newEntry);
        for (let j4 = i7; j4 < target.length; j4++) {
          entries3.push(target[j4]);
        }
        return entries3;
      }
      if (i7 > 0 && newEntry[0] > target[i7 - 1][0] && newEntry[0] < k4) {
        entries3.push(newEntry);
        for (let j4 = i7; j4 < target.length; j4++) {
          entries3.push(target[j4]);
        }
        return entries3;
      }
      entries3.push(entry);
    }
    entries3.push(newEntry);
    return entries3;
  };
  var isPrintableASCII = (s6) => /^[\x20-\x7E]*$/.test(s6);

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/index.js
  var put = async (blocks, root2, key, value) => {
    const shards = new ShardFetcher(blocks);
    const rshard = await shards.get(root2);
    if (rshard.value.keyChars !== KeyCharsASCII) {
      throw new Error(`unsupported key character set: ${rshard.value.keyChars}`);
    }
    if (!isPrintableASCII(key)) {
      throw new Error("key contains non-ASCII characters");
    }
    if (new TextEncoder().encode(key).length > rshard.value.maxKeySize) {
      throw new Error(`UTF-8 encoded key exceeds max size of ${rshard.value.maxKeySize} bytes`);
    }
    const path2 = await traverse(shards, rshard, key);
    const target = path2[path2.length - 1];
    const skey = key.slice(target.value.prefix.length);
    let entry = [skey, value];
    let targetEntries = [...target.value.entries];
    const additions = [];
    for (const [i7, e9] of targetEntries.entries()) {
      const [k4, v6] = e9;
      if (k4 === skey) break;
      const shortest = k4.length < skey.length ? k4 : skey;
      const other = shortest === k4 ? skey : k4;
      let common = "";
      for (const char of shortest) {
        const next = common + char;
        if (!other.startsWith(next)) break;
        common = next;
      }
      if (common.length) {
        let entries3 = [];
        if (common !== skey) {
          entries3 = putEntry(entries3, [skey.slice(common.length), value]);
        }
        if (common !== k4) {
          entries3 = putEntry(entries3, [k4.slice(common.length), v6]);
        }
        let child2 = await encodeBlock(
          withEntries(entries3, { ...target.value, prefix: target.value.prefix + common })
        );
        additions.push(child2);
        const commonChars = [...common];
        for (let i8 = commonChars.length - 1; i8 > 0; i8--) {
          const parentConfig = { ...target.value, prefix: target.value.prefix + commonChars.slice(0, i8).join("") };
          let parentValue;
          if (i8 === commonChars.length - 1 && common === k4) {
            if (Array.isArray(v6)) throw new Error("found a shard link when expecting a value");
            parentValue = [child2.cid, v6];
          } else if (i8 === commonChars.length - 1 && common === skey) {
            parentValue = [child2.cid, value];
          } else {
            parentValue = [child2.cid];
          }
          const parent = await encodeBlock(withEntries([[commonChars[i8], parentValue]], parentConfig));
          additions.push(parent);
          child2 = parent;
        }
        targetEntries.splice(i7, 1);
        if (commonChars.length === 1 && common === k4) {
          if (Array.isArray(v6)) throw new Error("found a shard link when expecting a value");
          entry = [commonChars[0], [child2.cid, v6]];
        } else if (commonChars.length === 1 && common === skey) {
          entry = [commonChars[0], [child2.cid, value]];
        } else {
          entry = [commonChars[0], [child2.cid]];
        }
        break;
      }
    }
    const shard = withEntries(putEntry(targetEntries, entry), target.value);
    let child = await encodeBlock(shard);
    if (child.cid.toString() === target.cid.toString()) {
      return { root: root2, additions: [], removals: [] };
    }
    additions.push(child);
    for (let i7 = path2.length - 2; i7 >= 0; i7--) {
      const parent = path2[i7];
      const key2 = child.value.prefix.slice(parent.value.prefix.length);
      const value2 = withEntries(
        parent.value.entries.map((entry2) => {
          const [k4, v6] = entry2;
          if (k4 !== key2) return entry2;
          if (!Array.isArray(v6)) throw new Error(`"${key2}" is not a shard link in: ${parent.cid}`);
          return (
            /** @type {API.ShardEntry} */
            v6[1] == null ? [k4, [child.cid]] : [k4, [child.cid, v6[1]]]
          );
        }),
        parent.value
      );
      child = await encodeBlock(value2);
      additions.push(child);
    }
    return { root: additions[additions.length - 1].cid, additions, removals: path2 };
  };
  var get3 = async (blocks, root2, key) => {
    const shards = new ShardFetcher(blocks);
    const rshard = await shards.get(root2);
    const path2 = await traverse(shards, rshard, key);
    const target = path2[path2.length - 1];
    const skey = key.slice(target.value.prefix.length);
    const entry = target.value.entries.find(([k4]) => k4 === skey);
    if (!entry) return;
    return Array.isArray(entry[1]) ? entry[1][1] : entry[1];
  };
  var del = async (blocks, root2, key) => {
    const shards = new ShardFetcher(blocks);
    const rshard = await shards.get(root2);
    const path2 = await traverse(shards, rshard, key);
    const target = path2[path2.length - 1];
    const skey = key.slice(target.value.prefix.length);
    const entryidx = target.value.entries.findIndex(([k4]) => k4 === skey);
    if (entryidx === -1) return { root: root2, additions: [], removals: [] };
    const entry = target.value.entries[entryidx];
    if (Array.isArray(entry[1]) && entry[1][1] == null) {
      return { root: root2, additions: [], removals: [] };
    }
    const additions = [];
    const removals = [...path2];
    let shard = withEntries([...target.value.entries], target.value);
    if (Array.isArray(entry[1])) {
      shard.entries[entryidx] = [entry[0], [entry[1][0]]];
    } else {
      shard.entries.splice(entryidx, 1);
      while (!shard.entries.length) {
        const child2 = path2[path2.length - 1];
        const parent = path2[path2.length - 2];
        if (!parent) break;
        path2.pop();
        shard = withEntries(
          parent.value.entries.filter((e9) => {
            if (!Array.isArray(e9[1])) return true;
            return e9[1][0].toString() !== child2.cid.toString();
          }),
          parent.value
        );
      }
    }
    let child = await encodeBlock(shard);
    additions.push(child);
    for (let i7 = path2.length - 2; i7 >= 0; i7--) {
      const parent = path2[i7];
      const key2 = child.value.prefix.slice(parent.value.prefix.length);
      const value = withEntries(
        parent.value.entries.map((entry2) => {
          const [k4, v6] = entry2;
          if (k4 !== key2) return entry2;
          if (!Array.isArray(v6)) throw new Error(`"${key2}" is not a shard link in: ${parent.cid}`);
          return (
            /** @type {API.ShardEntry} */
            v6[1] == null ? [k4, [child.cid]] : [k4, [child.cid, v6[1]]]
          );
        }),
        parent.value
      );
      child = await encodeBlock(value);
      additions.push(child);
    }
    return { root: additions[additions.length - 1].cid, additions, removals };
  };
  var isKeyPrefixOption = (options) => {
    const opts = options ?? {};
    return "prefix" in opts && Boolean(opts.prefix);
  };
  var isKeyRangeOption = (options) => {
    const opts = options ?? {};
    return "gt" in opts && Boolean(opts.gt) || "gte" in opts && Boolean(opts.gte) || "lt" in opts && Boolean(opts.lt) || "lte" in opts && Boolean(opts.lte);
  };
  var isKeyLowerBoundRangeOption = (options) => "gt" in options && Boolean(options.gt) || "gte" in options && Boolean(options.gte);
  var isKeyLowerBoundRangeInclusiveOption = (options) => "gte" in options && Boolean(options.gte);
  var isKeyLowerBoundRangeExclusiveOption = (options) => "gt" in options && Boolean(options.gt);
  var isKeyUpperBoundRangeOption = (options) => "lt" in options && Boolean(options.lt) || "lte" in options && Boolean(options.lte);
  var isKeyUpperBoundRangeInclusiveOption = (options) => "lte" in options && Boolean(options.lte);
  var isKeyUpperBoundRangeExclusiveOption = (options) => "lt" in options && Boolean(options.lt);
  var entries = async function* (blocks, root2, options) {
    const hasKeyPrefix = isKeyPrefixOption(options);
    const hasKeyRange = isKeyRangeOption(options);
    const hasKeyLowerBoundRange = hasKeyRange && isKeyLowerBoundRangeOption(options);
    const hasKeyLowerBoundRangeInclusive = hasKeyLowerBoundRange && isKeyLowerBoundRangeInclusiveOption(options);
    const hasKeyLowerBoundRangeExclusive = hasKeyLowerBoundRange && isKeyLowerBoundRangeExclusiveOption(options);
    const hasKeyUpperBoundRange = hasKeyRange && isKeyUpperBoundRangeOption(options);
    const hasKeyUpperBoundRangeInclusive = hasKeyUpperBoundRange && isKeyUpperBoundRangeInclusiveOption(options);
    const hasKeyUpperBoundRangeExclusive = hasKeyUpperBoundRange && isKeyUpperBoundRangeExclusiveOption(options);
    const hasKeyUpperAndLowerBoundRange = hasKeyLowerBoundRange && hasKeyUpperBoundRange;
    const shards = new ShardFetcher(blocks);
    const rshard = await shards.get(root2);
    yield* (
      /** @returns {AsyncIterableIterator<API.ShardValueEntry>} */
      async function* ents(shard) {
        for (const entry of shard.value.entries) {
          const key = shard.value.prefix + entry[0];
          if (Array.isArray(entry[1])) {
            if (entry[1][1]) {
              if (hasKeyPrefix && key.startsWith(options.prefix) || hasKeyUpperAndLowerBoundRange && ((hasKeyLowerBoundRangeExclusive && key > options.gt || hasKeyLowerBoundRangeInclusive && key >= options.gte) && (hasKeyUpperBoundRangeExclusive && key < options.lt || hasKeyUpperBoundRangeInclusive && key <= options.lte)) || hasKeyLowerBoundRangeExclusive && key > options.gt || hasKeyLowerBoundRangeInclusive && key >= options.gte || hasKeyUpperBoundRangeExclusive && key < options.lt || hasKeyUpperBoundRangeInclusive && key <= options.lte || !hasKeyPrefix && !hasKeyRange) {
                yield [key, entry[1][1]];
              }
            }
            if (hasKeyPrefix) {
              if (options.prefix.length <= key.length && !key.startsWith(options.prefix)) {
                continue;
              }
              if (options.prefix.length > key.length && !options.prefix.startsWith(key)) {
                continue;
              }
            } else if (hasKeyLowerBoundRangeExclusive && trunc(key, Math.min(key.length, options.gt.length)) < trunc(options.gt, Math.min(key.length, options.gt.length)) || hasKeyLowerBoundRangeInclusive && trunc(key, Math.min(key.length, options.gte.length)) < trunc(options.gte, Math.min(key.length, options.gte.length)) || hasKeyUpperBoundRangeExclusive && trunc(key, Math.min(key.length, options.lt.length)) > trunc(options.lt, Math.min(key.length, options.lt.length)) || hasKeyUpperBoundRangeInclusive && trunc(key, Math.min(key.length, options.lte.length)) > trunc(options.lte, Math.min(key.length, options.lte.length))) {
              continue;
            }
            yield* ents(await shards.get(entry[1][0]));
          } else {
            if (hasKeyPrefix && key.startsWith(options.prefix) || hasKeyRange && hasKeyUpperAndLowerBoundRange && ((hasKeyLowerBoundRangeExclusive && key > options.gt || hasKeyLowerBoundRangeInclusive && key >= options.gte) && (hasKeyUpperBoundRangeExclusive && key < options.lt || hasKeyUpperBoundRangeInclusive && key <= options.lte)) || hasKeyRange && !hasKeyUpperAndLowerBoundRange && (hasKeyLowerBoundRangeExclusive && key > options.gt || hasKeyLowerBoundRangeInclusive && key >= options.gte || hasKeyUpperBoundRangeExclusive && key < options.lt || hasKeyUpperBoundRangeInclusive && key <= options.lte) || !hasKeyPrefix && !hasKeyRange) {
              yield [key, entry[1]];
            }
          }
        }
      }(rshard)
    );
  };
  var trunc = (str, len) => str.length <= len ? str : str.slice(0, len);
  var traverse = async (shards, shard, key) => {
    for (const [k4, v6] of shard.value.entries) {
      if (key === k4) return [shard];
      if (key.startsWith(k4) && Array.isArray(v6)) {
        const path2 = await traverse(shards, await shards.get(v6[0]), key.slice(k4.length));
        return [shard, ...path2];
      }
    }
    return [shard];
  };

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/block.js
  init_dirname();
  init_buffer2();
  init_process2();
  var MemoryBlockstore = class {
    /** @type {Map<string, Uint8Array>} */
    #blocks = /* @__PURE__ */ new Map();
    /**
     * @param {Array<import('multiformats').Block>} [blocks]
     */
    constructor(blocks) {
      if (blocks) {
        this.#blocks = new Map(blocks.map((b5) => [b5.cid.toString(), b5.bytes]));
      }
    }
    /** @type {API.BlockFetcher['get']} */
    async get(cid) {
      const bytes = this.#blocks.get(cid.toString());
      if (!bytes) return;
      return { cid, bytes };
    }
    /**
     * @param {API.UnknownLink} cid
     * @param {Uint8Array} bytes
     */
    async put(cid, bytes) {
      this.#blocks.set(cid.toString(), bytes);
    }
    /**
     * @param {API.UnknownLink} cid
     * @param {Uint8Array} bytes
     */
    putSync(cid, bytes) {
      this.#blocks.set(cid.toString(), bytes);
    }
    /** @param {API.UnknownLink} cid */
    async delete(cid) {
      this.#blocks.delete(cid.toString());
    }
    /** @param {API.UnknownLink} cid */
    deleteSync(cid) {
      this.#blocks.delete(cid.toString());
    }
    *entries() {
      for (const [str, bytes] of this.#blocks) {
        yield { cid: parse5(str), bytes };
      }
    }
  };
  var MultiBlockFetcher = class {
    /** @type {API.BlockFetcher[]} */
    #fetchers;
    /** @param {API.BlockFetcher[]} fetchers */
    constructor(...fetchers) {
      this.#fetchers = fetchers;
    }
    /** @type {API.BlockFetcher['get']} */
    async get(link4) {
      for (const f7 of this.#fetchers) {
        const v6 = await f7.get(link4);
        if (v6) return v6;
      }
    }
  };

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/batch/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/batch/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/batch/shard.js
  init_dirname();
  init_buffer2();
  init_process2();
  var create4 = (init3) => ({
    base: init3?.base,
    entries: [...init3?.entries ?? []],
    ...configure(init3)
  });

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/batch/index.js
  var Batcher = class _Batcher {
    #committed = false;
    /**
     * @param {object} init
     * @param {API.BlockFetcher} init.blocks Block storage.
     * @param {API.BatcherShardEntry[]} init.entries The entries in this shard.
     * @param {string} init.prefix Key prefix.
     * @param {number} init.version Shard compatibility version.
     * @param {string} init.keyChars Characters allowed in keys, referring to a known character set.
     * @param {number} init.maxKeySize Max key size in bytes.
     * @param {API.ShardBlockView} init.base Original shard this batcher is based on.
     */
    constructor({ blocks, entries: entries3, prefix, version: version2, keyChars, maxKeySize, base: base3 }) {
      this.blocks = blocks;
      this.prefix = prefix;
      this.entries = [...entries3];
      this.base = base3;
      this.version = version2;
      this.keyChars = keyChars;
      this.maxKeySize = maxKeySize;
    }
    /**
     * @param {string} key The key of the value to put.
     * @param {API.UnknownLink} value The value to put.
     * @returns {Promise<void>}
     */
    async put(key, value) {
      if (this.#committed) throw new BatchCommittedError();
      return put2(this.blocks, this, key, value);
    }
    async commit() {
      if (this.#committed) throw new BatchCommittedError();
      this.#committed = true;
      return commit(this);
    }
    /**
     * @param {object} init
     * @param {API.BlockFetcher} init.blocks Block storage.
     * @param {API.ShardLink} init.link CID of the shard block.
     */
    static async create({ blocks, link: link4 }) {
      const shards = new ShardFetcher(blocks);
      const base3 = await shards.get(link4);
      return new _Batcher({ blocks, base: base3, ...base3.value });
    }
  };
  var put2 = async (blocks, shard, key, value) => {
    if (shard.keyChars !== KeyCharsASCII) {
      throw new Error(`unsupported key character set: ${shard.keyChars}`);
    }
    if (!isPrintableASCII(key)) {
      throw new Error("key contains non-ASCII characters");
    }
    if (new TextEncoder().encode(key).length > shard.maxKeySize) {
      throw new Error(`UTF-8 encoded key exceeds max size of ${shard.maxKeySize} bytes`);
    }
    const shards = new ShardFetcher(blocks);
    const dest = await traverse2(shards, shard, key);
    if (dest.shard !== shard) {
      shard = dest.shard;
      key = dest.key;
    }
    let entry = [dest.key, value];
    let targetEntries = [...dest.shard.entries];
    for (const [i7, e9] of targetEntries.entries()) {
      const [k4, v6] = e9;
      if (k4 === dest.key) break;
      const shortest = k4.length < dest.key.length ? k4 : dest.key;
      const other = shortest === k4 ? dest.key : k4;
      let common = "";
      for (const char of shortest) {
        const next = common + char;
        if (!other.startsWith(next)) break;
        common = next;
      }
      if (common.length) {
        let entries3 = [];
        if (common !== dest.key) {
          entries3 = putEntry(entries3, [dest.key.slice(common.length), value]);
        }
        if (common !== k4) {
          entries3 = putEntry(entries3, asShardEntry([k4.slice(common.length), v6]));
        }
        let child = create4({
          ...configure(dest.shard),
          prefix: dest.shard.prefix + common,
          entries: entries3
        });
        const commonChars = [...common];
        for (let i8 = commonChars.length - 1; i8 > 0; i8--) {
          let parentValue;
          if (i8 === commonChars.length - 1 && common === k4) {
            if (Array.isArray(v6)) throw new Error("found a shard link when expecting a value");
            parentValue = [child, v6];
          } else if (i8 === commonChars.length - 1 && common === dest.key) {
            parentValue = [child, value];
          } else {
            parentValue = [child];
          }
          const parent = create4({
            ...configure(dest.shard),
            prefix: dest.shard.prefix + commonChars.slice(0, i8).join(""),
            entries: [[commonChars[i8], parentValue]]
          });
          child = parent;
        }
        targetEntries.splice(i7, 1);
        if (commonChars.length === 1 && common === k4) {
          if (Array.isArray(v6)) throw new Error("found a shard link when expecting a value");
          entry = [commonChars[0], [child, v6]];
        } else if (commonChars.length === 1 && common === dest.key) {
          entry = [commonChars[0], [child, value]];
        } else {
          entry = [commonChars[0], [child]];
        }
        break;
      }
    }
    shard.entries = putEntry(asShardEntries(targetEntries), asShardEntry(entry));
  };
  var traverse2 = async (shards, shard, key) => {
    for (let i7 = 0; i7 < shard.entries.length; i7++) {
      const [k4, v6] = shard.entries[i7];
      if (key <= k4) break;
      if (key.startsWith(k4) && Array.isArray(v6)) {
        if (isShardLink(v6[0])) {
          const blk = await shards.get(v6[0]);
          const batcher = create4({ base: blk, ...blk.value });
          shard.entries[i7] = [k4, v6[1] == null ? [batcher] : [batcher, v6[1]]];
          return traverse2(shards, batcher, key.slice(k4.length));
        }
        return traverse2(shards, v6[0], key.slice(k4.length));
      }
    }
    return { shard, key };
  };
  var commit = async (shard) => {
    const additions = [];
    const removals = [];
    const entries3 = [];
    for (const entry of shard.entries) {
      if (Array.isArray(entry[1]) && !isShardLink(entry[1][0])) {
        const result = await commit(entry[1][0]);
        entries3.push([
          entry[0],
          entry[1][1] == null ? [result.root] : [result.root, entry[1][1]]
        ]);
        additions.push(...result.additions);
        removals.push(...result.removals);
      } else {
        entries3.push(asShardEntry(entry));
      }
    }
    const block = await encodeBlock(withEntries(entries3, shard));
    additions.push(block);
    if (shard.base && shard.base.cid.toString() === block.cid.toString()) {
      return { root: block.cid, additions: [], removals: [] };
    }
    if (shard.base) removals.push(shard.base);
    return { root: block.cid, additions, removals };
  };
  var asShardEntries = (entries3) => (
    /** @type {API.ShardEntry[]} */
    entries3
  );
  var asShardEntry = (entry) => (
    /** @type {API.ShardEntry} */
    entry
  );
  var create5 = (blocks, root2) => Batcher.create({ blocks, link: root2 });
  var BatchCommittedError = class _BatchCommittedError extends Error {
    /**
     * @param {string} [message]
     * @param {ErrorOptions} [options]
     */
    constructor(message2, options) {
      super(message2 ?? "batch already committed", options);
      this.code = _BatchCommittedError.code;
    }
    static code = "ERR_BATCH_COMMITTED";
  };

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/crdt/index.js
  var put3 = async (blocks, head, key, value) => {
    const mblocks = new MemoryBlockstore();
    blocks = new MultiBlockFetcher(mblocks, blocks);
    if (!head.length) {
      const shard = await ShardBlock.create();
      mblocks.putSync(shard.cid, shard.bytes);
      const result2 = await put(blocks, shard.cid, key, value);
      const data2 = { type: "put", root: result2.root, key, value };
      const event2 = await EventBlock.create(data2, head);
      head = await advance(blocks, head, event2.cid);
      return {
        root: result2.root,
        additions: [shard, ...result2.additions],
        removals: result2.removals,
        head,
        event: event2
      };
    }
    const events = new EventFetcher(blocks);
    const ancestor = await findCommonAncestor(events, head);
    if (!ancestor) throw new Error("failed to find common ancestor event");
    const aevent = await events.get(ancestor);
    let { root: root2 } = aevent.value.data;
    const sorted = await findSortedEvents(events, head, ancestor);
    const additions = /* @__PURE__ */ new Map();
    const removals = /* @__PURE__ */ new Map();
    for (const { value: event2 } of sorted) {
      let result2;
      if (event2.data.type === "put") {
        result2 = await put(blocks, root2, event2.data.key, event2.data.value);
      } else if (event2.data.type === "del") {
        result2 = await del(blocks, root2, event2.data.key);
      } else if (event2.data.type === "batch") {
        const batch2 = await create5(blocks, root2);
        for (const op of event2.data.ops) {
          if (op.type !== "put") throw new Error(`unsupported batch operation: ${op.type}`);
          await batch2.put(op.key, op.value);
        }
        result2 = await batch2.commit();
      } else {
        throw new Error(`unknown operation: ${event2.data.type}`);
      }
      root2 = result2.root;
      for (const a7 of result2.additions) {
        mblocks.putSync(a7.cid, a7.bytes);
        additions.set(a7.cid.toString(), a7);
      }
      for (const r9 of result2.removals) {
        removals.set(r9.cid.toString(), r9);
      }
    }
    const result = await put(blocks, root2, key, value);
    if (result.root.toString() === root2.toString()) {
      return { root: root2, additions: [], removals: [], head };
    }
    for (const a7 of result.additions) {
      mblocks.putSync(a7.cid, a7.bytes);
      additions.set(a7.cid.toString(), a7);
    }
    for (const r9 of result.removals) {
      removals.set(r9.cid.toString(), r9);
    }
    const data = { type: "put", root: result.root, key, value };
    const event = await EventBlock.create(data, head);
    mblocks.putSync(event.cid, event.bytes);
    head = await advance(blocks, head, event.cid);
    for (const k4 of removals.keys()) {
      if (additions.has(k4)) {
        additions.delete(k4);
        removals.delete(k4);
      }
    }
    return {
      root: result.root,
      additions: [...additions.values()],
      removals: [...removals.values()],
      head,
      event
    };
  };
  var root = async (blocks, head) => {
    if (!head.length) throw new Error("cannot determine root of headless clock");
    const mblocks = new MemoryBlockstore();
    blocks = new MultiBlockFetcher(mblocks, blocks);
    const events = new EventFetcher(blocks);
    if (head.length === 1) {
      const event = await events.get(head[0]);
      const { root: root3 } = event.value.data;
      return { root: root3, additions: [], removals: [] };
    }
    const ancestor = await findCommonAncestor(events, head);
    if (!ancestor) throw new Error("failed to find common ancestor event");
    const aevent = await events.get(ancestor);
    let { root: root2 } = aevent.value.data;
    const sorted = await findSortedEvents(events, head, ancestor);
    const additions = /* @__PURE__ */ new Map();
    const removals = /* @__PURE__ */ new Map();
    for (const { value: event } of sorted) {
      let result;
      if (event.data.type === "put") {
        result = await put(blocks, root2, event.data.key, event.data.value);
      } else if (event.data.type === "del") {
        result = await del(blocks, root2, event.data.key);
      } else if (event.data.type === "batch") {
        const batch2 = await create5(blocks, root2);
        for (const op of event.data.ops) {
          if (op.type !== "put") throw new Error(`unsupported batch operation: ${op.type}`);
          await batch2.put(op.key, op.value);
        }
        result = await batch2.commit();
      } else {
        throw new Error(`unknown operation: ${event.data.type}`);
      }
      root2 = result.root;
      for (const a7 of result.additions) {
        mblocks.putSync(a7.cid, a7.bytes);
        additions.set(a7.cid.toString(), a7);
      }
      for (const r9 of result.removals) {
        removals.set(r9.cid.toString(), r9);
      }
    }
    for (const k4 of removals.keys()) {
      if (additions.has(k4)) {
        additions.delete(k4);
        removals.delete(k4);
      }
    }
    return {
      root: root2,
      additions: [...additions.values()],
      removals: [...removals.values()]
    };
  };
  var get4 = async (blocks, head, key) => {
    if (!head.length) return;
    const result = await root(blocks, head);
    if (result.additions.length) {
      blocks = new MultiBlockFetcher(new MemoryBlockstore(result.additions), blocks);
    }
    return get3(blocks, result.root, key);
  };
  var entries2 = async function* (blocks, head, options) {
    if (!head.length) return;
    const result = await root(blocks, head);
    if (result.additions.length) {
      blocks = new MultiBlockFetcher(new MemoryBlockstore(result.additions), blocks);
    }
    yield* entries(blocks, result.root, options);
  };
  var findCommonAncestor = async (events, children) => {
    if (!children.length) return;
    const candidates = children.map((c7) => [c7]);
    while (true) {
      let changed = false;
      for (const c7 of candidates) {
        const candidate = await findAncestorCandidate(events, c7[c7.length - 1]);
        if (!candidate) continue;
        changed = true;
        c7.push(candidate);
        const ancestor = findCommonString(candidates);
        if (ancestor) return ancestor;
      }
      if (!changed) return;
    }
  };
  var findAncestorCandidate = async (events, root2) => {
    const { value: event } = await events.get(root2);
    if (!event.parents.length) return root2;
    return event.parents.length === 1 ? event.parents[0] : findCommonAncestor(events, event.parents);
  };
  var findCommonString = (arrays) => {
    arrays = arrays.map((a7) => [...a7]);
    for (const arr of arrays) {
      for (const item of arr) {
        let matched = true;
        for (const other of arrays) {
          if (arr === other) continue;
          matched = other.some((i7) => String(i7) === String(item));
          if (!matched) break;
        }
        if (matched) return item;
      }
    }
  };
  var findSortedEvents = async (events, head, tail) => {
    if (head.length === 1 && head[0].toString() === tail.toString()) {
      return [];
    }
    const weights = /* @__PURE__ */ new Map();
    const all = await Promise.all(head.map((h8) => findEvents(events, h8, tail)));
    for (const arr of all) {
      for (const { event, depth } of arr) {
        const info = weights.get(event.cid.toString());
        if (info) {
          info.weight += depth;
        } else {
          weights.set(event.cid.toString(), { event, weight: depth });
        }
      }
    }
    const buckets = /* @__PURE__ */ new Map();
    for (const { event, weight } of weights.values()) {
      const bucket = buckets.get(weight);
      if (bucket) {
        bucket.push(event);
      } else {
        buckets.set(weight, [event]);
      }
    }
    return Array.from(buckets).sort((a7, b5) => b5[0] - a7[0]).flatMap(([, es]) => es.sort((a7, b5) => String(a7.cid) < String(b5.cid) ? -1 : 1));
  };
  var findEvents = async (events, start, end, depth = 0) => {
    const event = await events.get(start);
    const acc = [{ event, depth }];
    const { parents } = event.value;
    if (parents.length === 1 && String(parents[0]) === String(end)) return acc;
    const rest = await Promise.all(parents.map((p7) => findEvents(events, p7, end, depth + 1)));
    return acc.concat(...rest);
  };

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/crdt/batch/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/crdt/batch/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/crdt/batch/index.js
  var Batcher2 = class _Batcher {
    #committed = false;
    /**
     * @param {object} init
     * @param {API.BlockFetcher} init.blocks Block storage.
     * @param {API.EventLink<API.Operation>[]} init.head Merkle clock head.
     * @param {API.BatcherShardEntry[]} init.entries The entries in this shard.
     * @param {string} init.prefix Key prefix.
     * @param {number} init.version Shard compatibility version.
     * @param {string} init.keyChars Characters allowed in keys, referring to a known character set.
     * @param {number} init.maxKeySize Max key size in bytes.
     * @param {API.ShardBlockView} init.base Original shard this batcher is based on.
     * @param {API.ShardBlockView[]} init.additions Additions to include in the committed batch.
     * @param {API.ShardBlockView[]} init.removals Removals to include in the committed batch.
     */
    constructor({ blocks, head, entries: entries3, prefix, version: version2, keyChars, maxKeySize, base: base3, additions, removals }) {
      this.blocks = blocks;
      this.head = head;
      this.prefix = prefix;
      this.entries = [...entries3];
      this.base = base3;
      this.version = version2;
      this.keyChars = keyChars;
      this.maxKeySize = maxKeySize;
      this.additions = additions;
      this.removals = removals;
      this.ops = [];
    }
    /**
     * @param {string} key The key of the value to put.
     * @param {API.UnknownLink} value The value to put.
     * @returns {Promise<void>}
     */
    async put(key, value) {
      if (this.#committed) throw new BatchCommittedError();
      await put2(this.blocks, this, key, value);
      this.ops.push({ type: "put", key, value });
    }
    async commit() {
      if (this.#committed) throw new BatchCommittedError();
      this.#committed = true;
      const res = await commit(this);
      const data = { type: "batch", ops: this.ops, root: res.root };
      const event = await EventBlock.create(data, this.head);
      const mblocks = new MemoryBlockstore();
      const blocks = new MultiBlockFetcher(mblocks, this.blocks);
      mblocks.putSync(event.cid, event.bytes);
      const head = await advance(blocks, this.head, event.cid);
      const additions = /* @__PURE__ */ new Map();
      const removals = /* @__PURE__ */ new Map();
      for (const a7 of this.additions) {
        additions.set(a7.cid.toString(), a7);
      }
      for (const r9 of this.removals) {
        removals.set(r9.cid.toString(), r9);
      }
      for (const a7 of res.additions) {
        if (removals.has(a7.cid.toString())) {
          removals.delete(a7.cid.toString());
        }
        additions.set(a7.cid.toString(), a7);
      }
      for (const r9 of res.removals) {
        if (additions.has(r9.cid.toString())) {
          additions.delete(r9.cid.toString());
        } else {
          removals.set(r9.cid.toString(), r9);
        }
      }
      return {
        head,
        event,
        root: res.root,
        additions: [...additions.values()],
        removals: [...removals.values()]
      };
    }
    /**
     * @param {object} init
     * @param {API.BlockFetcher} init.blocks Block storage.
     * @param {API.EventLink<API.Operation>[]} init.head Merkle clock head.
     */
    static async create({ blocks, head }) {
      const mblocks = new MemoryBlockstore();
      blocks = new MultiBlockFetcher(mblocks, blocks);
      if (!head.length) {
        const base4 = await ShardBlock.create();
        mblocks.putSync(base4.cid, base4.bytes);
        return new _Batcher({
          blocks,
          head,
          entries: [],
          base: base4,
          additions: [base4],
          removals: [],
          ...configure(base4.value)
        });
      }
      const { root: root2, additions, removals } = await root(blocks, head);
      for (const a7 of additions) {
        mblocks.putSync(a7.cid, a7.bytes);
      }
      const shards = new ShardFetcher(blocks);
      const base3 = await shards.get(root2);
      return new _Batcher({
        blocks,
        head,
        entries: base3.value.entries,
        base: base3,
        additions,
        removals,
        ...configure(base3.value)
      });
    }
  };
  var create6 = (blocks, head) => Batcher2.create({ blocks, head });

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/index.js
  init_cement();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/lib.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/codec.js
  var codec_exports = {};
  __export(codec_exports, {
    DEFAULT_DIRECTORY_MODE: () => DEFAULT_DIRECTORY_MODE,
    DEFAULT_FILE_MODE: () => DEFAULT_FILE_MODE,
    NodeType: () => NodeType,
    code: () => code3,
    createAdvancedFile: () => createAdvancedFile,
    createComplexFile: () => createComplexFile,
    createDirectoryShard: () => createDirectoryShard,
    createEmptyFile: () => createEmptyFile,
    createFileChunk: () => createFileChunk,
    createFileShard: () => createFileShard,
    createFlatDirectory: () => createFlatDirectory,
    createRaw: () => createRaw,
    createShardedDirectory: () => createShardedDirectory,
    createSimpleFile: () => createSimpleFile,
    createSymlink: () => createSymlink,
    cumulativeContentByteLength: () => cumulativeContentByteLength,
    cumulativeDagByteLength: () => cumulativeDagByteLength,
    decode: () => decode13,
    decodeMetadata: () => decodeMetadata,
    encode: () => encode9,
    encodeAdvancedFile: () => encodeAdvancedFile,
    encodeComplexFile: () => encodeComplexFile,
    encodeDirectory: () => encodeDirectory,
    encodeDirectoryMetadata: () => encodeDirectoryMetadata,
    encodeFile: () => encodeFile,
    encodeFileChunk: () => encodeFileChunk,
    encodeFileShard: () => encodeFileShard,
    encodeHAMTShard: () => encodeHAMTShard,
    encodeLink: () => encodeLink2,
    encodeMetadata: () => encodeMetadata,
    encodeMode: () => encodeMode,
    encodeRaw: () => encodeRaw,
    encodeSimpleFile: () => encodeSimpleFile,
    encodeSymlink: () => encodeSymlink,
    filesize: () => filesize,
    matchFile: () => matchFile,
    name: () => name3
  });
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/pb-decode.js
  init_dirname();
  init_buffer2();
  init_process2();
  var textDecoder2 = new TextDecoder();
  function decodeVarint(bytes, offset) {
    let v6 = 0;
    for (let shift = 0; ; shift += 7) {
      if (shift >= 64) {
        throw new Error("protobuf: varint overflow");
      }
      if (offset >= bytes.length) {
        throw new Error("protobuf: unexpected end of data");
      }
      const b5 = bytes[offset++];
      v6 += shift < 28 ? (b5 & 127) << shift : (b5 & 127) * 2 ** shift;
      if (b5 < 128) {
        break;
      }
    }
    return [v6, offset];
  }
  function decodeBytes(bytes, offset) {
    let byteLen;
    [byteLen, offset] = decodeVarint(bytes, offset);
    const postOffset = offset + byteLen;
    if (byteLen < 0 || postOffset < 0) {
      throw new Error("protobuf: invalid length");
    }
    if (postOffset > bytes.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    return [bytes.subarray(offset, postOffset), postOffset];
  }
  function decodeKey(bytes, index2) {
    let wire;
    [wire, index2] = decodeVarint(bytes, index2);
    return [wire & 7, wire >> 3, index2];
  }
  function decodeLink(bytes) {
    const link4 = {};
    const l7 = bytes.length;
    let index2 = 0;
    while (index2 < l7) {
      let wireType, fieldNum;
      [wireType, fieldNum, index2] = decodeKey(bytes, index2);
      if (fieldNum === 1) {
        if (link4.Hash) {
          throw new Error("protobuf: (PBLink) duplicate Hash section");
        }
        if (wireType !== 2) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
        }
        if (link4.Name !== void 0) {
          throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
        }
        if (link4.Tsize !== void 0) {
          throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
        }
        [link4.Hash, index2] = decodeBytes(bytes, index2);
      } else if (fieldNum === 2) {
        if (link4.Name !== void 0) {
          throw new Error("protobuf: (PBLink) duplicate Name section");
        }
        if (wireType !== 2) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
        }
        if (link4.Tsize !== void 0) {
          throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
        }
        let byts;
        [byts, index2] = decodeBytes(bytes, index2);
        link4.Name = textDecoder2.decode(byts);
      } else if (fieldNum === 3) {
        if (link4.Tsize !== void 0) {
          throw new Error("protobuf: (PBLink) duplicate Tsize section");
        }
        if (wireType !== 0) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
        }
        [link4.Tsize, index2] = decodeVarint(bytes, index2);
      } else {
        throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
      }
    }
    if (index2 > l7) {
      throw new Error("protobuf: (PBLink) unexpected end of data");
    }
    return link4;
  }
  function decodeNode(bytes) {
    const l7 = bytes.length;
    let index2 = 0;
    let links4 = void 0;
    let linksBeforeData = false;
    let data = void 0;
    while (index2 < l7) {
      let wireType, fieldNum;
      [wireType, fieldNum, index2] = decodeKey(bytes, index2);
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
      }
      if (fieldNum === 1) {
        if (data) {
          throw new Error("protobuf: (PBNode) duplicate Data section");
        }
        [data, index2] = decodeBytes(bytes, index2);
        if (links4) {
          linksBeforeData = true;
        }
      } else if (fieldNum === 2) {
        if (linksBeforeData) {
          throw new Error("protobuf: (PBNode) duplicate Links section");
        } else if (!links4) {
          links4 = [];
        }
        let byts;
        [byts, index2] = decodeBytes(bytes, index2);
        links4.push(decodeLink(byts));
      } else {
        throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
      }
    }
    if (index2 > l7) {
      throw new Error("protobuf: (PBNode) unexpected end of data");
    }
    const node = {};
    if (data) {
      node.Data = data;
    }
    node.Links = links4 || [];
    return node;
  }

  // node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/pb-encode.js
  init_dirname();
  init_buffer2();
  init_process2();
  var textEncoder2 = new TextEncoder();
  var maxInt32 = 2 ** 32;
  var maxUInt32 = 2 ** 31;
  function encodeLink(link4, bytes) {
    let i7 = bytes.length;
    if (typeof link4.Tsize === "number") {
      if (link4.Tsize < 0) {
        throw new Error("Tsize cannot be negative");
      }
      if (!Number.isSafeInteger(link4.Tsize)) {
        throw new Error("Tsize too large for encoding");
      }
      i7 = encodeVarint(bytes, i7, link4.Tsize) - 1;
      bytes[i7] = 24;
    }
    if (typeof link4.Name === "string") {
      const nameBytes = textEncoder2.encode(link4.Name);
      i7 -= nameBytes.length;
      bytes.set(nameBytes, i7);
      i7 = encodeVarint(bytes, i7, nameBytes.length) - 1;
      bytes[i7] = 18;
    }
    if (link4.Hash) {
      i7 -= link4.Hash.length;
      bytes.set(link4.Hash, i7);
      i7 = encodeVarint(bytes, i7, link4.Hash.length) - 1;
      bytes[i7] = 10;
    }
    return bytes.length - i7;
  }
  function encodeNode(node) {
    const size = sizeNode(node);
    const bytes = new Uint8Array(size);
    let i7 = size;
    if (node.Data) {
      i7 -= node.Data.length;
      bytes.set(node.Data, i7);
      i7 = encodeVarint(bytes, i7, node.Data.length) - 1;
      bytes[i7] = 10;
    }
    if (node.Links) {
      for (let index2 = node.Links.length - 1; index2 >= 0; index2--) {
        const size2 = encodeLink(node.Links[index2], bytes.subarray(0, i7));
        i7 -= size2;
        i7 = encodeVarint(bytes, i7, size2) - 1;
        bytes[i7] = 18;
      }
    }
    return bytes;
  }
  function sizeLink(link4) {
    let n8 = 0;
    if (link4.Hash) {
      const l7 = link4.Hash.length;
      n8 += 1 + l7 + sov(l7);
    }
    if (typeof link4.Name === "string") {
      const l7 = textEncoder2.encode(link4.Name).length;
      n8 += 1 + l7 + sov(l7);
    }
    if (typeof link4.Tsize === "number") {
      n8 += 1 + sov(link4.Tsize);
    }
    return n8;
  }
  function sizeNode(node) {
    let n8 = 0;
    if (node.Data) {
      const l7 = node.Data.length;
      n8 += 1 + l7 + sov(l7);
    }
    if (node.Links) {
      for (const link4 of node.Links) {
        const l7 = sizeLink(link4);
        n8 += 1 + l7 + sov(l7);
      }
    }
    return n8;
  }
  function encodeVarint(bytes, offset, v6) {
    offset -= sov(v6);
    const base3 = offset;
    while (v6 >= maxUInt32) {
      bytes[offset++] = v6 & 127 | 128;
      v6 /= 128;
    }
    while (v6 >= 128) {
      bytes[offset++] = v6 & 127 | 128;
      v6 >>>= 7;
    }
    bytes[offset] = v6;
    return base3;
  }
  function sov(x4) {
    if (x4 % 2 === 0) {
      x4++;
    }
    return Math.floor((len64(x4) + 6) / 7);
  }
  function len64(x4) {
    let n8 = 0;
    if (x4 >= maxInt32) {
      x4 = Math.floor(x4 / maxInt32);
      n8 = 32;
    }
    if (x4 >= 1 << 16) {
      x4 >>>= 16;
      n8 += 16;
    }
    if (x4 >= 1 << 8) {
      x4 >>>= 8;
      n8 += 8;
    }
    return n8 + len8tab[x4];
  }
  var len8tab = [
    0,
    1,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8
  ];

  // node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/util.js
  init_dirname();
  init_buffer2();
  init_process2();
  var pbNodeProperties = ["Data", "Links"];
  var pbLinkProperties = ["Hash", "Name", "Tsize"];
  var textEncoder3 = new TextEncoder();
  function linkComparator(a7, b5) {
    if (a7 === b5) {
      return 0;
    }
    const abuf = a7.Name ? textEncoder3.encode(a7.Name) : [];
    const bbuf = b5.Name ? textEncoder3.encode(b5.Name) : [];
    let x4 = abuf.length;
    let y6 = bbuf.length;
    for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
      if (abuf[i7] !== bbuf[i7]) {
        x4 = abuf[i7];
        y6 = bbuf[i7];
        break;
      }
    }
    return x4 < y6 ? -1 : y6 < x4 ? 1 : 0;
  }
  function hasOnlyProperties(node, properties) {
    return !Object.keys(node).some((p7) => !properties.includes(p7));
  }
  function asLink(link4) {
    if (typeof link4.asCID === "object") {
      const Hash = CID2.asCID(link4);
      if (!Hash) {
        throw new TypeError("Invalid DAG-PB form");
      }
      return { Hash };
    }
    if (typeof link4 !== "object" || Array.isArray(link4)) {
      throw new TypeError("Invalid DAG-PB form");
    }
    const pbl = {};
    if (link4.Hash) {
      let cid = CID2.asCID(link4.Hash);
      try {
        if (!cid) {
          if (typeof link4.Hash === "string") {
            cid = CID2.parse(link4.Hash);
          } else if (link4.Hash instanceof Uint8Array) {
            cid = CID2.decode(link4.Hash);
          }
        }
      } catch (e9) {
        throw new TypeError(`Invalid DAG-PB form: ${e9.message}`);
      }
      if (cid) {
        pbl.Hash = cid;
      }
    }
    if (!pbl.Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    if (typeof link4.Name === "string") {
      pbl.Name = link4.Name;
    }
    if (typeof link4.Tsize === "number") {
      pbl.Tsize = link4.Tsize;
    }
    return pbl;
  }
  function prepare(node) {
    if (node instanceof Uint8Array || typeof node === "string") {
      node = { Data: node };
    }
    if (typeof node !== "object" || Array.isArray(node)) {
      throw new TypeError("Invalid DAG-PB form");
    }
    const pbn = {};
    if (node.Data !== void 0) {
      if (typeof node.Data === "string") {
        pbn.Data = textEncoder3.encode(node.Data);
      } else if (node.Data instanceof Uint8Array) {
        pbn.Data = node.Data;
      } else {
        throw new TypeError("Invalid DAG-PB form");
      }
    }
    if (node.Links !== void 0) {
      if (Array.isArray(node.Links)) {
        pbn.Links = node.Links.map(asLink);
        pbn.Links.sort(linkComparator);
      } else {
        throw new TypeError("Invalid DAG-PB form");
      }
    } else {
      pbn.Links = [];
    }
    return pbn;
  }
  function validate(node) {
    if (!node || typeof node !== "object" || Array.isArray(node) || node instanceof Uint8Array || node["/"] && node["/"] === node.bytes) {
      throw new TypeError("Invalid DAG-PB form");
    }
    if (!hasOnlyProperties(node, pbNodeProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties)");
    }
    if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
      throw new TypeError("Invalid DAG-PB form (Data must be bytes)");
    }
    if (!Array.isArray(node.Links)) {
      throw new TypeError("Invalid DAG-PB form (Links must be a list)");
    }
    for (let i7 = 0; i7 < node.Links.length; i7++) {
      const link4 = node.Links[i7];
      if (!link4 || typeof link4 !== "object" || Array.isArray(link4) || link4 instanceof Uint8Array || link4["/"] && link4["/"] === link4.bytes) {
        throw new TypeError("Invalid DAG-PB form (bad link)");
      }
      if (!hasOnlyProperties(link4, pbLinkProperties)) {
        throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");
      }
      if (link4.Hash === void 0) {
        throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
      }
      if (link4.Hash == null || !link4.Hash["/"] || link4.Hash["/"] !== link4.Hash.bytes) {
        throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
      }
      if (link4.Name !== void 0 && typeof link4.Name !== "string") {
        throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
      }
      if (link4.Tsize !== void 0) {
        if (typeof link4.Tsize !== "number" || link4.Tsize % 1 !== 0) {
          throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
        }
        if (link4.Tsize < 0) {
          throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)");
        }
      }
      if (i7 > 0 && linkComparator(link4, node.Links[i7 - 1]) === -1) {
        throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
      }
    }
  }
  function toByteView2(buf3) {
    if (buf3 instanceof ArrayBuffer) {
      return new Uint8Array(buf3, 0, buf3.byteLength);
    }
    return buf3;
  }

  // node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/index.js
  var code2 = 112;
  function encode8(node) {
    validate(node);
    const pbn = {};
    if (node.Links) {
      pbn.Links = node.Links.map((l7) => {
        const link4 = {};
        if (l7.Hash) {
          link4.Hash = l7.Hash.bytes;
        }
        if (l7.Name !== void 0) {
          link4.Name = l7.Name;
        }
        if (l7.Tsize !== void 0) {
          link4.Tsize = l7.Tsize;
        }
        return link4;
      });
    }
    if (node.Data) {
      pbn.Data = node.Data;
    }
    return encodeNode(pbn);
  }
  function decode12(bytes) {
    const buf3 = toByteView2(bytes);
    const pbn = decodeNode(buf3);
    const node = {};
    if (pbn.Data) {
      node.Data = pbn.Data;
    }
    if (pbn.Links) {
      node.Links = pbn.Links.map((l7) => {
        const link4 = {};
        try {
          link4.Hash = CID2.decode(l7.Hash);
        } catch (e9) {
        }
        if (!link4.Hash) {
          throw new Error("Invalid Hash field found in link, expected CID");
        }
        if (l7.Name !== void 0) {
          link4.Name = l7.Name;
        }
        if (l7.Tsize !== void 0) {
          link4.Tsize = l7.Tsize;
        }
        return link4;
      });
    }
    return node;
  }

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/unixfs.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/gen/unixfs.js
  init_dirname();
  init_buffer2();
  init_process2();
  var import_minimal = __toESM(require_minimal2(), 1);
  var $Reader = import_minimal.default.Reader;
  var $Writer = import_minimal.default.Writer;
  var $util = import_minimal.default.util;
  var $root = import_minimal.default.roots.unixfs || (import_minimal.default.roots.unixfs = {});
  var Data = $root.Data = (() => {
    function Data3(p7) {
      this.blocksizes = [];
      if (p7) {
        for (var ks = Object.keys(p7), i7 = 0; i7 < ks.length; ++i7)
          if (p7[ks[i7]] != null)
            this[ks[i7]] = p7[ks[i7]];
      }
    }
    Data3.prototype.Type = 0;
    Data3.prototype.Data = $util.newBuffer([]);
    Data3.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    Data3.prototype.blocksizes = $util.emptyArray;
    Data3.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    Data3.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    Data3.prototype.mode = 0;
    Data3.prototype.mtime = null;
    Data3.encode = function encode18(m6, w4) {
      if (!w4)
        w4 = $Writer.create();
      w4.uint32(8).int32(m6.Type);
      if (m6.Data != null && Object.hasOwnProperty.call(m6, "Data"))
        w4.uint32(18).bytes(m6.Data);
      if (m6.filesize != null && Object.hasOwnProperty.call(m6, "filesize"))
        w4.uint32(24).uint64(m6.filesize);
      if (m6.blocksizes != null && m6.blocksizes.length) {
        for (var i7 = 0; i7 < m6.blocksizes.length; ++i7)
          w4.uint32(32).uint64(m6.blocksizes[i7]);
      }
      if (m6.hashType != null && Object.hasOwnProperty.call(m6, "hashType"))
        w4.uint32(40).uint64(m6.hashType);
      if (m6.fanout != null && Object.hasOwnProperty.call(m6, "fanout"))
        w4.uint32(48).uint64(m6.fanout);
      if (m6.mode != null && Object.hasOwnProperty.call(m6, "mode"))
        w4.uint32(56).uint32(m6.mode);
      if (m6.mtime != null && Object.hasOwnProperty.call(m6, "mtime"))
        $root.UnixTime.encode(m6.mtime, w4.uint32(66).fork()).ldelim();
      return w4;
    };
    Data3.decode = function decode21(r9, l7) {
      if (!(r9 instanceof $Reader))
        r9 = $Reader.create(r9);
      var c7 = l7 === void 0 ? r9.len : r9.pos + l7, m6 = new $root.Data();
      while (r9.pos < c7) {
        var t8 = r9.uint32();
        switch (t8 >>> 3) {
          case 1:
            m6.Type = r9.int32();
            break;
          case 2:
            m6.Data = r9.bytes();
            break;
          case 3:
            m6.filesize = r9.uint64();
            break;
          case 4:
            if (!(m6.blocksizes && m6.blocksizes.length))
              m6.blocksizes = [];
            if ((t8 & 7) === 2) {
              var c22 = r9.uint32() + r9.pos;
              while (r9.pos < c22)
                m6.blocksizes.push(r9.uint64());
            } else
              m6.blocksizes.push(r9.uint64());
            break;
          case 5:
            m6.hashType = r9.uint64();
            break;
          case 6:
            m6.fanout = r9.uint64();
            break;
          case 7:
            m6.mode = r9.uint32();
            break;
          case 8:
            m6.mtime = $root.UnixTime.decode(r9, r9.uint32());
            break;
          default:
            r9.skipType(t8 & 7);
            break;
        }
      }
      if (!m6.hasOwnProperty("Type"))
        throw $util.ProtocolError("missing required 'Type'", { instance: m6 });
      return m6;
    };
    Data3.fromObject = function fromObject(d6) {
      if (d6 instanceof $root.Data)
        return d6;
      var m6 = new $root.Data();
      switch (d6.Type) {
        case "Raw":
        case 0:
          m6.Type = 0;
          break;
        case "Directory":
        case 1:
          m6.Type = 1;
          break;
        case "File":
        case 2:
          m6.Type = 2;
          break;
        case "Metadata":
        case 3:
          m6.Type = 3;
          break;
        case "Symlink":
        case 4:
          m6.Type = 4;
          break;
        case "HAMTShard":
        case 5:
          m6.Type = 5;
          break;
      }
      if (d6.Data != null) {
        if (typeof d6.Data === "string")
          $util.base64.decode(d6.Data, m6.Data = $util.newBuffer($util.base64.length(d6.Data)), 0);
        else if (d6.Data.length)
          m6.Data = d6.Data;
      }
      if (d6.filesize != null) {
        if ($util.Long)
          (m6.filesize = $util.Long.fromValue(d6.filesize)).unsigned = true;
        else if (typeof d6.filesize === "string")
          m6.filesize = parseInt(d6.filesize, 10);
        else if (typeof d6.filesize === "number")
          m6.filesize = d6.filesize;
        else if (typeof d6.filesize === "object")
          m6.filesize = new $util.LongBits(d6.filesize.low >>> 0, d6.filesize.high >>> 0).toNumber(true);
      }
      if (d6.blocksizes) {
        if (!Array.isArray(d6.blocksizes))
          throw TypeError(".Data.blocksizes: array expected");
        m6.blocksizes = [];
        for (var i7 = 0; i7 < d6.blocksizes.length; ++i7) {
          if ($util.Long)
            (m6.blocksizes[i7] = $util.Long.fromValue(d6.blocksizes[i7])).unsigned = true;
          else if (typeof d6.blocksizes[i7] === "string")
            m6.blocksizes[i7] = parseInt(d6.blocksizes[i7], 10);
          else if (typeof d6.blocksizes[i7] === "number")
            m6.blocksizes[i7] = d6.blocksizes[i7];
          else if (typeof d6.blocksizes[i7] === "object")
            m6.blocksizes[i7] = new $util.LongBits(d6.blocksizes[i7].low >>> 0, d6.blocksizes[i7].high >>> 0).toNumber(true);
        }
      }
      if (d6.hashType != null) {
        if ($util.Long)
          (m6.hashType = $util.Long.fromValue(d6.hashType)).unsigned = true;
        else if (typeof d6.hashType === "string")
          m6.hashType = parseInt(d6.hashType, 10);
        else if (typeof d6.hashType === "number")
          m6.hashType = d6.hashType;
        else if (typeof d6.hashType === "object")
          m6.hashType = new $util.LongBits(d6.hashType.low >>> 0, d6.hashType.high >>> 0).toNumber(true);
      }
      if (d6.fanout != null) {
        if ($util.Long)
          (m6.fanout = $util.Long.fromValue(d6.fanout)).unsigned = true;
        else if (typeof d6.fanout === "string")
          m6.fanout = parseInt(d6.fanout, 10);
        else if (typeof d6.fanout === "number")
          m6.fanout = d6.fanout;
        else if (typeof d6.fanout === "object")
          m6.fanout = new $util.LongBits(d6.fanout.low >>> 0, d6.fanout.high >>> 0).toNumber(true);
      }
      if (d6.mode != null) {
        m6.mode = d6.mode >>> 0;
      }
      if (d6.mtime != null) {
        if (typeof d6.mtime !== "object")
          throw TypeError(".Data.mtime: object expected");
        m6.mtime = $root.UnixTime.fromObject(d6.mtime);
      }
      return m6;
    };
    Data3.toObject = function toObject(m6, o8) {
      if (!o8)
        o8 = {};
      var d6 = {};
      if (o8.arrays || o8.defaults) {
        d6.blocksizes = [];
      }
      if (o8.defaults) {
        d6.Type = o8.enums === String ? "Raw" : 0;
        if (o8.bytes === String)
          d6.Data = "";
        else {
          d6.Data = [];
          if (o8.bytes !== Array)
            d6.Data = $util.newBuffer(d6.Data);
        }
        if ($util.Long) {
          var n8 = new $util.Long(0, 0, true);
          d6.filesize = o8.longs === String ? n8.toString() : o8.longs === Number ? n8.toNumber() : n8;
        } else
          d6.filesize = o8.longs === String ? "0" : 0;
        if ($util.Long) {
          var n8 = new $util.Long(0, 0, true);
          d6.hashType = o8.longs === String ? n8.toString() : o8.longs === Number ? n8.toNumber() : n8;
        } else
          d6.hashType = o8.longs === String ? "0" : 0;
        if ($util.Long) {
          var n8 = new $util.Long(0, 0, true);
          d6.fanout = o8.longs === String ? n8.toString() : o8.longs === Number ? n8.toNumber() : n8;
        } else
          d6.fanout = o8.longs === String ? "0" : 0;
        d6.mode = 0;
        d6.mtime = null;
      }
      if (m6.Type != null && m6.hasOwnProperty("Type")) {
        d6.Type = o8.enums === String ? $root.Data.DataType[m6.Type] : m6.Type;
      }
      if (m6.Data != null && m6.hasOwnProperty("Data")) {
        d6.Data = o8.bytes === String ? $util.base64.encode(m6.Data, 0, m6.Data.length) : o8.bytes === Array ? Array.prototype.slice.call(m6.Data) : m6.Data;
      }
      if (m6.filesize != null && m6.hasOwnProperty("filesize")) {
        if (typeof m6.filesize === "number")
          d6.filesize = o8.longs === String ? String(m6.filesize) : m6.filesize;
        else
          d6.filesize = o8.longs === String ? $util.Long.prototype.toString.call(m6.filesize) : o8.longs === Number ? new $util.LongBits(m6.filesize.low >>> 0, m6.filesize.high >>> 0).toNumber(true) : m6.filesize;
      }
      if (m6.blocksizes && m6.blocksizes.length) {
        d6.blocksizes = [];
        for (var j4 = 0; j4 < m6.blocksizes.length; ++j4) {
          if (typeof m6.blocksizes[j4] === "number")
            d6.blocksizes[j4] = o8.longs === String ? String(m6.blocksizes[j4]) : m6.blocksizes[j4];
          else
            d6.blocksizes[j4] = o8.longs === String ? $util.Long.prototype.toString.call(m6.blocksizes[j4]) : o8.longs === Number ? new $util.LongBits(m6.blocksizes[j4].low >>> 0, m6.blocksizes[j4].high >>> 0).toNumber(true) : m6.blocksizes[j4];
        }
      }
      if (m6.hashType != null && m6.hasOwnProperty("hashType")) {
        if (typeof m6.hashType === "number")
          d6.hashType = o8.longs === String ? String(m6.hashType) : m6.hashType;
        else
          d6.hashType = o8.longs === String ? $util.Long.prototype.toString.call(m6.hashType) : o8.longs === Number ? new $util.LongBits(m6.hashType.low >>> 0, m6.hashType.high >>> 0).toNumber(true) : m6.hashType;
      }
      if (m6.fanout != null && m6.hasOwnProperty("fanout")) {
        if (typeof m6.fanout === "number")
          d6.fanout = o8.longs === String ? String(m6.fanout) : m6.fanout;
        else
          d6.fanout = o8.longs === String ? $util.Long.prototype.toString.call(m6.fanout) : o8.longs === Number ? new $util.LongBits(m6.fanout.low >>> 0, m6.fanout.high >>> 0).toNumber(true) : m6.fanout;
      }
      if (m6.mode != null && m6.hasOwnProperty("mode")) {
        d6.mode = m6.mode;
      }
      if (m6.mtime != null && m6.hasOwnProperty("mtime")) {
        d6.mtime = $root.UnixTime.toObject(m6.mtime, o8);
      }
      return d6;
    };
    Data3.prototype.toJSON = function toJSON3() {
      return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
    };
    Data3.DataType = function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "Raw"] = 0;
      values[valuesById[1] = "Directory"] = 1;
      values[valuesById[2] = "File"] = 2;
      values[valuesById[3] = "Metadata"] = 3;
      values[valuesById[4] = "Symlink"] = 4;
      values[valuesById[5] = "HAMTShard"] = 5;
      return values;
    }();
    return Data3;
  })();
  var UnixTime = $root.UnixTime = (() => {
    function UnixTime3(p7) {
      if (p7) {
        for (var ks = Object.keys(p7), i7 = 0; i7 < ks.length; ++i7)
          if (p7[ks[i7]] != null)
            this[ks[i7]] = p7[ks[i7]];
      }
    }
    UnixTime3.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    UnixTime3.prototype.FractionalNanoseconds = 0;
    UnixTime3.encode = function encode18(m6, w4) {
      if (!w4)
        w4 = $Writer.create();
      w4.uint32(8).int64(m6.Seconds);
      if (m6.FractionalNanoseconds != null && Object.hasOwnProperty.call(m6, "FractionalNanoseconds"))
        w4.uint32(21).fixed32(m6.FractionalNanoseconds);
      return w4;
    };
    UnixTime3.decode = function decode21(r9, l7) {
      if (!(r9 instanceof $Reader))
        r9 = $Reader.create(r9);
      var c7 = l7 === void 0 ? r9.len : r9.pos + l7, m6 = new $root.UnixTime();
      while (r9.pos < c7) {
        var t8 = r9.uint32();
        switch (t8 >>> 3) {
          case 1:
            m6.Seconds = r9.int64();
            break;
          case 2:
            m6.FractionalNanoseconds = r9.fixed32();
            break;
          default:
            r9.skipType(t8 & 7);
            break;
        }
      }
      if (!m6.hasOwnProperty("Seconds"))
        throw $util.ProtocolError("missing required 'Seconds'", { instance: m6 });
      return m6;
    };
    UnixTime3.fromObject = function fromObject(d6) {
      if (d6 instanceof $root.UnixTime)
        return d6;
      var m6 = new $root.UnixTime();
      if (d6.Seconds != null) {
        if ($util.Long)
          (m6.Seconds = $util.Long.fromValue(d6.Seconds)).unsigned = false;
        else if (typeof d6.Seconds === "string")
          m6.Seconds = parseInt(d6.Seconds, 10);
        else if (typeof d6.Seconds === "number")
          m6.Seconds = d6.Seconds;
        else if (typeof d6.Seconds === "object")
          m6.Seconds = new $util.LongBits(d6.Seconds.low >>> 0, d6.Seconds.high >>> 0).toNumber();
      }
      if (d6.FractionalNanoseconds != null) {
        m6.FractionalNanoseconds = d6.FractionalNanoseconds >>> 0;
      }
      return m6;
    };
    UnixTime3.toObject = function toObject(m6, o8) {
      if (!o8)
        o8 = {};
      var d6 = {};
      if (o8.defaults) {
        if ($util.Long) {
          var n8 = new $util.Long(0, 0, false);
          d6.Seconds = o8.longs === String ? n8.toString() : o8.longs === Number ? n8.toNumber() : n8;
        } else
          d6.Seconds = o8.longs === String ? "0" : 0;
        d6.FractionalNanoseconds = 0;
      }
      if (m6.Seconds != null && m6.hasOwnProperty("Seconds")) {
        if (typeof m6.Seconds === "number")
          d6.Seconds = o8.longs === String ? String(m6.Seconds) : m6.Seconds;
        else
          d6.Seconds = o8.longs === String ? $util.Long.prototype.toString.call(m6.Seconds) : o8.longs === Number ? new $util.LongBits(m6.Seconds.low >>> 0, m6.Seconds.high >>> 0).toNumber() : m6.Seconds;
      }
      if (m6.FractionalNanoseconds != null && m6.hasOwnProperty("FractionalNanoseconds")) {
        d6.FractionalNanoseconds = m6.FractionalNanoseconds;
      }
      return d6;
    };
    UnixTime3.prototype.toJSON = function toJSON3() {
      return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
    };
    return UnixTime3;
  })();
  var Metadata = $root.Metadata = (() => {
    function Metadata3(p7) {
      if (p7) {
        for (var ks = Object.keys(p7), i7 = 0; i7 < ks.length; ++i7)
          if (p7[ks[i7]] != null)
            this[ks[i7]] = p7[ks[i7]];
      }
    }
    Metadata3.prototype.MimeType = "";
    Metadata3.encode = function encode18(m6, w4) {
      if (!w4)
        w4 = $Writer.create();
      if (m6.MimeType != null && Object.hasOwnProperty.call(m6, "MimeType"))
        w4.uint32(10).string(m6.MimeType);
      return w4;
    };
    Metadata3.decode = function decode21(r9, l7) {
      if (!(r9 instanceof $Reader))
        r9 = $Reader.create(r9);
      var c7 = l7 === void 0 ? r9.len : r9.pos + l7, m6 = new $root.Metadata();
      while (r9.pos < c7) {
        var t8 = r9.uint32();
        switch (t8 >>> 3) {
          case 1:
            m6.MimeType = r9.string();
            break;
          default:
            r9.skipType(t8 & 7);
            break;
        }
      }
      return m6;
    };
    Metadata3.fromObject = function fromObject(d6) {
      if (d6 instanceof $root.Metadata)
        return d6;
      var m6 = new $root.Metadata();
      if (d6.MimeType != null) {
        m6.MimeType = String(d6.MimeType);
      }
      return m6;
    };
    Metadata3.toObject = function toObject(m6, o8) {
      if (!o8)
        o8 = {};
      var d6 = {};
      if (o8.defaults) {
        d6.MimeType = "";
      }
      if (m6.MimeType != null && m6.hasOwnProperty("MimeType")) {
        d6.MimeType = m6.MimeType;
      }
      return d6;
    };
    Metadata3.prototype.toJSON = function toJSON3() {
      return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
    };
    return Metadata3;
  })();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/unixfs.js
  var NodeType = Data.DataType;

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/codec.js
  var EMPTY = Object.freeze([]);
  var EMPTY_BUFFER = new Uint8Array(0);
  var BLANK = Object.freeze({});
  var DEFAULT_FILE_MODE = parseInt("0644", 8);
  var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
  var code3 = code2;
  var name3 = "UnixFS";
  var encodePB = (data, links4) => {
    Object(globalThis).debug && console.log({ data, links: links4 });
    return encode8(
      // We run through prepare as links need to be sorted by name which it will
      // do.
      prepare({
        Data: Data.encode(data).finish(),
        // We can cast to mutable array as we know no mutation occurs there
        Links: (
          /** @type {PB.PBLink[]} */
          links4
        )
      })
    );
  };
  var createRaw = (content) => ({
    type: NodeType.Raw,
    content
  });
  var createEmptyFile = (metadata) => createSimpleFile(EMPTY_BUFFER, metadata);
  var createSimpleFile = (content, metadata) => ({
    type: NodeType.File,
    layout: "simple",
    content,
    metadata: decodeMetadata(metadata)
  });
  var createFileChunk = (content) => ({
    type: NodeType.File,
    layout: "simple",
    content
  });
  var createAdvancedFile = (parts, metadata) => ({
    type: NodeType.File,
    layout: "advanced",
    parts,
    metadata: decodeMetadata(metadata)
  });
  var createFileShard = (parts) => ({
    type: NodeType.File,
    layout: "advanced",
    parts
  });
  var createComplexFile = (content, parts, metadata) => ({
    type: NodeType.File,
    layout: "complex",
    content,
    parts,
    metadata: decodeMetadata(metadata)
  });
  var createFlatDirectory = (entries3, metadata) => ({
    type: NodeType.Directory,
    metadata: decodeMetadata(metadata),
    entries: entries3
  });
  var createShardedDirectory = (entries3, bitfield, fanout, hashType, metadata = BLANK) => ({
    type: NodeType.HAMTShard,
    bitfield,
    fanout: readFanout(fanout),
    hashType: readInt(hashType),
    entries: entries3,
    metadata: decodeMetadata(metadata)
  });
  var createDirectoryShard = (entries3, bitfield, fanout, hashType) => ({
    type: NodeType.HAMTShard,
    bitfield,
    fanout: readFanout(fanout),
    hashType: readInt(hashType),
    entries: entries3
  });
  var encodeRaw = (content) => encodePB(
    {
      Type: NodeType.Raw,
      // TODO:
      Data: content.byteLength > 0 ? content : void 0,
      filesize: content.byteLength,
      // @ts-ignore
      blocksizes: EMPTY
    },
    []
  );
  var encodeFile = (node, ignoreMetadata = false) => {
    const metadata = ignoreMetadata ? BLANK : Object(node).metadata;
    switch (node.layout) {
      case "simple":
        return encodeSimpleFile(node.content, metadata);
      case "advanced":
        return encodeAdvancedFile(node.parts, metadata);
      case "complex":
        return encodeComplexFile(node.content, node.parts, metadata);
      default:
        throw new TypeError(
          `File with unknown layout "${Object(node).layout}" was passed`
        );
    }
  };
  var encodeFileChunk = (content) => encodeSimpleFile(content, BLANK);
  var encodeFileShard = (parts) => encodePB(
    {
      Type: NodeType.File,
      blocksizes: parts.map(contentByteLength),
      filesize: cumulativeContentByteLength(parts)
    },
    parts.map(encodeLink2)
  );
  var encodeAdvancedFile = (parts, metadata = BLANK) => encodePB(
    {
      Type: NodeType.File,
      blocksizes: parts.map(contentByteLength),
      filesize: cumulativeContentByteLength(parts),
      ...encodeMetadata(metadata)
    },
    parts.map(encodeLink2)
  );
  var encodeLink2 = (dag) => ({
    Name: "",
    Tsize: dag.dagByteLength,
    // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161
    Hash: dag.cid
  });
  var encodeSimpleFile = (content, metadata = BLANK) => encodePB(
    {
      Type: NodeType.File,
      // adding empty file to both go-ipfs and js-ipfs produces block in
      // which `Data` is omitted but filesize and blocksizes are present.
      // For the sake of hash consistency we do the same.
      Data: content.byteLength > 0 ? content : void 0,
      filesize: content.byteLength,
      blocksizes: [],
      ...encodeMetadata(metadata)
    },
    []
  );
  var encodeComplexFile = (content, parts, metadata = BLANK) => encodePB(
    {
      Type: NodeType.File,
      Data: content,
      filesize: content.byteLength + cumulativeContentByteLength(parts),
      blocksizes: parts.map(contentByteLength)
    },
    parts.map(encodeLink2)
  );
  var encodeDirectory = (node) => encodePB(
    {
      Type: node.type,
      ...encodeDirectoryMetadata(node.metadata || BLANK)
    },
    node.entries.map(encodeNamedLink)
  );
  var encodeHAMTShard = ({
    bitfield,
    fanout,
    hashType,
    entries: entries3,
    metadata = BLANK
  }) => encodePB(
    {
      Type: NodeType.HAMTShard,
      Data: bitfield.byteLength > 0 ? bitfield : void 0,
      fanout: readFanout(fanout),
      hashType: readInt(hashType),
      ...encodeDirectoryMetadata(metadata)
    },
    entries3.map(encodeNamedLink)
  );
  var readFanout = (n8) => {
    if (Math.log2(n8) % 1 === 0) {
      return n8;
    } else {
      throw new TypeError(
        `Expected hamt size to be a power of two instead got ${n8}`
      );
    }
  };
  var readInt = (n8) => {
    if (Number.isInteger(n8)) {
      return n8;
    } else {
      throw new TypeError(`Expected an integer value instead got ${n8}`);
    }
  };
  var createSymlink = (path2, metadata = BLANK) => ({
    type: NodeType.Symlink,
    content: path2,
    metadata: decodeMetadata(metadata)
  });
  var encodeSymlink = (node, ignoreMetadata = false) => {
    const metadata = ignoreMetadata ? BLANK : Object(node).metadata;
    return encodePB(
      {
        Type: NodeType.Symlink,
        Data: node.content,
        ...encodeMetadata(metadata || BLANK)
      },
      []
    );
  };
  var encode9 = (node, root2 = true) => {
    switch (node.type) {
      case NodeType.Raw:
        return encodeRaw(node.content);
      case NodeType.File:
        return encodeFile(node);
      case NodeType.Directory:
        return encodeDirectory(node);
      case NodeType.HAMTShard:
        return encodeHAMTShard(node);
      case NodeType.Symlink:
        return encodeSymlink(node);
      default:
        throw new Error(`Unknown node type ${Object(node).type}`);
    }
  };
  var decode13 = (bytes) => {
    const pb = decode12(bytes);
    const message2 = Data.decode(
      /** @type {Uint8Array} */
      pb.Data
    );
    const {
      Type: type2,
      Data: data,
      mtime,
      mode,
      blocksizes,
      ...rest
    } = Data.toObject(message2, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const metadata = {
      ...mode && { mode },
      ...decodeMtime(mtime)
    };
    const links4 = pb.Links;
    switch (message2.Type) {
      case NodeType.Raw:
        return createRaw(data);
      case NodeType.File:
        if (links4.length === 0) {
          return new SimpleFileView(data, metadata);
        } else if (data.byteLength === 0) {
          return new AdvancedFileView(
            decodeFileLinks(rest.blocksizes, links4),
            metadata
          );
        } else {
          return new ComplexFileView(
            data,
            decodeFileLinks(rest.blocksizes, links4),
            metadata
          );
        }
      case NodeType.Directory:
        return createFlatDirectory(decodeDirectoryLinks(links4), metadata);
      case NodeType.HAMTShard:
        return createShardedDirectory(
          decodeDirectoryLinks(links4),
          data || EMPTY_BUFFER,
          rest.fanout,
          rest.hashType,
          metadata
        );
      case NodeType.Symlink:
        return createSymlink(data, metadata);
      default:
        throw new TypeError(`Unsupported node type ${message2.Type}`);
    }
  };
  var decodeMtime = (mtime) => mtime == null ? void 0 : {
    mtime: { secs: mtime.Seconds, nsecs: mtime.FractionalNanoseconds || 0 }
  };
  var decodeFileLinks = (blocksizes, links4) => {
    const parts = [];
    const length4 = blocksizes.length;
    let n8 = 0;
    while (n8 < length4) {
      parts.push(
        /** @type {UnixFS.FileLink} */
        {
          cid: links4[n8].Hash,
          dagByteLength: links4[n8].Tsize || 0,
          contentByteLength: blocksizes[n8]
        }
      );
    }
    return parts;
  };
  var decodeDirectoryLinks = (links4) => links4.map(
    (link4) => (
      /** @type {UnixFS.DirectoryEntryLink} */
      {
        cid: link4.Hash,
        name: link4.Name || "",
        dagByteLength: link4.Tsize || 0
      }
    )
  );
  var cumulativeContentByteLength = (links4) => links4.reduce((size, link4) => size + link4.contentByteLength, 0);
  var cumulativeDagByteLength = (root2, links4) => links4.reduce((size, link4) => size + link4.dagByteLength, root2.byteLength);
  var contentByteLength = (link4) => link4.contentByteLength;
  var encodeNamedLink = ({ name: name8, dagByteLength, cid }) => ({
    Name: name8,
    Tsize: dagByteLength,
    Hash: cid
  });
  var encodeDirectoryMetadata = (metadata) => encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE);
  var encodeMetadata = ({ mode, mtime }, defaultMode = DEFAULT_FILE_MODE) => ({
    mode: mode != null ? encodeMode(mode, defaultMode) : void 0,
    mtime: mtime != null ? encodeMTime(mtime) : void 0
  });
  var decodeMetadata = (data) => data == null ? BLANK : {
    ...data.mode == null ? void 0 : { mode: decodeMode(data.mode) },
    ...data.mtime == null ? void 0 : { mtime: data.mtime }
  };
  var encodeMTime = (mtime) => {
    return mtime == null ? void 0 : mtime.nsecs !== 0 ? { Seconds: mtime.secs, FractionalNanoseconds: mtime.nsecs } : { Seconds: mtime.secs };
  };
  var encodeMode = (specifiedMode, defaultMode) => {
    const mode = specifiedMode == null ? void 0 : decodeMode(specifiedMode);
    return mode === defaultMode || mode == null ? void 0 : mode;
  };
  var decodeMode = (mode) => mode & 4095 | mode & 4294963200;
  var matchFile = ({
    content = EMPTY_BUFFER,
    parts = EMPTY,
    metadata = BLANK,
    ...rest
  }) => {
    if (parts.length === 0) {
      return new SimpleFileView(content, metadata);
    } else if (content.byteLength === 0) {
      return new AdvancedFileView(parts, metadata);
    } else {
      return new ComplexFileView(content, parts, metadata);
    }
  };
  var SimpleFileView = class {
    /**
     * @param {Uint8Array} content
     * @param {UnixFS.Metadata} metadata
     */
    constructor(content, metadata) {
      this.content = content;
      this.metadata = metadata;
      this.layout = "simple";
      this.type = NodeType.File;
    }
    get filesize() {
      return this.content.byteLength;
    }
    encode() {
      return encodeSimpleFile(this.content, this.metadata);
    }
  };
  var AdvancedFileView = class {
    /**
     * @param {ReadonlyArray<UnixFS.FileLink>} parts
     * @param {UnixFS.Metadata} metadata
     */
    constructor(parts, metadata) {
      this.parts = parts;
      this.metadata = metadata;
    }
    /** @type {"advanced"} */
    get layout() {
      return "advanced";
    }
    /**
     * @returns {NodeType.File}
     */
    get type() {
      return NodeType.File;
    }
    get fileSize() {
      return cumulativeContentByteLength(this.parts);
    }
    get blockSizes() {
      return this.parts.map(contentByteLength);
    }
    encode() {
      return encodeAdvancedFile(this.parts, this.metadata);
    }
  };
  var ComplexFileView = class {
    /**
     * @param {Uint8Array} content
     * @param {ReadonlyArray<UnixFS.FileLink>} parts
     * @param {UnixFS.Metadata} metadata
     */
    constructor(content, parts, metadata) {
      this.content = content;
      this.parts = parts;
      this.metadata = metadata;
    }
    /** @type {"complex"} */
    get layout() {
      return "complex";
    }
    /**
     * @returns {NodeType.File}
     */
    get type() {
      return NodeType.File;
    }
    get fileSize() {
      return this.content.byteLength + cumulativeContentByteLength(this.parts);
    }
    get blockSizes() {
      return this.parts.map(contentByteLength);
    }
    encode() {
      return encodeComplexFile(this.content, this.parts, this.metadata);
    }
  };
  var filesize = (node) => {
    switch (node.type) {
      case NodeType.Raw:
      case NodeType.Symlink:
        return node.content.byteLength;
      case NodeType.File:
        switch (node.layout) {
          case "simple":
            return node.content.byteLength;
          case "advanced":
            return cumulativeContentByteLength(node.parts);
          case "complex":
            return node.content.byteLength + cumulativeContentByteLength(node.parts);
        }
      default:
        return 0;
    }
  };

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/writer.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/actor@2.3.1/node_modules/actor/src/lib.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/actor@2.3.1/node_modules/actor/src/task.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/actor@2.3.1/node_modules/actor/src/lib.js
  var effect = function* (task) {
    const message2 = yield* task;
    yield* send(message2);
  };
  function* current() {
    return (
      /** @type {Task.Controller<T, X, M>} */
      yield CURRENT
    );
  }
  var suspend = function* () {
    yield SUSPEND;
  };
  var wait = function* (input) {
    const task = yield* current();
    if (isAsync(input)) {
      let failed = false;
      let output = void 0;
      input.then(
        (value) => {
          failed = false;
          output = value;
          enqueue(task);
        },
        (error) => {
          failed = true;
          output = error;
          enqueue(task);
        }
      );
      yield* suspend();
      if (failed) {
        throw output;
      } else {
        return (
          /** @type {T} */
          output
        );
      }
    } else {
      main(wake(task));
      yield* suspend();
      return input;
    }
  };
  function* wake(task) {
    enqueue(task);
  }
  var isAsync = (node) => node != null && typeof /** @type {{then?:unknown}} */
  node.then === "function";
  var send = function* (message2) {
    yield (
      /** @type {Task.Message<T>} */
      message2
    );
  };
  var listen = function* (source) {
    const forks = [];
    for (const entry of Object.entries(source)) {
      const [name8, effect2] = (
        /** @type {[Tag, Task.Effect<T>]} */
        entry
      );
      if (effect2 !== NONE) {
        forks.push(yield* fork(tag(effect2, name8)));
      }
    }
    yield* group(forks);
  };
  var effects = (tasks) => tasks.length > 0 ? batch(tasks.map(effect)) : NONE;
  function* batch(effects2) {
    const forks = [];
    for (const effect2 of effects2) {
      forks.push(yield* fork(effect2));
    }
    yield* group(forks);
  }
  var tag = (effect2, tag2) => (
    // @ts-ignore
    effect2 === NONE ? NONE : effect2 instanceof Tagger ? new Tagger([...effect2.tags, tag2], effect2.source) : new Tagger([tag2], effect2)
  );
  var Tagger = class {
    /**
     * @param {Task.Task<Success, Failure, Message>} source
     * @param {string[]} tags
     */
    constructor(tags, source) {
      this.tags = tags;
      this.source = source;
      this.controller;
    }
    /* c8 ignore next 3 */
    [Symbol.iterator]() {
      if (!this.controller) {
        this.controller = this.source[Symbol.iterator]();
      }
      return this;
    }
    /**
     * @param {Task.TaskState<Success, Message>} state
     * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}
     */
    box(state) {
      if (state.done) {
        return state;
      } else {
        switch (state.value) {
          case SUSPEND:
          case CURRENT:
            return (
              /** @type {Task.TaskState<Success, Tagged<Tag, Message>>} */
              state
            );
          default: {
            const tagged = (
              /** @type {{ done: false, value: any }} */
              state
            );
            let { value } = tagged;
            for (const tag2 of this.tags) {
              value = withTag(tag2, value);
            }
            tagged.value = value;
            return tagged;
          }
        }
      }
    }
    /**
     *
     * @param {Task.Instruction<Message>} instruction
     */
    next(instruction) {
      return this.box(this.controller.next(instruction));
    }
    /**
     *
     * @param {Failure} error
     */
    throw(error) {
      return this.box(this.controller.throw(error));
    }
    /**
     * @param {Success} value
     */
    return(value) {
      return this.box(this.controller.return(value));
    }
    get [Symbol.toStringTag]() {
      return "TaggedEffect";
    }
  };
  var none = () => NONE;
  var withTag = (tag2, value) => (
    /** @type {Tagged<Tag, T>} */
    { type: tag2, [tag2]: value }
  );
  var CURRENT = Symbol("current");
  var SUSPEND = Symbol("suspend");
  var Group = class _Group {
    /**
     * @template T, X, M
     * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member
     * @returns {Task.Group<T, X, M>}
     */
    static of(member) {
      return (
        /** @type {{group?:Task.TaskGroup<T, X, M>}} */
        member.group || MAIN
      );
    }
    /**
     * @template T, X, M
     * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member
     * @param {Task.TaskGroup<T, X, M>} group
     */
    static enqueue(member, group2) {
      member.group = group2;
      group2.stack.active.push(member);
    }
    /**
     * @param {Task.Controller<T, X, M>} driver
     * @param {Task.Controller<T, X, M>[]} [active]
     * @param {Set<Task.Controller<T, X, M>>} [idle]
     * @param {Task.Stack<T, X, M>} [stack]
     */
    constructor(driver, active = [], idle = /* @__PURE__ */ new Set(), stack = new Stack(active, idle)) {
      this.driver = driver;
      this.parent = _Group.of(driver);
      this.stack = stack;
      this.id = ++ID;
    }
  };
  var Main = class {
    constructor() {
      this.status = IDLE;
      this.stack = new Stack();
      this.id = /** @type {0} */
      0;
    }
  };
  var Stack = class {
    /**
     * @param {Task.Controller<T, X, M>[]} [active]
     * @param {Set<Task.Controller<T, X, M>>} [idle]
     */
    constructor(active = [], idle = /* @__PURE__ */ new Set()) {
      this.active = active;
      this.idle = idle;
    }
    /**
     *
     * @param {Task.Stack<unknown, unknown, unknown>} stack
     * @returns
     */
    static size({ active, idle }) {
      return active.length + idle.size;
    }
  };
  var main = (task) => enqueue(task[Symbol.iterator]());
  var enqueue = (task) => {
    let group2 = Group.of(task);
    group2.stack.active.push(task);
    group2.stack.idle.delete(task);
    while (group2.parent) {
      const { idle, active } = group2.parent.stack;
      if (idle.has(group2.driver)) {
        idle.delete(group2.driver);
        active.push(group2.driver);
      } else {
        break;
      }
      group2 = group2.parent;
    }
    if (MAIN.status === IDLE) {
      MAIN.status = ACTIVE;
      while (true) {
        try {
          for (const _message of step(MAIN)) {
          }
          MAIN.status = IDLE;
          break;
        } catch (_error) {
          MAIN.stack.active.shift();
        }
      }
    }
  };
  var resume = (task) => enqueue(task);
  var step = function* (group2) {
    const { active } = group2.stack;
    let task = active[0];
    group2.stack.idle.delete(task);
    while (task) {
      let state = INIT;
      loop: while (!state.done && task === active[0]) {
        const instruction = state.value;
        switch (instruction) {
          // if task is suspended we add it to the idle list and break the loop
          // to move to a next task.
          case SUSPEND:
            group2.stack.idle.add(task);
            break loop;
          // if task requested a context (which is usually to suspend itself)
          // pass back a task reference and continue.
          case CURRENT:
            state = task.next(task);
            break;
          default:
            state = task.next(
              yield (
                /** @type {M & Task.Message<M>}*/
                instruction
              )
            );
            break;
        }
      }
      active.shift();
      task = active[0];
      group2.stack.idle.delete(task);
    }
  };
  var fork = (task, options) => new Fork(task, options);
  var exit2 = (handle, value) => conclude(handle, { ok: true, value });
  var abort2 = (handle, error) => conclude(handle, { ok: false, error });
  function* conclude(handle, result) {
    try {
      const task = handle;
      const state = result.ok ? task.return(result.value) : task.throw(result.error);
      if (!state.done) {
        if (state.value === SUSPEND) {
          const { idle } = Group.of(task).stack;
          idle.add(task);
        } else {
          enqueue(task);
        }
      }
    } catch (error) {
    }
  }
  function* group(forks) {
    if (forks.length === 0) return;
    const self2 = yield* current();
    const group2 = new Group(self2);
    let failure = null;
    for (const fork4 of forks) {
      const { result } = fork4;
      if (result) {
        if (!result.ok && !failure) {
          failure = result;
        }
        continue;
      }
      move(fork4, group2);
    }
    try {
      if (failure) {
        throw failure.error;
      }
      while (true) {
        yield* step(group2);
        if (Stack.size(group2.stack) > 0) {
          yield* suspend();
        } else {
          break;
        }
      }
    } catch (error) {
      for (const task of group2.stack.active) {
        yield* abort2(task, error);
      }
      for (const task of group2.stack.idle) {
        yield* abort2(task, error);
        enqueue(task);
      }
      throw error;
    }
  }
  var move = (fork4, group2) => {
    const from8 = Group.of(fork4);
    if (from8 !== group2) {
      const { active, idle } = from8.stack;
      const target = group2.stack;
      fork4.group = group2;
      if (idle.has(fork4)) {
        idle.delete(fork4);
        target.idle.add(fork4);
      } else {
        const index2 = active.indexOf(fork4);
        if (index2 >= 0) {
          active.splice(index2, 1);
          target.active.push(fork4);
        }
      }
    }
  };
  function* join2(fork4) {
    if (fork4.status === IDLE) {
      yield* fork4;
    }
    if (!fork4.result) {
      yield* group([fork4]);
    }
    const result = (
      /** @type {Task.Result<T, X>} */
      fork4.result
    );
    if (result.ok) {
      return result.value;
    } else {
      throw result.error;
    }
  }
  var Future2 = class {
    /**
     * @param {Task.StateHandler<T, X>} handler
     */
    constructor(handler) {
      this.handler = handler;
      this.result;
    }
    /**
     * @type {Promise<T>}
     */
    get promise() {
      const { result } = this;
      const promise = result == null ? new Promise((succeed, fail2) => {
        this.handler.onsuccess = succeed;
        this.handler.onfailure = fail2;
      }) : result.ok ? Promise.resolve(result.value) : Promise.reject(result.error);
      Object.defineProperty(this, "promise", { value: promise });
      return promise;
    }
    /**
     * @template U, [E=never]
     * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]
     * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]
     * @returns {Promise<U|E>}
     */
    then(onresolve, onreject) {
      return this.activate().promise.then(onresolve, onreject);
    }
    /**
     * @template [U=never]
     * @param {(error:X) => U} onreject
     */
    catch(onreject) {
      return (
        /** @type {Task.Future<T|U, never>} */
        this.activate().promise.catch(onreject)
      );
    }
    /**
     * @param {() => void} onfinally
     * @returns {Task.Future<T, X>}
     */
    finally(onfinally) {
      return (
        /** @type {Task.Future<T, X>} */
        this.activate().promise.finally(onfinally)
      );
    }
    /**
     * @abstract
     */
    /* c8 ignore next 3 */
    activate() {
      return this;
    }
  };
  var Fork = class extends Future2 {
    /**
     * @param {Task.Task<T, X, M>} task
     * @param {Task.ForkOptions} [options]
     * @param {Task.StateHandler<T, X>} [handler]
     * @param {Task.TaskState<T, M>} [state]
     */
    constructor(task, options = BLANK2, handler = {}, state = INIT) {
      super(handler);
      this.id = ++ID;
      this.name = options.name || "";
      this.task = task;
      this.state = state;
      this.status = IDLE;
      this.result;
      this.handler = handler;
      this.controller;
    }
    *resume() {
      resume(this);
    }
    /**
     * @returns {Task.Task<T, X, M>}
     */
    join() {
      return join2(this);
    }
    /**
     * @param {X} error
     */
    abort(error) {
      return abort2(this, error);
    }
    /**
     * @param {T} value
     */
    exit(value) {
      return exit2(this, value);
    }
    get [Symbol.toStringTag]() {
      return "Fork";
    }
    /**
     * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}
     */
    *[Symbol.iterator]() {
      return this.activate();
    }
    activate() {
      this.controller = this.task[Symbol.iterator]();
      this.status = ACTIVE;
      enqueue(this);
      return this;
    }
    /**
     * @private
     * @param {any} error
     * @returns {never}
     */
    panic(error) {
      this.result = { ok: false, error };
      this.status = FINISHED;
      const { handler } = this;
      if (handler.onfailure) {
        handler.onfailure(error);
      }
      throw error;
    }
    /**
     * @private
     * @param {Task.TaskState<T, M>} state
     */
    step(state) {
      this.state = state;
      if (state.done) {
        this.result = { ok: true, value: state.value };
        this.status = FINISHED;
        const { handler } = this;
        if (handler.onsuccess) {
          handler.onsuccess(state.value);
        }
      }
      return state;
    }
    /**
     * @param {unknown} value
     */
    next(value) {
      try {
        return this.step(this.controller.next(value));
      } catch (error) {
        return this.panic(error);
      }
    }
    /**
     * @param {T} value
     */
    return(value) {
      try {
        return this.step(this.controller.return(value));
      } catch (error) {
        return this.panic(error);
      }
    }
    /**
     * @param {X} error
     */
    throw(error) {
      try {
        return this.step(this.controller.throw(error));
      } catch (error2) {
        return this.panic(error2);
      }
    }
  };
  var loop = function* (init3, next) {
    const controller = yield* current();
    const group2 = new Group(controller);
    Group.enqueue(init3[Symbol.iterator](), group2);
    while (true) {
      for (const message2 of step(group2)) {
        Group.enqueue(next(message2)[Symbol.iterator](), group2);
      }
      if (Stack.size(group2.stack) > 0) {
        yield* suspend();
      } else {
        break;
      }
    }
  };
  var ID = 0;
  var IDLE = "idle";
  var ACTIVE = "active";
  var FINISHED = "finished";
  var INIT = { done: false, value: CURRENT };
  var BLANK2 = {};
  var NONE = function* none2() {
  }();
  var MAIN = new Main();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/layout/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker/buffer.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker/indexed.js
  init_dirname();
  init_buffer2();
  init_process2();
  function Indexed() {
  }
  Object.defineProperties(Indexed, {
    prototype: {
      value: new Proxy(Object.prototype, {
        /**
         * @param {object} target
         * @param {PropertyKey} property
         * @param {{get(key:PropertyKey): any}} receiver
         */
        get(target, property, receiver) {
          return typeof property === "symbol" ? Reflect.get(target, property, receiver) : receiver.get(property);
        }
      })
    }
  });

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker/buffer.js
  var empty3 = () => new BufferView();
  var slice2 = (buffer4, startOffset = 0, endOffset = buffer4.byteLength) => {
    const segments = [];
    const start = startOffset < 0 ? buffer4.byteLength - startOffset : startOffset;
    const end = endOffset < 0 ? buffer4.byteLength - endOffset : endOffset;
    if (start === 0 && end >= buffer4.byteLength) {
      return buffer4;
    }
    if (start > end || start > buffer4.byteLength || end <= 0) {
      return empty3();
    }
    let byteLength = 0;
    let offset = 0;
    for (const segment of buffer4.segments) {
      const nextOffset = offset + segment.byteLength;
      if (byteLength === 0) {
        if (end <= nextOffset) {
          const range = segment.subarray(start - offset, end - offset);
          segments.push(range);
          byteLength = range.byteLength;
          break;
        } else if (start < nextOffset) {
          const range = start === offset ? segment : segment.subarray(start - offset);
          segments.push(range);
          byteLength = range.byteLength;
        }
      } else if (end <= nextOffset) {
        const range = end === nextOffset ? segment : segment.subarray(0, end - offset);
        segments.push(range);
        byteLength += range.byteLength;
        break;
      } else {
        segments.push(segment);
        byteLength += segment.byteLength;
      }
      offset = nextOffset;
    }
    return new BufferView(segments, buffer4.byteOffset + start, byteLength);
  };
  var push = (buffer4, part) => {
    if (part.byteLength > 0) {
      buffer4.segments.push(part);
      return new BufferView(
        buffer4.segments,
        buffer4.byteOffset,
        buffer4.byteLength + part.byteLength
      );
    } else {
      return buffer4;
    }
  };
  var get5 = (buffer4, n8) => {
    if (n8 < buffer4.byteLength) {
      let offset = 0;
      for (const segment of buffer4.segments) {
        if (n8 < offset + segment.byteLength) {
          return segment[n8 - offset];
        } else {
          offset += segment.byteLength;
        }
      }
    }
    return void 0;
  };
  var copyTo = (buffer4, target, byteOffset) => {
    let offset = byteOffset;
    for (const segment of buffer4.segments) {
      target.set(segment, offset);
      offset += segment.byteLength;
    }
    return target;
  };
  function* iterate(buffer4) {
    for (const part of buffer4.segments) {
      yield* part;
    }
  }
  var BufferView = class extends Indexed {
    /**
     * @param {Uint8Array[]} segments
     * @param {number} byteOffset
     * @param {number} byteLength
     */
    constructor(segments = [], byteOffset = 0, byteLength = 0) {
      super();
      this.segments = segments;
      this.byteLength = byteLength;
      this.length = byteLength;
      this.byteOffset = byteOffset;
    }
    [Symbol.iterator]() {
      return iterate(this);
    }
    /**
     * @param {number} [start]
     * @param {number} [end]
     */
    slice(start, end) {
      return (
        /** @type {BufferView} */
        slice2(this, start, end)
      );
    }
    /**
     * @param {number} [start]
     * @param {number} [end]
     */
    subarray(start, end) {
      return (
        /** @type {BufferView} */
        slice2(this, start, end)
      );
    }
    /**
     *
     * @param {Uint8Array} bytes
     */
    push(bytes) {
      return (
        /** @type {BufferView} */
        push(this, bytes)
      );
    }
    /**
     * @param {number} n
     */
    get(n8) {
      return get5(this, n8);
    }
    /**
     *
     * @param {Uint8Array} target
     * @param {number} offset
     */
    copyTo(target, offset) {
      return copyTo(this, target, offset);
    }
  };

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/writer/util.js
  init_dirname();
  init_buffer2();
  init_process2();
  var panic = (reason) => {
    throw new Error(reason);
  };
  var unreachable = (template, subject, ...substitutions) => panic(String.raw(template, JSON.stringify(subject), ...substitutions));
  var EMPTY_BUFFER2 = new Uint8Array(0);
  var EMPTY2 = [];

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker.js
  var open3 = (config3) => ({
    config: config3,
    buffer: empty3()
  });
  var write2 = (state, bytes) => bytes.byteLength > 0 ? split(state.config, state.buffer.push(bytes), false) : { ...state, chunks: EMPTY2 };
  var close2 = (state) => split(state.config, state.buffer, true);
  var split = (config3, buffer4, end) => {
    const chunker = config3.chunker;
    const chunks = [];
    let offset = 0;
    for (const size of chunker.cut(chunker.context, buffer4, end)) {
      if (size > 0) {
        const chunk = buffer4.subarray(offset, offset + size);
        chunks.push(chunk);
        offset += size;
      }
    }
    return { config: config3, chunks, buffer: buffer4.subarray(offset) };
  };

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/layout/queue.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/layout/queue/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/layout/queue.js
  var mutable = () => ({
    mutable: true,
    needs: {},
    nodes: {},
    links: {},
    linked: EMPTY3
  });
  var addNodes = (newNodes, input) => {
    let queue2 = patch(input, {});
    for (const node of newNodes) {
      const { ready, has: has2, wants } = collect(node.children, queue2.links);
      if (wants.length === 0) {
        queue2 = patch(queue2, {
          links: assign(void 0, has2),
          linked: [{ id: node.id, links: ready }]
        });
      } else {
        queue2 = patch(queue2, {
          needs: assign(node.id, wants),
          nodes: {
            [node.id]: {
              children: node.children,
              count: wants.length
            }
          }
        });
      }
    }
    return queue2;
  };
  var addLink = (id, link4, queue2) => {
    const nodeID = queue2.needs[id];
    const node = queue2.nodes[nodeID];
    if (node != null) {
      if (node.count === 1) {
        const { ready, has: has2 } = collect(node.children, {
          ...queue2.links,
          [id]: link4
        });
        return patch(queue2, {
          needs: { [id]: void 0 },
          links: assign(void 0, has2),
          nodes: { [nodeID]: void 0 },
          linked: [{ id: nodeID, links: ready }]
        });
      } else {
        return patch(queue2, {
          needs: { [id]: void 0 },
          links: { [id]: link4 },
          nodes: {
            [nodeID]: {
              ...node,
              count: node.count - 1
            }
          }
        });
      }
    } else {
      return patch(queue2, {
        links: { [id]: link4 }
      });
    }
  };
  var patch = (queue2, { needs, nodes, links: links4, linked }) => {
    const result = queue2.mutable ? queue2 : { ...queue2 };
    const original = queue2.mutable ? BLANK3 : void 0;
    if (needs) {
      result.needs = patchDict(queue2.needs, needs, original);
    }
    if (nodes) {
      result.nodes = patchDict(queue2.nodes, nodes, original);
    }
    if (links4) {
      result.links = patchDict(queue2.links, links4, original);
    }
    result.linked = linked ? append(queue2.linked || EMPTY3, linked, EMPTY3) : queue2.linked || [];
    return (
      /** @type {Queue.Result} */
      result
    );
  };
  var assign = (value, keys) => {
    const delta = (
      /** @type {Record<K, V>} */
      {}
    );
    for (const key of keys) {
      delta[key] = value;
    }
    return delta;
  };
  var patchDict = (target, delta, original = target) => {
    const result = target === original ? { ...target } : target;
    for (const entry of Object.entries(delta)) {
      const [id, value] = (
        /** @type {[K, V|void]} */
        entry
      );
      if (value == null) {
        delete result[id];
      } else {
        result[id] = value;
      }
    }
    return result;
  };
  var append = (target, items, original = target) => {
    if (target === original) {
      return [...target, ...items];
    } else {
      for (const item of items) {
        target.push(item);
      }
      return target;
    }
  };
  var collect = (children, source) => {
    const has2 = [];
    const wants = [];
    const ready = [];
    for (const child of children) {
      const link4 = source[child];
      if (link4) {
        has2.push(child);
        ready.push(link4);
      } else {
        wants.push(child);
      }
    }
    return { has: has2, wants, ready };
  };
  var EMPTY3 = (
    /** @type {never[]} */
    Object.freeze([])
  );
  var BLANK3 = (
    /** @type {Record<never, never>} */
    Object.freeze({})
  );

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/writer.js
  var update = (message2, state) => {
    switch (message2.type) {
      case "write":
        return write3(state, message2.bytes);
      case "link":
        return link3(state, message2.link);
      /* c8 ignore next 2 */
      case "block":
        return { state, effect: none() };
      case "close":
        return close3(state);
      case "end":
        return { state, effect: none() };
      default:
        return unreachable`File Writer got unknown message ${message2}`;
    }
  };
  var init2 = (writer, metadata, config3) => {
    return {
      status: "open",
      metadata,
      config: config3,
      writer,
      chunker: open3({ chunker: config3.chunker }),
      layout: config3.fileLayout.open(),
      // Note: Writing in large slices e.g. 1GiB at a time creates large queues
      // with around `16353` items. Immutable version ends up copying it every
      // time state of the queue changes, which introduces significant overhead.
      // To avoid this overhead we use mutable implementation which is API
      // compatible but makes in place updates.
      // TODO: We should consider using Persistent bit-partitioned vector tries
      // instead of arrays which would provide immutable interface with neglegable
      // overhead.
      // @see https://github.com/Gozala/vectrie
      nodeQueue: mutable()
    };
  };
  var write3 = (state, bytes) => {
    if (state.status === "open") {
      const { chunks, ...chunker } = write2(state.chunker, bytes);
      const { nodes, leaves, layout } = state.config.fileLayout.write(
        state.layout,
        chunks
      );
      const { linked, ...nodeQueue } = addNodes(nodes, state.nodeQueue);
      const tasks = [
        ...encodeLeaves(leaves, state.config),
        ...encodeBranches(linked, state.config)
      ];
      return {
        state: {
          ...state,
          chunker,
          layout,
          nodeQueue
        },
        effect: listen({
          link: effects(tasks)
        })
      };
    } else {
      return panic("Unable to perform write on closed file");
    }
  };
  var link3 = (state, { id, link: link4, block }) => {
    let { linked, ...nodeQueue } = addLink(id, link4, state.nodeQueue);
    const tasks = encodeBranches(linked, state.config);
    const newState = state.status === "closed" && id === state.rootID ? {
      ...state,
      status: "linked",
      link: link4,
      nodeQueue
    } : { ...state, nodeQueue };
    const end = state.status === "closed" && id === state.rootID && state.end ? state.end.resume() : none();
    return {
      state: newState,
      effect: listen({
        link: effects(tasks),
        block: writeBlock(state.writer, block),
        end
      })
    };
  };
  var close3 = (state) => {
    if (state.status === "open") {
      const { chunks } = close2(state.chunker);
      const { layout, ...write7 } = state.config.fileLayout.write(
        state.layout,
        chunks
      );
      const { root: root2, ...close10 } = state.config.fileLayout.close(
        layout,
        state.metadata
      );
      const [nodes, leaves] = isLeafNode(root2) ? [
        [...write7.nodes, ...close10.nodes],
        [...write7.leaves, ...close10.leaves, root2]
      ] : [
        [...write7.nodes, ...close10.nodes, root2],
        [...write7.leaves, ...close10.leaves]
      ];
      const { linked, ...nodeQueue } = addNodes(nodes, state.nodeQueue);
      const tasks = [
        ...encodeLeaves(leaves, state.config),
        ...encodeBranches(linked, state.config)
      ];
      const fork4 = fork(suspend());
      return {
        state: {
          ...state,
          chunker: null,
          layout: null,
          rootID: root2.id,
          status: "closed",
          end: fork4,
          nodeQueue
        },
        effect: listen({
          link: effects(tasks),
          end: join2(fork4)
        })
      };
    } else {
      return { state, effect: none() };
    }
  };
  var encodeLeaves = (leaves, config3) => leaves.map((leaf) => encodeLeaf(config3, leaf, config3.fileChunkEncoder));
  var encodeLeaf = function* ({ hasher, linker }, { id, content }, encoder2) {
    const bytes = encoder2.encode(content ? asUint8Array(content) : EMPTY_BUFFER2);
    const hash2 = yield* wait(hasher.digest(bytes));
    const cid = linker.createLink(encoder2.code, hash2);
    const block = { cid, bytes };
    const link4 = (
      /** @type {UnixFS.FileLink} */
      {
        cid,
        contentByteLength: content ? content.byteLength : 0,
        dagByteLength: bytes.byteLength
      }
    );
    return { id, block, link: link4 };
  };
  var encodeBranches = (nodes, config3) => nodes.map((node) => encodeBranch(config3, node));
  var encodeBranch = function* (config3, { id, links: links4 }, metadata) {
    const bytes = config3.fileEncoder.encode({
      type: NodeType.File,
      layout: "advanced",
      parts: links4,
      metadata
    });
    const hash2 = yield* wait(Promise.resolve(config3.hasher.digest(bytes)));
    const cid = config3.linker.createLink(config3.fileEncoder.code, hash2);
    const block = { bytes, cid };
    const link4 = (
      /** @type {UnixFS.FileLink} */
      {
        cid,
        contentByteLength: cumulativeContentByteLength(links4),
        dagByteLength: cumulativeDagByteLength(bytes, links4)
      }
    );
    return { id, block, link: link4 };
  };
  var writeBlock = function* (writer, block) {
    if ((writer.desiredSize || 0) <= 0) {
      yield* wait(writer.ready);
    }
    writer.write(block);
  };
  var asUint8Array = (buffer4) => buffer4 instanceof Uint8Array ? buffer4 : buffer4.copyTo(new Uint8Array(buffer4.byteLength), 0);
  var isLeafNode = (node) => node.children == null;

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker/fixed.js
  var fixed_exports = {};
  __export(fixed_exports, {
    context: () => context,
    cut: () => cut,
    name: () => name4,
    type: () => type,
    withMaxChunkSize: () => withMaxChunkSize
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var name4 = "fixed";
  var context = {
    maxChunkSize: 262144
  };
  var type = "Stateless";
  var withMaxChunkSize = (maxChunkSize) => ({
    type: "Stateless",
    context: { maxChunkSize },
    name: name4,
    cut
  });
  var cut = ({ maxChunkSize }, { byteLength }, end) => {
    const n8 = byteLength / maxChunkSize | 0;
    const chunks = new Array(n8).fill(maxChunkSize);
    const lastChunkSize = end ? byteLength - n8 * maxChunkSize : 0;
    if (lastChunkSize > 0) {
      chunks.push(lastChunkSize);
    }
    return chunks;
  };

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/layout/balanced.js
  init_dirname();
  init_buffer2();
  init_process2();
  var Node = class {
    /**
     *
     * @param {number} id
     * @param {number[]} children
     * @param {Layout.Metadata} [metadata]
     */
    constructor(id, children, metadata) {
      this.id = id;
      this.children = children;
      this.metadata = metadata;
    }
  };
  var withWidth = (width) => ({
    open: () => open4({ width }),
    write: write4,
    close: close4
  });
  var defaults = { width: 174 };
  var open4 = ({ width } = defaults) => ({
    width,
    head: null,
    leafIndex: [],
    nodeIndex: [],
    lastID: 0
  });
  var write4 = (layout, chunks) => {
    if (chunks.length === 0) {
      return { layout, nodes: EMPTY4, leaves: EMPTY4 };
    } else {
      let { lastID } = layout;
      const [head, slices] = layout.head ? (
        // If we had a head we have more then two chunks (we already checked
        // chunks weren't empty) so we process head along with other chunks.
        [null, (chunks.unshift(layout.head), chunks)]
      ) : (
        // If we have no head no leaves and got only one chunk we have to save it
        // until we can decide what to do with it.
        chunks.length === 1 && layout.leafIndex.length === 0 ? [chunks[0], EMPTY4] : (
          // Otherwise we have no head but got enough chunks to know we'll have a
          // node.
          [null, chunks]
        )
      );
      if (slices.length === 0) {
        return { layout: { ...layout, head }, nodes: EMPTY4, leaves: EMPTY4 };
      } else {
        const leafIndex = [...layout.leafIndex];
        const leaves = [];
        for (const chunk of slices) {
          const leaf = { id: ++lastID, content: chunk };
          leaves.push(leaf);
          leafIndex.push(leaf.id);
        }
        if (leafIndex.length > layout.width) {
          return flush({ ...layout, leafIndex, head, lastID }, leaves);
        } else {
          return {
            layout: { ...layout, head, leafIndex, lastID },
            leaves,
            nodes: EMPTY4
          };
        }
      }
    }
  };
  var flush = (state, leaves = EMPTY4, nodes = [], close10 = false) => {
    let { lastID } = state;
    const nodeIndex = state.nodeIndex.map((row) => [...row]);
    const leafIndex = [...state.leafIndex];
    const { width } = state;
    while (leafIndex.length > width || leafIndex.length > 0 && close10) {
      grow(nodeIndex, 1);
      const node = new Node(++lastID, leafIndex.splice(0, width));
      nodeIndex[0].push(node.id);
      nodes.push(node);
    }
    let depth = 0;
    while (depth < nodeIndex.length) {
      const row = nodeIndex[depth];
      depth++;
      while (row.length > width || row.length > 0 && close10 && depth < nodeIndex.length) {
        const node = new Node(++lastID, row.splice(0, width));
        grow(nodeIndex, depth + 1);
        nodeIndex[depth].push(node.id);
        nodes.push(node);
      }
    }
    return { layout: { ...state, lastID, leafIndex, nodeIndex }, leaves, nodes };
  };
  var close4 = (layout, metadata) => {
    const state = layout;
    if (layout.head) {
      return {
        root: { id: 1, content: layout.head, metadata },
        leaves: EMPTY4,
        nodes: EMPTY4
      };
    } else if (layout.leafIndex.length === 0) {
      return {
        root: { id: 1, metadata },
        leaves: EMPTY4,
        nodes: EMPTY4
      };
    } else {
      const { nodes, layout: layout2 } = flush(state, EMPTY4, [], true);
      const { nodeIndex } = layout2;
      const height = nodeIndex.length - 1;
      const top = nodeIndex[height];
      if (top.length === 1) {
        const root2 = nodes[nodes.length - 1];
        nodes.length = nodes.length - 1;
        return { root: root2, nodes, leaves: EMPTY4 };
      } else {
        const root2 = new Node(layout2.lastID + 1, top, metadata);
        return { root: root2, nodes, leaves: EMPTY4 };
      }
    }
  };
  var grow = (index2, length4) => {
    while (index2.length < length4) {
      index2.push([]);
    }
    return index2;
  };
  var EMPTY4 = [];

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file.js
  var defaults2 = () => ({
    chunker: fixed_exports,
    fileChunkEncoder: UnixFSLeaf,
    smallFileEncoder: UnixFSLeaf,
    fileEncoder: codec_exports,
    fileLayout: withWidth(174),
    hasher: sha256,
    linker: { createLink: CID.createV1 }
  });
  var configure2 = (config3) => ({
    ...defaults2(),
    ...config3
  });
  var UnixFSLeaf = {
    code: code3,
    name: name3,
    encode: encodeFileChunk
  };
  var create7 = ({ writer, metadata = {}, settings: settings2 = defaults2() }) => new FileWriterView(init2(writer, metadata, configure2(settings2)));
  var write5 = async (view, bytes) => {
    await perform(view, send({ type: "write", bytes }));
    return view;
  };
  var close5 = async (view, { releaseLock = false, closeWriter = false } = {}) => {
    await perform(view, send({ type: "close" }));
    const { state } = view;
    if (state.status === "linked") {
      if (closeWriter) {
        await view.state.writer.close();
      } else if (releaseLock) {
        view.state.writer.releaseLock();
      }
      return state.link;
    } else {
      panic(
        `Expected writer to be in 'linked' state after close, but it is in "${state.status}" instead`
      );
    }
  };
  var perform = (view, effect2) => fork(
    loop(effect2, (message2) => {
      const { state, effect: effect3 } = update(message2, view.state);
      view.state = state;
      return effect3;
    })
  );
  var FileWriterView = class {
    /**
     * @param {Writer.State<Layout>} state
     */
    constructor(state) {
      this.state = state;
    }
    get writer() {
      return this.state.writer;
    }
    get settings() {
      return this.state.config;
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {Promise<API.View<Layout>>}
     */
    write(bytes) {
      return write5(this, bytes);
    }
    /**
     * @param {API.CloseOptions} [options]
     * @returns {Promise<UnixFS.FileLink>}
     */
    close(options) {
      return close5(this, options);
    }
  };

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/directory.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/directory/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/directory.js
  var defaults3 = defaults2;
  var create8 = ({ writer, settings: settings2 = defaults3(), metadata = {} }) => new DirectoryWriter({
    writer,
    metadata,
    settings: settings2,
    entries: /* @__PURE__ */ new Map(),
    closed: false
  });
  var set2 = (view, name8, link4, { overwrite = false } = {}) => {
    const writable = asWritable(view.state);
    if (name8.includes("/")) {
      throw new Error(
        `Directory entry name "${name8}" contains forbidden "/" character`
      );
    }
    if (!overwrite && writable.entries.has(name8)) {
      throw new Error(`Directory already contains entry with name "${name8}"`);
    } else {
      writable.entries.set(name8, link4);
      return view;
    }
  };
  var remove = (view, name8) => {
    const writer = asWritable(view.state);
    writer.entries.delete(name8);
    return view;
  };
  var asWritable = (writer) => {
    if (!writer.closed) {
      return writer;
    } else {
      throw new Error(
        `Can not change written directory, but you can .fork() and make changes to it`
      );
    }
  };
  var close6 = async (view, { closeWriter = false, releaseLock = false } = {}) => {
    const { writer, settings: settings2, metadata } = asWritable(view.state);
    view.state.closed = true;
    const entries3 = [...links3(view)];
    const node = createFlatDirectory(entries3, metadata);
    const bytes = encodeDirectory(node);
    const digest3 = await settings2.hasher.digest(bytes);
    const cid = settings2.linker.createLink(code3, digest3);
    if ((writer.desiredSize || 0) <= 0) {
      await writer.ready;
    }
    writer.write({ cid, bytes });
    if (closeWriter) {
      await writer.close();
    } else if (releaseLock) {
      writer.releaseLock();
    }
    return {
      cid,
      dagByteLength: cumulativeDagByteLength(bytes, entries3)
    };
  };
  var links3 = function* ({ state }) {
    for (const [name8, { dagByteLength, cid }] of state.entries) {
      yield (
        /** @type {UnixFS.DirectoryEntryLink} */
        {
          name: name8,
          dagByteLength,
          cid
        }
      );
    }
  };
  var fork2 = ({ state }, {
    writer = state.writer,
    metadata = state.metadata,
    settings: settings2 = state.settings
  } = {}) => new DirectoryWriter({
    writer,
    metadata,
    settings: settings2,
    entries: new Map(state.entries.entries()),
    closed: false
  });
  var DirectoryWriter = class {
    /**
     * @param {API.State<Layout>} state
     */
    constructor(state) {
      this.state = state;
    }
    get writer() {
      return this.state.writer;
    }
    get settings() {
      return this.state.settings;
    }
    links() {
      return links3(this);
    }
    /**
     * @param {string} name
     * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link
     * @param {API.WriteOptions} [options]
     */
    set(name8, link4, options) {
      return set2(this, name8, link4, options);
    }
    /**
     * @param {string} name
     */
    remove(name8) {
      return remove(this, name8);
    }
    /**
     * @template L
     * @param {Partial<API.Options<L>>} [options]
     * @returns {API.View<Layout|L>}
     */
    fork(options) {
      return fork2(this, options);
    }
    /**
     * @param {API.CloseOptions} [options]
     * @returns {Promise<UnixFS.DirectoryLink>}
     */
    close(options) {
      return close6(this, options);
    }
    entries() {
      return this.state.entries.entries();
    }
    /**
     * @param {string} name
     */
    has(name8) {
      return this.state.entries.has(name8);
    }
    get size() {
      return this.state.entries.size;
    }
  };

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/sharded-directory.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/lib.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/node.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/Uint32.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint32.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/api.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint32.js
  var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);
  var utf8 = new TextEncoder();
  var hash32 = import_murmurhash3js_revisited.default.x64.hash126;

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint8Array.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@multiformats+murmur3@2.1.8/node_modules/@multiformats/murmur3/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  var import_murmurhash3js_revisited2 = __toESM(require_murmurhash3js_revisited(), 1);
  function fromNumberTo32BitBuf(number) {
    const bytes = new Array(4);
    for (let i7 = 0; i7 < 4; i7++) {
      bytes[i7] = number & 255;
      number = number >> 8;
    }
    return new Uint8Array(bytes);
  }
  var murmur332 = from5({
    name: "murmur3-32",
    code: 35,
    encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited2.default.x86.hash32(input))
  });
  var murmur3128 = from5({
    name: "murmur3-128",
    code: 34,
    encode: (input) => bytes_exports3.fromHex(import_murmurhash3js_revisited2.default.x64.hash128(input))
  });
  var murmur364 = from5({
    name: "murmur3-x64-64",
    code: 34,
    encode: (input) => bytes_exports3.fromHex(import_murmurhash3js_revisited2.default.x64.hash128(input)).subarray(0, 8)
  });

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint8Array.js
  var utf82 = new TextEncoder();
  var toInt = (bytes, offset, count) => {
    let byteOffset = offset / 8 | 0;
    let bitOffset = offset % 8;
    let desired = count;
    let bits = 0;
    while (desired > 0 && byteOffset < bytes.byteLength) {
      const byte = bytes[byteOffset];
      const available = 8 - bitOffset;
      const taking = available < desired ? available : desired;
      const bitsLeft = 8 - bitOffset - taking;
      const mask = 255 >> bitOffset;
      const value = (mask & byte) >> bitsLeft;
      bits = (bits << taking) + value;
      desired -= taking;
      byteOffset++;
      bitOffset = 0;
    }
    return bits;
  };

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/Uint8Array.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/lib.js
  var NOT_FOUND = new RangeError("Not Found");

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/unixfs.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/InfiniteUint8Array.js
  init_dirname();
  init_buffer2();
  init_process2();
  var utf83 = new TextEncoder();
  var hash64 = (bytes) => (
    /** @type {Uint8Array} */
    murmur364.encode(bytes)
  );
  var configure5 = ({ bitWidth: bitWidth2 = 8, hash: hash2 = hash64 }) => {
    const hashSize = hash2(new Uint8Array()).byteLength;
    const options = { bitWidth: bitWidth2, hash: hash2, hashSize };
    const at = (path2, depth) => read4(path2, depth, options);
    const from8 = (key) => utf83.encode(key);
    return { at, from: from8, size: Infinity };
  };
  var read4 = (key, depth = 0, { bitWidth: bitWidth2 = 8, hash: hash2, hashSize }) => {
    const frameBitSize = hashSize * 8;
    let digest3 = 0;
    let bitCount2 = bitWidth2;
    let bitOffset = bitWidth2 * depth;
    while (bitCount2 > 0) {
      const frameOffset = bitOffset / frameBitSize >> 0;
      const frame = frameOffset === 0 ? hash2(key) : hash2(appendByte(key, frameOffset));
      const offset = frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset;
      const maxBits = frameBitSize - offset;
      const count = maxBits < bitCount2 ? maxBits : bitCount2;
      digest3 = (digest3 << count) + toInt(frame, offset, count);
      bitCount2 -= count;
      bitOffset += count;
    }
    return digest3;
  };
  var appendByte = (source, byte) => {
    const bytes = new Uint8Array(source.byteLength + 1).fill(
      byte,
      source.byteLength
    );
    bytes.set(source);
    return bytes;
  };

  // node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/unixfs.js
  var bitWidth = 8;
  var config2 = {
    bitWidth,
    Path: configure5({ bitWidth })
  };

  // node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/lib.js
  var createWriter = ({ writable, settings: settings2 = defaults2() }) => new FileSystemWriter({
    writer: writable.getWriter(),
    settings: settings2
  });
  var close8 = async (view, { releaseLock = true, closeWriter = true } = {}) => {
    if (closeWriter) {
      await view.writer.close();
    } else if (releaseLock) {
      view.writer.releaseLock();
    }
    return view;
  };
  var FileSystemWriter = class {
    /**
     * @param {object} options
     * @param {API.BlockWriter} options.writer
     * @param {Partial<API.EncoderSettings<Layout>>} options.settings
     */
    constructor({ writer, settings: settings2 }) {
      this.writer = writer;
      this.settings = configure2(settings2);
    }
    /**
     * @template [L=unknown]
     * @param {API.WriterOptions<L|Layout>} config
     */
    createFileWriter({ settings: settings2 = this.settings, metadata } = {}) {
      return create7({
        writer: this.writer,
        settings: settings2,
        metadata
      });
    }
    /**
     * @template [L=unknown]
     * @param {API.WriterOptions<L|Layout>} config
     */
    createDirectoryWriter({ settings: settings2 = this.settings, metadata } = {}) {
      return create8({
        writer: this.writer,
        settings: settings2,
        metadata
      });
    }
    /**
     * @param {API.CloseOptions} [options]
     */
    close(options) {
      return close8(this, options);
    }
  };
  var BLOCK_SIZE_LIMIT = 1048576;
  var defaultCapacity = BLOCK_SIZE_LIMIT * 100;
  var withCapacity = (byteLength = defaultCapacity) => ({
    highWaterMark: byteLength,
    size: (block) => block.bytes.length
  });

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/codecs/raw.js
  var raw_exports = {};
  __export(raw_exports, {
    code: () => code4,
    decode: () => decode14,
    encode: () => encode10,
    name: () => name5
  });
  init_dirname();
  init_buffer2();
  init_process2();
  init_bytes();
  var name5 = "raw";
  var code4 = 85;
  function encode10(node) {
    return coerce(node);
  }
  function decode14(data) {
    return coerce(data);
  }

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/it-last@3.0.6/node_modules/it-last/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function last(source) {
    if (isAsyncIterable(source)) {
      return (async () => {
        let res2;
        for await (const entry of source) {
          res2 = entry;
        }
        return res2;
      })();
    }
    let res;
    for (const entry of source) {
      res = entry;
    }
    return res;
  }
  var src_default = last;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/errors.js
  init_dirname();
  init_buffer2();
  init_process2();
  var BadPathError = class _BadPathError extends Error {
    static name = "BadPathError";
    static code = "ERR_BAD_PATH";
    name = _BadPathError.name;
    code = _BadPathError.code;
    constructor(message2 = "Bad path") {
      super(message2);
    }
  };
  var NotFoundError2 = class _NotFoundError extends Error {
    static name = "NotFoundError";
    static code = "ERR_NOT_FOUND";
    name = _NotFoundError.name;
    code = _NotFoundError.code;
    constructor(message2 = "Not found") {
      super(message2);
    }
  };
  var NoResolverError = class _NoResolverError extends Error {
    static name = "NoResolverError";
    static code = "ERR_NO_RESOLVER";
    name = _NoResolverError.name;
    code = _NoResolverError.code;
    constructor(message2 = "No resolver") {
      super(message2);
    }
  };
  var NotUnixFSError = class _NotUnixFSError extends Error {
    static name = "NotUnixFSError";
    static code = "ERR_NOT_UNIXFS";
    name = _NotUnixFSError.name;
    code = _NotUnixFSError.code;
    constructor(message2 = "Not UnixFS") {
      super(message2);
    }
  };
  var OverReadError = class _OverReadError extends Error {
    static name = "OverReadError";
    static code = "ERR_OVER_READ";
    name = _OverReadError.name;
    code = _OverReadError.code;
    constructor(message2 = "Over read") {
      super(message2);
    }
  };
  var UnderReadError = class _UnderReadError extends Error {
    static name = "UnderReadError";
    static code = "ERR_UNDER_READ";
    name = _UnderReadError.name;
    code = _UnderReadError.code;
    constructor(message2 = "Under read") {
      super(message2);
    }
  };
  var NoPropError = class _NoPropError extends Error {
    static name = "NoPropError";
    static code = "ERR_NO_PROP";
    name = _NoPropError.name;
    code = _NoPropError.code;
    constructor(message2 = "No Property found") {
      super(message2);
    }
  };
  var InvalidParametersError = class _InvalidParametersError extends Error {
    static name = "InvalidParametersError";
    static code = "ERR_INVALID_PARAMS";
    name = _InvalidParametersError.name;
    code = _InvalidParametersError.code;
    constructor(message2 = "Invalid parameters") {
      super(message2);
    }
  };

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+dag-json@10.2.2/node_modules/@ipld/dag-json/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/cborg.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/encode.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/is.js
  init_dirname();
  init_buffer2();
  init_process2();
  var typeofs2 = [
    "string",
    "number",
    "bigint",
    "symbol"
  ];
  var objectTypeNames2 = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "HTMLElement",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  function is2(value) {
    if (value === null) {
      return "null";
    }
    if (value === void 0) {
      return "undefined";
    }
    if (value === true || value === false) {
      return "boolean";
    }
    const typeOf = typeof value;
    if (typeofs2.includes(typeOf)) {
      return typeOf;
    }
    if (typeOf === "function") {
      return "Function";
    }
    if (Array.isArray(value)) {
      return "Array";
    }
    if (isBuffer5(value)) {
      return "Buffer";
    }
    const objectType = getObjectType2(value);
    if (objectType) {
      return objectType;
    }
    return "Object";
  }
  function isBuffer5(value) {
    return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
  }
  function getObjectType2(value) {
    const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
    if (objectTypeNames2.includes(objectTypeName)) {
      return objectTypeName;
    }
    return void 0;
  }

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/token.js
  init_dirname();
  init_buffer2();
  init_process2();
  var Type2 = class {
    /**
     * @param {number} major
     * @param {string} name
     * @param {boolean} terminal
     */
    constructor(major, name8, terminal) {
      this.major = major;
      this.majorEncoded = major << 5;
      this.name = name8;
      this.terminal = terminal;
    }
    /* c8 ignore next 3 */
    toString() {
      return `Type[${this.major}].${this.name}`;
    }
    /**
     * @param {Type} typ
     * @returns {number}
     */
    compare(typ) {
      return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
    }
  };
  Type2.uint = new Type2(0, "uint", true);
  Type2.negint = new Type2(1, "negint", true);
  Type2.bytes = new Type2(2, "bytes", true);
  Type2.string = new Type2(3, "string", true);
  Type2.array = new Type2(4, "array", false);
  Type2.map = new Type2(5, "map", false);
  Type2.tag = new Type2(6, "tag", false);
  Type2.float = new Type2(7, "float", true);
  Type2.false = new Type2(7, "false", true);
  Type2.true = new Type2(7, "true", true);
  Type2.null = new Type2(7, "null", true);
  Type2.undefined = new Type2(7, "undefined", true);
  Type2.break = new Type2(7, "break", true);
  var Token2 = class {
    /**
     * @param {Type} type
     * @param {any} [value]
     * @param {number} [encodedLength]
     */
    constructor(type2, value, encodedLength) {
      this.type = type2;
      this.value = value;
      this.encodedLength = encodedLength;
      this.encodedBytes = void 0;
      this.byteValue = void 0;
    }
    /* c8 ignore next 3 */
    toString() {
      return `Token[${this.type}].${this.value}`;
    }
  };

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/bl.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/byte-utils.js
  init_dirname();
  init_buffer2();
  init_process2();
  var useBuffer2 = globalThis.process && // @ts-ignore
  !globalThis.process.browser && // @ts-ignore
  globalThis.Buffer && // @ts-ignore
  typeof globalThis.Buffer.isBuffer === "function";
  var textDecoder3 = new TextDecoder();
  var textEncoder4 = new TextEncoder();
  function isBuffer6(buf3) {
    return useBuffer2 && globalThis.Buffer.isBuffer(buf3);
  }
  function asU8A2(buf3) {
    if (!(buf3 instanceof Uint8Array)) {
      return Uint8Array.from(buf3);
    }
    return isBuffer6(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
  }
  var toString4 = useBuffer2 ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      return end - start > 64 ? (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8")
      ) : utf8Slice2(bytes, start, end);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      return end - start > 64 ? textDecoder3.decode(bytes.subarray(start, end)) : utf8Slice2(bytes, start, end);
    }
  );
  var fromString4 = useBuffer2 ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {string} string
     */
    (string3) => {
      return string3.length > 64 ? (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(string3)
      ) : utf8ToBytes2(string3);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {string} string
     */
    (string3) => {
      return string3.length > 64 ? textEncoder4.encode(string3) : utf8ToBytes2(string3);
    }
  );
  var fromArray2 = (arr) => {
    return Uint8Array.from(arr);
  };
  var slice3 = useBuffer2 ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      if (isBuffer6(bytes)) {
        return new Uint8Array(bytes.subarray(start, end));
      }
      return bytes.slice(start, end);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      return bytes.slice(start, end);
    }
  );
  var concat2 = useBuffer2 ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array[]} chunks
     * @param {number} length
     * @returns {Uint8Array}
     */
    (chunks, length4) => {
      chunks = chunks.map((c7) => c7 instanceof Uint8Array ? c7 : (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(c7)
      ));
      return asU8A2(globalThis.Buffer.concat(chunks, length4));
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array[]} chunks
     * @param {number} length
     * @returns {Uint8Array}
     */
    (chunks, length4) => {
      const out = new Uint8Array(length4);
      let off2 = 0;
      for (let b5 of chunks) {
        if (off2 + b5.length > out.length) {
          b5 = b5.subarray(0, out.length - off2);
        }
        out.set(b5, off2);
        off2 += b5.length;
      }
      return out;
    }
  );
  var alloc2 = useBuffer2 ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {number} size
     * @returns {Uint8Array}
     */
    (size) => {
      return globalThis.Buffer.allocUnsafe(size);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {number} size
     * @returns {Uint8Array}
     */
    (size) => {
      return new Uint8Array(size);
    }
  );
  function compare2(b1, b22) {
    if (isBuffer6(b1) && isBuffer6(b22)) {
      return b1.compare(b22);
    }
    for (let i7 = 0; i7 < b1.length; i7++) {
      if (b1[i7] === b22[i7]) {
        continue;
      }
      return b1[i7] < b22[i7] ? -1 : 1;
    }
    return 0;
  }
  function utf8ToBytes2(str) {
    const out = [];
    let p7 = 0;
    for (let i7 = 0; i7 < str.length; i7++) {
      let c7 = str.charCodeAt(i7);
      if (c7 < 128) {
        out[p7++] = c7;
      } else if (c7 < 2048) {
        out[p7++] = c7 >> 6 | 192;
        out[p7++] = c7 & 63 | 128;
      } else if ((c7 & 64512) === 55296 && i7 + 1 < str.length && (str.charCodeAt(i7 + 1) & 64512) === 56320) {
        c7 = 65536 + ((c7 & 1023) << 10) + (str.charCodeAt(++i7) & 1023);
        out[p7++] = c7 >> 18 | 240;
        out[p7++] = c7 >> 12 & 63 | 128;
        out[p7++] = c7 >> 6 & 63 | 128;
        out[p7++] = c7 & 63 | 128;
      } else {
        out[p7++] = c7 >> 12 | 224;
        out[p7++] = c7 >> 6 & 63 | 128;
        out[p7++] = c7 & 63 | 128;
      }
    }
    return out;
  }
  function utf8Slice2(buf3, offset, end) {
    const res = [];
    while (offset < end) {
      const firstByte = buf3[offset];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (offset + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf3[offset + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf3[offset + 1];
            thirdByte = buf3[offset + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf3[offset + 1];
            thirdByte = buf3[offset + 2];
            fourthByte = buf3[offset + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      offset += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  var MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i7 = 0;
    while (i7 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/bl.js
  var defaultChunkSize2 = 256;
  var Bl2 = class {
    /**
     * @param {number} [chunkSize]
     */
    constructor(chunkSize = defaultChunkSize2) {
      this.chunkSize = chunkSize;
      this.cursor = 0;
      this.maxCursor = -1;
      this.chunks = [];
      this._initReuseChunk = null;
    }
    reset() {
      this.cursor = 0;
      this.maxCursor = -1;
      if (this.chunks.length) {
        this.chunks = [];
      }
      if (this._initReuseChunk !== null) {
        this.chunks.push(this._initReuseChunk);
        this.maxCursor = this._initReuseChunk.length - 1;
      }
    }
    /**
     * @param {Uint8Array|number[]} bytes
     */
    push(bytes) {
      let topChunk = this.chunks[this.chunks.length - 1];
      const newMax = this.cursor + bytes.length;
      if (newMax <= this.maxCursor + 1) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        topChunk.set(bytes, chunkPos);
      } else {
        if (topChunk) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          if (chunkPos < topChunk.length) {
            this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
            this.maxCursor = this.cursor - 1;
          }
        }
        if (bytes.length < 64 && bytes.length < this.chunkSize) {
          topChunk = alloc2(this.chunkSize);
          this.chunks.push(topChunk);
          this.maxCursor += topChunk.length;
          if (this._initReuseChunk === null) {
            this._initReuseChunk = topChunk;
          }
          topChunk.set(bytes, 0);
        } else {
          this.chunks.push(bytes);
          this.maxCursor += bytes.length;
        }
      }
      this.cursor += bytes.length;
    }
    /**
     * @param {boolean} [reset]
     * @returns {Uint8Array}
     */
    toBytes(reset = false) {
      let byts;
      if (this.chunks.length === 1) {
        const chunk = this.chunks[0];
        if (reset && this.cursor > chunk.length / 2) {
          byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
          this._initReuseChunk = null;
          this.chunks = [];
        } else {
          byts = slice3(chunk, 0, this.cursor);
        }
      } else {
        byts = concat2(this.chunks, this.cursor);
      }
      if (reset) {
        this.reset();
      }
      return byts;
    }
  };

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/common.js
  init_dirname();
  init_buffer2();
  init_process2();
  var decodeErrPrefix2 = "CBOR decode error:";
  var encodeErrPrefix2 = "CBOR encode error:";
  var uintMinorPrefixBytes2 = [];
  uintMinorPrefixBytes2[23] = 1;
  uintMinorPrefixBytes2[24] = 2;
  uintMinorPrefixBytes2[25] = 3;
  uintMinorPrefixBytes2[26] = 5;
  uintMinorPrefixBytes2[27] = 9;
  function assertEnoughData2(data, pos, need) {
    if (data.length - pos < need) {
      throw new Error(`${decodeErrPrefix2} not enough data for type`);
    }
  }

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/jump.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/0uint.js
  init_dirname();
  init_buffer2();
  init_process2();
  var uintBoundaries2 = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
  function readUint82(data, offset, options) {
    assertEnoughData2(data, offset, 1);
    const value = data[offset];
    if (options.strict === true && value < uintBoundaries2[0]) {
      throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint162(data, offset, options) {
    assertEnoughData2(data, offset, 2);
    const value = data[offset] << 8 | data[offset + 1];
    if (options.strict === true && value < uintBoundaries2[1]) {
      throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint322(data, offset, options) {
    assertEnoughData2(data, offset, 4);
    const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    if (options.strict === true && value < uintBoundaries2[2]) {
      throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint642(data, offset, options) {
    assertEnoughData2(data, offset, 8);
    const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
    const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
    if (options.strict === true && value < uintBoundaries2[3]) {
      throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
    }
    if (value <= Number.MAX_SAFE_INTEGER) {
      return Number(value);
    }
    if (options.allowBigInt === true) {
      return value;
    }
    throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
  }
  function decodeUint82(data, pos, _minor, options) {
    return new Token2(Type2.uint, readUint82(data, pos + 1, options), 2);
  }
  function decodeUint162(data, pos, _minor, options) {
    return new Token2(Type2.uint, readUint162(data, pos + 1, options), 3);
  }
  function decodeUint322(data, pos, _minor, options) {
    return new Token2(Type2.uint, readUint322(data, pos + 1, options), 5);
  }
  function decodeUint642(data, pos, _minor, options) {
    return new Token2(Type2.uint, readUint642(data, pos + 1, options), 9);
  }
  function encodeUint2(buf3, token) {
    return encodeUintValue2(buf3, 0, token.value);
  }
  function encodeUintValue2(buf3, major, uint) {
    if (uint < uintBoundaries2[0]) {
      const nuint = Number(uint);
      buf3.push([major | nuint]);
    } else if (uint < uintBoundaries2[1]) {
      const nuint = Number(uint);
      buf3.push([major | 24, nuint]);
    } else if (uint < uintBoundaries2[2]) {
      const nuint = Number(uint);
      buf3.push([major | 25, nuint >>> 8, nuint & 255]);
    } else if (uint < uintBoundaries2[3]) {
      const nuint = Number(uint);
      buf3.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
    } else {
      const buint = BigInt(uint);
      if (buint < uintBoundaries2[4]) {
        const set4 = [major | 27, 0, 0, 0, 0, 0, 0, 0];
        let lo = Number(buint & BigInt(4294967295));
        let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
        set4[8] = lo & 255;
        lo = lo >> 8;
        set4[7] = lo & 255;
        lo = lo >> 8;
        set4[6] = lo & 255;
        lo = lo >> 8;
        set4[5] = lo & 255;
        set4[4] = hi & 255;
        hi = hi >> 8;
        set4[3] = hi & 255;
        hi = hi >> 8;
        set4[2] = hi & 255;
        hi = hi >> 8;
        set4[1] = hi & 255;
        buf3.push(set4);
      } else {
        throw new Error(`${decodeErrPrefix2} encountered BigInt larger than allowable range`);
      }
    }
  }
  encodeUint2.encodedSize = function encodedSize9(token) {
    return encodeUintValue2.encodedSize(token.value);
  };
  encodeUintValue2.encodedSize = function encodedSize10(uint) {
    if (uint < uintBoundaries2[0]) {
      return 1;
    }
    if (uint < uintBoundaries2[1]) {
      return 2;
    }
    if (uint < uintBoundaries2[2]) {
      return 3;
    }
    if (uint < uintBoundaries2[3]) {
      return 5;
    }
    return 9;
  };
  encodeUint2.compareTokens = function compareTokens4(tok1, tok2) {
    return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
      /* c8 ignore next */
      0
    );
  };

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/1negint.js
  init_dirname();
  init_buffer2();
  init_process2();
  function decodeNegint82(data, pos, _minor, options) {
    return new Token2(Type2.negint, -1 - readUint82(data, pos + 1, options), 2);
  }
  function decodeNegint162(data, pos, _minor, options) {
    return new Token2(Type2.negint, -1 - readUint162(data, pos + 1, options), 3);
  }
  function decodeNegint322(data, pos, _minor, options) {
    return new Token2(Type2.negint, -1 - readUint322(data, pos + 1, options), 5);
  }
  var neg1b2 = BigInt(-1);
  var pos1b2 = BigInt(1);
  function decodeNegint642(data, pos, _minor, options) {
    const int3 = readUint642(data, pos + 1, options);
    if (typeof int3 !== "bigint") {
      const value = -1 - int3;
      if (value >= Number.MIN_SAFE_INTEGER) {
        return new Token2(Type2.negint, value, 9);
      }
    }
    if (options.allowBigInt !== true) {
      throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
    }
    return new Token2(Type2.negint, neg1b2 - BigInt(int3), 9);
  }
  function encodeNegint2(buf3, token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
    encodeUintValue2(buf3, token.type.majorEncoded, unsigned);
  }
  encodeNegint2.encodedSize = function encodedSize11(token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
    if (unsigned < uintBoundaries2[0]) {
      return 1;
    }
    if (unsigned < uintBoundaries2[1]) {
      return 2;
    }
    if (unsigned < uintBoundaries2[2]) {
      return 3;
    }
    if (unsigned < uintBoundaries2[3]) {
      return 5;
    }
    return 9;
  };
  encodeNegint2.compareTokens = function compareTokens5(tok1, tok2) {
    return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
      /* c8 ignore next */
      0
    );
  };

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/2bytes.js
  init_dirname();
  init_buffer2();
  init_process2();
  function toToken5(data, pos, prefix, length4) {
    assertEnoughData2(data, pos, prefix + length4);
    const buf3 = slice3(data, pos + prefix, pos + prefix + length4);
    return new Token2(Type2.bytes, buf3, prefix + length4);
  }
  function decodeBytesCompact2(data, pos, minor, _options) {
    return toToken5(data, pos, 1, minor);
  }
  function decodeBytes82(data, pos, _minor, options) {
    return toToken5(data, pos, 2, readUint82(data, pos + 1, options));
  }
  function decodeBytes162(data, pos, _minor, options) {
    return toToken5(data, pos, 3, readUint162(data, pos + 1, options));
  }
  function decodeBytes322(data, pos, _minor, options) {
    return toToken5(data, pos, 5, readUint322(data, pos + 1, options));
  }
  function decodeBytes642(data, pos, _minor, options) {
    const l7 = readUint642(data, pos + 1, options);
    if (typeof l7 === "bigint") {
      throw new Error(`${decodeErrPrefix2} 64-bit integer bytes lengths not supported`);
    }
    return toToken5(data, pos, 9, l7);
  }
  function tokenBytes2(token) {
    if (token.encodedBytes === void 0) {
      token.encodedBytes = token.type === Type2.string ? fromString4(token.value) : token.value;
    }
    return token.encodedBytes;
  }
  function encodeBytes2(buf3, token) {
    const bytes = tokenBytes2(token);
    encodeUintValue2(buf3, token.type.majorEncoded, bytes.length);
    buf3.push(bytes);
  }
  encodeBytes2.encodedSize = function encodedSize12(token) {
    const bytes = tokenBytes2(token);
    return encodeUintValue2.encodedSize(bytes.length) + bytes.length;
  };
  encodeBytes2.compareTokens = function compareTokens6(tok1, tok2) {
    return compareBytes2(tokenBytes2(tok1), tokenBytes2(tok2));
  };
  function compareBytes2(b1, b22) {
    return b1.length < b22.length ? -1 : b1.length > b22.length ? 1 : compare2(b1, b22);
  }

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/3string.js
  init_dirname();
  init_buffer2();
  init_process2();
  function toToken6(data, pos, prefix, length4, options) {
    const totLength = prefix + length4;
    assertEnoughData2(data, pos, totLength);
    const tok = new Token2(Type2.string, toString4(data, pos + prefix, pos + totLength), totLength);
    if (options.retainStringBytes === true) {
      tok.byteValue = slice3(data, pos + prefix, pos + totLength);
    }
    return tok;
  }
  function decodeStringCompact2(data, pos, minor, options) {
    return toToken6(data, pos, 1, minor, options);
  }
  function decodeString82(data, pos, _minor, options) {
    return toToken6(data, pos, 2, readUint82(data, pos + 1, options), options);
  }
  function decodeString162(data, pos, _minor, options) {
    return toToken6(data, pos, 3, readUint162(data, pos + 1, options), options);
  }
  function decodeString322(data, pos, _minor, options) {
    return toToken6(data, pos, 5, readUint322(data, pos + 1, options), options);
  }
  function decodeString642(data, pos, _minor, options) {
    const l7 = readUint642(data, pos + 1, options);
    if (typeof l7 === "bigint") {
      throw new Error(`${decodeErrPrefix2} 64-bit integer string lengths not supported`);
    }
    return toToken6(data, pos, 9, l7, options);
  }
  var encodeString2 = encodeBytes2;

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/4array.js
  init_dirname();
  init_buffer2();
  init_process2();
  function toToken7(_data, _pos, prefix, length4) {
    return new Token2(Type2.array, length4, prefix);
  }
  function decodeArrayCompact2(data, pos, minor, _options) {
    return toToken7(data, pos, 1, minor);
  }
  function decodeArray82(data, pos, _minor, options) {
    return toToken7(data, pos, 2, readUint82(data, pos + 1, options));
  }
  function decodeArray162(data, pos, _minor, options) {
    return toToken7(data, pos, 3, readUint162(data, pos + 1, options));
  }
  function decodeArray322(data, pos, _minor, options) {
    return toToken7(data, pos, 5, readUint322(data, pos + 1, options));
  }
  function decodeArray642(data, pos, _minor, options) {
    const l7 = readUint642(data, pos + 1, options);
    if (typeof l7 === "bigint") {
      throw new Error(`${decodeErrPrefix2} 64-bit integer array lengths not supported`);
    }
    return toToken7(data, pos, 9, l7);
  }
  function decodeArrayIndefinite2(data, pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
    }
    return toToken7(data, pos, 1, Infinity);
  }
  function encodeArray2(buf3, token) {
    encodeUintValue2(buf3, Type2.array.majorEncoded, token.value);
  }
  encodeArray2.compareTokens = encodeUint2.compareTokens;
  encodeArray2.encodedSize = function encodedSize13(token) {
    return encodeUintValue2.encodedSize(token.value);
  };

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/5map.js
  init_dirname();
  init_buffer2();
  init_process2();
  function toToken8(_data, _pos, prefix, length4) {
    return new Token2(Type2.map, length4, prefix);
  }
  function decodeMapCompact2(data, pos, minor, _options) {
    return toToken8(data, pos, 1, minor);
  }
  function decodeMap82(data, pos, _minor, options) {
    return toToken8(data, pos, 2, readUint82(data, pos + 1, options));
  }
  function decodeMap162(data, pos, _minor, options) {
    return toToken8(data, pos, 3, readUint162(data, pos + 1, options));
  }
  function decodeMap322(data, pos, _minor, options) {
    return toToken8(data, pos, 5, readUint322(data, pos + 1, options));
  }
  function decodeMap642(data, pos, _minor, options) {
    const l7 = readUint642(data, pos + 1, options);
    if (typeof l7 === "bigint") {
      throw new Error(`${decodeErrPrefix2} 64-bit integer map lengths not supported`);
    }
    return toToken8(data, pos, 9, l7);
  }
  function decodeMapIndefinite2(data, pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
    }
    return toToken8(data, pos, 1, Infinity);
  }
  function encodeMap2(buf3, token) {
    encodeUintValue2(buf3, Type2.map.majorEncoded, token.value);
  }
  encodeMap2.compareTokens = encodeUint2.compareTokens;
  encodeMap2.encodedSize = function encodedSize14(token) {
    return encodeUintValue2.encodedSize(token.value);
  };

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/6tag.js
  init_dirname();
  init_buffer2();
  init_process2();
  function decodeTagCompact2(_data, _pos, minor, _options) {
    return new Token2(Type2.tag, minor, 1);
  }
  function decodeTag82(data, pos, _minor, options) {
    return new Token2(Type2.tag, readUint82(data, pos + 1, options), 2);
  }
  function decodeTag162(data, pos, _minor, options) {
    return new Token2(Type2.tag, readUint162(data, pos + 1, options), 3);
  }
  function decodeTag322(data, pos, _minor, options) {
    return new Token2(Type2.tag, readUint322(data, pos + 1, options), 5);
  }
  function decodeTag642(data, pos, _minor, options) {
    return new Token2(Type2.tag, readUint642(data, pos + 1, options), 9);
  }
  function encodeTag2(buf3, token) {
    encodeUintValue2(buf3, Type2.tag.majorEncoded, token.value);
  }
  encodeTag2.compareTokens = encodeUint2.compareTokens;
  encodeTag2.encodedSize = function encodedSize15(token) {
    return encodeUintValue2.encodedSize(token.value);
  };

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/7float.js
  init_dirname();
  init_buffer2();
  init_process2();
  var MINOR_FALSE2 = 20;
  var MINOR_TRUE2 = 21;
  var MINOR_NULL2 = 22;
  var MINOR_UNDEFINED2 = 23;
  function decodeUndefined2(_data, _pos, _minor, options) {
    if (options.allowUndefined === false) {
      throw new Error(`${decodeErrPrefix2} undefined values are not supported`);
    } else if (options.coerceUndefinedToNull === true) {
      return new Token2(Type2.null, null, 1);
    }
    return new Token2(Type2.undefined, void 0, 1);
  }
  function decodeBreak2(_data, _pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
    }
    return new Token2(Type2.break, void 0, 1);
  }
  function createToken2(value, bytes, options) {
    if (options) {
      if (options.allowNaN === false && Number.isNaN(value)) {
        throw new Error(`${decodeErrPrefix2} NaN values are not supported`);
      }
      if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
        throw new Error(`${decodeErrPrefix2} Infinity values are not supported`);
      }
    }
    return new Token2(Type2.float, value, bytes);
  }
  function decodeFloat162(data, pos, _minor, options) {
    return createToken2(readFloat162(data, pos + 1), 3, options);
  }
  function decodeFloat322(data, pos, _minor, options) {
    return createToken2(readFloat322(data, pos + 1), 5, options);
  }
  function decodeFloat642(data, pos, _minor, options) {
    return createToken2(readFloat642(data, pos + 1), 9, options);
  }
  function encodeFloat2(buf3, token, options) {
    const float3 = token.value;
    if (float3 === false) {
      buf3.push([Type2.float.majorEncoded | MINOR_FALSE2]);
    } else if (float3 === true) {
      buf3.push([Type2.float.majorEncoded | MINOR_TRUE2]);
    } else if (float3 === null) {
      buf3.push([Type2.float.majorEncoded | MINOR_NULL2]);
    } else if (float3 === void 0) {
      buf3.push([Type2.float.majorEncoded | MINOR_UNDEFINED2]);
    } else {
      let decoded;
      let success = false;
      if (!options || options.float64 !== true) {
        encodeFloat162(float3);
        decoded = readFloat162(ui8a2, 1);
        if (float3 === decoded || Number.isNaN(float3)) {
          ui8a2[0] = 249;
          buf3.push(ui8a2.slice(0, 3));
          success = true;
        } else {
          encodeFloat322(float3);
          decoded = readFloat322(ui8a2, 1);
          if (float3 === decoded) {
            ui8a2[0] = 250;
            buf3.push(ui8a2.slice(0, 5));
            success = true;
          }
        }
      }
      if (!success) {
        encodeFloat642(float3);
        decoded = readFloat642(ui8a2, 1);
        ui8a2[0] = 251;
        buf3.push(ui8a2.slice(0, 9));
      }
    }
  }
  encodeFloat2.encodedSize = function encodedSize16(token, options) {
    const float3 = token.value;
    if (float3 === false || float3 === true || float3 === null || float3 === void 0) {
      return 1;
    }
    if (!options || options.float64 !== true) {
      encodeFloat162(float3);
      let decoded = readFloat162(ui8a2, 1);
      if (float3 === decoded || Number.isNaN(float3)) {
        return 3;
      }
      encodeFloat322(float3);
      decoded = readFloat322(ui8a2, 1);
      if (float3 === decoded) {
        return 5;
      }
    }
    return 9;
  };
  var buffer3 = new ArrayBuffer(9);
  var dataView2 = new DataView(buffer3, 1);
  var ui8a2 = new Uint8Array(buffer3, 0);
  function encodeFloat162(inp) {
    if (inp === Infinity) {
      dataView2.setUint16(0, 31744, false);
    } else if (inp === -Infinity) {
      dataView2.setUint16(0, 64512, false);
    } else if (Number.isNaN(inp)) {
      dataView2.setUint16(0, 32256, false);
    } else {
      dataView2.setFloat32(0, inp);
      const valu32 = dataView2.getUint32(0);
      const exponent = (valu32 & 2139095040) >> 23;
      const mantissa = valu32 & 8388607;
      if (exponent === 255) {
        dataView2.setUint16(0, 31744, false);
      } else if (exponent === 0) {
        dataView2.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
      } else {
        const logicalExponent = exponent - 127;
        if (logicalExponent < -24) {
          dataView2.setUint16(0, 0);
        } else if (logicalExponent < -14) {
          dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
          1 << 24 + logicalExponent, false);
        } else {
          dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
        }
      }
    }
  }
  function readFloat162(ui8a3, pos) {
    if (ui8a3.length - pos < 2) {
      throw new Error(`${decodeErrPrefix2} not enough data for float16`);
    }
    const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
    if (half === 31744) {
      return Infinity;
    }
    if (half === 64512) {
      return -Infinity;
    }
    if (half === 32256) {
      return NaN;
    }
    const exp = half >> 10 & 31;
    const mant = half & 1023;
    let val;
    if (exp === 0) {
      val = mant * 2 ** -24;
    } else if (exp !== 31) {
      val = (mant + 1024) * 2 ** (exp - 25);
    } else {
      val = mant === 0 ? Infinity : NaN;
    }
    return half & 32768 ? -val : val;
  }
  function encodeFloat322(inp) {
    dataView2.setFloat32(0, inp, false);
  }
  function readFloat322(ui8a3, pos) {
    if (ui8a3.length - pos < 4) {
      throw new Error(`${decodeErrPrefix2} not enough data for float32`);
    }
    const offset = (ui8a3.byteOffset || 0) + pos;
    return new DataView(ui8a3.buffer, offset, 4).getFloat32(0, false);
  }
  function encodeFloat642(inp) {
    dataView2.setFloat64(0, inp, false);
  }
  function readFloat642(ui8a3, pos) {
    if (ui8a3.length - pos < 8) {
      throw new Error(`${decodeErrPrefix2} not enough data for float64`);
    }
    const offset = (ui8a3.byteOffset || 0) + pos;
    return new DataView(ui8a3.buffer, offset, 8).getFloat64(0, false);
  }
  encodeFloat2.compareTokens = encodeUint2.compareTokens;

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/jump.js
  function invalidMinor2(data, pos, minor) {
    throw new Error(`${decodeErrPrefix2} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
  }
  function errorer2(msg) {
    return () => {
      throw new Error(`${decodeErrPrefix2} ${msg}`);
    };
  }
  var jump2 = [];
  for (let i7 = 0; i7 <= 23; i7++) {
    jump2[i7] = invalidMinor2;
  }
  jump2[24] = decodeUint82;
  jump2[25] = decodeUint162;
  jump2[26] = decodeUint322;
  jump2[27] = decodeUint642;
  jump2[28] = invalidMinor2;
  jump2[29] = invalidMinor2;
  jump2[30] = invalidMinor2;
  jump2[31] = invalidMinor2;
  for (let i7 = 32; i7 <= 55; i7++) {
    jump2[i7] = invalidMinor2;
  }
  jump2[56] = decodeNegint82;
  jump2[57] = decodeNegint162;
  jump2[58] = decodeNegint322;
  jump2[59] = decodeNegint642;
  jump2[60] = invalidMinor2;
  jump2[61] = invalidMinor2;
  jump2[62] = invalidMinor2;
  jump2[63] = invalidMinor2;
  for (let i7 = 64; i7 <= 87; i7++) {
    jump2[i7] = decodeBytesCompact2;
  }
  jump2[88] = decodeBytes82;
  jump2[89] = decodeBytes162;
  jump2[90] = decodeBytes322;
  jump2[91] = decodeBytes642;
  jump2[92] = invalidMinor2;
  jump2[93] = invalidMinor2;
  jump2[94] = invalidMinor2;
  jump2[95] = errorer2("indefinite length bytes/strings are not supported");
  for (let i7 = 96; i7 <= 119; i7++) {
    jump2[i7] = decodeStringCompact2;
  }
  jump2[120] = decodeString82;
  jump2[121] = decodeString162;
  jump2[122] = decodeString322;
  jump2[123] = decodeString642;
  jump2[124] = invalidMinor2;
  jump2[125] = invalidMinor2;
  jump2[126] = invalidMinor2;
  jump2[127] = errorer2("indefinite length bytes/strings are not supported");
  for (let i7 = 128; i7 <= 151; i7++) {
    jump2[i7] = decodeArrayCompact2;
  }
  jump2[152] = decodeArray82;
  jump2[153] = decodeArray162;
  jump2[154] = decodeArray322;
  jump2[155] = decodeArray642;
  jump2[156] = invalidMinor2;
  jump2[157] = invalidMinor2;
  jump2[158] = invalidMinor2;
  jump2[159] = decodeArrayIndefinite2;
  for (let i7 = 160; i7 <= 183; i7++) {
    jump2[i7] = decodeMapCompact2;
  }
  jump2[184] = decodeMap82;
  jump2[185] = decodeMap162;
  jump2[186] = decodeMap322;
  jump2[187] = decodeMap642;
  jump2[188] = invalidMinor2;
  jump2[189] = invalidMinor2;
  jump2[190] = invalidMinor2;
  jump2[191] = decodeMapIndefinite2;
  for (let i7 = 192; i7 <= 215; i7++) {
    jump2[i7] = decodeTagCompact2;
  }
  jump2[216] = decodeTag82;
  jump2[217] = decodeTag162;
  jump2[218] = decodeTag322;
  jump2[219] = decodeTag642;
  jump2[220] = invalidMinor2;
  jump2[221] = invalidMinor2;
  jump2[222] = invalidMinor2;
  jump2[223] = invalidMinor2;
  for (let i7 = 224; i7 <= 243; i7++) {
    jump2[i7] = errorer2("simple values are not supported");
  }
  jump2[244] = invalidMinor2;
  jump2[245] = invalidMinor2;
  jump2[246] = invalidMinor2;
  jump2[247] = decodeUndefined2;
  jump2[248] = errorer2("simple values are not supported");
  jump2[249] = decodeFloat162;
  jump2[250] = decodeFloat322;
  jump2[251] = decodeFloat642;
  jump2[252] = invalidMinor2;
  jump2[253] = invalidMinor2;
  jump2[254] = invalidMinor2;
  jump2[255] = decodeBreak2;
  var quick2 = [];
  for (let i7 = 0; i7 < 24; i7++) {
    quick2[i7] = new Token2(Type2.uint, i7, 1);
  }
  for (let i7 = -1; i7 >= -24; i7--) {
    quick2[31 - i7] = new Token2(Type2.negint, i7, 1);
  }
  quick2[64] = new Token2(Type2.bytes, new Uint8Array(0), 1);
  quick2[96] = new Token2(Type2.string, "", 1);
  quick2[128] = new Token2(Type2.array, 0, 1);
  quick2[160] = new Token2(Type2.map, 0, 1);
  quick2[244] = new Token2(Type2.false, false, 1);
  quick2[245] = new Token2(Type2.true, true, 1);
  quick2[246] = new Token2(Type2.null, null, 1);
  function quickEncodeToken2(token) {
    switch (token.type) {
      case Type2.false:
        return fromArray2([244]);
      case Type2.true:
        return fromArray2([245]);
      case Type2.null:
        return fromArray2([246]);
      case Type2.bytes:
        if (!token.value.length) {
          return fromArray2([64]);
        }
        return;
      case Type2.string:
        if (token.value === "") {
          return fromArray2([96]);
        }
        return;
      case Type2.array:
        if (token.value === 0) {
          return fromArray2([128]);
        }
        return;
      case Type2.map:
        if (token.value === 0) {
          return fromArray2([160]);
        }
        return;
      case Type2.uint:
        if (token.value < 24) {
          return fromArray2([Number(token.value)]);
        }
        return;
      case Type2.negint:
        if (token.value >= -24) {
          return fromArray2([31 - Number(token.value)]);
        }
    }
  }

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/encode.js
  var defaultEncodeOptions2 = {
    float64: false,
    mapSorter: mapSorter2,
    quickEncodeToken: quickEncodeToken2
  };
  function makeCborEncoders2() {
    const encoders = [];
    encoders[Type2.uint.major] = encodeUint2;
    encoders[Type2.negint.major] = encodeNegint2;
    encoders[Type2.bytes.major] = encodeBytes2;
    encoders[Type2.string.major] = encodeString2;
    encoders[Type2.array.major] = encodeArray2;
    encoders[Type2.map.major] = encodeMap2;
    encoders[Type2.tag.major] = encodeTag2;
    encoders[Type2.float.major] = encodeFloat2;
    return encoders;
  }
  var cborEncoders2 = makeCborEncoders2();
  var buf2 = new Bl2();
  var Ref2 = class _Ref {
    /**
     * @param {object|any[]} obj
     * @param {Reference|undefined} parent
     */
    constructor(obj, parent) {
      this.obj = obj;
      this.parent = parent;
    }
    /**
     * @param {object|any[]} obj
     * @returns {boolean}
     */
    includes(obj) {
      let p7 = this;
      do {
        if (p7.obj === obj) {
          return true;
        }
      } while (p7 = p7.parent);
      return false;
    }
    /**
     * @param {Reference|undefined} stack
     * @param {object|any[]} obj
     * @returns {Reference}
     */
    static createCheck(stack, obj) {
      if (stack && stack.includes(obj)) {
        throw new Error(`${encodeErrPrefix2} object contains circular references`);
      }
      return new _Ref(obj, stack);
    }
  };
  var simpleTokens2 = {
    null: new Token2(Type2.null, null),
    undefined: new Token2(Type2.undefined, void 0),
    true: new Token2(Type2.true, true),
    false: new Token2(Type2.false, false),
    emptyArray: new Token2(Type2.array, 0),
    emptyMap: new Token2(Type2.map, 0)
  };
  var typeEncoders2 = {
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    number(obj, _typ, _options, _refStack) {
      if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
        return new Token2(Type2.float, obj);
      } else if (obj >= 0) {
        return new Token2(Type2.uint, obj);
      } else {
        return new Token2(Type2.negint, obj);
      }
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    bigint(obj, _typ, _options, _refStack) {
      if (obj >= BigInt(0)) {
        return new Token2(Type2.uint, obj);
      } else {
        return new Token2(Type2.negint, obj);
      }
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    Uint8Array(obj, _typ, _options, _refStack) {
      return new Token2(Type2.bytes, obj);
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    string(obj, _typ, _options, _refStack) {
      return new Token2(Type2.string, obj);
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    boolean(obj, _typ, _options, _refStack) {
      return obj ? simpleTokens2.true : simpleTokens2.false;
    },
    /**
     * @param {any} _obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    null(_obj, _typ, _options, _refStack) {
      return simpleTokens2.null;
    },
    /**
     * @param {any} _obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    undefined(_obj, _typ, _options, _refStack) {
      return simpleTokens2.undefined;
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    ArrayBuffer(obj, _typ, _options, _refStack) {
      return new Token2(Type2.bytes, new Uint8Array(obj));
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    DataView(obj, _typ, _options, _refStack) {
      return new Token2(Type2.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} options
     * @param {Reference} [refStack]
     * @returns {TokenOrNestedTokens}
     */
    Array(obj, _typ, options, refStack) {
      if (!obj.length) {
        if (options.addBreakTokens === true) {
          return [simpleTokens2.emptyArray, new Token2(Type2.break)];
        }
        return simpleTokens2.emptyArray;
      }
      refStack = Ref2.createCheck(refStack, obj);
      const entries3 = [];
      let i7 = 0;
      for (const e9 of obj) {
        entries3[i7++] = objectToTokens2(e9, options, refStack);
      }
      if (options.addBreakTokens) {
        return [new Token2(Type2.array, obj.length), entries3, new Token2(Type2.break)];
      }
      return [new Token2(Type2.array, obj.length), entries3];
    },
    /**
     * @param {any} obj
     * @param {string} typ
     * @param {EncodeOptions} options
     * @param {Reference} [refStack]
     * @returns {TokenOrNestedTokens}
     */
    Object(obj, typ, options, refStack) {
      const isMap2 = typ !== "Object";
      const keys = isMap2 ? obj.keys() : Object.keys(obj);
      const length4 = isMap2 ? obj.size : keys.length;
      if (!length4) {
        if (options.addBreakTokens === true) {
          return [simpleTokens2.emptyMap, new Token2(Type2.break)];
        }
        return simpleTokens2.emptyMap;
      }
      refStack = Ref2.createCheck(refStack, obj);
      const entries3 = [];
      let i7 = 0;
      for (const key of keys) {
        entries3[i7++] = [
          objectToTokens2(key, options, refStack),
          objectToTokens2(isMap2 ? obj.get(key) : obj[key], options, refStack)
        ];
      }
      sortMapEntries2(entries3, options);
      if (options.addBreakTokens) {
        return [new Token2(Type2.map, length4), entries3, new Token2(Type2.break)];
      }
      return [new Token2(Type2.map, length4), entries3];
    }
  };
  typeEncoders2.Map = typeEncoders2.Object;
  typeEncoders2.Buffer = typeEncoders2.Uint8Array;
  for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
    typeEncoders2[`${typ}Array`] = typeEncoders2.DataView;
  }
  function objectToTokens2(obj, options = {}, refStack) {
    const typ = is2(obj);
    const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
    options.typeEncoders[typ] || typeEncoders2[typ];
    if (typeof customTypeEncoder === "function") {
      const tokens = customTypeEncoder(obj, typ, options, refStack);
      if (tokens != null) {
        return tokens;
      }
    }
    const typeEncoder = typeEncoders2[typ];
    if (!typeEncoder) {
      throw new Error(`${encodeErrPrefix2} unsupported type: ${typ}`);
    }
    return typeEncoder(obj, typ, options, refStack);
  }
  function sortMapEntries2(entries3, options) {
    if (options.mapSorter) {
      entries3.sort(options.mapSorter);
    }
  }
  function mapSorter2(e1, e22) {
    const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
    const keyToken2 = Array.isArray(e22[0]) ? e22[0][0] : e22[0];
    if (keyToken1.type !== keyToken2.type) {
      return keyToken1.type.compare(keyToken2.type);
    }
    const major = keyToken1.type.major;
    const tcmp = cborEncoders2[major].compareTokens(keyToken1, keyToken2);
    if (tcmp === 0) {
      console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
    }
    return tcmp;
  }
  function tokensToEncoded2(buf3, tokens, encoders, options) {
    if (Array.isArray(tokens)) {
      for (const token of tokens) {
        tokensToEncoded2(buf3, token, encoders, options);
      }
    } else {
      encoders[tokens.type.major](buf3, tokens, options);
    }
  }
  function encodeCustom2(data, encoders, options) {
    const tokens = objectToTokens2(data, options);
    if (!Array.isArray(tokens) && options.quickEncodeToken) {
      const quickBytes = options.quickEncodeToken(tokens);
      if (quickBytes) {
        return quickBytes;
      }
      const encoder2 = encoders[tokens.type.major];
      if (encoder2.encodedSize) {
        const size = encoder2.encodedSize(tokens, options);
        const buf3 = new Bl2(size);
        encoder2(buf3, tokens, options);
        if (buf3.chunks.length !== 1) {
          throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
        }
        return asU8A2(buf3.chunks[0]);
      }
    }
    buf2.reset();
    tokensToEncoded2(buf2, tokens, encoders, options);
    return buf2.toBytes(true);
  }
  function encode11(data, options) {
    options = Object.assign({}, defaultEncodeOptions2, options);
    return encodeCustom2(data, cborEncoders2, options);
  }

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/decode.js
  init_dirname();
  init_buffer2();
  init_process2();
  var defaultDecodeOptions2 = {
    strict: false,
    allowIndefinite: true,
    allowUndefined: true,
    allowBigInt: true
  };
  var Tokeniser2 = class {
    /**
     * @param {Uint8Array} data
     * @param {DecodeOptions} options
     */
    constructor(data, options = {}) {
      this._pos = 0;
      this.data = data;
      this.options = options;
    }
    pos() {
      return this._pos;
    }
    done() {
      return this._pos >= this.data.length;
    }
    next() {
      const byt = this.data[this._pos];
      let token = quick2[byt];
      if (token === void 0) {
        const decoder2 = jump2[byt];
        if (!decoder2) {
          throw new Error(`${decodeErrPrefix2} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
        }
        const minor = byt & 31;
        token = decoder2(this.data, this._pos, minor, this.options);
      }
      this._pos += token.encodedLength;
      return token;
    }
  };
  var DONE2 = Symbol.for("DONE");
  var BREAK4 = Symbol.for("BREAK");
  function tokenToArray2(token, tokeniser, options) {
    const arr = [];
    for (let i7 = 0; i7 < token.value; i7++) {
      const value = tokensToObject2(tokeniser, options);
      if (value === BREAK4) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed array`);
      }
      if (value === DONE2) {
        throw new Error(`${decodeErrPrefix2} found array but not enough entries (got ${i7}, expected ${token.value})`);
      }
      arr[i7] = value;
    }
    return arr;
  }
  function tokenToMap2(token, tokeniser, options) {
    const useMaps = options.useMaps === true;
    const obj = useMaps ? void 0 : {};
    const m6 = useMaps ? /* @__PURE__ */ new Map() : void 0;
    for (let i7 = 0; i7 < token.value; i7++) {
      const key = tokensToObject2(tokeniser, options);
      if (key === BREAK4) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed map`);
      }
      if (key === DONE2) {
        throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i7} [no key], expected ${token.value})`);
      }
      if (useMaps !== true && typeof key !== "string") {
        throw new Error(`${decodeErrPrefix2} non-string keys not supported (got ${typeof key})`);
      }
      if (options.rejectDuplicateMapKeys === true) {
        if (useMaps && m6.has(key) || !useMaps && key in obj) {
          throw new Error(`${decodeErrPrefix2} found repeat map key "${key}"`);
        }
      }
      const value = tokensToObject2(tokeniser, options);
      if (value === DONE2) {
        throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i7} [no value], expected ${token.value})`);
      }
      if (useMaps) {
        m6.set(key, value);
      } else {
        obj[key] = value;
      }
    }
    return useMaps ? m6 : obj;
  }
  function tokensToObject2(tokeniser, options) {
    if (tokeniser.done()) {
      return DONE2;
    }
    const token = tokeniser.next();
    if (token.type === Type2.break) {
      return BREAK4;
    }
    if (token.type.terminal) {
      return token.value;
    }
    if (token.type === Type2.array) {
      return tokenToArray2(token, tokeniser, options);
    }
    if (token.type === Type2.map) {
      return tokenToMap2(token, tokeniser, options);
    }
    if (token.type === Type2.tag) {
      if (options.tags && typeof options.tags[token.value] === "function") {
        const tagged = tokensToObject2(tokeniser, options);
        return options.tags[token.value](tagged);
      }
      throw new Error(`${decodeErrPrefix2} tag not supported (${token.value})`);
    }
    throw new Error("unsupported");
  }
  function decodeFirst2(data, options) {
    if (!(data instanceof Uint8Array)) {
      throw new Error(`${decodeErrPrefix2} data to decode must be a Uint8Array`);
    }
    options = Object.assign({}, defaultDecodeOptions2, options);
    const tokeniser = options.tokenizer || new Tokeniser2(data, options);
    const decoded = tokensToObject2(tokeniser, options);
    if (decoded === DONE2) {
      throw new Error(`${decodeErrPrefix2} did not find any content to decode`);
    }
    if (decoded === BREAK4) {
      throw new Error(`${decodeErrPrefix2} got unexpected break`);
    }
    return [decoded, data.subarray(tokeniser.pos())];
  }
  function decode15(data, options) {
    const [decoded, remainder] = decodeFirst2(data, options);
    if (remainder.length > 0) {
      throw new Error(`${decodeErrPrefix2} too many terminals, data makes no sense`);
    }
    return decoded;
  }

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/json/json.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/json/encode.js
  init_dirname();
  init_buffer2();
  init_process2();
  var JSONEncoder = class extends Array {
    constructor() {
      super();
      this.inRecursive = [];
    }
    /**
     * @param {Bl} buf
     */
    prefix(buf3) {
      const recurs = this.inRecursive[this.inRecursive.length - 1];
      if (recurs) {
        if (recurs.type === Type2.array) {
          recurs.elements++;
          if (recurs.elements !== 1) {
            buf3.push([44]);
          }
        }
        if (recurs.type === Type2.map) {
          recurs.elements++;
          if (recurs.elements !== 1) {
            if (recurs.elements % 2 === 1) {
              buf3.push([44]);
            } else {
              buf3.push([58]);
            }
          }
        }
      }
    }
    /**
     * @param {Bl} buf
     * @param {Token} token
     */
    [Type2.uint.major](buf3, token) {
      this.prefix(buf3);
      const is3 = String(token.value);
      const isa = [];
      for (let i7 = 0; i7 < is3.length; i7++) {
        isa[i7] = is3.charCodeAt(i7);
      }
      buf3.push(isa);
    }
    /**
     * @param {Bl} buf
     * @param {Token} token
     */
    [Type2.negint.major](buf3, token) {
      this[Type2.uint.major](buf3, token);
    }
    /**
     * @param {Bl} _buf
     * @param {Token} _token
     */
    [Type2.bytes.major](_buf, _token) {
      throw new Error(`${encodeErrPrefix2} unsupported type: Uint8Array`);
    }
    /**
     * @param {Bl} buf
     * @param {Token} token
     */
    [Type2.string.major](buf3, token) {
      this.prefix(buf3);
      const byts = fromString4(JSON.stringify(token.value));
      buf3.push(byts.length > 32 ? asU8A2(byts) : byts);
    }
    /**
     * @param {Bl} buf
     * @param {Token} _token
     */
    [Type2.array.major](buf3, _token) {
      this.prefix(buf3);
      this.inRecursive.push({ type: Type2.array, elements: 0 });
      buf3.push([91]);
    }
    /**
     * @param {Bl} buf
     * @param {Token} _token
     */
    [Type2.map.major](buf3, _token) {
      this.prefix(buf3);
      this.inRecursive.push({ type: Type2.map, elements: 0 });
      buf3.push([123]);
    }
    /**
     * @param {Bl} _buf
     * @param {Token} _token
     */
    [Type2.tag.major](_buf, _token) {
    }
    /**
     * @param {Bl} buf
     * @param {Token} token
     */
    [Type2.float.major](buf3, token) {
      if (token.type.name === "break") {
        const recurs = this.inRecursive.pop();
        if (recurs) {
          if (recurs.type === Type2.array) {
            buf3.push([93]);
          } else if (recurs.type === Type2.map) {
            buf3.push([125]);
          } else {
            throw new Error("Unexpected recursive type; this should not happen!");
          }
          return;
        }
        throw new Error("Unexpected break; this should not happen!");
      }
      if (token.value === void 0) {
        throw new Error(`${encodeErrPrefix2} unsupported type: undefined`);
      }
      this.prefix(buf3);
      if (token.type.name === "true") {
        buf3.push([116, 114, 117, 101]);
        return;
      } else if (token.type.name === "false") {
        buf3.push([102, 97, 108, 115, 101]);
        return;
      } else if (token.type.name === "null") {
        buf3.push([110, 117, 108, 108]);
        return;
      }
      const is3 = String(token.value);
      const isa = [];
      let dp = false;
      for (let i7 = 0; i7 < is3.length; i7++) {
        isa[i7] = is3.charCodeAt(i7);
        if (!dp && (isa[i7] === 46 || isa[i7] === 101 || isa[i7] === 69)) {
          dp = true;
        }
      }
      if (!dp) {
        isa.push(46);
        isa.push(48);
      }
      buf3.push(isa);
    }
  };
  function mapSorter3(e1, e22) {
    if (Array.isArray(e1[0]) || Array.isArray(e22[0])) {
      throw new Error(`${encodeErrPrefix2} complex map keys are not supported`);
    }
    const keyToken1 = e1[0];
    const keyToken2 = e22[0];
    if (keyToken1.type !== Type2.string || keyToken2.type !== Type2.string) {
      throw new Error(`${encodeErrPrefix2} non-string map keys are not supported`);
    }
    if (keyToken1 < keyToken2) {
      return -1;
    }
    if (keyToken1 > keyToken2) {
      return 1;
    }
    throw new Error(`${encodeErrPrefix2} unexpected duplicate map keys, this is not supported`);
  }
  var defaultEncodeOptions3 = { addBreakTokens: true, mapSorter: mapSorter3 };
  function encode12(data, options) {
    options = Object.assign({}, defaultEncodeOptions3, options);
    return encodeCustom2(data, new JSONEncoder(), options);
  }

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/json/decode.js
  init_dirname();
  init_buffer2();
  init_process2();
  var Tokenizer = class {
    /**
     * @param {Uint8Array} data
     * @param {DecodeOptions} options
     */
    constructor(data, options = {}) {
      this._pos = 0;
      this.data = data;
      this.options = options;
      this.modeStack = ["value"];
      this.lastToken = "";
    }
    pos() {
      return this._pos;
    }
    /**
     * @returns {boolean}
     */
    done() {
      return this._pos >= this.data.length;
    }
    /**
     * @returns {number}
     */
    ch() {
      return this.data[this._pos];
    }
    /**
     * @returns {string}
     */
    currentMode() {
      return this.modeStack[this.modeStack.length - 1];
    }
    skipWhitespace() {
      let c7 = this.ch();
      while (c7 === 32 || c7 === 9 || c7 === 13 || c7 === 10) {
        c7 = this.data[++this._pos];
      }
    }
    /**
     * @param {number[]} str
     */
    expect(str) {
      if (this.data.length - this._pos < str.length) {
        throw new Error(`${decodeErrPrefix2} unexpected end of input at position ${this._pos}`);
      }
      for (let i7 = 0; i7 < str.length; i7++) {
        if (this.data[this._pos++] !== str[i7]) {
          throw new Error(`${decodeErrPrefix2} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`);
        }
      }
    }
    parseNumber() {
      const startPos = this._pos;
      let negative = false;
      let float3 = false;
      const swallow = (chars) => {
        while (!this.done()) {
          const ch = this.ch();
          if (chars.includes(ch)) {
            this._pos++;
          } else {
            break;
          }
        }
      };
      if (this.ch() === 45) {
        negative = true;
        this._pos++;
      }
      if (this.ch() === 48) {
        this._pos++;
        if (this.ch() === 46) {
          this._pos++;
          float3 = true;
        } else {
          return new Token2(Type2.uint, 0, this._pos - startPos);
        }
      }
      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
      if (negative && this._pos === startPos + 1) {
        throw new Error(`${decodeErrPrefix2} unexpected token at position ${this._pos}`);
      }
      if (!this.done() && this.ch() === 46) {
        if (float3) {
          throw new Error(`${decodeErrPrefix2} unexpected token at position ${this._pos}`);
        }
        float3 = true;
        this._pos++;
        swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
      }
      if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
        float3 = true;
        this._pos++;
        if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
          this._pos++;
        }
        swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
      }
      const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos));
      const num = parseFloat(numStr);
      if (float3) {
        return new Token2(Type2.float, num, this._pos - startPos);
      }
      if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
        return new Token2(num >= 0 ? Type2.uint : Type2.negint, num, this._pos - startPos);
      }
      return new Token2(num >= 0 ? Type2.uint : Type2.negint, BigInt(numStr), this._pos - startPos);
    }
    /**
     * @returns {Token}
     */
    parseString() {
      if (this.ch() !== 34) {
        throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}; this shouldn't happen`);
      }
      this._pos++;
      for (let i7 = this._pos, l7 = 0; i7 < this.data.length && l7 < 65536; i7++, l7++) {
        const ch = this.data[i7];
        if (ch === 92 || ch < 32 || ch >= 128) {
          break;
        }
        if (ch === 34) {
          const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i7));
          this._pos = i7 + 1;
          return new Token2(Type2.string, str, l7);
        }
      }
      const startPos = this._pos;
      const chars = [];
      const readu4 = () => {
        if (this._pos + 4 >= this.data.length) {
          throw new Error(`${decodeErrPrefix2} unexpected end of unicode escape sequence at position ${this._pos}`);
        }
        let u42 = 0;
        for (let i7 = 0; i7 < 4; i7++) {
          let ch = this.ch();
          if (ch >= 48 && ch <= 57) {
            ch -= 48;
          } else if (ch >= 97 && ch <= 102) {
            ch = ch - 97 + 10;
          } else if (ch >= 65 && ch <= 70) {
            ch = ch - 65 + 10;
          } else {
            throw new Error(`${decodeErrPrefix2} unexpected unicode escape character at position ${this._pos}`);
          }
          u42 = u42 * 16 + ch;
          this._pos++;
        }
        return u42;
      };
      const readUtf8Char = () => {
        const firstByte = this.ch();
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (this._pos + bytesPerSequence > this.data.length) {
          throw new Error(`${decodeErrPrefix2} unexpected unicode sequence at position ${this._pos}`);
        }
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          /* c8 ignore next 6 */
          // this case is dealt with by the caller function
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = this.data[this._pos + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = this.data[this._pos + 1];
            thirdByte = this.data[this._pos + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = this.data[this._pos + 1];
            thirdByte = this.data[this._pos + 2];
            fourthByte = this.data[this._pos + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          chars.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        chars.push(codePoint);
        this._pos += bytesPerSequence;
      };
      while (!this.done()) {
        const ch = this.ch();
        let ch1;
        switch (ch) {
          case 92:
            this._pos++;
            if (this.done()) {
              throw new Error(`${decodeErrPrefix2} unexpected string termination at position ${this._pos}`);
            }
            ch1 = this.ch();
            this._pos++;
            switch (ch1) {
              case 34:
              // '"'
              case 39:
              // '\''
              case 92:
              // '\'
              case 47:
                chars.push(ch1);
                break;
              case 98:
                chars.push(8);
                break;
              case 116:
                chars.push(9);
                break;
              case 110:
                chars.push(10);
                break;
              case 102:
                chars.push(12);
                break;
              case 114:
                chars.push(13);
                break;
              case 117:
                chars.push(readu4());
                break;
              default:
                throw new Error(`${decodeErrPrefix2} unexpected string escape character at position ${this._pos}`);
            }
            break;
          case 34:
            this._pos++;
            return new Token2(Type2.string, decodeCodePointsArray2(chars), this._pos - startPos);
          default:
            if (ch < 32) {
              throw new Error(`${decodeErrPrefix2} invalid control character at position ${this._pos}`);
            } else if (ch < 128) {
              chars.push(ch);
              this._pos++;
            } else {
              readUtf8Char();
            }
        }
      }
      throw new Error(`${decodeErrPrefix2} unexpected end of string at position ${this._pos}`);
    }
    /**
     * @returns {Token}
     */
    parseValue() {
      switch (this.ch()) {
        case 123:
          this.modeStack.push("obj-start");
          this._pos++;
          return new Token2(Type2.map, Infinity, 1);
        case 91:
          this.modeStack.push("array-start");
          this._pos++;
          return new Token2(Type2.array, Infinity, 1);
        case 34: {
          return this.parseString();
        }
        case 110:
          this.expect([110, 117, 108, 108]);
          return new Token2(Type2.null, null, 4);
        case 102:
          this.expect([102, 97, 108, 115, 101]);
          return new Token2(Type2.false, false, 5);
        case 116:
          this.expect([116, 114, 117, 101]);
          return new Token2(Type2.true, true, 4);
        case 45:
        // '-'
        case 48:
        // '0'
        case 49:
        // '1'
        case 50:
        // '2'
        case 51:
        // '3'
        case 52:
        // '4'
        case 53:
        // '5'
        case 54:
        // '6'
        case 55:
        // '7'
        case 56:
        // '8'
        case 57:
          return this.parseNumber();
        default:
          throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}`);
      }
    }
    /**
     * @returns {Token}
     */
    next() {
      this.skipWhitespace();
      switch (this.currentMode()) {
        case "value":
          this.modeStack.pop();
          return this.parseValue();
        case "array-value": {
          this.modeStack.pop();
          if (this.ch() === 93) {
            this._pos++;
            this.skipWhitespace();
            return new Token2(Type2.break, void 0, 1);
          }
          if (this.ch() !== 44) {
            throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
          }
          this._pos++;
          this.modeStack.push("array-value");
          this.skipWhitespace();
          return this.parseValue();
        }
        case "array-start": {
          this.modeStack.pop();
          if (this.ch() === 93) {
            this._pos++;
            this.skipWhitespace();
            return new Token2(Type2.break, void 0, 1);
          }
          this.modeStack.push("array-value");
          this.skipWhitespace();
          return this.parseValue();
        }
        // @ts-ignore
        case "obj-key":
          if (this.ch() === 125) {
            this.modeStack.pop();
            this._pos++;
            this.skipWhitespace();
            return new Token2(Type2.break, void 0, 1);
          }
          if (this.ch() !== 44) {
            throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
          }
          this._pos++;
          this.skipWhitespace();
        case "obj-start": {
          this.modeStack.pop();
          if (this.ch() === 125) {
            this._pos++;
            this.skipWhitespace();
            return new Token2(Type2.break, void 0, 1);
          }
          const token = this.parseString();
          this.skipWhitespace();
          if (this.ch() !== 58) {
            throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
          }
          this._pos++;
          this.modeStack.push("obj-value");
          return token;
        }
        case "obj-value": {
          this.modeStack.pop();
          this.modeStack.push("obj-key");
          this.skipWhitespace();
          return this.parseValue();
        }
        /* c8 ignore next 2 */
        default:
          throw new Error(`${decodeErrPrefix2} unexpected parse state at position ${this._pos}; this shouldn't happen`);
      }
    }
  };
  function decode16(data, options) {
    options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
    return decode15(data, options);
  }

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/bases/base64.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_base();
  var base64 = rfc4648({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad = rfc4648({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url = rfc4648({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad = rfc4648({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // node_modules/.pnpm/@ipld+dag-json@10.2.2/node_modules/@ipld/dag-json/src/index.js
  function toByteView3(buf3) {
    if (buf3 instanceof ArrayBuffer) {
      return new Uint8Array(buf3, 0, buf3.byteLength);
    }
    return buf3;
  }
  function cidEncoder2(obj) {
    if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
      return null;
    }
    const cid = CID.asCID(obj);
    if (!cid) {
      return null;
    }
    const cidString = cid.toString();
    return [
      new Token2(Type2.map, Infinity, 1),
      new Token2(Type2.string, "/", 1),
      // key
      new Token2(Type2.string, cidString, cidString.length),
      // value
      new Token2(Type2.break, void 0, 1)
    ];
  }
  function bytesEncoder(bytes) {
    const bytesString = base64.encode(bytes).slice(1);
    return [
      new Token2(Type2.map, Infinity, 1),
      new Token2(Type2.string, "/", 1),
      // key
      new Token2(Type2.map, Infinity, 1),
      // value
      new Token2(Type2.string, "bytes", 5),
      // inner key
      new Token2(Type2.string, bytesString, bytesString.length),
      // inner value
      new Token2(Type2.break, void 0, 1),
      new Token2(Type2.break, void 0, 1)
    ];
  }
  function taBytesEncoder(obj) {
    return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  }
  function abBytesEncoder(ab) {
    return bytesEncoder(new Uint8Array(ab));
  }
  function undefinedEncoder2() {
    throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
  }
  function numberEncoder2(num) {
    if (Number.isNaN(num)) {
      throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
    }
    if (num === Infinity || num === -Infinity) {
      throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
    }
    return null;
  }
  var encodeOptions2 = {
    typeEncoders: {
      Object: cidEncoder2,
      Buffer: bytesEncoder,
      Uint8Array: bytesEncoder,
      Int8Array: taBytesEncoder,
      Uint16Array: taBytesEncoder,
      Int16Array: taBytesEncoder,
      Uint32Array: taBytesEncoder,
      Int32Array: taBytesEncoder,
      Float32Array: taBytesEncoder,
      Float64Array: taBytesEncoder,
      Uint8ClampedArray: taBytesEncoder,
      BigInt64Array: taBytesEncoder,
      BigUint64Array: taBytesEncoder,
      DataView: taBytesEncoder,
      ArrayBuffer: abBytesEncoder,
      undefined: undefinedEncoder2,
      number: numberEncoder2
    }
  };
  var DagJsonTokenizer = class extends Tokenizer {
    /**
     * @param {Uint8Array} data
     * @param {object} [options]
     */
    constructor(data, options) {
      super(data, options);
      this.tokenBuffer = [];
    }
    /**
     * @returns {boolean}
     */
    done() {
      return this.tokenBuffer.length === 0 && super.done();
    }
    /**
     * @returns {Token}
     */
    _next() {
      if (this.tokenBuffer.length > 0) {
        return this.tokenBuffer.pop();
      }
      return super.next();
    }
    /**
     * Implements rules outlined in https://github.com/ipld/specs/pull/356
     *
     * @returns {Token}
     */
    next() {
      const token = this._next();
      if (token.type === Type2.map) {
        const keyToken = this._next();
        if (keyToken.type === Type2.string && keyToken.value === "/") {
          const valueToken = this._next();
          if (valueToken.type === Type2.string) {
            const breakToken = this._next();
            if (breakToken.type !== Type2.break) {
              throw new Error("Invalid encoded CID form");
            }
            this.tokenBuffer.push(valueToken);
            return new Token2(Type2.tag, 42, 0);
          }
          if (valueToken.type === Type2.map) {
            const innerKeyToken = this._next();
            if (innerKeyToken.type === Type2.string && innerKeyToken.value === "bytes") {
              const innerValueToken = this._next();
              if (innerValueToken.type === Type2.string) {
                for (let i7 = 0; i7 < 2; i7++) {
                  const breakToken = this._next();
                  if (breakToken.type !== Type2.break) {
                    throw new Error("Invalid encoded Bytes form");
                  }
                }
                const bytes = base64.decode(`m${innerValueToken.value}`);
                return new Token2(Type2.bytes, bytes, innerValueToken.value.length);
              }
              this.tokenBuffer.push(innerValueToken);
            }
            this.tokenBuffer.push(innerKeyToken);
          }
          this.tokenBuffer.push(valueToken);
        }
        this.tokenBuffer.push(keyToken);
      }
      return token;
    }
  };
  var decodeOptions2 = {
    allowIndefinite: false,
    allowUndefined: false,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // this will lead to BigInt for ints outside of
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */
    tags: []
  };
  decodeOptions2.tags[42] = CID.parse;
  var code5 = 297;
  var encode13 = (node) => encode12(node, encodeOptions2);
  var decode17 = (data) => {
    const buf3 = toByteView3(data);
    const options = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(buf3, decodeOptions2) });
    return decode16(buf3, options);
  };
  var format7 = (node) => utf8Decoder.decode(encode13(node));
  var utf8Decoder = new TextDecoder();
  var parse6 = (data) => decode17(utf8Encoder.encode(data));
  var utf8Encoder = new TextEncoder();

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/codecs/json.js
  init_dirname();
  init_buffer2();
  init_process2();
  var textEncoder5 = new TextEncoder();
  var textDecoder4 = new TextDecoder();
  var code6 = 512;
  function decode18(data) {
    return JSON.parse(textDecoder4.decode(data));
  }

  // node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/dist/src/hashes/identity.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_bytes();
  var code7 = 0;
  var name6 = "identity";
  var encode14 = coerce;
  function digest(input) {
    return create(code7, encode14(input));
  }
  var identity = { code: code7, name: name6, encode: encode14, digest };

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-cbor.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/utils/resolve-object-path.js
  init_dirname();
  init_buffer2();
  init_process2();
  function resolveObjectPath(object, block, cid, name8, path2, toResolve, depth) {
    let subObject = object;
    let subPath = path2;
    while (toResolve.length > 0) {
      const prop = toResolve[0];
      if (prop in subObject) {
        toResolve.shift();
        subPath = `${subPath}/${prop}`;
        const subObjectCid = CID.asCID(subObject[prop]);
        if (subObjectCid != null) {
          return {
            entry: {
              type: "object",
              name: name8,
              path: path2,
              cid,
              node: block,
              depth,
              size: BigInt(block.length),
              content: async function* () {
                yield object;
              }
            },
            next: {
              cid: subObjectCid,
              name: prop,
              path: subPath,
              toResolve
            }
          };
        }
        subObject = subObject[prop];
      } else {
        throw new NoPropError(`No property named ${prop} found in node ${cid}`);
      }
    }
    return {
      entry: {
        type: "object",
        name: name8,
        path: path2,
        cid,
        node: block,
        depth,
        size: BigInt(block.length),
        content: async function* () {
          yield object;
        }
      }
    };
  }

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-cbor.js
  var resolve3 = async (cid, name8, path2, toResolve, resolve9, depth, blockstore, options) => {
    const block = await blockstore.get(cid, options);
    const object = decode10(block);
    return resolveObjectPath(object, block, cid, name8, path2, toResolve, depth);
  };
  var dag_cbor_default = resolve3;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-json.js
  init_dirname();
  init_buffer2();
  init_process2();
  var resolve4 = async (cid, name8, path2, toResolve, resolve9, depth, blockstore, options) => {
    const block = await blockstore.get(cid, options);
    const object = decode17(block);
    return resolveObjectPath(object, block, cid, name8, path2, toResolve, depth);
  };
  var dag_json_default = resolve4;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/identity.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/progress-events@1.0.1/node_modules/progress-events/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  var CustomProgressEvent = class extends Event {
    type;
    detail;
    constructor(type2, detail) {
      super(type2);
      this.type = type2;
      this.detail = detail;
    }
  };

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/utils/extract-data-from-block.js
  init_dirname();
  init_buffer2();
  init_process2();
  function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
    const blockLength2 = BigInt(block.length);
    const blockEnd = BigInt(blockStart + blockLength2);
    if (requestedStart >= blockEnd || requestedEnd < blockStart) {
      return new Uint8Array(0);
    }
    if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
      block = block.subarray(0, Number(requestedEnd - blockStart));
    }
    if (requestedStart >= blockStart && requestedStart < blockEnd) {
      block = block.subarray(Number(requestedStart - blockStart));
    }
    return block;
  }
  var extract_data_from_block_default = extractDataFromBlock;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/utils/validate-offset-and-length.js
  init_dirname();
  init_buffer2();
  init_process2();
  var validateOffsetAndLength = (size, offset = 0, length4 = size) => {
    const fileSize = BigInt(size);
    const start = BigInt(offset ?? 0);
    let end = BigInt(length4);
    if (end !== fileSize) {
      end = start + end;
    }
    if (end > fileSize) {
      end = fileSize;
    }
    if (start < 0n) {
      throw new InvalidParametersError("Offset must be greater than or equal to 0");
    }
    if (start > fileSize) {
      throw new InvalidParametersError("Offset must be less than the file size");
    }
    if (end < 0n) {
      throw new InvalidParametersError("Length must be greater than or equal to 0");
    }
    if (end > fileSize) {
      throw new InvalidParametersError("Length must be less than the file size");
    }
    return {
      start,
      end
    };
  };
  var validate_offset_and_length_default = validateOffsetAndLength;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/identity.js
  var rawContent = (node) => {
    async function* contentGenerator(options = {}) {
      const { start, end } = validate_offset_and_length_default(node.length, options.offset, options.length);
      const buf3 = extract_data_from_block_default(node, 0n, start, end);
      options.onProgress?.(new CustomProgressEvent("unixfs:exporter:progress:identity", {
        bytesRead: BigInt(buf3.byteLength),
        totalBytes: end - start,
        fileSize: BigInt(node.byteLength)
      }));
      yield buf3;
    }
    return contentGenerator;
  };
  var resolve5 = async (cid, name8, path2, toResolve, resolve9, depth, blockstore, options) => {
    if (toResolve.length > 0) {
      throw new NotFoundError2(`No link named ${path2} found in raw node ${cid}`);
    }
    const buf3 = decode4(cid.multihash.bytes);
    return {
      entry: {
        type: "identity",
        name: name8,
        path: path2,
        cid,
        content: rawContent(buf3.digest),
        depth,
        size: BigInt(buf3.digest.length),
        node: buf3.digest
      }
    };
  };
  var identity_default = resolve5;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/json.js
  init_dirname();
  init_buffer2();
  init_process2();
  var resolve6 = async (cid, name8, path2, toResolve, resolve9, depth, blockstore, options) => {
    const block = await blockstore.get(cid, options);
    const object = decode18(block);
    return resolveObjectPath(object, block, cid, name8, path2, toResolve, depth);
  };
  var json_default = resolve6;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/raw.js
  init_dirname();
  init_buffer2();
  init_process2();
  var rawContent2 = (node) => {
    async function* contentGenerator(options = {}) {
      const { start, end } = validate_offset_and_length_default(node.length, options.offset, options.length);
      const buf3 = extract_data_from_block_default(node, 0n, start, end);
      options.onProgress?.(new CustomProgressEvent("unixfs:exporter:progress:raw", {
        bytesRead: BigInt(buf3.byteLength),
        totalBytes: end - start,
        fileSize: BigInt(node.byteLength)
      }));
      yield buf3;
    }
    return contentGenerator;
  };
  var resolve7 = async (cid, name8, path2, toResolve, resolve9, depth, blockstore, options) => {
    if (toResolve.length > 0) {
      throw new NotFoundError2(`No link named ${path2} found in raw node ${cid}`);
    }
    const block = await blockstore.get(cid, options);
    return {
      entry: {
        type: "raw",
        name: name8,
        path: path2,
        cid,
        content: rawContent2(block),
        depth,
        size: BigInt(block.length),
        node: block
      }
    };
  };
  var raw_default = resolve7;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/ipfs-unixfs@11.1.4/node_modules/ipfs-unixfs/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  var import_err_code = __toESM(require_err_code(), 1);

  // node_modules/.pnpm/ipfs-unixfs@11.1.4/node_modules/ipfs-unixfs/dist/src/unixfs.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/decode.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/utils/reader.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/uint8-varint@2.0.4/node_modules/uint8-varint/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/alloc.js
  init_dirname();
  init_buffer2();
  init_process2();
  function allocUnsafe(size = 0) {
    return new Uint8Array(size);
  }

  // node_modules/.pnpm/uint8-varint@2.0.4/node_modules/uint8-varint/dist/src/index.js
  var N13 = Math.pow(2, 7);
  var N24 = Math.pow(2, 14);
  var N34 = Math.pow(2, 21);
  var N43 = Math.pow(2, 28);
  var N53 = Math.pow(2, 35);
  var N63 = Math.pow(2, 42);
  var N73 = Math.pow(2, 49);
  var MSB3 = 128;
  var REST3 = 127;
  function encodingLength3(value) {
    if (value < N13) {
      return 1;
    }
    if (value < N24) {
      return 2;
    }
    if (value < N34) {
      return 3;
    }
    if (value < N43) {
      return 4;
    }
    if (value < N53) {
      return 5;
    }
    if (value < N63) {
      return 6;
    }
    if (value < N73) {
      return 7;
    }
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("Could not encode varint");
    }
    return 8;
  }
  function encodeUint8Array(value, buf3, offset = 0) {
    switch (encodingLength3(value)) {
      case 8: {
        buf3[offset++] = value & 255 | MSB3;
        value /= 128;
      }
      case 7: {
        buf3[offset++] = value & 255 | MSB3;
        value /= 128;
      }
      case 6: {
        buf3[offset++] = value & 255 | MSB3;
        value /= 128;
      }
      case 5: {
        buf3[offset++] = value & 255 | MSB3;
        value /= 128;
      }
      case 4: {
        buf3[offset++] = value & 255 | MSB3;
        value >>>= 7;
      }
      case 3: {
        buf3[offset++] = value & 255 | MSB3;
        value >>>= 7;
      }
      case 2: {
        buf3[offset++] = value & 255 | MSB3;
        value >>>= 7;
      }
      case 1: {
        buf3[offset++] = value & 255;
        value >>>= 7;
        break;
      }
      default:
        throw new Error("unreachable");
    }
    return buf3;
  }
  function decodeUint8Array(buf3, offset) {
    let b5 = buf3[offset];
    let res = 0;
    res += b5 & REST3;
    if (b5 < MSB3) {
      return res;
    }
    b5 = buf3[offset + 1];
    res += (b5 & REST3) << 7;
    if (b5 < MSB3) {
      return res;
    }
    b5 = buf3[offset + 2];
    res += (b5 & REST3) << 14;
    if (b5 < MSB3) {
      return res;
    }
    b5 = buf3[offset + 3];
    res += (b5 & REST3) << 21;
    if (b5 < MSB3) {
      return res;
    }
    b5 = buf3[offset + 4];
    res += (b5 & REST3) * N43;
    if (b5 < MSB3) {
      return res;
    }
    b5 = buf3[offset + 5];
    res += (b5 & REST3) * N53;
    if (b5 < MSB3) {
      return res;
    }
    b5 = buf3[offset + 6];
    res += (b5 & REST3) * N63;
    if (b5 < MSB3) {
      return res;
    }
    b5 = buf3[offset + 7];
    res += (b5 & REST3) * N73;
    if (b5 < MSB3) {
      return res;
    }
    throw new RangeError("Could not decode varint");
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/utils/float.js
  init_dirname();
  init_buffer2();
  init_process2();
  var f32 = new Float32Array([-0]);
  var f8b = new Uint8Array(f32.buffer);
  function writeFloatLE(val, buf3, pos) {
    f32[0] = val;
    buf3[pos] = f8b[0];
    buf3[pos + 1] = f8b[1];
    buf3[pos + 2] = f8b[2];
    buf3[pos + 3] = f8b[3];
  }
  function readFloatLE(buf3, pos) {
    f8b[0] = buf3[pos];
    f8b[1] = buf3[pos + 1];
    f8b[2] = buf3[pos + 2];
    f8b[3] = buf3[pos + 3];
    return f32[0];
  }
  var f64 = new Float64Array([-0]);
  var d8b = new Uint8Array(f64.buffer);
  function writeDoubleLE(val, buf3, pos) {
    f64[0] = val;
    buf3[pos] = d8b[0];
    buf3[pos + 1] = d8b[1];
    buf3[pos + 2] = d8b[2];
    buf3[pos + 3] = d8b[3];
    buf3[pos + 4] = d8b[4];
    buf3[pos + 5] = d8b[5];
    buf3[pos + 6] = d8b[6];
    buf3[pos + 7] = d8b[7];
  }
  function readDoubleLE(buf3, pos) {
    d8b[0] = buf3[pos];
    d8b[1] = buf3[pos + 1];
    d8b[2] = buf3[pos + 2];
    d8b[3] = buf3[pos + 3];
    d8b[4] = buf3[pos + 4];
    d8b[5] = buf3[pos + 5];
    d8b[6] = buf3[pos + 6];
    d8b[7] = buf3[pos + 7];
    return f64[0];
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/utils/longbits.js
  init_dirname();
  init_buffer2();
  init_process2();
  var MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
  var MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
  var LongBits = class _LongBits {
    lo;
    hi;
    constructor(lo, hi) {
      this.lo = lo | 0;
      this.hi = hi | 0;
    }
    /**
     * Converts this long bits to a possibly unsafe JavaScript number
     */
    toNumber(unsigned = false) {
      if (!unsigned && this.hi >>> 31 > 0) {
        const lo = ~this.lo + 1 >>> 0;
        let hi = ~this.hi >>> 0;
        if (lo === 0) {
          hi = hi + 1 >>> 0;
        }
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }
    /**
     * Converts this long bits to a bigint
     */
    toBigInt(unsigned = false) {
      if (unsigned) {
        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
      }
      if (this.hi >>> 31 !== 0) {
        const lo = ~this.lo + 1 >>> 0;
        let hi = ~this.hi >>> 0;
        if (lo === 0) {
          hi = hi + 1 >>> 0;
        }
        return -(BigInt(lo) + (BigInt(hi) << 32n));
      }
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    /**
     * Converts this long bits to a string
     */
    toString(unsigned = false) {
      return this.toBigInt(unsigned).toString();
    }
    /**
     * Zig-zag encodes this long bits
     */
    zzEncode() {
      const mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    }
    /**
     * Zig-zag decodes this long bits
     */
    zzDecode() {
      const mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    }
    /**
     * Calculates the length of this longbits when encoded as a varint.
     */
    length() {
      const part0 = this.lo;
      const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
      const part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }
    /**
     * Constructs new long bits from the specified number
     */
    static fromBigInt(value) {
      if (value === 0n) {
        return zero;
      }
      if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {
        return this.fromNumber(Number(value));
      }
      const negative = value < 0n;
      if (negative) {
        value = -value;
      }
      let hi = value >> 32n;
      let lo = value - (hi << 32n);
      if (negative) {
        hi = ~hi | 0n;
        lo = ~lo | 0n;
        if (++lo > TWO_32) {
          lo = 0n;
          if (++hi > TWO_32) {
            hi = 0n;
          }
        }
      }
      return new _LongBits(Number(lo), Number(hi));
    }
    /**
     * Constructs new long bits from the specified number
     */
    static fromNumber(value) {
      if (value === 0) {
        return zero;
      }
      const sign = value < 0;
      if (sign) {
        value = -value;
      }
      let lo = value >>> 0;
      let hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295) {
            hi = 0;
          }
        }
      }
      return new _LongBits(lo, hi);
    }
    /**
     * Constructs new long bits from a number, long or string
     */
    static from(value) {
      if (typeof value === "number") {
        return _LongBits.fromNumber(value);
      }
      if (typeof value === "bigint") {
        return _LongBits.fromBigInt(value);
      }
      if (typeof value === "string") {
        return _LongBits.fromBigInt(BigInt(value));
      }
      return value.low != null || value.high != null ? new _LongBits(value.low >>> 0, value.high >>> 0) : zero;
    }
  };
  var zero = new LongBits(0, 0);
  zero.toBigInt = function() {
    return 0n;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var TWO_32 = 4294967296n;

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/utils/utf8.js
  init_dirname();
  init_buffer2();
  init_process2();
  function length3(string3) {
    let len = 0;
    let c7 = 0;
    for (let i7 = 0; i7 < string3.length; ++i7) {
      c7 = string3.charCodeAt(i7);
      if (c7 < 128) {
        len += 1;
      } else if (c7 < 2048) {
        len += 2;
      } else if ((c7 & 64512) === 55296 && (string3.charCodeAt(i7 + 1) & 64512) === 56320) {
        ++i7;
        len += 4;
      } else {
        len += 3;
      }
    }
    return len;
  }
  function read5(buffer4, start, end) {
    const len = end - start;
    if (len < 1) {
      return "";
    }
    let parts;
    const chunk = [];
    let i7 = 0;
    let t8;
    while (start < end) {
      t8 = buffer4[start++];
      if (t8 < 128) {
        chunk[i7++] = t8;
      } else if (t8 > 191 && t8 < 224) {
        chunk[i7++] = (t8 & 31) << 6 | buffer4[start++] & 63;
      } else if (t8 > 239 && t8 < 365) {
        t8 = ((t8 & 7) << 18 | (buffer4[start++] & 63) << 12 | (buffer4[start++] & 63) << 6 | buffer4[start++] & 63) - 65536;
        chunk[i7++] = 55296 + (t8 >> 10);
        chunk[i7++] = 56320 + (t8 & 1023);
      } else {
        chunk[i7++] = (t8 & 15) << 12 | (buffer4[start++] & 63) << 6 | buffer4[start++] & 63;
      }
      if (i7 > 8191) {
        (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i7 = 0;
      }
    }
    if (parts != null) {
      if (i7 > 0) {
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i7)));
      }
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i7));
  }
  function write6(string3, buffer4, offset) {
    const start = offset;
    let c1;
    let c22;
    for (let i7 = 0; i7 < string3.length; ++i7) {
      c1 = string3.charCodeAt(i7);
      if (c1 < 128) {
        buffer4[offset++] = c1;
      } else if (c1 < 2048) {
        buffer4[offset++] = c1 >> 6 | 192;
        buffer4[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c22 = string3.charCodeAt(i7 + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c22 & 1023);
        ++i7;
        buffer4[offset++] = c1 >> 18 | 240;
        buffer4[offset++] = c1 >> 12 & 63 | 128;
        buffer4[offset++] = c1 >> 6 & 63 | 128;
        buffer4[offset++] = c1 & 63 | 128;
      } else {
        buffer4[offset++] = c1 >> 12 | 224;
        buffer4[offset++] = c1 >> 6 & 63 | 128;
        buffer4[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/utils/reader.js
  function indexOutOfRange(reader, writeLength) {
    return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);
  }
  function readFixed32End(buf3, end) {
    return (buf3[end - 4] | buf3[end - 3] << 8 | buf3[end - 2] << 16 | buf3[end - 1] << 24) >>> 0;
  }
  var Uint8ArrayReader = class {
    buf;
    pos;
    len;
    _slice = Uint8Array.prototype.subarray;
    constructor(buffer4) {
      this.buf = buffer4;
      this.pos = 0;
      this.len = buffer4.length;
    }
    /**
     * Reads a varint as an unsigned 32 bit value
     */
    uint32() {
      let value = 4294967295;
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    }
    /**
     * Reads a varint as a signed 32 bit value
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Reads a zig-zag encoded varint as a signed 32 bit value
     */
    sint32() {
      const value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    }
    /**
     * Reads a varint as a boolean
     */
    bool() {
      return this.uint32() !== 0;
    }
    /**
     * Reads fixed 32 bits as an unsigned 32 bit integer
     */
    fixed32() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const res = readFixed32End(this.buf, this.pos += 4);
      return res;
    }
    /**
     * Reads fixed 32 bits as a signed 32 bit integer
     */
    sfixed32() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const res = readFixed32End(this.buf, this.pos += 4) | 0;
      return res;
    }
    /**
     * Reads a float (32 bit) as a number
     */
    float() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const value = readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    }
    /**
     * Reads a double (64 bit float) as a number
     */
    double() {
      if (this.pos + 8 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const value = readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    }
    /**
     * Reads a sequence of bytes preceded by its length as a varint
     */
    bytes() {
      const length4 = this.uint32();
      const start = this.pos;
      const end = this.pos + length4;
      if (end > this.len) {
        throw indexOutOfRange(this, length4);
      }
      this.pos += length4;
      return start === end ? new Uint8Array(0) : this.buf.subarray(start, end);
    }
    /**
     * Reads a string preceded by its byte length as a varint
     */
    string() {
      const bytes = this.bytes();
      return read5(bytes, 0, bytes.length);
    }
    /**
     * Skips the specified number of bytes if specified, otherwise skips a varint
     */
    skip(length4) {
      if (typeof length4 === "number") {
        if (this.pos + length4 > this.len) {
          throw indexOutOfRange(this, length4);
        }
        this.pos += length4;
      } else {
        do {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
        } while ((this.buf[this.pos++] & 128) !== 0);
      }
      return this;
    }
    /**
     * Skips the next element of the specified wire type
     */
    skipType(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
      }
      return this;
    }
    readLongVarint() {
      const bits = new LongBits(0, 0);
      let i7 = 0;
      if (this.len - this.pos > 4) {
        for (; i7 < 4; ++i7) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i7 * 7) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
        i7 = 0;
      } else {
        for (; i7 < 3; ++i7) {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i7 * 7) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i7 * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i7 < 5; ++i7) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i7 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
      } else {
        for (; i7 < 5; ++i7) {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i7 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
      }
      throw Error("invalid varint encoding");
    }
    readFixed64() {
      if (this.pos + 8 > this.len) {
        throw indexOutOfRange(this, 8);
      }
      const lo = readFixed32End(this.buf, this.pos += 4);
      const hi = readFixed32End(this.buf, this.pos += 4);
      return new LongBits(lo, hi);
    }
    /**
     * Reads a varint as a signed 64 bit value
     */
    int64() {
      return this.readLongVarint().toBigInt();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a possibly unsafe
     * JavaScript number
     */
    int64Number() {
      return this.readLongVarint().toNumber();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a string
     */
    int64String() {
      return this.readLongVarint().toString();
    }
    /**
     * Reads a varint as an unsigned 64 bit value
     */
    uint64() {
      return this.readLongVarint().toBigInt(true);
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
     * JavaScript number
     */
    uint64Number() {
      const value = decodeUint8Array(this.buf, this.pos);
      this.pos += encodingLength3(value);
      return value;
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a string
     */
    uint64String() {
      return this.readLongVarint().toString(true);
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value
     */
    sint64() {
      return this.readLongVarint().zzDecode().toBigInt();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * possibly unsafe JavaScript number
     */
    sint64Number() {
      return this.readLongVarint().zzDecode().toNumber();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * string
     */
    sint64String() {
      return this.readLongVarint().zzDecode().toString();
    }
    /**
     * Reads fixed 64 bits
     */
    fixed64() {
      return this.readFixed64().toBigInt();
    }
    /**
     * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
     */
    fixed64Number() {
      return this.readFixed64().toNumber();
    }
    /**
     * Reads fixed 64 bits returned as a string
     */
    fixed64String() {
      return this.readFixed64().toString();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits
     */
    sfixed64() {
      return this.readFixed64().toBigInt();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
     * JavaScript number
     */
    sfixed64Number() {
      return this.readFixed64().toNumber();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a string
     */
    sfixed64String() {
      return this.readFixed64().toString();
    }
  };
  function createReader(buf3) {
    return new Uint8ArrayReader(buf3 instanceof Uint8Array ? buf3 : buf3.subarray());
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/decode.js
  function decodeMessage(buf3, codec, opts) {
    const reader = createReader(buf3);
    return codec.decode(reader, void 0, opts);
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/encode.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/utils/writer.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/from-string.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/util/bases.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/basics.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports = {};
  __export(base10_exports, {
    base10: () => base10
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var base10 = baseX2({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports = {};
  __export(base16_exports, {
    base16: () => base16,
    base16upper: () => base16upper
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var base16 = rfc46482({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper = rfc46482({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports = {};
  __export(base2_exports, {
    base2: () => base22
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var base22 = rfc46482({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports = {};
  __export(base256emoji_exports, {
    base256emoji: () => base256emoji
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars = alphabet.reduce((p7, c7, i7) => {
    p7[i7] = c7;
    return p7;
  }, []);
  var alphabetCharsToBytes = alphabet.reduce((p7, c7, i7) => {
    p7[c7.codePointAt(0)] = i7;
    return p7;
  }, []);
  function encode15(data) {
    return data.reduce((p7, c7) => {
      p7 += alphabetBytesToChars[c7];
      return p7;
    }, "");
  }
  function decode19(str) {
    const byts = [];
    for (const char of str) {
      const byt = alphabetCharsToBytes[char.codePointAt(0)];
      if (byt === void 0) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji = from4({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode15,
    decode: decode19
  });

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports = {};
  __export(base36_exports, {
    base36: () => base362,
    base36upper: () => base36upper2
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var base362 = baseX2({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper2 = baseX2({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports = {};
  __export(base64_exports, {
    base64: () => base642,
    base64pad: () => base64pad2,
    base64url: () => base64url2,
    base64urlpad: () => base64urlpad2
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var base642 = rfc46482({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad2 = rfc46482({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url2 = rfc46482({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad2 = rfc46482({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports = {};
  __export(base8_exports, {
    base8: () => base8
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var base8 = rfc46482({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports = {};
  __export(identity_exports, {
    identity: () => identity2
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var identity2 = from4({
    prefix: "\0",
    name: "identity",
    encode: (buf3) => toString3(buf3),
    decode: (str) => fromString3(str)
  });

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/codecs/json.js
  init_dirname();
  init_buffer2();
  init_process2();
  var textEncoder6 = new TextEncoder();
  var textDecoder5 = new TextDecoder();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/codecs/raw.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports2 = {};
  __export(identity_exports2, {
    identity: () => identity3
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var code8 = 0;
  var name7 = "identity";
  var encode16 = coerce2;
  function digest2(input) {
    return create2(code8, encode16(input));
  }
  var identity3 = { code: code8, name: name7, encode: encode16, digest: digest2 };

  // node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/basics.js
  var bases = { ...identity_exports, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
  var hashes = { ...sha2_browser_exports, ...identity_exports2 };

  // node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec(name8, prefix, encode18, decode21) {
    return {
      name: name8,
      prefix,
      encoder: {
        name: name8,
        prefix,
        encode: encode18
      },
      decoder: {
        decode: decode21
      }
    };
  }
  var string2 = createCodec("utf8", "u", (buf3) => {
    const decoder2 = new TextDecoder("utf8");
    return "u" + decoder2.decode(buf3);
  }, (str) => {
    const encoder2 = new TextEncoder();
    return encoder2.encode(str.substring(1));
  });
  var ascii = createCodec("ascii", "a", (buf3) => {
    let string3 = "a";
    for (let i7 = 0; i7 < buf3.length; i7++) {
      string3 += String.fromCharCode(buf3[i7]);
    }
    return string3;
  }, (str) => {
    str = str.substring(1);
    const buf3 = allocUnsafe(str.length);
    for (let i7 = 0; i7 < str.length; i7++) {
      buf3[i7] = str.charCodeAt(i7);
    }
    return buf3;
  });
  var BASES = {
    utf8: string2,
    "utf-8": string2,
    hex: bases.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...bases
  };
  var bases_default = BASES;

  // node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/from-string.js
  function fromString5(string3, encoding = "utf8") {
    const base3 = bases_default[encoding];
    if (base3 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.decoder.decode(`${base3.prefix}${string3}`);
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/utils/pool.js
  init_dirname();
  init_buffer2();
  init_process2();
  function pool(size) {
    const SIZE = size ?? 8192;
    const MAX = SIZE >>> 1;
    let slab;
    let offset = SIZE;
    return function poolAlloc(size2) {
      if (size2 < 1 || size2 > MAX) {
        return allocUnsafe(size2);
      }
      if (offset + size2 > SIZE) {
        slab = allocUnsafe(SIZE);
        offset = 0;
      }
      const buf3 = slab.subarray(offset, offset += size2);
      if ((offset & 7) !== 0) {
        offset = (offset | 7) + 1;
      }
      return buf3;
    };
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/utils/writer.js
  var Op = class {
    /**
     * Function to call
     */
    fn;
    /**
     * Value byte length
     */
    len;
    /**
     * Next operation
     */
    next;
    /**
     * Value to write
     */
    val;
    constructor(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
  };
  function noop2() {
  }
  var State = class {
    /**
     * Current head
     */
    head;
    /**
     * Current tail
     */
    tail;
    /**
     * Current buffer length
     */
    len;
    /**
     * Next state
     */
    next;
    constructor(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
  };
  var bufferPool = pool();
  function alloc3(size) {
    if (globalThis.Buffer != null) {
      return allocUnsafe(size);
    }
    return bufferPool(size);
  }
  var Uint8ArrayWriter = class {
    /**
     * Current length
     */
    len;
    /**
     * Operations head
     */
    head;
    /**
     * Operations tail
     */
    tail;
    /**
     * Linked forked states
     */
    states;
    constructor() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    /**
     * Pushes a new operation to the queue
     */
    _push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    }
    /**
     * Writes an unsigned 32 bit value as a varint
     */
    uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    }
    /**
     * Writes a signed 32 bit value as a varint`
     */
    int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    }
    /**
     * Writes a 32 bit value as a varint, zig-zag encoded
     */
    sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64(value) {
      const bits = LongBits.fromBigInt(value);
      return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64Number(value) {
      return this._push(encodeUint8Array, encodingLength3(value), value);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64String(value) {
      return this.uint64(BigInt(value));
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64(value) {
      return this.uint64(value);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64Number(value) {
      return this.uint64Number(value);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64String(value) {
      return this.uint64String(value);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64(value) {
      const bits = LongBits.fromBigInt(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64Number(value) {
      const bits = LongBits.fromNumber(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64String(value) {
      return this.sint64(BigInt(value));
    }
    /**
     * Writes a boolish value as a varint
     */
    bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    }
    /**
     * Writes an unsigned 32 bit value as fixed 32 bits
     */
    fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    }
    /**
     * Writes a signed 32 bit value as fixed 32 bits
     */
    sfixed32(value) {
      return this.fixed32(value);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64(value) {
      const bits = LongBits.fromBigInt(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64Number(value) {
      const bits = LongBits.fromNumber(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64String(value) {
      return this.fixed64(BigInt(value));
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64(value) {
      return this.fixed64(value);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64Number(value) {
      return this.fixed64Number(value);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64String(value) {
      return this.fixed64String(value);
    }
    /**
     * Writes a float (32 bit)
     */
    float(value) {
      return this._push(writeFloatLE, 4, value);
    }
    /**
     * Writes a double (64 bit float).
     *
     * @function
     * @param {number} value - Value to write
     * @returns {Writer} `this`
     */
    double(value) {
      return this._push(writeDoubleLE, 8, value);
    }
    /**
     * Writes a sequence of bytes
     */
    bytes(value) {
      const len = value.length >>> 0;
      if (len === 0) {
        return this._push(writeByte, 1, 0);
      }
      return this.uint32(len)._push(writeBytes, len, value);
    }
    /**
     * Writes a string
     */
    string(value) {
      const len = length3(value);
      return len !== 0 ? this.uint32(len)._push(write6, len, value) : this._push(writeByte, 1, 0);
    }
    /**
     * Forks this writer's state by pushing it to a stack.
     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
     */
    fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    }
    /**
     * Resets this instance to the last state
     */
    reset() {
      if (this.states != null) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    }
    /**
     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
     */
    ldelim() {
      const head = this.head;
      const tail = this.tail;
      const len = this.len;
      this.reset().uint32(len);
      if (len !== 0) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    }
    /**
     * Finishes the write operation
     */
    finish() {
      let head = this.head.next;
      const buf3 = alloc3(this.len);
      let pos = 0;
      while (head != null) {
        head.fn(head.val, buf3, pos);
        pos += head.len;
        head = head.next;
      }
      return buf3;
    }
  };
  function writeByte(val, buf3, pos) {
    buf3[pos] = val & 255;
  }
  function writeVarint32(val, buf3, pos) {
    while (val > 127) {
      buf3[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf3[pos] = val;
  }
  var VarintOp = class extends Op {
    next;
    constructor(len, val) {
      super(writeVarint32, len, val);
      this.next = void 0;
    }
  };
  function writeVarint64(val, buf3, pos) {
    while (val.hi !== 0) {
      buf3[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf3[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf3[pos++] = val.lo;
  }
  function writeFixed32(val, buf3, pos) {
    buf3[pos] = val & 255;
    buf3[pos + 1] = val >>> 8 & 255;
    buf3[pos + 2] = val >>> 16 & 255;
    buf3[pos + 3] = val >>> 24;
  }
  function writeBytes(val, buf3, pos) {
    buf3.set(val, pos);
  }
  if (globalThis.Buffer != null) {
    Uint8ArrayWriter.prototype.bytes = function(value) {
      const len = value.length >>> 0;
      this.uint32(len);
      if (len > 0) {
        this._push(writeBytesBuffer, len, value);
      }
      return this;
    };
    Uint8ArrayWriter.prototype.string = function(value) {
      const len = globalThis.Buffer.byteLength(value);
      this.uint32(len);
      if (len > 0) {
        this._push(writeStringBuffer, len, value);
      }
      return this;
    };
  }
  function writeBytesBuffer(val, buf3, pos) {
    buf3.set(val, pos);
  }
  function writeStringBuffer(val, buf3, pos) {
    if (val.length < 40) {
      write6(val, buf3, pos);
    } else if (buf3.utf8Write != null) {
      buf3.utf8Write(val, pos);
    } else {
      buf3.set(fromString5(val), pos);
    }
  }
  function createWriter2() {
    return new Uint8ArrayWriter();
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/encode.js
  function encodeMessage(message2, codec) {
    const w4 = createWriter2();
    codec.encode(message2, w4, {
      lengthDelimited: false
    });
    return w4.finish();
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/codecs/enum.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/codec.js
  init_dirname();
  init_buffer2();
  init_process2();
  var CODEC_TYPES;
  (function(CODEC_TYPES2) {
    CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
    CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
    CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
    CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
    CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
    CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
  })(CODEC_TYPES || (CODEC_TYPES = {}));
  function createCodec2(name8, type2, encode18, decode21) {
    return {
      name: name8,
      type: type2,
      encode: encode18,
      decode: decode21
    };
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/codecs/enum.js
  function enumeration(v6) {
    function findValue(val) {
      if (v6[val.toString()] == null) {
        throw new Error("Invalid enum value");
      }
      return v6[val];
    }
    const encode18 = function enumEncode(val, writer) {
      const enumValue = findValue(val);
      writer.int32(enumValue);
    };
    const decode21 = function enumDecode(reader) {
      const val = reader.int32();
      return findValue(val);
    };
    return createCodec2("enum", CODEC_TYPES.VARINT, encode18, decode21);
  }

  // node_modules/.pnpm/protons-runtime@5.5.0/node_modules/protons-runtime/dist/src/codecs/message.js
  init_dirname();
  init_buffer2();
  init_process2();
  function message(encode18, decode21) {
    return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode18, decode21);
  }

  // node_modules/.pnpm/ipfs-unixfs@11.1.4/node_modules/ipfs-unixfs/dist/src/unixfs.js
  var Data2;
  (function(Data3) {
    let DataType;
    (function(DataType2) {
      DataType2["Raw"] = "Raw";
      DataType2["Directory"] = "Directory";
      DataType2["File"] = "File";
      DataType2["Metadata"] = "Metadata";
      DataType2["Symlink"] = "Symlink";
      DataType2["HAMTShard"] = "HAMTShard";
    })(DataType = Data3.DataType || (Data3.DataType = {}));
    let __DataTypeValues;
    (function(__DataTypeValues2) {
      __DataTypeValues2[__DataTypeValues2["Raw"] = 0] = "Raw";
      __DataTypeValues2[__DataTypeValues2["Directory"] = 1] = "Directory";
      __DataTypeValues2[__DataTypeValues2["File"] = 2] = "File";
      __DataTypeValues2[__DataTypeValues2["Metadata"] = 3] = "Metadata";
      __DataTypeValues2[__DataTypeValues2["Symlink"] = 4] = "Symlink";
      __DataTypeValues2[__DataTypeValues2["HAMTShard"] = 5] = "HAMTShard";
    })(__DataTypeValues || (__DataTypeValues = {}));
    (function(DataType2) {
      DataType2.codec = () => {
        return enumeration(__DataTypeValues);
      };
    })(DataType = Data3.DataType || (Data3.DataType = {}));
    let _codec;
    Data3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w4, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w4.fork();
          }
          if (obj.Type != null) {
            w4.uint32(8);
            Data3.DataType.codec().encode(obj.Type, w4);
          }
          if (obj.Data != null) {
            w4.uint32(18);
            w4.bytes(obj.Data);
          }
          if (obj.filesize != null) {
            w4.uint32(24);
            w4.uint64(obj.filesize);
          }
          if (obj.blocksizes != null) {
            for (const value of obj.blocksizes) {
              w4.uint32(32);
              w4.uint64(value);
            }
          }
          if (obj.hashType != null) {
            w4.uint32(40);
            w4.uint64(obj.hashType);
          }
          if (obj.fanout != null) {
            w4.uint32(48);
            w4.uint64(obj.fanout);
          }
          if (obj.mode != null) {
            w4.uint32(56);
            w4.uint32(obj.mode);
          }
          if (obj.mtime != null) {
            w4.uint32(66);
            UnixTime2.codec().encode(obj.mtime, w4);
          }
          if (opts.lengthDelimited !== false) {
            w4.ldelim();
          }
        }, (reader, length4) => {
          const obj = {
            blocksizes: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag2 = reader.uint32();
            switch (tag2 >>> 3) {
              case 1:
                obj.Type = Data3.DataType.codec().decode(reader);
                break;
              case 2:
                obj.Data = reader.bytes();
                break;
              case 3:
                obj.filesize = reader.uint64();
                break;
              case 4:
                obj.blocksizes.push(reader.uint64());
                break;
              case 5:
                obj.hashType = reader.uint64();
                break;
              case 6:
                obj.fanout = reader.uint64();
                break;
              case 7:
                obj.mode = reader.uint32();
                break;
              case 8:
                obj.mtime = UnixTime2.codec().decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag2 & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Data3.encode = (obj) => {
      return encodeMessage(obj, Data3.codec());
    };
    Data3.decode = (buf3) => {
      return decodeMessage(buf3, Data3.codec());
    };
  })(Data2 || (Data2 = {}));
  var UnixTime2;
  (function(UnixTime3) {
    let _codec;
    UnixTime3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w4, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w4.fork();
          }
          if (obj.Seconds != null) {
            w4.uint32(8);
            w4.int64(obj.Seconds);
          }
          if (obj.FractionalNanoseconds != null) {
            w4.uint32(21);
            w4.fixed32(obj.FractionalNanoseconds);
          }
          if (opts.lengthDelimited !== false) {
            w4.ldelim();
          }
        }, (reader, length4) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag2 = reader.uint32();
            switch (tag2 >>> 3) {
              case 1:
                obj.Seconds = reader.int64();
                break;
              case 2:
                obj.FractionalNanoseconds = reader.fixed32();
                break;
              default:
                reader.skipType(tag2 & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    UnixTime3.encode = (obj) => {
      return encodeMessage(obj, UnixTime3.codec());
    };
    UnixTime3.decode = (buf3) => {
      return decodeMessage(buf3, UnixTime3.codec());
    };
  })(UnixTime2 || (UnixTime2 = {}));
  var Metadata2;
  (function(Metadata3) {
    let _codec;
    Metadata3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w4, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w4.fork();
          }
          if (obj.MimeType != null) {
            w4.uint32(10);
            w4.string(obj.MimeType);
          }
          if (opts.lengthDelimited !== false) {
            w4.ldelim();
          }
        }, (reader, length4) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag2 = reader.uint32();
            switch (tag2 >>> 3) {
              case 1:
                obj.MimeType = reader.string();
                break;
              default:
                reader.skipType(tag2 & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Metadata3.encode = (obj) => {
      return encodeMessage(obj, Metadata3.codec());
    };
    Metadata3.decode = (buf3) => {
      return decodeMessage(buf3, Metadata3.codec());
    };
  })(Metadata2 || (Metadata2 = {}));

  // node_modules/.pnpm/ipfs-unixfs@11.1.4/node_modules/ipfs-unixfs/dist/src/index.js
  var types3 = {
    Raw: "raw",
    Directory: "directory",
    File: "file",
    Metadata: "metadata",
    Symlink: "symlink",
    HAMTShard: "hamt-sharded-directory"
  };
  var dirTypes = [
    "directory",
    "hamt-sharded-directory"
  ];
  var DEFAULT_FILE_MODE2 = parseInt("0644", 8);
  var DEFAULT_DIRECTORY_MODE2 = parseInt("0755", 8);
  var UnixFS = class _UnixFS {
    /**
     * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md
     */
    static unmarshal(marshaled) {
      const message2 = Data2.decode(marshaled);
      const data = new _UnixFS({
        type: types3[message2.Type != null ? message2.Type.toString() : "File"],
        data: message2.Data,
        blockSizes: message2.blocksizes,
        mode: message2.mode,
        mtime: message2.mtime != null ? {
          secs: message2.mtime.Seconds ?? 0n,
          nsecs: message2.mtime.FractionalNanoseconds
        } : void 0,
        fanout: message2.fanout
      });
      data._originalMode = message2.mode ?? 0;
      return data;
    }
    type;
    data;
    blockSizes;
    hashType;
    fanout;
    mtime;
    _mode;
    _originalMode;
    constructor(options = {
      type: "file"
    }) {
      const { type: type2, data, blockSizes, hashType, fanout, mtime, mode } = options;
      if (type2 != null && !Object.values(types3).includes(type2)) {
        throw (0, import_err_code.default)(new Error("Type: " + type2 + " is not valid"), "ERR_INVALID_TYPE");
      }
      this.type = type2 ?? "file";
      this.data = data;
      this.hashType = hashType;
      this.fanout = fanout;
      this.blockSizes = blockSizes ?? [];
      this._originalMode = 0;
      this.mode = mode;
      this.mtime = mtime;
    }
    set mode(mode) {
      if (mode == null) {
        this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE2 : DEFAULT_FILE_MODE2;
      } else {
        this._mode = mode & 4095;
      }
    }
    get mode() {
      return this._mode;
    }
    isDirectory() {
      return dirTypes.includes(this.type);
    }
    addBlockSize(size) {
      this.blockSizes.push(size);
    }
    removeBlockSize(index2) {
      this.blockSizes.splice(index2, 1);
    }
    /**
     * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else
     */
    fileSize() {
      if (this.isDirectory()) {
        return 0n;
      }
      let sum = 0n;
      this.blockSizes.forEach((size) => {
        sum += size;
      });
      if (this.data != null) {
        sum += BigInt(this.data.length);
      }
      return sum;
    }
    /**
     * encode to protobuf Uint8Array
     */
    marshal() {
      let type2;
      switch (this.type) {
        case "raw":
          type2 = Data2.DataType.Raw;
          break;
        case "directory":
          type2 = Data2.DataType.Directory;
          break;
        case "file":
          type2 = Data2.DataType.File;
          break;
        case "metadata":
          type2 = Data2.DataType.Metadata;
          break;
        case "symlink":
          type2 = Data2.DataType.Symlink;
          break;
        case "hamt-sharded-directory":
          type2 = Data2.DataType.HAMTShard;
          break;
        default:
          throw (0, import_err_code.default)(new Error(`Type: ${type2} is not valid`), "ERR_INVALID_TYPE");
      }
      let data = this.data;
      if (this.data == null || this.data.length === 0) {
        data = void 0;
      }
      let mode;
      if (this.mode != null) {
        mode = this._originalMode & 4294963200 | (this.mode ?? 0);
        if (mode === DEFAULT_FILE_MODE2 && !this.isDirectory()) {
          mode = void 0;
        }
        if (mode === DEFAULT_DIRECTORY_MODE2 && this.isDirectory()) {
          mode = void 0;
        }
      }
      let mtime;
      if (this.mtime != null) {
        mtime = {
          Seconds: this.mtime.secs,
          FractionalNanoseconds: this.mtime.nsecs
        };
      }
      return Data2.encode({
        Type: type2,
        Data: data,
        filesize: this.isDirectory() ? void 0 : this.fileSize(),
        blocksizes: this.blockSizes,
        hashType: this.hashType,
        fanout: this.fanout,
        mode,
        mtime
      });
    }
  };

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/utils/find-cid-in-shard.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/hamt-sharding@3.0.6/node_modules/hamt-sharding/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/hamt-sharding@3.0.6/node_modules/hamt-sharding/dist/src/bucket.js
  init_dirname();
  init_buffer2();
  init_process2();
  var import_sparse_array = __toESM(require_sparse_array(), 1);
  var Bucket = class _Bucket {
    _options;
    _popCount;
    _parent;
    _posAtParent;
    _children;
    key;
    constructor(options, parent, posAtParent = 0) {
      this._options = options;
      this._popCount = 0;
      this._parent = parent;
      this._posAtParent = posAtParent;
      this._children = new import_sparse_array.default();
      this.key = null;
    }
    async put(key, value) {
      const place = await this._findNewBucketAndPos(key);
      place.bucket._putAt(place, key, value);
    }
    async get(key) {
      const child = await this._findChild(key);
      if (child != null) {
        return child.value;
      }
    }
    async del(key) {
      const place = await this._findPlace(key);
      const child = place.bucket._at(place.pos);
      if (child != null && child.key === key) {
        place.bucket._delAt(place.pos);
      }
    }
    leafCount() {
      const children = this._children.compactArray();
      return children.reduce((acc, child) => {
        if (child instanceof _Bucket) {
          return acc + child.leafCount();
        }
        return acc + 1;
      }, 0);
    }
    childrenCount() {
      return this._children.length;
    }
    onlyChild() {
      return this._children.get(0);
    }
    *eachLeafSeries() {
      const children = this._children.compactArray();
      for (const child of children) {
        if (child instanceof _Bucket) {
          yield* child.eachLeafSeries();
        } else {
          yield child;
        }
      }
    }
    serialize(map3, reduce) {
      const acc = [];
      return reduce(this._children.reduce((acc2, child, index2) => {
        if (child != null) {
          if (child instanceof _Bucket) {
            acc2.push(child.serialize(map3, reduce));
          } else {
            acc2.push(map3(child, index2));
          }
        }
        return acc2;
      }, acc));
    }
    async asyncTransform(asyncMap, asyncReduce) {
      return asyncTransformBucket(this, asyncMap, asyncReduce);
    }
    toJSON() {
      return this.serialize(mapNode, reduceNodes);
    }
    prettyPrint() {
      return JSON.stringify(this.toJSON(), null, "  ");
    }
    tableSize() {
      return Math.pow(2, this._options.bits);
    }
    async _findChild(key) {
      const result = await this._findPlace(key);
      const child = result.bucket._at(result.pos);
      if (child instanceof _Bucket) {
        return void 0;
      }
      if (child != null && child.key === key) {
        return child;
      }
    }
    async _findPlace(key) {
      const hashValue = this._options.hash(typeof key === "string" ? fromString5(key) : key);
      const index2 = await hashValue.take(this._options.bits);
      const child = this._children.get(index2);
      if (child instanceof _Bucket) {
        return child._findPlace(hashValue);
      }
      return {
        bucket: this,
        pos: index2,
        hash: hashValue,
        existingChild: child
      };
    }
    async _findNewBucketAndPos(key) {
      const place = await this._findPlace(key);
      if (place.existingChild != null && place.existingChild.key !== key) {
        const bucket = new _Bucket(this._options, place.bucket, place.pos);
        place.bucket._putObjectAt(place.pos, bucket);
        const newPlace = await bucket._findPlace(place.existingChild.hash);
        newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
        return bucket._findNewBucketAndPos(place.hash);
      }
      return place;
    }
    _putAt(place, key, value) {
      this._putObjectAt(place.pos, {
        key,
        value,
        hash: place.hash
      });
    }
    _putObjectAt(pos, object) {
      if (this._children.get(pos) == null) {
        this._popCount++;
      }
      this._children.set(pos, object);
    }
    _delAt(pos) {
      if (pos === -1) {
        throw new Error("Invalid position");
      }
      if (this._children.get(pos) != null) {
        this._popCount--;
      }
      this._children.unset(pos);
      this._level();
    }
    _level() {
      if (this._parent != null && this._popCount <= 1) {
        if (this._popCount === 1) {
          const onlyChild = this._children.find(exists2);
          if (onlyChild != null && !(onlyChild instanceof _Bucket)) {
            const hash2 = onlyChild.hash;
            hash2.untake(this._options.bits);
            const place = {
              pos: this._posAtParent,
              hash: hash2,
              bucket: this._parent
            };
            this._parent._putAt(place, onlyChild.key, onlyChild.value);
          }
        } else {
          this._parent._delAt(this._posAtParent);
        }
      }
    }
    _at(index2) {
      return this._children.get(index2);
    }
  };
  function exists2(o8) {
    return Boolean(o8);
  }
  function mapNode(node, _4) {
    return node.key;
  }
  function reduceNodes(nodes) {
    return nodes;
  }
  async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
    const output = [];
    for (const child of bucket._children.compactArray()) {
      if (child instanceof Bucket) {
        await asyncTransformBucket(child, asyncMap, asyncReduce);
      } else {
        const mappedChildren = await asyncMap(child);
        output.push({
          bitField: bucket._children.bitField(),
          children: mappedChildren
        });
      }
    }
    return asyncReduce(output);
  }

  // node_modules/.pnpm/hamt-sharding@3.0.6/node_modules/hamt-sharding/dist/src/consumable-hash.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/concat.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/util/as-uint8array.js
  init_dirname();
  init_buffer2();
  init_process2();
  function asUint8Array2(buf3) {
    return buf3;
  }

  // node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/concat.js
  function concat3(arrays, length4) {
    if (length4 == null) {
      length4 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = allocUnsafe(length4);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array2(output);
  }

  // node_modules/.pnpm/hamt-sharding@3.0.6/node_modules/hamt-sharding/dist/src/consumable-buffer.js
  init_dirname();
  init_buffer2();
  init_process2();
  var START_MASKS = [
    255,
    254,
    252,
    248,
    240,
    224,
    192,
    128
  ];
  var STOP_MASKS = [
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255
  ];
  var ConsumableBuffer = class {
    _value;
    _currentBytePos;
    _currentBitPos;
    constructor(value) {
      this._value = value;
      this._currentBytePos = value.length - 1;
      this._currentBitPos = 7;
    }
    availableBits() {
      return this._currentBitPos + 1 + this._currentBytePos * 8;
    }
    totalBits() {
      return this._value.length * 8;
    }
    take(bits) {
      let pendingBits = bits;
      let result = 0;
      while (pendingBits > 0 && this._haveBits()) {
        const byte = this._value[this._currentBytePos];
        const availableBits = this._currentBitPos + 1;
        const taking = Math.min(availableBits, pendingBits);
        const value = byteBitsToInt(byte, availableBits - taking, taking);
        result = (result << taking) + value;
        pendingBits -= taking;
        this._currentBitPos -= taking;
        if (this._currentBitPos < 0) {
          this._currentBitPos = 7;
          this._currentBytePos--;
        }
      }
      return result;
    }
    untake(bits) {
      this._currentBitPos += bits;
      while (this._currentBitPos > 7) {
        this._currentBitPos -= 8;
        this._currentBytePos += 1;
      }
    }
    _haveBits() {
      return this._currentBytePos >= 0;
    }
  };
  function byteBitsToInt(byte, start, length4) {
    const mask = maskFor(start, length4);
    return (byte & mask) >>> start;
  }
  function maskFor(start, length4) {
    return START_MASKS[start] & STOP_MASKS[Math.min(length4 + start - 1, 7)];
  }

  // node_modules/.pnpm/hamt-sharding@3.0.6/node_modules/hamt-sharding/dist/src/consumable-hash.js
  function wrapHash(hashFn2) {
    function hashing(value) {
      if (value instanceof InfiniteHash) {
        return value;
      } else {
        return new InfiniteHash(value, hashFn2);
      }
    }
    return hashing;
  }
  var InfiniteHash = class {
    _value;
    _hashFn;
    _depth;
    _availableBits;
    _currentBufferIndex;
    _buffers;
    constructor(value, hashFn2) {
      if (!(value instanceof Uint8Array)) {
        throw new Error("can only hash Uint8Arrays");
      }
      this._value = value;
      this._hashFn = hashFn2;
      this._depth = -1;
      this._availableBits = 0;
      this._currentBufferIndex = 0;
      this._buffers = [];
    }
    async take(bits) {
      let pendingBits = bits;
      while (this._availableBits < pendingBits) {
        await this._produceMoreBits();
      }
      let result = 0;
      while (pendingBits > 0) {
        const hash2 = this._buffers[this._currentBufferIndex];
        const available = Math.min(hash2.availableBits(), pendingBits);
        const took = hash2.take(available);
        result = (result << available) + took;
        pendingBits -= available;
        this._availableBits -= available;
        if (hash2.availableBits() === 0) {
          this._currentBufferIndex++;
        }
      }
      return result;
    }
    untake(bits) {
      let pendingBits = bits;
      while (pendingBits > 0) {
        const hash2 = this._buffers[this._currentBufferIndex];
        const availableForUntake = Math.min(hash2.totalBits() - hash2.availableBits(), pendingBits);
        hash2.untake(availableForUntake);
        pendingBits -= availableForUntake;
        this._availableBits += availableForUntake;
        if (this._currentBufferIndex > 0 && hash2.totalBits() === hash2.availableBits()) {
          this._depth--;
          this._currentBufferIndex--;
        }
      }
    }
    async _produceMoreBits() {
      this._depth++;
      const value = this._depth > 0 ? concat3([this._value, Uint8Array.from([this._depth])]) : this._value;
      const hashValue = await this._hashFn(value);
      const buffer4 = new ConsumableBuffer(hashValue);
      this._buffers.push(buffer4);
      this._availableBits += buffer4.availableBits();
    }
  };

  // node_modules/.pnpm/hamt-sharding@3.0.6/node_modules/hamt-sharding/dist/src/index.js
  function createHAMT(options) {
    if (options == null || options.hashFn == null) {
      throw new Error("please define an options.hashFn");
    }
    const bucketOptions = {
      bits: options.bits ?? 8,
      hash: wrapHash(options.hashFn)
    };
    return new Bucket(bucketOptions);
  }

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/utils/find-cid-in-shard.js
  var hashFn = async function(buf3) {
    return (await murmur3128.encode(buf3)).slice(0, 8).reverse();
  };
  var addLinksToHamtBucket = async (links4, bucket, rootBucket) => {
    const padLength = (bucket.tableSize() - 1).toString(16).length;
    await Promise.all(links4.map(async (link4) => {
      if (link4.Name == null) {
        throw new Error("Unexpected Link without a Name");
      }
      if (link4.Name.length === padLength) {
        const pos = parseInt(link4.Name, 16);
        bucket._putObjectAt(pos, new Bucket({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos));
        return;
      }
      await rootBucket.put(link4.Name.substring(2), true);
    }));
  };
  var toPrefix = (position, padLength) => {
    return position.toString(16).toUpperCase().padStart(padLength, "0").substring(0, padLength);
  };
  var toBucketPath = (position) => {
    let bucket = position.bucket;
    const path2 = [];
    while (bucket._parent != null) {
      path2.push(bucket);
      bucket = bucket._parent;
    }
    path2.push(bucket);
    return path2.reverse();
  };
  var findShardCid = async (node, name8, blockstore, context2, options) => {
    if (context2 == null) {
      if (node.Data == null) {
        throw new NotUnixFSError("no data in PBNode");
      }
      let dir;
      try {
        dir = UnixFS.unmarshal(node.Data);
      } catch (err) {
        throw new NotUnixFSError(err.message);
      }
      if (dir.type !== "hamt-sharded-directory") {
        throw new NotUnixFSError("not a HAMT");
      }
      if (dir.fanout == null) {
        throw new NotUnixFSError("missing fanout");
      }
      const rootBucket = createHAMT({
        hashFn,
        bits: Math.log2(Number(dir.fanout))
      });
      context2 = {
        rootBucket,
        hamtDepth: 1,
        lastBucket: rootBucket
      };
    }
    const padLength = (context2.lastBucket.tableSize() - 1).toString(16).length;
    await addLinksToHamtBucket(node.Links, context2.lastBucket, context2.rootBucket);
    const position = await context2.rootBucket._findNewBucketAndPos(name8);
    let prefix = toPrefix(position.pos, padLength);
    const bucketPath = toBucketPath(position);
    if (bucketPath.length > context2.hamtDepth) {
      context2.lastBucket = bucketPath[context2.hamtDepth];
      prefix = toPrefix(context2.lastBucket._posAtParent, padLength);
    }
    const link4 = node.Links.find((link5) => {
      if (link5.Name == null) {
        return false;
      }
      const entryPrefix = link5.Name.substring(0, padLength);
      const entryName = link5.Name.substring(padLength);
      if (entryPrefix !== prefix) {
        return false;
      }
      if (entryName !== "" && entryName !== name8) {
        return false;
      }
      return true;
    });
    if (link4 == null) {
      return;
    }
    if (link4.Name != null && link4.Name.substring(padLength) === name8) {
      return link4.Hash;
    }
    context2.hamtDepth++;
    const block = await blockstore.get(link4.Hash, options);
    node = decode12(block);
    return findShardCid(node, name8, blockstore, context2, options);
  };
  var find_cid_in_shard_default = findShardCid;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/directory.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/it-filter@3.1.1/node_modules/it-filter/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/it-peekable@3.0.5/node_modules/it-peekable/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  function peekable(iterable) {
    const [iterator, symbol] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
    const queue2 = [];
    return {
      peek: () => {
        return iterator.next();
      },
      push: (value) => {
        queue2.push(value);
      },
      next: () => {
        if (queue2.length > 0) {
          return {
            done: false,
            value: queue2.shift()
          };
        }
        return iterator.next();
      },
      [symbol]() {
        return this;
      }
    };
  }
  var src_default2 = peekable;

  // node_modules/.pnpm/it-filter@3.1.1/node_modules/it-filter/dist/src/index.js
  function isAsyncIterable2(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function filter(source, fn) {
    let index2 = 0;
    if (isAsyncIterable2(source)) {
      return async function* () {
        for await (const entry of source) {
          if (await fn(entry, index2++)) {
            yield entry;
          }
        }
      }();
    }
    const peekable2 = src_default2(source);
    const { value, done } = peekable2.next();
    if (done === true) {
      return function* () {
      }();
    }
    const res = fn(value, index2++);
    if (typeof res.then === "function") {
      return async function* () {
        if (await res) {
          yield value;
        }
        for await (const entry of peekable2) {
          if (await fn(entry, index2++)) {
            yield entry;
          }
        }
      }();
    }
    const func = fn;
    return function* () {
      if (res === true) {
        yield value;
      }
      for (const entry of peekable2) {
        if (func(entry, index2++)) {
          yield entry;
        }
      }
    }();
  }
  var src_default3 = filter;

  // node_modules/.pnpm/it-map@3.1.1/node_modules/it-map/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  function isAsyncIterable3(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function map2(source, func) {
    let index2 = 0;
    if (isAsyncIterable3(source)) {
      return async function* () {
        for await (const val of source) {
          yield func(val, index2++);
        }
      }();
    }
    const peekable2 = src_default2(source);
    const { value, done } = peekable2.next();
    if (done === true) {
      return function* () {
      }();
    }
    const res = func(value, index2++);
    if (typeof res.then === "function") {
      return async function* () {
        yield await res;
        for await (const val of peekable2) {
          yield func(val, index2++);
        }
      }();
    }
    const fn = func;
    return function* () {
      yield res;
      for (const val of peekable2) {
        yield fn(val, index2++);
      }
    }();
  }
  var src_default4 = map2;

  // node_modules/.pnpm/it-parallel@3.0.8/node_modules/it-parallel/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/p-defer@4.0.1/node_modules/p-defer/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  function pDefer() {
    const deferred = {};
    deferred.promise = new Promise((resolve9, reject) => {
      deferred.resolve = resolve9;
      deferred.reject = reject;
    });
    return deferred;
  }

  // node_modules/.pnpm/it-parallel@3.0.8/node_modules/it-parallel/dist/src/index.js
  var CustomEvent = globalThis.CustomEvent ?? Event;
  async function* parallel(source, options = {}) {
    let concurrency = options.concurrency ?? Infinity;
    if (concurrency < 1) {
      concurrency = Infinity;
    }
    const ordered = options.ordered == null ? false : options.ordered;
    const emitter = new EventTarget();
    const ops = [];
    let slotAvailable = pDefer();
    let resultAvailable = pDefer();
    let sourceFinished = false;
    let sourceErr;
    let opErred = false;
    emitter.addEventListener("task-complete", () => {
      resultAvailable.resolve();
    });
    void Promise.resolve().then(async () => {
      try {
        for await (const task of source) {
          if (ops.length === concurrency) {
            slotAvailable = pDefer();
            await slotAvailable.promise;
          }
          if (opErred) {
            break;
          }
          const op = {
            done: false
          };
          ops.push(op);
          task().then((result) => {
            op.done = true;
            op.ok = true;
            op.value = result;
            emitter.dispatchEvent(new CustomEvent("task-complete"));
          }, (err) => {
            op.done = true;
            op.err = err;
            emitter.dispatchEvent(new CustomEvent("task-complete"));
          });
        }
        sourceFinished = true;
        emitter.dispatchEvent(new CustomEvent("task-complete"));
      } catch (err) {
        sourceErr = err;
        emitter.dispatchEvent(new CustomEvent("task-complete"));
      }
    });
    function valuesAvailable() {
      if (ordered) {
        return ops[0]?.done;
      }
      return Boolean(ops.find((op) => op.done));
    }
    function* yieldOrderedValues() {
      while (ops.length > 0 && ops[0].done) {
        const op = ops[0];
        ops.shift();
        if (op.ok) {
          yield op.value;
        } else {
          opErred = true;
          slotAvailable.resolve();
          throw op.err;
        }
        slotAvailable.resolve();
      }
    }
    function* yieldUnOrderedValues() {
      while (valuesAvailable()) {
        for (let i7 = 0; i7 < ops.length; i7++) {
          if (ops[i7].done) {
            const op = ops[i7];
            ops.splice(i7, 1);
            i7--;
            if (op.ok) {
              yield op.value;
            } else {
              opErred = true;
              slotAvailable.resolve();
              throw op.err;
            }
            slotAvailable.resolve();
          }
        }
      }
    }
    while (true) {
      if (!valuesAvailable()) {
        resultAvailable = pDefer();
        await resultAvailable.promise;
      }
      if (sourceErr != null) {
        throw sourceErr;
      }
      if (ordered) {
        yield* yieldOrderedValues();
      } else {
        yield* yieldUnOrderedValues();
      }
      if (sourceFinished && ops.length === 0) {
        break;
      }
    }
  }

  // node_modules/.pnpm/it-pipe@3.0.1/node_modules/it-pipe/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/it-pushable@3.2.3/node_modules/it-pushable/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/it-pushable@3.2.3/node_modules/it-pushable/dist/src/fifo.js
  init_dirname();
  init_buffer2();
  init_process2();
  var FixedFIFO = class {
    buffer;
    mask;
    top;
    btm;
    next;
    constructor(hwm) {
      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
        throw new Error("Max size for a FixedFIFO should be a power of two");
      }
      this.buffer = new Array(hwm);
      this.mask = hwm - 1;
      this.top = 0;
      this.btm = 0;
      this.next = null;
    }
    push(data) {
      if (this.buffer[this.top] !== void 0) {
        return false;
      }
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return true;
    }
    shift() {
      const last2 = this.buffer[this.btm];
      if (last2 === void 0) {
        return void 0;
      }
      this.buffer[this.btm] = void 0;
      this.btm = this.btm + 1 & this.mask;
      return last2;
    }
    isEmpty() {
      return this.buffer[this.btm] === void 0;
    }
  };
  var FIFO = class {
    size;
    hwm;
    head;
    tail;
    constructor(options = {}) {
      this.hwm = options.splitLimit ?? 16;
      this.head = new FixedFIFO(this.hwm);
      this.tail = this.head;
      this.size = 0;
    }
    calculateSize(obj) {
      if (obj?.byteLength != null) {
        return obj.byteLength;
      }
      return 1;
    }
    push(val) {
      if (val?.value != null) {
        this.size += this.calculateSize(val.value);
      }
      if (!this.head.push(val)) {
        const prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
        this.head.push(val);
      }
    }
    shift() {
      let val = this.tail.shift();
      if (val === void 0 && this.tail.next != null) {
        const next = this.tail.next;
        this.tail.next = null;
        this.tail = next;
        val = this.tail.shift();
      }
      if (val?.value != null) {
        this.size -= this.calculateSize(val.value);
      }
      return val;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
  };

  // node_modules/.pnpm/it-pushable@3.2.3/node_modules/it-pushable/dist/src/index.js
  var AbortError = class extends Error {
    type;
    code;
    constructor(message2, code9) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.code = code9 ?? "ABORT_ERR";
    }
  };
  function pushable(options = {}) {
    const getNext = (buffer4) => {
      const next = buffer4.shift();
      if (next == null) {
        return { done: true };
      }
      if (next.error != null) {
        throw next.error;
      }
      return {
        done: next.done === true,
        // @ts-expect-error if done is false, value will be present
        value: next.value
      };
    };
    return _pushable(getNext, options);
  }
  function _pushable(getNext, options) {
    options = options ?? {};
    let onEnd = options.onEnd;
    let buffer4 = new FIFO();
    let pushable2;
    let onNext;
    let ended;
    let drain = pDefer();
    const waitNext = async () => {
      try {
        if (!buffer4.isEmpty()) {
          return getNext(buffer4);
        }
        if (ended) {
          return { done: true };
        }
        return await new Promise((resolve9, reject) => {
          onNext = (next) => {
            onNext = null;
            buffer4.push(next);
            try {
              resolve9(getNext(buffer4));
            } catch (err) {
              reject(err);
            }
            return pushable2;
          };
        });
      } finally {
        if (buffer4.isEmpty()) {
          queueMicrotask(() => {
            drain.resolve();
            drain = pDefer();
          });
        }
      }
    };
    const bufferNext = (next) => {
      if (onNext != null) {
        return onNext(next);
      }
      buffer4.push(next);
      return pushable2;
    };
    const bufferError = (err) => {
      buffer4 = new FIFO();
      if (onNext != null) {
        return onNext({ error: err });
      }
      buffer4.push({ error: err });
      return pushable2;
    };
    const push2 = (value) => {
      if (ended) {
        return pushable2;
      }
      if (options?.objectMode !== true && value?.byteLength == null) {
        throw new Error("objectMode was not true but tried to push non-Uint8Array value");
      }
      return bufferNext({ done: false, value });
    };
    const end = (err) => {
      if (ended)
        return pushable2;
      ended = true;
      return err != null ? bufferError(err) : bufferNext({ done: true });
    };
    const _return = () => {
      buffer4 = new FIFO();
      end();
      return { done: true };
    };
    const _throw = (err) => {
      end(err);
      return { done: true };
    };
    pushable2 = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next: waitNext,
      return: _return,
      throw: _throw,
      push: push2,
      end,
      get readableLength() {
        return buffer4.size;
      },
      onEmpty: async (options2) => {
        const signal = options2?.signal;
        signal?.throwIfAborted();
        if (buffer4.isEmpty()) {
          return;
        }
        let cancel;
        let listener;
        if (signal != null) {
          cancel = new Promise((resolve9, reject) => {
            listener = () => {
              reject(new AbortError());
            };
            signal.addEventListener("abort", listener);
          });
        }
        try {
          await Promise.race([
            drain.promise,
            cancel
          ]);
        } finally {
          if (listener != null && signal != null) {
            signal?.removeEventListener("abort", listener);
          }
        }
      }
    };
    if (onEnd == null) {
      return pushable2;
    }
    const _pushable2 = pushable2;
    pushable2 = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next() {
        return _pushable2.next();
      },
      throw(err) {
        _pushable2.throw(err);
        if (onEnd != null) {
          onEnd(err);
          onEnd = void 0;
        }
        return { done: true };
      },
      return() {
        _pushable2.return();
        if (onEnd != null) {
          onEnd();
          onEnd = void 0;
        }
        return { done: true };
      },
      push: push2,
      end(err) {
        _pushable2.end(err);
        if (onEnd != null) {
          onEnd(err);
          onEnd = void 0;
        }
        return pushable2;
      },
      get readableLength() {
        return _pushable2.readableLength;
      },
      onEmpty: (opts) => {
        return _pushable2.onEmpty(opts);
      }
    };
    return pushable2;
  }

  // node_modules/.pnpm/it-merge@3.0.5/node_modules/it-merge/dist/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  function isAsyncIterable4(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function merge(...sources) {
    const syncSources = [];
    for (const source of sources) {
      if (!isAsyncIterable4(source)) {
        syncSources.push(source);
      }
    }
    if (syncSources.length === sources.length) {
      return function* () {
        for (const source of syncSources) {
          yield* source;
        }
      }();
    }
    return async function* () {
      const output = pushable({
        objectMode: true
      });
      void Promise.resolve().then(async () => {
        try {
          await Promise.all(sources.map(async (source) => {
            for await (const item of source) {
              output.push(item);
            }
          }));
          output.end();
        } catch (err) {
          output.end(err);
        }
      });
      yield* output;
    }();
  }
  var src_default5 = merge;

  // node_modules/.pnpm/it-pipe@3.0.1/node_modules/it-pipe/dist/src/index.js
  function pipe(first, ...rest) {
    if (first == null) {
      throw new Error("Empty pipeline");
    }
    if (isDuplex(first)) {
      const duplex = first;
      first = () => duplex.source;
    } else if (isIterable(first) || isAsyncIterable5(first)) {
      const source = first;
      first = () => source;
    }
    const fns = [first, ...rest];
    if (fns.length > 1) {
      if (isDuplex(fns[fns.length - 1])) {
        fns[fns.length - 1] = fns[fns.length - 1].sink;
      }
    }
    if (fns.length > 2) {
      for (let i7 = 1; i7 < fns.length - 1; i7++) {
        if (isDuplex(fns[i7])) {
          fns[i7] = duplexPipelineFn(fns[i7]);
        }
      }
    }
    return rawPipe(...fns);
  }
  var rawPipe = (...fns) => {
    let res;
    while (fns.length > 0) {
      res = fns.shift()(res);
    }
    return res;
  };
  var isAsyncIterable5 = (obj) => {
    return obj?.[Symbol.asyncIterator] != null;
  };
  var isIterable = (obj) => {
    return obj?.[Symbol.iterator] != null;
  };
  var isDuplex = (obj) => {
    if (obj == null) {
      return false;
    }
    return obj.sink != null && obj.source != null;
  };
  var duplexPipelineFn = (duplex) => {
    return (source) => {
      const p7 = duplex.sink(source);
      if (p7?.then != null) {
        const stream = pushable({
          objectMode: true
        });
        p7.then(() => {
          stream.end();
        }, (err) => {
          stream.end(err);
        });
        let sourceWrap;
        const source2 = duplex.source;
        if (isAsyncIterable5(source2)) {
          sourceWrap = async function* () {
            yield* source2;
            stream.end();
          };
        } else if (isIterable(source2)) {
          sourceWrap = function* () {
            yield* source2;
            stream.end();
          };
        } else {
          throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
        }
        return src_default5(stream, sourceWrap());
      }
      return duplex.source;
    };
  };

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/directory.js
  var directoryContent = (cid, node, unixfs, path2, resolve9, depth, blockstore) => {
    async function* yieldDirectoryContent(options = {}) {
      const offset = options.offset ?? 0;
      const length4 = options.length ?? node.Links.length;
      const links4 = node.Links.slice(offset, length4);
      options.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:directory", {
        cid
      }));
      yield* pipe(links4, (source) => src_default4(source, (link4) => {
        return async () => {
          const linkName = link4.Name ?? "";
          const linkPath = `${path2}/${linkName}`;
          const result = await resolve9(link4.Hash, linkName, linkPath, [], depth + 1, blockstore, options);
          return result.entry;
        };
      }), (source) => parallel(source, {
        ordered: true,
        concurrency: options.blockReadConcurrency
      }), (source) => src_default3(source, (entry) => entry != null));
    }
    return yieldDirectoryContent;
  };
  var directory_default = directoryContent;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/file.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs
  init_dirname();
  init_buffer2();
  init_process2();
  var import_index4 = __toESM(require_eventemitter3(), 1);

  // node_modules/.pnpm/p-timeout@6.1.2/node_modules/p-timeout/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  var TimeoutError = class extends Error {
    constructor(message2) {
      super(message2);
      this.name = "TimeoutError";
    }
  };
  var AbortError2 = class extends Error {
    constructor(message2) {
      super();
      this.name = "AbortError";
      this.message = message2;
    }
  };
  var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError2(errorMessage) : new DOMException(errorMessage);
  var getAbortedReason = (signal) => {
    const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException(reason);
  };
  function pTimeout(promise, options) {
    const {
      milliseconds,
      fallback,
      message: message2,
      customTimers = { setTimeout, clearTimeout }
    } = options;
    let timer;
    const wrappedPromise = new Promise((resolve9, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason(signal));
        }
        signal.addEventListener("abort", () => {
          reject(getAbortedReason(signal));
        });
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        promise.then(resolve9, reject);
        return;
      }
      const timeoutError = new TimeoutError();
      timer = customTimers.setTimeout.call(void 0, () => {
        if (fallback) {
          try {
            resolve9(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        if (message2 === false) {
          resolve9();
        } else if (message2 instanceof Error) {
          reject(message2);
        } else {
          timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
          reject(timeoutError);
        }
      }, milliseconds);
      (async () => {
        try {
          resolve9(await promise);
        } catch (error) {
          reject(error);
        }
      })();
    });
    const cancelablePromise = wrappedPromise.finally(() => {
      cancelablePromise.clear();
    });
    cancelablePromise.clear = () => {
      customTimers.clearTimeout.call(void 0, timer);
      timer = void 0;
    };
    return cancelablePromise;
  }

  // node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/priority-queue.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/lower-bound.js
  init_dirname();
  init_buffer2();
  init_process2();
  function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while (count > 0) {
      const step2 = Math.trunc(count / 2);
      let it = first + step2;
      if (comparator(array[it], value) <= 0) {
        first = ++it;
        count -= step2 + 1;
      } else {
        count = step2;
      }
    }
    return first;
  }

  // node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/priority-queue.js
  var PriorityQueue = class {
    #queue = [];
    enqueue(run, options) {
      options = {
        priority: 0,
        ...options
      };
      const element = {
        priority: options.priority,
        run
      };
      if (this.size && this.#queue[this.size - 1].priority >= options.priority) {
        this.#queue.push(element);
        return;
      }
      const index2 = lowerBound(this.#queue, element, (a7, b5) => b5.priority - a7.priority);
      this.#queue.splice(index2, 0, element);
    }
    dequeue() {
      const item = this.#queue.shift();
      return item?.run;
    }
    filter(options) {
      return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
      return this.#queue.length;
    }
  };

  // node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/index.js
  var PQueue = class extends import_index4.default {
    #carryoverConcurrencyCount;
    #isIntervalIgnored;
    #intervalCount = 0;
    #intervalCap;
    #interval;
    #intervalEnd = 0;
    #intervalId;
    #timeoutId;
    #queue;
    #queueClass;
    #pending = 0;
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    #concurrency;
    #isPaused;
    #throwOnTimeout;
    /**
        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
    
        Applies to each future operation.
        */
    timeout;
    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
    constructor(options) {
      super();
      options = {
        carryoverConcurrencyCount: false,
        intervalCap: Number.POSITIVE_INFINITY,
        interval: 0,
        concurrency: Number.POSITIVE_INFINITY,
        autoStart: true,
        queueClass: PriorityQueue,
        ...options
      };
      if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap?.toString() ?? ""}\` (${typeof options.intervalCap})`);
      }
      if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval?.toString() ?? ""}\` (${typeof options.interval})`);
      }
      this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
      this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
      this.#intervalCap = options.intervalCap;
      this.#interval = options.interval;
      this.#queue = new options.queueClass();
      this.#queueClass = options.queueClass;
      this.concurrency = options.concurrency;
      this.timeout = options.timeout;
      this.#throwOnTimeout = options.throwOnTimeout === true;
      this.#isPaused = options.autoStart === false;
    }
    get #doesIntervalAllowAnother() {
      return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
    }
    get #doesConcurrentAllowAnother() {
      return this.#pending < this.#concurrency;
    }
    #next() {
      this.#pending--;
      this.#tryToStartAnother();
      this.emit("next");
    }
    #onResumeInterval() {
      this.#onInterval();
      this.#initializeIntervalIfNeeded();
      this.#timeoutId = void 0;
    }
    get #isIntervalPaused() {
      const now = Date.now();
      if (this.#intervalId === void 0) {
        const delay = this.#intervalEnd - now;
        if (delay < 0) {
          this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
        } else {
          if (this.#timeoutId === void 0) {
            this.#timeoutId = setTimeout(() => {
              this.#onResumeInterval();
            }, delay);
          }
          return true;
        }
      }
      return false;
    }
    #tryToStartAnother() {
      if (this.#queue.size === 0) {
        if (this.#intervalId) {
          clearInterval(this.#intervalId);
        }
        this.#intervalId = void 0;
        this.emit("empty");
        if (this.#pending === 0) {
          this.emit("idle");
        }
        return false;
      }
      if (!this.#isPaused) {
        const canInitializeInterval = !this.#isIntervalPaused;
        if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
          const job = this.#queue.dequeue();
          if (!job) {
            return false;
          }
          this.emit("active");
          job();
          if (canInitializeInterval) {
            this.#initializeIntervalIfNeeded();
          }
          return true;
        }
      }
      return false;
    }
    #initializeIntervalIfNeeded() {
      if (this.#isIntervalIgnored || this.#intervalId !== void 0) {
        return;
      }
      this.#intervalId = setInterval(() => {
        this.#onInterval();
      }, this.#interval);
      this.#intervalEnd = Date.now() + this.#interval;
    }
    #onInterval() {
      if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
        clearInterval(this.#intervalId);
        this.#intervalId = void 0;
      }
      this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
      this.#processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    #processQueue() {
      while (this.#tryToStartAnother()) {
      }
    }
    get concurrency() {
      return this.#concurrency;
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      this.#concurrency = newConcurrency;
      this.#processQueue();
    }
    async #throwOnAbort(signal) {
      return new Promise((_resolve, reject) => {
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        }, { once: true });
      });
    }
    async add(function_, options = {}) {
      options = {
        timeout: this.timeout,
        throwOnTimeout: this.#throwOnTimeout,
        ...options
      };
      return new Promise((resolve9, reject) => {
        this.#queue.enqueue(async () => {
          this.#pending++;
          this.#intervalCount++;
          try {
            options.signal?.throwIfAborted();
            let operation = function_({ signal: options.signal });
            if (options.timeout) {
              operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
            }
            if (options.signal) {
              operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
            }
            const result = await operation;
            resolve9(result);
            this.emit("completed", result);
          } catch (error) {
            if (error instanceof TimeoutError && !options.throwOnTimeout) {
              resolve9();
              return;
            }
            reject(error);
            this.emit("error", error);
          } finally {
            this.#next();
          }
        }, options);
        this.emit("add");
        this.#tryToStartAnother();
      });
    }
    async addAll(functions, options) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
      if (!this.#isPaused) {
        return this;
      }
      this.#isPaused = false;
      this.#processQueue();
      return this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
      this.#isPaused = true;
    }
    /**
    Clear the queue.
    */
    clear() {
      this.#queue = new this.#queueClass();
    }
    /**
        Can be called multiple times. Useful if you for example add additional items at a later time.
    
        @returns A promise that settles when the queue becomes empty.
        */
    async onEmpty() {
      if (this.#queue.size === 0) {
        return;
      }
      await this.#onEvent("empty");
    }
    /**
        @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
    
        If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
    
        Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
        */
    async onSizeLessThan(limit) {
      if (this.#queue.size < limit) {
        return;
      }
      await this.#onEvent("next", () => this.#queue.size < limit);
    }
    /**
        The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
    
        @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
        */
    async onIdle() {
      if (this.#pending === 0 && this.#queue.size === 0) {
        return;
      }
      await this.#onEvent("idle");
    }
    async #onEvent(event, filter2) {
      return new Promise((resolve9) => {
        const listener = () => {
          if (filter2 && !filter2()) {
            return;
          }
          this.off(event, listener);
          resolve9();
        };
        this.on(event, listener);
      });
    }
    /**
    Size of the queue, the number of queued items waiting to run.
    */
    get size() {
      return this.#queue.size;
    }
    /**
        Size of the queue, filtered by the given options.
    
        For example, this can be used to find the number of items remaining in the queue with a specific priority level.
        */
    sizeBy(options) {
      return this.#queue.filter(options).length;
    }
    /**
    Number of running items (no longer in the queue).
    */
    get pending() {
      return this.#pending;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
      return this.#isPaused;
    }
  };

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/file.js
  async function walkDAG(blockstore, node, queue2, streamPosition, start, end, options) {
    if (node instanceof Uint8Array) {
      const buf3 = extract_data_from_block_default(node, streamPosition, start, end);
      queue2.push(buf3);
      return;
    }
    if (node.Data == null) {
      throw new NotUnixFSError("no data in PBNode");
    }
    let file;
    try {
      file = UnixFS.unmarshal(node.Data);
    } catch (err) {
      throw new NotUnixFSError(err.message);
    }
    if (file.data != null) {
      const data = file.data;
      const buf3 = extract_data_from_block_default(data, streamPosition, start, end);
      queue2.push(buf3);
      streamPosition += BigInt(buf3.byteLength);
    }
    const childOps = [];
    if (node.Links.length !== file.blockSizes.length) {
      throw new NotUnixFSError("Inconsistent block sizes and dag links");
    }
    for (let i7 = 0; i7 < node.Links.length; i7++) {
      const childLink = node.Links[i7];
      const childStart = streamPosition;
      const childEnd = childStart + file.blockSizes[i7];
      if (start >= childStart && start < childEnd || // child has offset byte
      end >= childStart && end <= childEnd || // child has end byte
      start < childStart && end > childEnd) {
        childOps.push({
          link: childLink,
          blockStart: streamPosition
        });
      }
      streamPosition = childEnd;
      if (streamPosition > end) {
        break;
      }
    }
    await pipe(childOps, (source) => src_default4(source, (op) => {
      return async () => {
        const block = await blockstore.get(op.link.Hash, options);
        return {
          ...op,
          block
        };
      };
    }), (source) => parallel(source, {
      ordered: true,
      concurrency: options.blockReadConcurrency
    }), async (source) => {
      for await (const { link: link4, block, blockStart } of source) {
        let child;
        switch (link4.Hash.code) {
          case code2:
            child = decode12(block);
            break;
          case code4:
            child = block;
            break;
          default:
            queue2.end(new NotUnixFSError(`Unsupported codec: ${link4.Hash.code}`));
            return;
        }
        const childQueue = new PQueue({
          concurrency: 1
        });
        childQueue.on("error", (error) => {
          queue2.end(error);
        });
        void childQueue.add(async () => {
          options.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:file", {
            cid: link4.Hash
          }));
          await walkDAG(blockstore, child, queue2, blockStart, start, end, options);
        });
        await childQueue.onIdle();
      }
    });
    if (streamPosition >= end) {
      queue2.end();
    }
  }
  var fileContent = (cid, node, unixfs, path2, resolve9, depth, blockstore) => {
    async function* yieldFileContent(options = {}) {
      const fileSize = unixfs.fileSize();
      if (fileSize === void 0) {
        throw new Error("File was a directory");
      }
      const { start, end } = validate_offset_and_length_default(fileSize, options.offset, options.length);
      if (end === 0n) {
        return;
      }
      let read6 = 0n;
      const wanted = end - start;
      const queue2 = pushable();
      options.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:file", {
        cid
      }));
      void walkDAG(blockstore, node, queue2, 0n, start, end, options).catch((err) => {
        queue2.end(err);
      });
      for await (const buf3 of queue2) {
        if (buf3 == null) {
          continue;
        }
        read6 += BigInt(buf3.byteLength);
        if (read6 > wanted) {
          queue2.end();
          throw new OverReadError("Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect");
        }
        if (read6 === wanted) {
          queue2.end();
        }
        options.onProgress?.(new CustomProgressEvent("unixfs:exporter:progress:unixfs:file", {
          bytesRead: read6,
          totalBytes: wanted,
          fileSize
        }));
        yield buf3;
      }
      if (read6 < wanted) {
        throw new UnderReadError("Traversed entire DAG but did not read enough bytes");
      }
    }
    return yieldFileContent;
  };
  var file_default = fileContent;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
  init_dirname();
  init_buffer2();
  init_process2();
  var hamtShardedDirectoryContent = (cid, node, unixfs, path2, resolve9, depth, blockstore) => {
    function yieldHamtDirectoryContent(options = {}) {
      options.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:hamt-sharded-directory", {
        cid
      }));
      return listDirectory(node, path2, resolve9, depth, blockstore, options);
    }
    return yieldHamtDirectoryContent;
  };
  async function* listDirectory(node, path2, resolve9, depth, blockstore, options) {
    const links4 = node.Links;
    if (node.Data == null) {
      throw new NotUnixFSError("no data in PBNode");
    }
    let dir;
    try {
      dir = UnixFS.unmarshal(node.Data);
    } catch (err) {
      throw new NotUnixFSError(err.message);
    }
    if (dir.fanout == null) {
      throw new NotUnixFSError("missing fanout");
    }
    const padLength = (dir.fanout - 1n).toString(16).length;
    const results = pipe(links4, (source) => src_default4(source, (link4) => {
      return async () => {
        const name8 = link4.Name != null ? link4.Name.substring(padLength) : null;
        if (name8 != null && name8 !== "") {
          const result = await resolve9(link4.Hash, name8, `${path2}/${name8}`, [], depth + 1, blockstore, options);
          return { entries: result.entry == null ? [] : [result.entry] };
        } else {
          const block = await blockstore.get(link4.Hash, options);
          node = decode12(block);
          options.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:hamt-sharded-directory", {
            cid: link4.Hash
          }));
          return { entries: listDirectory(node, path2, resolve9, depth, blockstore, options) };
        }
      };
    }), (source) => parallel(source, {
      ordered: true,
      concurrency: options.blockReadConcurrency
    }));
    for await (const { entries: entries3 } of results) {
      yield* entries3;
    }
  }
  var hamt_sharded_directory_default = hamtShardedDirectoryContent;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/index.js
  var findLinkCid = (node, name8) => {
    const link4 = node.Links.find((link5) => link5.Name === name8);
    return link4?.Hash;
  };
  var contentExporters = {
    raw: file_default,
    file: file_default,
    directory: directory_default,
    "hamt-sharded-directory": hamt_sharded_directory_default,
    metadata: (cid, node, unixfs, path2, resolve9, depth, blockstore) => {
      return () => [];
    },
    symlink: (cid, node, unixfs, path2, resolve9, depth, blockstore) => {
      return () => [];
    }
  };
  var unixFsResolver = async (cid, name8, path2, toResolve, resolve9, depth, blockstore, options) => {
    const block = await blockstore.get(cid, options);
    const node = decode12(block);
    let unixfs;
    let next;
    if (name8 == null) {
      name8 = cid.toString();
    }
    if (node.Data == null) {
      throw new NotUnixFSError("no data in PBNode");
    }
    try {
      unixfs = UnixFS.unmarshal(node.Data);
    } catch (err) {
      throw new NotUnixFSError(err.message);
    }
    if (path2 == null) {
      path2 = name8;
    }
    if (toResolve.length > 0) {
      let linkCid;
      if (unixfs?.type === "hamt-sharded-directory") {
        linkCid = await find_cid_in_shard_default(node, toResolve[0], blockstore);
      } else {
        linkCid = findLinkCid(node, toResolve[0]);
      }
      if (linkCid == null) {
        throw new NotFoundError2("file does not exist");
      }
      const nextName = toResolve.shift();
      const nextPath = `${path2}/${nextName}`;
      next = {
        cid: linkCid,
        toResolve,
        name: nextName ?? "",
        path: nextPath
      };
    }
    const content = contentExporters[unixfs.type](cid, node, unixfs, path2, resolve9, depth, blockstore);
    if (content == null) {
      throw new NotFoundError2("could not find content exporter");
    }
    if (unixfs.isDirectory()) {
      return {
        entry: {
          type: "directory",
          name: name8,
          path: path2,
          cid,
          content,
          unixfs,
          depth,
          node,
          size: unixfs.fileSize()
        },
        next
      };
    }
    return {
      entry: {
        type: "file",
        name: name8,
        path: path2,
        cid,
        content,
        unixfs,
        depth,
        node,
        size: unixfs.fileSize()
      },
      next
    };
  };
  var unixfs_v1_default = unixFsResolver;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/resolvers/index.js
  var resolvers = {
    [code2]: unixfs_v1_default,
    [code4]: raw_default,
    [code]: dag_cbor_default,
    [code5]: dag_json_default,
    [identity.code]: identity_default,
    [code6]: json_default
  };
  var resolve8 = async (cid, name8, path2, toResolve, depth, blockstore, options) => {
    const resolver = resolvers[cid.code];
    if (resolver == null) {
      throw new NoResolverError(`No resolver for code ${cid.code}`);
    }
    return resolver(cid, name8, path2, toResolve, resolve8, depth, blockstore, options);
  };
  var resolvers_default = resolve8;

  // node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/dist/src/index.js
  var toPathComponents = (path2 = "") => {
    return (path2.trim().match(/([^\\^/]|\\\/)+/g) ?? []).filter(Boolean);
  };
  var cidAndRest = (path2) => {
    if (path2 instanceof Uint8Array) {
      return {
        cid: CID.decode(path2),
        toResolve: []
      };
    }
    const cid = CID.asCID(path2);
    if (cid != null) {
      return {
        cid,
        toResolve: []
      };
    }
    if (typeof path2 === "string") {
      if (path2.indexOf("/ipfs/") === 0) {
        path2 = path2.substring(6);
      }
      const output = toPathComponents(path2);
      return {
        cid: CID.parse(output[0]),
        toResolve: output.slice(1)
      };
    }
    throw new BadPathError(`Unknown path type ${path2}`);
  };
  async function* walkPath(path2, blockstore, options = {}) {
    let { cid, toResolve } = cidAndRest(path2);
    let name8 = cid.toString();
    let entryPath = name8;
    const startingDepth = toResolve.length;
    while (true) {
      const result = await resolvers_default(cid, name8, entryPath, toResolve, startingDepth, blockstore, options);
      if (result.entry == null && result.next == null) {
        throw new NotFoundError2(`Could not resolve ${path2}`);
      }
      if (result.entry != null) {
        yield result.entry;
      }
      if (result.next == null) {
        return;
      }
      toResolve = result.next.toResolve;
      cid = result.next.cid;
      name8 = result.next.name;
      entryPath = result.next.path;
    }
  }
  async function exporter(path2, blockstore, options = {}) {
    const result = await src_default(walkPath(path2, blockstore, options));
    if (result == null) {
      throw new NotFoundError2(`Could not resolve ${path2}`);
    }
    return result;
  }

  // node_modules/.pnpm/p-limit@6.1.0/node_modules/p-limit/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/yocto-queue@1.1.1/node_modules/yocto-queue/index.js
  init_dirname();
  init_buffer2();
  init_process2();
  var Node2 = class {
    value;
    next;
    constructor(value) {
      this.value = value;
    }
  };
  var Queue = class {
    #head;
    #tail;
    #size;
    constructor() {
      this.clear();
    }
    enqueue(value) {
      const node = new Node2(value);
      if (this.#head) {
        this.#tail.next = node;
        this.#tail = node;
      } else {
        this.#head = node;
        this.#tail = node;
      }
      this.#size++;
    }
    dequeue() {
      const current2 = this.#head;
      if (!current2) {
        return;
      }
      this.#head = this.#head.next;
      this.#size--;
      return current2.value;
    }
    peek() {
      if (!this.#head) {
        return;
      }
      return this.#head.value;
    }
    clear() {
      this.#head = void 0;
      this.#tail = void 0;
      this.#size = 0;
    }
    get size() {
      return this.#size;
    }
    *[Symbol.iterator]() {
      let current2 = this.#head;
      while (current2) {
        yield current2.value;
        current2 = current2.next;
      }
    }
  };

  // node_modules/.pnpm/p-limit@6.1.0/node_modules/p-limit/index.js
  function pLimit(concurrency) {
    validateConcurrency(concurrency);
    const queue2 = new Queue();
    let activeCount = 0;
    const resumeNext = () => {
      if (activeCount < concurrency && queue2.size > 0) {
        queue2.dequeue()();
        activeCount++;
      }
    };
    const next = () => {
      activeCount--;
      resumeNext();
    };
    const run = async (function_, resolve9, arguments_) => {
      const result = (async () => function_(...arguments_))();
      resolve9(result);
      try {
        await result;
      } catch {
      }
      next();
    };
    const enqueue2 = (function_, resolve9, arguments_) => {
      new Promise((internalResolve) => {
        queue2.enqueue(internalResolve);
      }).then(
        run.bind(void 0, function_, resolve9, arguments_)
      );
      (async () => {
        await Promise.resolve();
        if (activeCount < concurrency) {
          resumeNext();
        }
      })();
    };
    const generator = (function_, ...arguments_) => new Promise((resolve9) => {
      enqueue2(function_, resolve9, arguments_);
    });
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue2.size
      },
      clearQueue: {
        value() {
          queue2.clear();
        }
      },
      concurrency: {
        get: () => concurrency,
        set(newConcurrency) {
          validateConcurrency(newConcurrency);
          concurrency = newConcurrency;
          queueMicrotask(() => {
            while (activeCount < concurrency && queue2.size > 0) {
              resumeNext();
            }
          });
        }
      }
    });
    return generator;
  }
  function validateConcurrency(concurrency) {
    if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
      throw new TypeError("Expected `concurrency` to be a number from 1 and up");
    }
  }

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/index.js
  init_cement();

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-reader-browser.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-decoder.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/decoder-common.js
  init_dirname();
  init_buffer2();
  init_process2();
  var import_varint3 = __toESM(require_varint(), 1);
  var CIDV0_BYTES = {
    SHA2_256: 18,
    LENGTH: 32,
    DAG_PB: 112
  };
  var V2_HEADER_LENGTH = (
    /* characteristics */
    16 + 8 + 8 + 8
  );
  function decodeVarint2(bytes, seeker) {
    if (!bytes.length) {
      throw new Error("Unexpected end of data");
    }
    const i7 = import_varint3.default.decode(bytes);
    seeker.seek(
      /** @type {number} */
      import_varint3.default.decode.bytes
    );
    return i7;
  }
  function decodeV2Header(bytes) {
    const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;
    const header = {
      version: 2,
      /** @type {[bigint, bigint]} */
      characteristics: [
        dv.getBigUint64(offset, true),
        dv.getBigUint64(offset += 8, true)
      ],
      dataOffset: Number(dv.getBigUint64(offset += 8, true)),
      dataSize: Number(dv.getBigUint64(offset += 8, true)),
      indexOffset: Number(dv.getBigUint64(offset += 8, true))
    };
    return header;
  }
  function getMultihashLength(bytes) {
    import_varint3.default.decode(bytes);
    const codeLength = (
      /** @type {number} */
      import_varint3.default.decode.bytes
    );
    const length4 = import_varint3.default.decode(bytes.subarray(import_varint3.default.decode.bytes));
    const lengthLength = (
      /** @type {number} */
      import_varint3.default.decode.bytes
    );
    const mhLength = codeLength + lengthLength + length4;
    return mhLength;
  }

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/header-validator.js
  init_dirname();
  init_buffer2();
  init_process2();
  var Kinds = {
    Null: (
      /** @returns {undefined|null} */
      (obj) => obj === null ? obj : void 0
    ),
    Int: (
      /** @returns {undefined|number} */
      (obj) => Number.isInteger(obj) ? obj : void 0
    ),
    Float: (
      /** @returns {undefined|number} */
      (obj) => typeof obj === "number" && Number.isFinite(obj) ? obj : void 0
    ),
    String: (
      /** @returns {undefined|string} */
      (obj) => typeof obj === "string" ? obj : void 0
    ),
    Bool: (
      /** @returns {undefined|boolean} */
      (obj) => typeof obj === "boolean" ? obj : void 0
    ),
    Bytes: (
      /** @returns {undefined|Uint8Array} */
      (obj) => obj instanceof Uint8Array ? obj : void 0
    ),
    Link: (
      /** @returns {undefined|object} */
      (obj) => obj !== null && typeof obj === "object" && obj.asCID === obj ? obj : void 0
    ),
    List: (
      /** @returns {undefined|Array<any>} */
      (obj) => Array.isArray(obj) ? obj : void 0
    ),
    Map: (
      /** @returns {undefined|object} */
      (obj) => obj !== null && typeof obj === "object" && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : void 0
    )
  };
  var Types = {
    "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
    "CarV1HeaderOrV2Pragma > roots (anon)": (
      /** @returns {undefined|any} */
      (obj) => {
        if (Kinds.List(obj) === void 0) {
          return void 0;
        }
        for (let i7 = 0; i7 < obj.length; i7++) {
          let v6 = obj[i7];
          v6 = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v6);
          if (v6 === void 0) {
            return void 0;
          }
          if (v6 !== obj[i7]) {
            const ret = obj.slice(0, i7);
            for (let j4 = i7; j4 < obj.length; j4++) {
              let v7 = obj[j4];
              v7 = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v7);
              if (v7 === void 0) {
                return void 0;
              }
              ret.push(v7);
            }
            return ret;
          }
        }
        return obj;
      }
    ),
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: (
      /** @returns {undefined|any} */
      (obj) => {
        if (Kinds.Map(obj) === void 0) {
          return void 0;
        }
        const entries3 = Object.entries(obj);
        let ret = obj;
        let requiredCount = 1;
        for (let i7 = 0; i7 < entries3.length; i7++) {
          const [key, value] = entries3[i7];
          switch (key) {
            case "roots":
              {
                const v6 = Types["CarV1HeaderOrV2Pragma > roots (anon)"](obj[key]);
                if (v6 === void 0) {
                  return void 0;
                }
                if (v6 !== value || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j4 = 0; j4 < i7; j4++) {
                      ret[entries3[j4][0]] = entries3[j4][1];
                    }
                  }
                  ret.roots = v6;
                }
              }
              break;
            case "version":
              {
                requiredCount--;
                const v6 = Types.Int(obj[key]);
                if (v6 === void 0) {
                  return void 0;
                }
                if (v6 !== value || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j4 = 0; j4 < i7; j4++) {
                      ret[entries3[j4][0]] = entries3[j4][1];
                    }
                  }
                  ret.version = v6;
                }
              }
              break;
            default:
              return void 0;
          }
        }
        if (requiredCount > 0) {
          return void 0;
        }
        return ret;
      }
    )
  };
  var Reprs = {
    "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
    "CarV1HeaderOrV2Pragma > roots (anon)": (
      /** @returns {undefined|any} */
      (obj) => {
        if (Kinds.List(obj) === void 0) {
          return void 0;
        }
        for (let i7 = 0; i7 < obj.length; i7++) {
          let v6 = obj[i7];
          v6 = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v6);
          if (v6 === void 0) {
            return void 0;
          }
          if (v6 !== obj[i7]) {
            const ret = obj.slice(0, i7);
            for (let j4 = i7; j4 < obj.length; j4++) {
              let v7 = obj[j4];
              v7 = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v7);
              if (v7 === void 0) {
                return void 0;
              }
              ret.push(v7);
            }
            return ret;
          }
        }
        return obj;
      }
    ),
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: (
      /** @returns {undefined|any} */
      (obj) => {
        if (Kinds.Map(obj) === void 0) {
          return void 0;
        }
        const entries3 = Object.entries(obj);
        let ret = obj;
        let requiredCount = 1;
        for (let i7 = 0; i7 < entries3.length; i7++) {
          const [key, value] = entries3[i7];
          switch (key) {
            case "roots":
              {
                const v6 = Reprs["CarV1HeaderOrV2Pragma > roots (anon)"](value);
                if (v6 === void 0) {
                  return void 0;
                }
                if (v6 !== value || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j4 = 0; j4 < i7; j4++) {
                      ret[entries3[j4][0]] = entries3[j4][1];
                    }
                  }
                  ret.roots = v6;
                }
              }
              break;
            case "version":
              {
                requiredCount--;
                const v6 = Reprs.Int(value);
                if (v6 === void 0) {
                  return void 0;
                }
                if (v6 !== value || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j4 = 0; j4 < i7; j4++) {
                      ret[entries3[j4][0]] = entries3[j4][1];
                    }
                  }
                  ret.version = v6;
                }
              }
              break;
            default:
              return void 0;
          }
        }
        if (requiredCount > 0) {
          return void 0;
        }
        return ret;
      }
    )
  };
  var CarV1HeaderOrV2Pragma = {
    toTyped: Types.CarV1HeaderOrV2Pragma,
    toRepresentation: Reprs.CarV1HeaderOrV2Pragma
  };

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-writer.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/length.js
  init_dirname();
  init_buffer2();
  init_process2();
  var cborEncoders3 = makeCborEncoders2();
  var defaultEncodeOptions4 = {
    float64: false,
    quickEncodeToken: quickEncodeToken2
  };
  function tokensToLength(tokens, encoders = cborEncoders3, options = defaultEncodeOptions4) {
    if (Array.isArray(tokens)) {
      let len = 0;
      for (const token of tokens) {
        len += tokensToLength(token, encoders, options);
      }
      return len;
    } else {
      const encoder2 = encoders[tokens.type.major];
      if (encoder2.encodedSize === void 0 || typeof encoder2.encodedSize !== "function") {
        throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`);
      }
      return encoder2.encodedSize(tokens, options);
    }
  }

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-writer.js
  var import_varint4 = __toESM(require_varint(), 1);
  var CarBufferWriter = class {
    /**
     * @param {Uint8Array} bytes
     * @param {number} headerSize
     */
    constructor(bytes, headerSize) {
      this.bytes = bytes;
      this.byteOffset = headerSize;
      this.roots = [];
      this.headerSize = headerSize;
    }
    /**
     * Add a root to this writer, to be used to create a header when the CAR is
     * finalized with {@link CarBufferWriter.close `close()`}
     *
     * @param {CID} root
     * @param {{resize?:boolean}} [options]
     * @returns {CarBufferWriter}
     */
    addRoot(root2, options) {
      addRoot(this, root2, options);
      return this;
    }
    /**
     * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
     * Throws if there is not enough capacity.
     *
     * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
     * @returns {CarBufferWriter}
     */
    write(block) {
      addBlock(this, block);
      return this;
    }
    /**
     * Finalize the CAR and return it as a `Uint8Array`.
     *
     * @param {object} [options]
     * @param {boolean} [options.resize]
     * @returns {Uint8Array}
     */
    close(options) {
      return close9(this, options);
    }
  };
  var addRoot = (writer, root2, options = {}) => {
    const { resize = false } = options;
    const { bytes, headerSize, byteOffset, roots } = writer;
    writer.roots.push(root2);
    const size = headerLength(writer);
    if (size > headerSize) {
      if (size - headerSize + byteOffset < bytes.byteLength) {
        if (resize) {
          resizeHeader(writer, size);
        } else {
          roots.pop();
          throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root2}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
        }
      } else {
        roots.pop();
        throw new RangeError(`Buffer has no capacity for a new root ${root2}`);
      }
    }
  };
  var blockLength = ({ cid, bytes }) => {
    const size = cid.bytes.byteLength + bytes.byteLength;
    return import_varint4.default.encodingLength(size) + size;
  };
  var addBlock = (writer, { cid, bytes }) => {
    const byteLength = cid.bytes.byteLength + bytes.byteLength;
    const size = import_varint4.default.encode(byteLength);
    if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {
      throw new RangeError("Buffer has no capacity for this block");
    } else {
      writeBytes2(writer, size);
      writeBytes2(writer, cid.bytes);
      writeBytes2(writer, bytes);
    }
  };
  var close9 = (writer, options = {}) => {
    const { resize = false } = options;
    const { roots, bytes, byteOffset, headerSize } = writer;
    const headerBytes = encode6({ version: 1, roots });
    const varintBytes = import_varint4.default.encode(headerBytes.length);
    const size = varintBytes.length + headerBytes.byteLength;
    const offset = headerSize - size;
    if (offset === 0) {
      writeHeader(writer, varintBytes, headerBytes);
      return bytes.subarray(0, byteOffset);
    } else if (resize) {
      resizeHeader(writer, size);
      writeHeader(writer, varintBytes, headerBytes);
      return bytes.subarray(0, writer.byteOffset);
    } else {
      throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
    }
  };
  var resizeHeader = (writer, byteLength) => {
    const { bytes, headerSize } = writer;
    bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength);
    writer.byteOffset += byteLength - headerSize;
    writer.headerSize = byteLength;
  };
  var writeBytes2 = (writer, bytes) => {
    writer.bytes.set(bytes, writer.byteOffset);
    writer.byteOffset += bytes.length;
  };
  var writeHeader = ({ bytes }, varint6, header) => {
    bytes.set(varint6);
    bytes.set(header, varint6.length);
  };
  var headerPreludeTokens = [
    new Token2(Type2.map, 2),
    new Token2(Type2.string, "version"),
    new Token2(Type2.uint, 1),
    new Token2(Type2.string, "roots")
  ];
  var CID_TAG = new Token2(Type2.tag, 42);
  var calculateHeaderLength = (rootLengths) => {
    const tokens = [...headerPreludeTokens];
    tokens.push(new Token2(Type2.array, rootLengths.length));
    for (const rootLength of rootLengths) {
      tokens.push(CID_TAG);
      tokens.push(new Token2(Type2.bytes, { length: rootLength + 1 }));
    }
    const length4 = tokensToLength(tokens);
    return import_varint4.default.encodingLength(length4) + length4;
  };
  var headerLength = ({ roots }) => calculateHeaderLength(roots.map((cid) => cid.bytes.byteLength));
  var createWriter3 = (buffer4, options = {}) => {
    const {
      roots = [],
      byteOffset = 0,
      byteLength = buffer4.byteLength,
      headerSize = headerLength({ roots })
    } = options;
    const bytes = new Uint8Array(buffer4, byteOffset, byteLength);
    const writer = new CarBufferWriter(bytes, headerSize);
    for (const root2 of roots) {
      writer.addRoot(root2);
    }
    return writer;
  };

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/indexed-reader.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.23.1/node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/indexed-reader.js
  init_stream();

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/indexer.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/decoder.js
  init_dirname();
  init_buffer2();
  init_process2();
  async function readHeader(reader, strictVersion) {
    const length4 = decodeVarint2(await reader.upTo(8), reader);
    if (length4 === 0) {
      throw new Error("Invalid CAR header (zero length)");
    }
    const header = await reader.exactly(length4, true);
    const block = decode10(header);
    if (CarV1HeaderOrV2Pragma.toTyped(block) === void 0) {
      throw new Error("Invalid CAR header format");
    }
    if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
      throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
    }
    if (block.version === 1) {
      if (!Array.isArray(block.roots)) {
        throw new Error("Invalid CAR header format");
      }
      return block;
    }
    if (block.roots !== void 0) {
      throw new Error("Invalid CAR header format");
    }
    const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true));
    reader.seek(v2Header.dataOffset - reader.pos);
    const v1Header = await readHeader(reader, 1);
    return Object.assign(v1Header, v2Header);
  }
  async function readCid(reader) {
    const first = await reader.exactly(2, false);
    if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
      const bytes2 = await reader.exactly(34, true);
      const multihash2 = decode4(bytes2);
      return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
    }
    const version2 = decodeVarint2(await reader.upTo(8), reader);
    if (version2 !== 1) {
      throw new Error(`Unexpected CID version (${version2})`);
    }
    const codec = decodeVarint2(await reader.upTo(8), reader);
    const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true);
    const multihash = decode4(bytes);
    return CID.create(version2, codec, multihash);
  }
  async function readBlockHead(reader) {
    const start = reader.pos;
    let length4 = decodeVarint2(await reader.upTo(8), reader);
    if (length4 === 0) {
      throw new Error("Invalid CAR section (zero length)");
    }
    length4 += reader.pos - start;
    const cid = await readCid(reader);
    const blockLength2 = length4 - Number(reader.pos - start);
    return { cid, length: length4, blockLength: blockLength2 };
  }
  async function readBlock(reader) {
    const { cid, blockLength: blockLength2 } = await readBlockHead(reader);
    const bytes = await reader.exactly(blockLength2, true);
    return { bytes, cid };
  }
  async function readBlockIndex(reader) {
    const offset = reader.pos;
    const { cid, length: length4, blockLength: blockLength2 } = await readBlockHead(reader);
    const index2 = { cid, length: length4, blockLength: blockLength2, offset, blockOffset: reader.pos };
    reader.seek(index2.blockLength);
    return index2;
  }
  function createDecoder(reader) {
    const headerPromise = (async () => {
      const header = await readHeader(reader);
      if (header.version === 2) {
        const v1length = reader.pos - header.dataOffset;
        reader = limitReader(reader, header.dataSize - v1length);
      }
      return header;
    })();
    return {
      header: () => headerPromise,
      async *blocks() {
        await headerPromise;
        while ((await reader.upTo(8)).length > 0) {
          yield await readBlock(reader);
        }
      },
      async *blocksIndex() {
        await headerPromise;
        while ((await reader.upTo(8)).length > 0) {
          yield await readBlockIndex(reader);
        }
      }
    };
  }
  function bytesReader(bytes) {
    let pos = 0;
    return {
      async upTo(length4) {
        const out = bytes.subarray(pos, pos + Math.min(length4, bytes.length - pos));
        return out;
      },
      async exactly(length4, seek = false) {
        if (length4 > bytes.length - pos) {
          throw new Error("Unexpected end of data");
        }
        const out = bytes.subarray(pos, pos + length4);
        if (seek) {
          pos += length4;
        }
        return out;
      },
      seek(length4) {
        pos += length4;
      },
      get pos() {
        return pos;
      }
    };
  }
  function chunkReader(readChunk) {
    let pos = 0;
    let have = 0;
    let offset = 0;
    let currentChunk = new Uint8Array(0);
    const read6 = async (length4) => {
      have = currentChunk.length - offset;
      const bufa = [currentChunk.subarray(offset)];
      while (have < length4) {
        const chunk = await readChunk();
        if (chunk == null) {
          break;
        }
        if (have < 0) {
          if (chunk.length > have) {
            bufa.push(chunk.subarray(-have));
          }
        } else {
          bufa.push(chunk);
        }
        have += chunk.length;
      }
      currentChunk = new Uint8Array(bufa.reduce((p7, c7) => p7 + c7.length, 0));
      let off2 = 0;
      for (const b5 of bufa) {
        currentChunk.set(b5, off2);
        off2 += b5.length;
      }
      offset = 0;
    };
    return {
      async upTo(length4) {
        if (currentChunk.length - offset < length4) {
          await read6(length4);
        }
        return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length4));
      },
      async exactly(length4, seek = false) {
        if (currentChunk.length - offset < length4) {
          await read6(length4);
        }
        if (currentChunk.length - offset < length4) {
          throw new Error("Unexpected end of data");
        }
        const out = currentChunk.subarray(offset, offset + length4);
        if (seek) {
          pos += length4;
          offset += length4;
        }
        return out;
      },
      seek(length4) {
        pos += length4;
        offset += length4;
      },
      get pos() {
        return pos;
      }
    };
  }
  function asyncIterableReader(asyncIterable) {
    const iterator = asyncIterable[Symbol.asyncIterator]();
    async function readChunk() {
      const next = await iterator.next();
      if (next.done) {
        return null;
      }
      return next.value;
    }
    return chunkReader(readChunk);
  }
  function limitReader(reader, byteLimit) {
    let bytesRead = 0;
    return {
      async upTo(length4) {
        let bytes = await reader.upTo(length4);
        if (bytes.length + bytesRead > byteLimit) {
          bytes = bytes.subarray(0, byteLimit - bytesRead);
        }
        return bytes;
      },
      async exactly(length4, seek = false) {
        const bytes = await reader.exactly(length4, seek);
        if (bytes.length + bytesRead > byteLimit) {
          throw new Error("Unexpected end of data");
        }
        if (seek) {
          bytesRead += length4;
        }
        return bytes;
      },
      seek(length4) {
        bytesRead += length4;
        reader.seek(length4);
      },
      get pos() {
        return reader.pos;
      }
    };
  }

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/reader-browser.js
  init_dirname();
  init_buffer2();
  init_process2();
  var CarReader = class {
    /**
     * @constructs CarReader
     * @param {CarHeader|CarV2Header} header
     * @param {Block[]} blocks
     */
    constructor(header, blocks) {
      this._header = header;
      this._blocks = blocks;
      this._keys = blocks.map((b5) => b5.cid.toString());
    }
    /**
     * @property
     * @memberof CarReader
     * @instance
     */
    get version() {
      return this._header.version;
    }
    /**
     * Get the list of roots defined by the CAR referenced by this reader. May be
     * zero or more `CID`s.
     *
     * @function
     * @memberof CarReader
     * @instance
     * @async
     * @returns {Promise<CID[]>}
     */
    async getRoots() {
      return this._header.roots;
    }
    /**
     * Check whether a given `CID` exists within the CAR referenced by this
     * reader.
     *
     * @function
     * @memberof CarReader
     * @instance
     * @async
     * @param {CID} key
     * @returns {Promise<boolean>}
     */
    async has(key) {
      return this._keys.indexOf(key.toString()) > -1;
    }
    /**
     * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
     * referenced by this reader matching the provided `CID`. In the case where
     * the provided `CID` doesn't exist within the CAR, `undefined` will be
     * returned.
     *
     * @function
     * @memberof CarReader
     * @instance
     * @async
     * @param {CID} key
     * @returns {Promise<Block | undefined>}
     */
    async get(key) {
      const index2 = this._keys.indexOf(key.toString());
      return index2 > -1 ? this._blocks[index2] : void 0;
    }
    /**
     * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all
     * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
     * the CAR referenced by this reader.
     *
     * @function
     * @memberof CarReader
     * @instance
     * @async
     * @generator
     * @returns {AsyncGenerator<Block>}
     */
    async *blocks() {
      for (const block of this._blocks) {
        yield block;
      }
    }
    /**
     * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of
     * the `CID`s contained within the CAR referenced by this reader.
     *
     * @function
     * @memberof CarReader
     * @instance
     * @async
     * @generator
     * @returns {AsyncGenerator<CID>}
     */
    async *cids() {
      for (const block of this._blocks) {
        yield block.cid;
      }
    }
    /**
     * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a
     * decode fully in memory and maintains the decoded state in memory for full
     * access to the data via the `CarReader` API.
     *
     * @async
     * @static
     * @memberof CarReader
     * @param {Uint8Array} bytes
     * @returns {Promise<CarReader>}
     */
    static async fromBytes(bytes) {
      if (!(bytes instanceof Uint8Array)) {
        throw new TypeError("fromBytes() requires a Uint8Array");
      }
      return decodeReaderComplete(bytesReader(bytes));
    }
    /**
     * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as
     * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
     * This performs a decode fully in memory and maintains the decoded state in
     * memory for full access to the data via the `CarReader` API.
     *
     * Care should be taken for large archives; this API may not be appropriate
     * where memory is a concern or the archive is potentially larger than the
     * amount of memory that the runtime can handle.
     *
     * @async
     * @static
     * @memberof CarReader
     * @param {AsyncIterable<Uint8Array>} asyncIterable
     * @returns {Promise<CarReader>}
     */
    static async fromIterable(asyncIterable) {
      if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
        throw new TypeError("fromIterable() requires an async iterable");
      }
      return decodeReaderComplete(asyncIterableReader(asyncIterable));
    }
  };
  async function decodeReaderComplete(reader) {
    const decoder2 = createDecoder(reader);
    const header = await decoder2.header();
    const blocks = [];
    for await (const block of decoder2.blocks()) {
      blocks.push(block);
    }
    return new CarReader(header, blocks);
  }

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/iterator.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/writer-browser.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/encoder.js
  init_dirname();
  init_buffer2();
  init_process2();
  var import_varint5 = __toESM(require_varint(), 1);

  // node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/iterator-channel.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/index.js
  init_cement();
  init_cement();
  init_cement();
  init_cement();
  init_base58();
  init_base58();
  init_cement();
  init_base58();
  init_cement();
  init_cement();
  var import_charwise = __toESM(require_charwise(), 1);

  // node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/db-index.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/map.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/base.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/utils.js
  init_dirname();
  init_buffer2();
  init_process2();
  var readUInt32LE = (buffer4) => {
    const offset = buffer4.byteLength - 4;
    return (buffer4[offset] | buffer4[offset + 1] << 8 | buffer4[offset + 2] << 16) + buffer4[offset + 3] * 16777216;
  };
  var MAX_UINT32 = 4294967295;
  var bf = (factor) => {
    const threshold = Math.floor(MAX_UINT32 / factor);
    return async (entry) => {
      const identity4 = await entry.identity();
      if (typeof identity4 !== "number") {
        throw new Error("Identity must be a number");
      }
      if (identity4 <= threshold) {
        return true;
      }
      return false;
    };
  };
  var simpleCompare = (a7, b5) => {
    if (a7 === b5)
      return 0;
    if (a7 > b5)
      return 1;
    return -1;
  };
  var CIDCounter = class {
    constructor() {
      this._cids = /* @__PURE__ */ new Set();
    }
    add(node) {
      if (!node.address) {
        throw new Error("Cannot add node without address");
      }
      if (node.address.then) {
        const p7 = node.address.then((cid) => this._cids.add(cid.toString()));
        this._cids.add(p7);
        p7.then(() => this._cids.delete(p7));
      } else {
        this._cids.add(node.address.toString());
      }
    }
    async all() {
      await Promise.all([...this._cids]);
      return this._cids;
    }
  };

  // node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/base.js
  var Entry = class {
    constructor({ key, address }, opts = {}) {
      this.key = key;
      this.address = address;
      this.codec = opts.codec;
      this.hasher = opts.hasher;
    }
    get isEntry() {
      return true;
    }
  };
  var EntryList = class {
    constructor({ entries: entries3, closed }) {
      if (typeof closed !== "boolean")
        throw new Error('Missing required argument "closed"');
      this.entries = entries3;
      this.closed = closed;
      this.startKey = entries3[0].key;
    }
    find(key, compare5) {
      const { entries: entries3 } = this;
      for (let i7 = entries3.length - 1; i7 > -1; i7--) {
        const entry = entries3[i7];
        const comp = compare5(key, entry.key);
        if (comp > -1) {
          return [
            i7,
            entry
          ];
        }
      }
      return null;
    }
    findMany(keys, compare5, sorted = false, strict2 = false) {
      const { entries: entries3 } = this;
      const results = /* @__PURE__ */ new Map();
      if (!sorted) {
        keys = keys.sort(compare5);
      } else {
        keys = [...keys];
      }
      for (let i7 = entries3.length - 1; i7 > -1; i7--) {
        if (!keys.length)
          break;
        const entry = entries3[i7];
        const found = [];
        while (keys.length) {
          let key = keys[keys.length - 1];
          key = key.key ? key.key : key;
          const comp = compare5(key, entry.key);
          if (!strict2) {
            if (comp > -1) {
              found.push(keys.pop());
            } else {
              break;
            }
          } else {
            if (comp === 0) {
              found.push(keys.pop());
            } else if (comp > 0) {
              keys.pop();
            } else {
              break;
            }
          }
        }
        if (found.length) {
          results.set(i7, [
            entry,
            found
          ]);
        }
      }
      return results;
    }
    findRange(start, end, compare5) {
      const { entries: entries3 } = this;
      let last2;
      let first = 0;
      for (let i7 = entries3.length - 1; i7 > -1; i7--) {
        const entry = entries3[i7];
        const comp = compare5(end, entry.key);
        if (comp > 0) {
          last2 = i7;
          break;
        }
      }
      for (let i7 = 0; i7 < entries3.length; i7++) {
        const entry = entries3[i7];
        const comp = compare5(start, entry.key);
        if (comp === 0) {
          first = i7;
          break;
        } else if (comp < 0) {
          break;
        }
        first = i7;
      }
      return {
        first,
        last: last2,
        entries: entries3.slice(first, last2 + 1)
      };
    }
  };
  var stringKey = (key) => typeof key === "string" ? key : JSON.stringify(key);
  function sortBulk(bulk, opts) {
    return bulk.sort(({ key: a7 }, { key: b5 }) => opts.compare(a7, b5));
  }
  async function filterLeftmostInserts(first, bulk, compare5) {
    const inserts = [];
    for (const b5 of bulk) {
      const { key, del: del2 } = b5;
      if (compare5(key, first) < 0) {
        if (!del2)
          inserts.push(b5);
      } else {
        break;
      }
    }
    return inserts;
  }
  async function generateNewLeaves(inserts, opts, { chunker, compare: compare5 }) {
    return await Node3.from({
      entries: inserts.map((insert) => new opts.LeafEntryClass(insert, opts)).sort((a7, b5) => compare5(a7.key, b5.key)),
      chunker,
      NodeClass: opts.LeafClass,
      distance: 0,
      opts
    });
  }
  async function generateBranchEntries(that, newLeaves, results, opts) {
    return await Promise.all(newLeaves.map(async (node) => {
      const block = await node.encode();
      results.blocks.push({
        block,
        node
      });
      that.cache.set(node);
      const newBranchEntry = new opts.BranchEntryClass({
        key: node.key,
        address: await node.address
      }, opts);
      return newBranchEntry;
    }));
  }
  async function processRoot(that, results, bulk, nodeOptions) {
    const root2 = results.root;
    results.blocks.push({
      block: await root2.encode(),
      node: root2
    });
    that.cache.set(root2);
    const opts = nodeOptions.opts;
    const distance = root2.distance;
    const first = root2.entryList.startKey;
    const inserts = await filterLeftmostInserts(first, bulk, that.compare);
    if (inserts.length) {
      const newLeaves = await generateNewLeaves(inserts, opts, that);
      const branchEntries = await generateBranchEntries(that, newLeaves, results, opts);
      const firstRootEntry = new opts.BranchEntryClass({
        key: root2.entryList.startKey,
        address: await root2.address
      }, opts);
      const newBranchEntries = [
        firstRootEntry,
        ...branchEntries
      ].sort(({ key: a7 }, { key: b5 }) => opts.compare(a7, b5));
      let newBranches = await Node3.from({
        ...nodeOptions,
        entries: newBranchEntries,
        chunker: that.chunker,
        NodeClass: opts.BranchClass,
        distance: distance + 1
      });
      let allBranches = [...newBranches];
      while (newBranches.length > 1) {
        const newBranchEntries2 = await Promise.all(newBranches.map(async (l7) => new opts.BranchEntryClass({
          key: l7.key,
          address: await l7.address
        }, opts)));
        newBranches = await Node3.from({
          ...nodeOptions,
          entries: newBranchEntries2.sort(({ key: a7 }, { key: b5 }) => opts.compare(a7, b5)),
          chunker: that.chunker,
          NodeClass: opts.BranchClass,
          distance: distance + 1
        });
        allBranches = [
          ...allBranches,
          ...newBranches
        ];
      }
      await Promise.all(allBranches.map(async (m6) => {
        const block = await m6.encode();
        that.cache.set(m6);
        results.blocks.push({
          block,
          node: m6
        });
      }));
      results.root = newBranches[0];
      results.nodes = [
        ...results.nodes,
        ...allBranches
      ];
    }
  }
  var Node3 = class _Node {
    constructor({ entryList, chunker, distance, getNode, compare: compare5, cache: cache3 }) {
      this.entryList = entryList;
      this.chunker = chunker;
      this.distance = distance;
      this.getNode = getNode;
      this.compare = compare5;
      this.cache = cache3;
    }
    get closed() {
      return this.entryList.closed;
    }
    get key() {
      return this.entryList.startKey;
    }
    async getEntry(key, cids = new CIDCounter()) {
      const result = await this._getEntry(key, cids);
      return {
        result,
        cids
      };
    }
    async _getEntry(key, cids) {
      cids.add(this);
      let node = this;
      while (!node.isLeaf) {
        const result2 = node.entryList.find(key, this.compare);
        if (result2 === null)
          throw new Error("Not found");
        const [, entry2] = result2;
        node = await this.getNode(await entry2.address);
        cids.add(node);
      }
      const result = node.entryList.find(key, this.compare);
      if (result === null || result[1].key.toString() !== key.toString())
        throw new Error("Not found");
      const [, entry] = result;
      return entry;
    }
    async getAllEntries(cids = new CIDCounter()) {
      const result = await this._getAllEntries(cids);
      return {
        result,
        cids
      };
    }
    _getAllEntries(cids) {
      cids.add(this);
      if (this.isLeaf) {
        return this.entryList.entries;
      } else {
        const { entries: entries3 } = this.entryList;
        const mapper = async (entry) => this.getNode(await entry.address).then((node) => node._getAllEntries(cids)).catch(async (err) => {
          throw err;
        });
        return Promise.all(entries3.map(mapper)).then((results) => results.flat());
      }
    }
    async *vis(cids = /* @__PURE__ */ new Set()) {
      const renderNodeLabel = async (node) => {
        if (node.isLeaf) {
          const entries3 = node.entryList.entries.map((e9) => `[${e9.key},${JSON.stringify(e9.value).replace(/"/g, "'")}]`).join(", ");
          return `Leaf [${entries3}]`;
        } else {
          const entries3 = node.entryList.entries.map((e9) => `[${e9.key}]`).join(", ");
          return `Branch [${entries3}]`;
        }
      };
      const shortCid = (cid) => cid.toString().slice(0, 4) + cid.toString().slice(-4);
      const visit3 = async function* (node, parentId, cids2) {
        const nodeId = await node.address;
        if (!cids2.has(nodeId)) {
          cids2.add(nodeId);
          const nodeLabel = await renderNodeLabel(node);
          yield `  node [shape=ellipse fontname="Courier"]; ${shortCid(nodeId)} [label="${nodeLabel}"];`;
          yield `  ${shortCid(parentId)} -> ${shortCid(nodeId)};`;
          for (const entry of node.entryList.entries) {
            if (entry.address) {
              const entryId = await entry.address;
              try {
                const childNode = await node.getNode(entryId);
                yield* await visit3(childNode, nodeId, cids2);
              } catch (err) {
                yield `  ${shortCid(nodeId)} -> ${shortCid(entryId)};`;
                yield `  node [shape=ellipse fontname="Courier"]; ${shortCid(entryId)} [label="Error: ${err.message}"];`;
              }
            }
          }
        }
      };
      yield "digraph tree {";
      yield '  node [shape=ellipse fontname="Courier"]; rootnode;';
      for await (const line of visit3(this, "rootnode", cids)) {
        yield line;
      }
      yield "}";
    }
    async getEntries(keys, sorted = false, cids = new CIDCounter()) {
      const result = await this._getEntries(keys, sorted, cids);
      return {
        result,
        cids
      };
    }
    async _getEntries(keys, sorted, cids) {
      cids.add(this);
      if (!sorted)
        keys = keys.sort(this.compare);
      const results = this.entryList.findMany(keys, this.compare, true, this.isLeaf);
      if (this.isLeaf) {
        return [...results.values()].map(([entry]) => entry);
      }
      let entries3 = [];
      for (const [entry, keys2] of [...results.values()].reverse()) {
        const p7 = this.getNode(await entry.address);
        entries3.push(p7.then((node) => node._getEntries(keys2.reverse(), true, cids)));
      }
      entries3 = await Promise.all(entries3);
      return entries3.flat();
    }
    async getRangeEntries(start, end, cids = new CIDCounter()) {
      const result = await this._getRangeEntries(start, end, cids);
      return {
        result,
        cids
      };
    }
    _getRangeEntries(start, end, cids) {
      cids.add(this);
      const { entries: entries3 } = this.entryList.findRange(start, end, this.compare);
      if (this.isLeaf) {
        return entries3.filter((entry) => {
          const s6 = this.compare(start, entry.key);
          const e9 = this.compare(end, entry.key);
          if (s6 <= 0 && e9 >= 0)
            return true;
          return false;
        });
      }
      if (!entries3.length)
        return [];
      const thenRange = async (entry) => this.getNode(await entry.address).then((node) => node._getRangeEntries(start, end, cids));
      const results = [thenRange(entries3.shift())];
      if (!entries3.length)
        return results[0];
      const last2 = thenRange(entries3.pop());
      while (entries3.length) {
        const thenAll = async (entry) => this.getNode(await entry.address).then(async (node) => node._getAllEntries(cids));
        results.push(thenAll(entries3.shift()));
      }
      results.push(last2);
      return Promise.all(results).then((results2) => results2.flat());
    }
    async transaction(bulk, opts = {}) {
      opts = {
        codec: this.codec,
        hasher: this.hasher,
        getNode: this.getNode,
        compare: this.compare,
        cache: this.cache,
        ...opts
      };
      const nodeOptions = {
        chunker: this.chunker,
        opts
      };
      const results = this.entryList.findMany(bulk, opts.compare, true, this.isLeaf);
      if (this.isLeaf) {
        return await this.transactionLeaf(bulk, opts, nodeOptions, results);
      } else {
        return await this.transactionBranch(bulk, opts, nodeOptions, results);
      }
    }
    async transactionLeaf(bulk, opts, nodeOptions, results) {
      const { LeafClass: LeafClass2, LeafEntryClass } = opts;
      const { entries: entries3, previous } = this.processLeafEntries(bulk, results, LeafEntryClass, opts);
      const _opts = {
        ...nodeOptions,
        entries: entries3,
        NodeClass: LeafClass2,
        distance: 0
      };
      const nodes = await _Node.from(_opts);
      return {
        nodes,
        previous,
        blocks: await Promise.all(nodes.map(async (n8) => {
          const block = await n8.encode();
          this.cache.set(n8);
          return {
            block,
            node: n8
          };
        })),
        distance: 0
      };
    }
    processLeafEntries(bulk, results, LeafEntryClass, opts) {
      const previous = [];
      let entries3 = [];
      const changes = {};
      const deletes = /* @__PURE__ */ new Map();
      for (const { key, del: del2, value } of bulk) {
        const skey = stringKey(key);
        if (del2) {
          if (typeof changes[skey] === "undefined")
            deletes.set(skey, null);
        } else {
          changes[skey] = {
            key,
            value
          };
          deletes.delete(skey);
        }
      }
      entries3 = [...this.entryList.entries];
      for (const [i7, [entry]] of results) {
        previous.push(entry);
        const skey = stringKey(entry.key);
        if (deletes.has(skey)) {
          deletes.set(skey, i7);
        } else {
          entries3[i7] = new LeafEntryClass(changes[skey], opts);
          delete changes[skey];
        }
      }
      let count = 0;
      for (const [, i7] of deletes) {
        if (i7 !== null)
          entries3.splice(i7 - count++, 1);
      }
      const appends = Object.values(changes).map((obj) => new LeafEntryClass(obj, opts));
      entries3 = entries3.concat(appends).sort(({ key: a7 }, { key: b5 }) => opts.compare(a7, b5));
      return {
        entries: entries3,
        previous
      };
    }
    async transactionBranch(bulk, opts, nodeOptions, results) {
      const { BranchClass: BranchClass2, BranchEntryClass } = opts;
      let distance = 0;
      for (const [i7, [entry, keys]] of results) {
        const p7 = this.getNode(await entry.address).then((node) => node.transaction(keys.reverse(), {
          ...opts,
          sorted: true
        })).then((r9) => ({
          entry,
          keys,
          distance,
          ...r9
        }));
        results.set(i7, p7);
      }
      let entries3 = [...this.entryList.entries];
      const final = {
        previous: [],
        blocks: [],
        nodes: []
      };
      for (const [i7, p7] of results) {
        const {
          nodes,
          previous,
          blocks,
          distance: _distance
        } = await p7;
        distance = _distance;
        entries3[i7] = nodes;
        if (previous.length)
          final.previous = final.previous.concat(previous);
        if (blocks.length)
          final.blocks = final.blocks.concat(blocks);
        if (nodes.length)
          final.nodes = final.nodes.concat(nodes);
      }
      entries3 = entries3.flat();
      const newEntries = await this.handlePrepend(entries3, opts, nodeOptions, final, distance);
      distance++;
      const toEntry = async (branch) => {
        if (branch.isEntry)
          return branch;
        const block = await branch.encode();
        final.blocks.push({
          block,
          node: branch
        });
        this.cache.set(branch);
        return new BranchEntryClass(branch, opts);
      };
      entries3 = await Promise.all(newEntries.map(toEntry));
      const _opts = {
        ...nodeOptions,
        entries: entries3,
        NodeClass: BranchClass2,
        distance
      };
      const newNodes = await _Node.from(_opts);
      await Promise.all(newNodes.map(async (n8) => {
        const block = await n8.encode();
        final.blocks.push({
          block,
          node: n8
        });
        this.cache.set(n8);
      }));
      final.nodes = newNodes;
      return {
        ...final,
        distance
      };
    }
    async handlePrepend(entries3, opts, nodeOptions, final, distance) {
      const { BranchClass: BranchClass2, LeafClass: LeafClass2 } = opts;
      let newEntries = [];
      let prepend = null;
      for (const entry of entries3) {
        if (prepend) {
          const mergeEntries = await this.mergeFirstLeftEntries(entry, prepend, nodeOptions, final, distance);
          prepend = null;
          const NodeClass = !mergeEntries[0].address ? LeafClass2 : BranchClass2;
          const _opts = {
            ...nodeOptions,
            entries: mergeEntries.sort(({ key: a7 }, { key: b5 }) => opts.compare(a7, b5)),
            NodeClass,
            distance
          };
          const nodes = await _Node.from(_opts);
          if (!nodes[nodes.length - 1].closed) {
            prepend = nodes.pop();
          }
          if (nodes.length) {
            newEntries = newEntries.concat(nodes);
          }
        } else {
          if (!entry.isEntry && !entry.closed) {
            prepend = entry;
          } else {
            newEntries.push(entry);
          }
        }
      }
      if (prepend) {
        newEntries.push(prepend);
      }
      return newEntries;
    }
    async getNodeFirstFromBlocks(blocks, addr) {
      for (const { block, node } of blocks) {
        if (await block.cid === addr)
          return node;
      }
      return await this.getNode(addr);
    }
    async mergeFirstLeftEntries(entry, prepend, nodeOptions, final, distance) {
      const opts = nodeOptions.opts;
      const { LeafClass: LeafClass2, BranchClass: BranchClass2, BranchEntryClass } = opts;
      if (entry.isEntry) {
        const addr = await entry.address;
        entry = await this.getNodeFirstFromBlocks(final.blocks, addr);
      }
      const es = entry.entryList.entries;
      if (!es.length)
        throw new Error("unreachable no entries");
      const basicMerge = (entries1, entries22) => {
        return entries1.concat(entries22);
      };
      const processNodesAndCreateEntries = async (nodes, final2, opts2) => {
        return await Promise.all(nodes.map(async (l7) => {
          final2.blocks.push({
            block: await l7.encode(),
            node: l7
          });
          this.cache.set(l7);
          return new BranchEntryClass({
            key: l7.key,
            address: await l7.address
          }, opts2);
        }));
      };
      if (es[0].constructor.name === prepend.entryList.entries[0].constructor.name) {
        return await basicMerge(prepend.entryList.entries, es);
      } else {
        const leftEntry = es.shift();
        if (!leftEntry)
          throw new Error("unreachable no left entry");
        if (!leftEntry.address)
          throw new Error("unreachable existing leaf, no leftEntry.address");
        const mergeLeftEntries = await this.mergeFirstLeftEntries(leftEntry, prepend, nodeOptions, final, distance - 1);
        const esf = es.shift();
        if (!esf) {
          return mergeLeftEntries;
        }
        if (!esf.address)
          throw new Error("unreachable existing leaf, no esf.address");
        const oldFront = await this.getNodeFirstFromBlocks(final.blocks, await esf.address);
        if (!oldFront.entryList.entries[0].address) {
          const leftLeafEntries = await basicMerge(mergeLeftEntries, oldFront.entryList.entries);
          const leftLeafNodes = await _Node.from({
            ...nodeOptions,
            entries: leftLeafEntries.sort(({ key: a7 }, { key: b5 }) => opts.compare(a7, b5)),
            NodeClass: LeafClass2,
            distance
          });
          const leftBranches = await processNodesAndCreateEntries(leftLeafNodes, final, opts);
          return await basicMerge(leftBranches, es);
        } else {
          if (mergeLeftEntries[0].address) {
            return mergeLeftEntries.concat(oldFront.entryList.entries);
          } else {
            const mergeLeftNodes = await _Node.from({
              ...nodeOptions,
              entries: mergeLeftEntries.sort(({ key: a7 }, { key: b5 }) => opts.compare(a7, b5)),
              NodeClass: LeafClass2,
              distance
            });
            const mergeLeftBranchEntries = await processNodesAndCreateEntries(mergeLeftNodes, final, opts);
            const newFirstNodes = await _Node.from({
              ...nodeOptions,
              entries: [
                ...oldFront.entryList.entries,
                ...mergeLeftBranchEntries,
                ...es
              ].sort(({ key: a7 }, { key: b5 }) => opts.compare(a7, b5)),
              NodeClass: BranchClass2,
              distance
            });
            const newBranchEntries = await processNodesAndCreateEntries(newFirstNodes, final, opts);
            return newBranchEntries;
          }
        }
      }
    }
    async bulk(bulk, opts = {}, isRoot = true) {
      const { BranchClass: BranchClass2 } = opts;
      opts = {
        codec: this.codec,
        hasher: this.hasher,
        getNode: this.getNode,
        compare: this.compare,
        cache: this.cache,
        ...opts
      };
      if (!opts.sorted) {
        bulk = sortBulk(bulk, opts);
        opts.sorted = true;
      }
      const nodeOptions = {
        chunker: this.chunker,
        opts
      };
      const results = await this.transaction(bulk, opts);
      while (results.nodes.length > 1) {
        const newDistance = results.nodes[0].distance + 1;
        const branchEntries = await Promise.all(results.nodes.map(async (node) => {
          const block = await node.encode();
          results.blocks.push({
            block,
            node
          });
          this.cache.set(node);
          return new opts.BranchEntryClass(node, opts);
        }));
        const newNodes = await _Node.from({
          ...nodeOptions,
          entries: branchEntries,
          NodeClass: BranchClass2,
          distance: newDistance
        });
        await Promise.all(newNodes.map(async (node) => {
          const block = await node.encode();
          this.cache.set(node);
          results.blocks.push({
            block,
            node
          });
        }));
        results.nodes = newNodes;
      }
      results.root = results.nodes[0];
      if (isRoot && results.root) {
        await processRoot(this, results, bulk, nodeOptions);
      }
      results.blocks = results.blocks.map(({ block }) => block);
      return results;
    }
    static async from({ entries: entries3, chunker, NodeClass, distance, opts }) {
      if (!entries3.every((entry) => entry.constructor.name === entries3[0].constructor.name))
        throw new Error("all entries must be of the same type");
      const parts = [];
      let chunk = [];
      for (const entry of entries3) {
        chunk.push(entry);
        if (await chunker(entry, distance)) {
          parts.push(new EntryList({
            entries: chunk,
            closed: true
          }));
          chunk = [];
        }
      }
      if (chunk.length) {
        parts.push(new EntryList({
          entries: chunk,
          closed: false
        }));
      }
      return parts.map((entryList) => new NodeClass({
        entryList,
        chunker,
        distance,
        ...opts
      }));
    }
  };
  var IPLDNode = class extends Node3 {
    constructor({ codec, hasher, block, ...opts }) {
      super(opts);
      this.codec = codec;
      this.hasher = hasher;
      if (!block) {
        this.block = this.encode();
        this.address = this.block.then((block2) => block2.cid);
      } else {
        this.block = block;
        this.address = block.cid;
      }
    }
    async get(key) {
      const {
        result: entry,
        cids
      } = await this.getEntry(key);
      return {
        result: entry.key,
        cids
      };
    }
    async encode() {
      if (this.block)
        return this.block;
      const value = await this.encodeNode();
      const opts = {
        codec: this.codec,
        hasher: this.hasher,
        value
      };
      this.block = await encode7(opts);
      return this.block;
    }
  };
  var IPLDBranch = class extends IPLDNode {
    async encodeNode() {
      const { entries: entries3 } = this.entryList;
      const mapper = async (entry) => {
        if (!entry.address)
          throw new Error("entry.address required");
        return [
          entry.key,
          await entry.address
        ];
      };
      const list = await Promise.all(entries3.map(mapper));
      return {
        branch: [
          this.distance,
          list
        ],
        closed: this.closed
      };
    }
    get isBranch() {
      return true;
    }
  };
  var IPLDLeaf = class extends IPLDNode {
    async encodeNode() {
      const list = await Promise.all(this.entryList.entries.map(async (entry) => await entry.encodeNode()));
      return {
        leaf: list,
        closed: this.closed
      };
    }
    get isLeaf() {
      return true;
    }
  };
  var create12 = async function* (obj) {
    let { LeafClass: LeafClass2, LeafEntryClass, BranchClass: BranchClass2, BranchEntryClass, list, chunker, compare: compare5, ...opts } = obj;
    list = list.map((value) => new LeafEntryClass(value, opts));
    opts.compare = compare5;
    let nodes = await Node3.from({
      entries: list,
      chunker,
      NodeClass: LeafClass2,
      distance: 0,
      opts
    });
    yield* nodes;
    let distance = 1;
    while (nodes.length > 1) {
      const mapper = async (node) => new BranchEntryClass({
        key: node.key,
        address: await node.address
      }, opts);
      const entries3 = await Promise.all(nodes.map(mapper));
      nodes = await Node3.from({
        entries: entries3,
        chunker,
        NodeClass: BranchClass2,
        distance,
        opts
      });
      yield* nodes;
      distance++;
    }
  };

  // node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/map.js
  var MapEntry = class extends Entry {
    async identity() {
      const encoded = await this.codec.encode(await this.encodeNode());
      const hash2 = await this.hasher.encode(encoded);
      return readUInt32LE(hash2);
    }
  };
  var MapLeafEntry = class extends MapEntry {
    constructor(node, opts) {
      super(node, opts);
      this.value = node.value;
    }
    encodeNode() {
      return [
        this.key,
        this.value
      ];
    }
  };
  var MapBranchEntry = class extends MapEntry {
    constructor(node, opts) {
      if (!node.address)
        throw new Error("Cannot create MapBranchEntry without address");
      super(node, opts);
    }
    async encodeNode() {
      return [
        this.key,
        await this.address
      ];
    }
  };
  var getValue = async (node, key) => {
    const {
      result: entry,
      cids
    } = await node.getEntry(key);
    return {
      result: entry.value,
      cids
    };
  };
  var getManyValues = async (node, keys) => {
    const {
      result: entries3,
      cids
    } = await node.getEntries(keys);
    return {
      result: entries3.map((entry) => entry.value),
      cids
    };
  };
  var MapLeaf = class extends IPLDLeaf {
    get(key) {
      return getValue(this, key);
    }
    getMany(keys) {
      return getManyValues(this, keys);
    }
    bulk(bulk, opts = {}, isRoot = true) {
      return super.bulk(bulk, {
        ...classes,
        ...opts
      }, isRoot);
    }
  };
  var MapBranch = class extends IPLDBranch {
    get(key) {
      return getValue(this, key);
    }
    getMany(keys) {
      return getManyValues(this, keys);
    }
    bulk(bulk, opts = {}, isRoot = true) {
      return super.bulk(bulk, {
        ...classes,
        ...opts
      }, isRoot);
    }
  };
  var classes = {
    LeafClass: MapLeaf,
    LeafEntryClass: MapLeafEntry,
    BranchClass: MapBranch,
    BranchEntryClass: MapBranchEntry
  };
  var createGetNode = (get8, cache3, chunker, codec, hasher, compare5, opts) => {
    const LeafClass2 = opts.LeafClass || MapLeaf;
    const LeafEntryClass = opts.LeafEntryClass || MapLeafEntry;
    const BranchClass2 = opts.BranchClass || MapBranch;
    const BranchEntryClass = opts.BranchEntryClass || MapBranchEntry;
    const getNode = async (cid) => {
      if (cache3.has(cid))
        return cache3.get(cid);
      return get8(cid).then((block) => decoder2(block));
    };
    const decoder2 = makeDecoder({
      chunker,
      cache: cache3,
      getNode,
      codec,
      hasher,
      compare: compare5,
      LeafEntryClass,
      LeafClass: LeafClass2,
      BranchEntryClass,
      BranchClass: BranchClass2
    });
    return getNode;
  };
  var create13 = ({ get: get8, cache: cache3, chunker, list, codec, hasher, sorted, compare: compare5, ...opts }) => {
    if (!sorted)
      list = list.sort(({ key: a7 }, { key: b5 }) => compare5(a7, b5));
    const getNode = createGetNode(get8, cache3, chunker, codec, hasher, compare5, opts);
    const _opts = {
      list,
      codec,
      hasher,
      chunker,
      getNode,
      sorted,
      compare: compare5,
      cache: cache3,
      LeafClass: opts.LeafClass || MapLeaf,
      LeafEntryClass: opts.LeafEntryClass || MapLeafEntry,
      BranchClass: opts.BranchClass || MapBranch,
      BranchEntryClass: opts.BranchEntryClass || MapBranchEntry
    };
    return create12(_opts);
  };
  var load = ({ cid, get: get8, cache: cache3, chunker, codec, hasher, compare: compare5, ...opts }) => {
    const getNode = createGetNode(get8, cache3, chunker, codec, hasher, compare5, opts);
    return getNode(cid);
  };
  function makeDecoder({ chunker, cache: cache3, getNode, codec, hasher, compare: compare5, LeafEntryClass, LeafClass: LeafClass2, BranchEntryClass, BranchClass: BranchClass2 }) {
    const entryOpts = {
      codec,
      hasher
    };
    return (block) => {
      const { value } = block;
      const opts = {
        chunker,
        cache: cache3,
        block,
        getNode,
        codec,
        hasher,
        compare: compare5
      };
      let entries3;
      let CLS;
      if (value.leaf) {
        entries3 = value.leaf.map(([key, value2]) => new LeafEntryClass({
          key,
          value: value2
        }, entryOpts));
        CLS = LeafClass2;
      } else if (value.branch) {
        const [distance, _entries] = value.branch;
        opts.distance = distance;
        entries3 = _entries.map(([key, address]) => new BranchEntryClass({
          key,
          address
        }, entryOpts));
        CLS = BranchClass2;
      } else {
        throw new Error("Unknown block data, does not match schema");
      }
      const entryList = new EntryList({
        entries: entries3,
        closed: value.closed
      });
      const node = new CLS({
        entryList,
        ...opts
      });
      cache3.set(node);
      return node;
    };
  }

  // node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/db-index.js
  var compare3 = (a7, b5) => {
    const [aKey, aRef] = a7;
    const [bKey, bRef] = b5;
    const comp = simpleCompare(aKey, bKey);
    if (comp !== 0)
      return comp;
    return refCompare(aRef, bRef);
  };
  var refCompare = (aRef, bRef) => {
    if (Number.isNaN(aRef))
      return -1;
    if (Number.isNaN(bRef))
      throw new Error("ref may not be Infinity or NaN");
    if (!Number.isFinite(aRef))
      return 1;
    return simpleCompare(aRef, bRef);
  };
  var getIndex = async (node, key) => {
    const start = [
      key,
      NaN
    ];
    const end = [
      key,
      Infinity
    ];
    const {
      result: entries3,
      cids
    } = await node.getRangeEntries(start, end);
    return {
      result: entries3.map((entry) => {
        const [key2, id] = entry.key;
        return {
          id,
          key: key2,
          row: entry.value
        };
      }),
      cids
    };
  };
  var getRange = async (node, start, end) => {
    start = [
      start,
      NaN
    ];
    end = [
      end,
      Infinity
    ];
    const {
      result: entries3,
      cids
    } = await node.getRangeEntries(start, end);
    const result = entries3.map((entry) => {
      const [key, id] = entry.key;
      return {
        id,
        key,
        row: entry.value
      };
    });
    return {
      result,
      cids
    };
  };
  var DBIndexLeaf = class extends MapLeaf {
    get(key) {
      return getIndex(this, key);
    }
    range(start, end) {
      return getRange(this, start, end);
    }
    bulk(bulk, opts = {}, isRoot = true) {
      return super.bulk(bulk, {
        ...classes2,
        ...opts
      }, isRoot);
    }
  };
  var DBIndexBranch = class extends MapBranch {
    get(key) {
      return getIndex(this, key);
    }
    range(start, end) {
      return getRange(this, start, end);
    }
    bulk(bulk, opts = {}, isRoot = true) {
      return super.bulk(bulk, {
        ...classes2,
        ...opts
      }, isRoot);
    }
  };
  var LeafClass = DBIndexLeaf;
  var BranchClass = DBIndexBranch;
  var classes2 = {
    LeafClass,
    BranchClass,
    LeafEntryClass: MapLeafEntry,
    BranchEntryClass: MapBranchEntry
  };
  var defaults4 = {
    ...classes2,
    compare: compare3
  };
  var create14 = (opts) => {
    opts = {
      ...defaults4,
      ...opts
    };
    return create13(opts);
  };
  var load2 = (opts) => {
    opts = {
      ...defaults4,
      ...opts
    };
    return load(opts);
  };

  // node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/cache.js
  init_dirname();
  init_buffer2();
  init_process2();
  var nocache = {
    has: () => false,
    get: () => {
      throw new Error("Cannot ask for entries from nocache");
    },
    set: () => {
    }
  };

  // node_modules/.pnpm/@fireproof+core@file+..+fireproof+dist+fireproof-core+fireproof-core-0.0.0-smoke.tgz_react@18.3.1_typescript@5.5.4/node_modules/@fireproof/core/index.js
  init_cement();
  function writeQueue(worker, payload = Infinity, unbounded = false) {
    const queue2 = [];
    let isProcessing = false;
    async function process4() {
      if (isProcessing || queue2.length === 0) return;
      isProcessing = true;
      const tasksToProcess = queue2.splice(0, payload);
      const updates = tasksToProcess.map((item) => item.task);
      if (unbounded) {
        const promises3 = updates.map(async (update2, index2) => {
          try {
            const result = await worker([update2]);
            tasksToProcess[index2].resolve(result);
          } catch (error) {
            tasksToProcess[index2].reject(error);
          }
        });
        await Promise.all(promises3);
      } else {
        try {
          const result = await worker(updates);
          tasksToProcess.forEach((task) => task.resolve(result));
        } catch (error) {
          tasksToProcess.forEach((task) => task.reject(error));
        }
      }
      isProcessing = false;
      void process4();
    }
    return {
      push(task) {
        return new Promise((resolve9, reject) => {
          queue2.push({ task, resolve: resolve9, reject });
          void process4();
        });
      }
    };
  }
  var block_exports = {};
  __export3(block_exports, {
    Block: () => Block3,
    create: () => create15,
    createUnsafe: () => createUnsafe,
    decode: () => decode20,
    encode: () => encode17
  });
  var Block3 = Block;
  async function decode20({
    bytes,
    codec: codec3,
    hasher: hasher7
  }) {
    if (bytes == null) throw new Error('Missing required argument "bytes"');
    if (codec3 == null || hasher7 == null) throw new Error("Missing required argument: codec or hasher");
    const value = await Promise.resolve(codec3.decode(bytes));
    const hash2 = await hasher7.digest(bytes);
    const cid = CID.create(1, codec3.code, hash2);
    return new Block({ value, bytes, cid });
  }
  async function encode17({
    value,
    codec: codec3,
    hasher: hasher7
  }) {
    if (typeof value === "undefined") throw new Error('Missing required argument "value"');
    if (codec3 == null || hasher7 == null) throw new Error("Missing required argument: codec or hasher");
    const bytes = await Promise.resolve(codec3.encode(value));
    const hash2 = await hasher7.digest(bytes);
    const cid = CID.create(1, codec3.code, hash2);
    return new Block({ value, bytes, cid });
  }
  async function create15({
    bytes,
    cid,
    hasher: hasher7,
    codec: codec3
  }) {
    if (bytes == null) throw new Error('Missing required argument "bytes"');
    if (hasher7 == null) throw new Error('Missing required argument "hasher"');
    const value = await Promise.resolve(codec3.decode(bytes));
    const hash2 = await hasher7.digest(bytes);
    if (!bytes_exports.equals(cid.multihash.bytes, hash2.bytes)) {
      throw new Error("CID hash does not match bytes");
    }
    return createUnsafe({
      bytes,
      cid,
      value,
      codec: codec3
    });
  }
  async function createUnsafe({
    bytes,
    cid,
    value: maybeValue,
    codec: codec3
  }) {
    const value = await Promise.resolve(maybeValue !== void 0 ? maybeValue : codec3?.decode(bytes));
    if (value === void 0) throw new Error('Missing required argument, must either provide "value" or "codec"');
    return new Block3({
      cid,
      bytes,
      value
    });
  }
  var blockstore_exports = {};
  __export3(blockstore_exports, {
    BaseBlockstore: () => BaseBlockstore,
    CarTransaction: () => CarTransaction,
    CompactionFetcher: () => CompactionFetcher,
    ConnectionBase: () => ConnectionBase,
    EncryptedBlockstore: () => EncryptedBlockstore,
    FragmentGateway: () => FragmentGateway,
    Loader: () => Loader,
    addCryptoKeyToGatewayMetaPayload: () => addCryptoKeyToGatewayMetaPayload,
    ensureStart: () => ensureStart,
    getGatewayFromURL: () => getGatewayFromURL,
    parseCarFile: () => parseCarFile,
    registerStoreProtocol: () => registerStoreProtocol,
    setCryptoKeyFromGatewayMetaPayload: () => setCryptoKeyFromGatewayMetaPayload,
    testStoreFactory: () => testStoreFactory,
    toCIDBlock: () => toCIDBlock,
    toStoreRuntime: () => toStoreRuntime
  });
  function toCIDBlock(block) {
    return block;
  }
  var files_exports = {};
  __export3(files_exports, {
    decodeFile: () => decodeFile,
    encodeFile: () => encodeFile2
  });
  var queuingStrategy = withCapacity();
  var settings = configure2({
    fileChunkEncoder: raw_exports,
    smallFileEncoder: raw_exports,
    chunker: withMaxChunkSize(1024 * 1024),
    fileLayout: withWidth(1024)
  });
  async function collect2(collectable) {
    const chunks = [];
    await collectable.pipeTo(
      new WritableStream({
        write(chunk) {
          chunks.push(chunk);
        }
      })
    );
    return chunks;
  }
  async function encodeFile2(blob) {
    const readable = createFileEncoderStream(blob);
    const blocks = await collect2(readable);
    return { cid: blocks.at(-1).cid, blocks };
  }
  async function decodeFile(blocks, cid, meta) {
    const entry = await exporter(cid.toString(), blocks, { length: meta.size });
    const chunks = [];
    for await (const chunk of entry.content()) {
      chunks.push(chunk);
    }
    return new File(chunks, entry.name, { type: meta.type, lastModified: 0 });
  }
  function createFileEncoderStream(blob) {
    const { readable, writable } = new TransformStream({}, queuingStrategy);
    const unixfsWriter = createWriter({ writable, settings });
    const fileBuilder = new UnixFSFileBuilder("", blob);
    void (async () => {
      await fileBuilder.finalize(unixfsWriter);
      await unixfsWriter.close();
    })();
    return readable;
  }
  var UnixFSFileBuilder = class {
    #file;
    constructor(name8, file) {
      this.name = name8;
      this.#file = file;
    }
    async finalize(writer) {
      const unixfsFileWriter = create7(writer);
      await this.#file.stream().pipeTo(
        new WritableStream({
          async write(chunk) {
            await unixfsFileWriter.write(chunk);
          }
        })
      );
      return await unixfsFileWriter.close();
    }
  };
  function isFalsy(value) {
    return value === false && value === null && value === void 0;
  }
  function throwFalsy(value) {
    if (isFalsy(value)) {
      throw new Error("value is Falsy");
    }
    return value;
  }
  function falsyToUndef(value) {
    if (isFalsy(value)) {
      return void 0;
    }
    return value;
  }
  async function parseCarFile(reader, logger) {
    const roots = await reader.getRoots();
    const header = await reader.get(roots[0]);
    if (!header) throw logger.Error().Msg("missing header block").AsError();
    const dec = await decode20({ bytes: header.bytes, hasher: sha256, codec: src_exports });
    const fpvalue = dec.value;
    if (fpvalue && !fpvalue.fp) {
      throw logger.Error().Msg("missing fp").AsError();
    }
    return fpvalue.fp;
  }
  var CarTransaction = class extends MemoryBlockstore {
    constructor(parent, opts = { add: true, noLoader: false }) {
      super();
      if (opts.add) {
        parent.transactions.add(this);
      }
      this.parent = parent;
    }
    async get(cid) {
      return await this.superGet(cid) || falsyToUndef(await this.parent.get(cid));
    }
    async superGet(cid) {
      return super.get(cid);
    }
  };
  function defaultedBlockstoreRuntime(sthis, opts, component, ctx) {
    const logger = ensureLogger(sthis, component, ctx);
    const store = opts.store || {};
    return {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      applyMeta: (meta, snap) => {
        return Promise.resolve();
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      compact: async (blocks) => {
        return {};
      },
      autoCompact: 100,
      public: false,
      name: void 0,
      threshold: 1e3 * 1e3,
      ...opts,
      logger,
      keyBag: opts.keyBag || {},
      crypto: toCryptoRuntime(opts.crypto),
      store,
      storeRuntime: toStoreRuntime(store, sthis)
    };
  }
  function blockstoreFactory(sthis, opts) {
    if (opts.name) {
      return new EncryptedBlockstore(sthis, opts);
    } else {
      return new BaseBlockstore(opts);
    }
  }
  var BaseBlockstore = class {
    constructor(ebOpts = {}) {
      this.transactions = /* @__PURE__ */ new Set();
      this.sthis = ensureSuperThis(ebOpts);
      this.ebOpts = defaultedBlockstoreRuntime(this.sthis, ebOpts, "BaseBlockstore");
      this.logger = this.ebOpts.logger;
    }
    // ready: Promise<void>;
    ready() {
      return Promise.resolve();
    }
    async close() {
    }
    async destroy() {
    }
    async get(cid) {
      if (!cid) throw this.logger.Error().Msg("required cid").AsError();
      for (const f7 of this.transactions) {
        const v6 = await f7.superGet(cid);
        if (v6) return v6;
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async put(cid, block) {
      throw this.logger.Error().Msg("use a transaction to put").AsError();
    }
    // TransactionMeta
    async transaction(fn, _opts) {
      const t8 = new CarTransaction(this, _opts);
      const done = await fn(t8);
      this.lastTxMeta = done;
      return { t: t8, meta: done };
    }
    async *entries() {
      const seen = /* @__PURE__ */ new Set();
      for (const t8 of this.transactions) {
        for await (const blk of t8.entries()) {
          if (seen.has(blk.cid.toString())) continue;
          seen.add(blk.cid.toString());
          yield blk;
        }
      }
    }
  };
  var EncryptedBlockstore = class extends BaseBlockstore {
    constructor(sthis, ebOpts) {
      super(ebOpts);
      this.compacting = false;
      this.logger = ensureLogger(this.sthis, "EncryptedBlockstore");
      const { name: name8 } = ebOpts;
      if (!name8) {
        throw this.logger.Error().Msg("name required").AsError();
      }
      this.name = name8;
      this.loader = new Loader(this.name, ebOpts, sthis);
    }
    ready() {
      return this.loader.ready();
    }
    close() {
      return this.loader.close();
    }
    destroy() {
      return this.loader.destroy();
    }
    async get(cid) {
      const got = await super.get(cid);
      if (got) return got;
      if (!this.loader) {
        return;
      }
      return falsyToUndef(await this.loader.getBlock(cid));
    }
    async transaction(fn, opts = { noLoader: false }) {
      const { t: t8, meta: done } = await super.transaction(fn);
      const cars = await this.loader.commit(t8, done, opts);
      if (this.ebOpts.autoCompact && this.loader.carLog.length > this.ebOpts.autoCompact) {
        setTimeout(() => void this.compact(), 10);
      }
      if (cars) {
        this.transactions.delete(t8);
        return { meta: done, cars, t: t8 };
      }
      throw this.logger.Error().Msg("failed to commit car files").AsError();
    }
    async getFile(car, cid) {
      await this.ready();
      if (!this.loader) throw this.logger.Error().Msg("loader required to get file, database must be named").AsError();
      const reader = await this.loader.loadFileCar(
        car
        /*, isPublic */
      );
      const block = await reader.get(cid);
      if (!block) throw this.logger.Error().Str("cid", cid.toString()).Msg(`Missing block`).AsError();
      return block.bytes;
    }
    async compact() {
      await this.ready();
      if (!this.loader) throw this.logger.Error().Msg("loader required to compact").AsError();
      if (this.loader.carLog.length < 2) return;
      const compactFn = this.ebOpts.compact || ((blocks) => this.defaultCompact(blocks, this.logger));
      if (!compactFn || this.compacting) return;
      const blockLog = new CompactionFetcher(this);
      this.compacting = true;
      const meta = await compactFn(blockLog);
      await this.loader?.commit(blockLog.loggedBlocks, meta, {
        compact: true,
        noLoader: true
      });
      this.compacting = false;
    }
    async defaultCompact(blocks, logger) {
      if (!this.loader) {
        throw logger.Error().Msg("no loader").AsError();
      }
      if (!this.lastTxMeta) {
        throw logger.Error().Msg("no lastTxMeta").AsError();
      }
      for await (const blk of this.loader.entries(false)) {
        blocks.loggedBlocks.putSync(blk.cid, blk.bytes);
      }
      for (const t8 of this.transactions) {
        for await (const blk of t8.entries()) {
          blocks.loggedBlocks.putSync(blk.cid, blk.bytes);
        }
      }
      return this.lastTxMeta;
    }
    async *entries() {
      for await (const blk of this.loader.entries()) {
        yield blk;
      }
    }
  };
  var CompactionFetcher = class {
    constructor(blocks) {
      this.blockstore = blocks;
      this.loggedBlocks = new CarTransaction(blocks);
    }
    async get(cid) {
      const block = await this.blockstore.get(cid);
      if (block) this.loggedBlocks.putSync(cid, block.bytes);
      return falsyToUndef(block);
    }
  };
  var CommitQueue = class {
    constructor() {
      this.queue = [];
      this.processing = false;
      this._waitIdleItems = /* @__PURE__ */ new Set();
    }
    waitIdle() {
      if (this.queue.length === 0 && !this.processing) {
        return Promise.resolve();
      }
      const fn = new Future();
      this._waitIdleItems.add(fn);
      return fn.asPromise();
    }
    async enqueue(fn) {
      return new Promise((resolve9, reject) => {
        const queueFn = async () => {
          try {
            resolve9(await fn());
          } catch (e9) {
            reject(e9);
          } finally {
            this.processing = false;
            this.processNext();
          }
        };
        this.queue.push(queueFn);
        if (!this.processing) {
          this.processNext();
        }
      });
    }
    processNext() {
      if (this.queue.length > 0 && !this.processing) {
        this.processing = true;
        const queueFn = this.queue.shift();
        if (queueFn) {
          queueFn().finally(() => {
          });
        }
      }
      if (this.queue.length === 0 && !this.processing) {
        const toResolve = Array.from(this._waitIdleItems);
        this._waitIdleItems.clear();
        toResolve.map((fn) => fn.resolve());
      }
    }
  };
  var key_bag_exports = {};
  __export3(key_bag_exports, {
    KeyBag: () => KeyBag,
    getKeyBag: () => getKeyBag,
    registerKeyBagProviderFactory: () => registerKeyBagProviderFactory
  });
  var KeyBag = class {
    constructor(rt) {
      this.rt = rt;
      this._warnOnce = new ResolveOnce();
      this._seq = new ResolveSeq();
      this.logger = ensureLogger(rt.sthis, "KeyBag");
      this.logger.Debug().Msg("KeyBag created");
    }
    async subtleKey(key) {
      const extractable = this.rt.url.getParam("extractKey") === "_deprecated_internal_api";
      if (extractable) {
        this._warnOnce.once(
          () => this.logger.Warn().Msg("extractKey is enabled via _deprecated_internal_api --- handle keys safely!!!")
        );
      }
      return await this.rt.crypto.importKey(
        "raw",
        // raw or jwk
        base58btc.decode(key),
        // hexStringToUint8Array(key), // raw data
        "AES-GCM",
        extractable,
        ["encrypt", "decrypt"]
      );
    }
    async ensureKeyFromUrl(url, keyFactory) {
      const storeKey = url.getParam("storekey");
      if (storeKey === "insecure") {
        return Result.Ok(url);
      }
      if (!storeKey) {
        const keyName = `@${keyFactory()}@`;
        const ret = await this.getNamedKey(keyName);
        if (ret.isErr()) {
          return ret;
        }
        const urb = url.build().setParam("storekey", keyName);
        return Result.Ok(urb.URI());
      }
      if (storeKey.startsWith("@") && storeKey.endsWith("@")) {
        const ret = await this.getNamedKey(storeKey);
        if (ret.isErr()) {
          return ret;
        }
      }
      return Result.Ok(url);
    }
    async toKeyWithFingerPrint(keyStr) {
      const material = base58btc.decode(keyStr);
      const key = await this.subtleKey(keyStr);
      const fpr = await this.rt.crypto.digestSHA256(material);
      return Result.Ok({
        key,
        fingerPrint: base58btc.encode(new Uint8Array(fpr))
      });
    }
    async setNamedKey(name8, key) {
      return this._seq.add(() => this._setNamedKey(name8, key));
    }
    // avoid deadlock
    async _setNamedKey(name8, key) {
      const item = {
        name: name8,
        key
      };
      const bag = await this.rt.getBag();
      this.logger.Debug().Str("name", name8).Msg("setNamedKey");
      await bag.set(name8, item);
      return await this.toKeyWithFingerPrint(item.key);
    }
    async getNamedExtractableKey(name8, failIfNotFound = false) {
      const ret = await this.getNamedKey(name8, failIfNotFound);
      if (ret.isErr()) {
        return ret;
      }
      const named = ret.Ok();
      return Result.Ok({
        ...named,
        extract: async () => {
          const ext = new Uint8Array(await this.rt.crypto.exportKey("raw", named.key));
          return {
            key: ext,
            keyStr: base58btc.encode(ext)
          };
        }
      });
    }
    async getNamedKey(name8, failIfNotFound = false) {
      const id = this.rt.sthis.nextId(4).str;
      return this._seq.add(async () => {
        const bag = await this.rt.getBag();
        const named = await bag.get(name8);
        if (named) {
          const fpr = await this.toKeyWithFingerPrint(named.key);
          this.logger.Debug().Str("id", id).Str("name", name8).Result("fpr", fpr).Msg("fingerPrint getNamedKey");
          return fpr;
        }
        if (failIfNotFound) {
          this.logger.Debug().Str("id", id).Str("name", name8).Msg("failIfNotFound getNamedKey");
          return Result.Err(new Error(`Key not found: ${name8}`));
        }
        const ret = await this._setNamedKey(name8, base58btc.encode(this.rt.crypto.randomBytes(this.rt.keyLength)));
        this.logger.Debug().Str("id", id).Str("name", name8).Result("fpr", ret).Msg("createKey getNamedKey-post");
        return ret;
      });
    }
  };
  var keyBagProviderFactories = new Map(
    [
      {
        protocol: "file:",
        factory: async (url, sthis) => {
          const { KeyBagProviderFile: KeyBagProviderFile2 } = await Promise.resolve().then(() => (init_key_bag_file_DFMW6ZM6(), key_bag_file_DFMW6ZM6_exports));
          return new KeyBagProviderFile2(url, sthis);
        }
      },
      {
        protocol: "indexdb:",
        factory: async (url, sthis) => {
          const { KeyBagProviderIndexDB: KeyBagProviderIndexDB2 } = await Promise.resolve().then(() => (init_key_bag_indexdb_R2RWGSQ4(), key_bag_indexdb_R2RWGSQ4_exports));
          return new KeyBagProviderIndexDB2(url, sthis);
        }
      }
    ].map((i7) => [i7.protocol, i7])
  );
  function registerKeyBagProviderFactory(item) {
    const protocol = item.protocol.endsWith(":") ? item.protocol : item.protocol + ":";
    keyBagProviderFactories.set(protocol, {
      ...item,
      protocol
    });
  }
  function defaultKeyBagOpts(sthis, kbo) {
    if (kbo.keyRuntime) {
      return kbo.keyRuntime;
    }
    const logger = ensureLogger(sthis, "KeyBag");
    let url;
    if (kbo.url) {
      url = URI.from(kbo.url);
      logger.Debug().Url(url).Msg("from opts");
    } else {
      let bagFnameOrUrl = sthis.env.get("FP_KEYBAG_URL");
      if (runtimeFn().isBrowser) {
        url = URI.from(bagFnameOrUrl || "indexdb://fp-keybag");
      } else {
        if (!bagFnameOrUrl) {
          const home = sthis.env.get("HOME");
          bagFnameOrUrl = `${home}/.fireproof/keybag`;
          url = URI.from(`file://${bagFnameOrUrl}`);
        } else {
          url = URI.from(bagFnameOrUrl);
        }
      }
      logger.Debug().Url(url).Msg("from env");
    }
    const kitem = keyBagProviderFactories.get(url.protocol);
    if (!kitem) {
      throw logger.Error().Url(url).Msg("unsupported protocol").AsError();
    }
    const getBag = async () => kitem.factory(url, sthis);
    if (url.hasParam("masterkey")) {
      throw logger.Error().Url(url).Msg("masterkey is not supported").AsError();
    }
    return {
      url,
      crypto: kbo.crypto || toCryptoRuntime({}),
      sthis,
      logger,
      keyLength: kbo.keyLength || 16,
      getBag,
      id: () => {
        return url.toString();
      }
    };
  }
  var _keyBags = new KeyedResolvOnce();
  async function getKeyBag(sthis, kbo = {}) {
    await sthis.start();
    const rt = defaultKeyBagOpts(sthis, kbo);
    return _keyBags.get(rt.id()).once(async () => new KeyBag(rt));
  }
  async function encodeCarFile(roots, t8, codec3) {
    let size = 0;
    const headerSize = headerLength({ roots });
    size += headerSize;
    for (const { cid, bytes } of t8.entries()) {
      size += blockLength({ cid, bytes });
    }
    const buffer4 = new Uint8Array(size);
    const writer = createWriter3(buffer4, { headerSize });
    for (const r9 of roots) {
      writer.addRoot(r9);
    }
    for (const { cid, bytes } of t8.entries()) {
      writer.write({ cid, bytes });
    }
    writer.close();
    return await encode17({ value: writer.bytes, hasher: sha256, codec: codec3 });
  }
  async function createCarFile(encoder2, cid, t8) {
    return encodeCarFile([cid], t8, encoder2);
  }
  async function commitFiles(fileStore, walStore, t8, done) {
    const { files: roots } = makeFileCarHeader(done);
    const cids = [];
    const codec3 = (await fileStore.keyedCrypto()).codec();
    const cars = await prepareCarFilesFiles(codec3, roots, t8);
    for (const car of cars) {
      const { cid, bytes } = car;
      await fileStore.save({ cid, bytes });
      await walStore.enqueueFile(
        cid
        /*, !!opts.public*/
      );
      cids.push(cid);
    }
    return cids;
  }
  function makeFileCarHeader(result) {
    const files = [];
    for (const [, meta] of Object.entries(result.files || {})) {
      if (meta && typeof meta === "object" && "cid" in meta && meta !== null) {
        files.push(meta.cid);
      }
    }
    return { ...result, files };
  }
  async function prepareCarFilesFiles(encoder2, roots, t8) {
    return [await encodeCarFile(roots, t8, encoder2)];
  }
  function makeCarHeader(meta, cars, compact = false) {
    const coreHeader = compact ? { cars: [], compact: cars } : { cars, compact: [] };
    return { ...coreHeader, meta };
  }
  async function encodeCarHeader(fp) {
    return await encode17({
      value: { fp },
      hasher: sha256,
      codec: src_exports
    });
  }
  async function commit2(params, t8, done, opts = { noLoader: false, compact: false }) {
    const fp = makeCarHeader(done, params.carLog, !!opts.compact);
    const rootBlock = await encodeCarHeader(fp);
    const cars = await prepareCarFiles(params.encoder, params.threshold, rootBlock, t8);
    const cids = [];
    for (const car of cars) {
      const { cid, bytes } = car;
      await params.carStore.save({ cid, bytes });
      cids.push(cid);
    }
    const newDbMeta = { cars: cids };
    await params.WALStore.enqueue(newDbMeta, opts);
    await params.metaStore.save(newDbMeta);
    return { cgrp: cids, header: fp };
  }
  async function prepareCarFiles(encoder2, threshold, rootBlock, t8) {
    const carFiles = [];
    threshold = threshold || 1e3 * 1e3;
    let clonedt = new CarTransaction(t8.parent, { add: false, noLoader: false });
    clonedt.putSync(rootBlock.cid, rootBlock.bytes);
    let newsize = blockLength(toCIDBlock(rootBlock));
    let cidRootBlock = rootBlock;
    for (const { cid, bytes } of t8.entries()) {
      newsize += blockLength(toCIDBlock({ cid, bytes }));
      if (newsize >= threshold) {
        carFiles.push(await createCarFile(encoder2, cidRootBlock.cid, clonedt));
        clonedt = new CarTransaction(t8.parent, { add: false, noLoader: false });
        clonedt.putSync(cid, bytes);
        cidRootBlock = { cid, bytes };
        newsize = blockLength(toCIDBlock({ cid, bytes }));
      } else {
        clonedt.putSync(cid, bytes);
      }
    }
    carFiles.push(await createCarFile(encoder2, cidRootBlock.cid, clonedt));
    return carFiles;
  }
  var TaskManager = class {
    constructor(sthis, callback) {
      this.eventsWeHandled = /* @__PURE__ */ new Set();
      this.queue = [];
      this.isProcessing = false;
      this.logger = ensureLogger(sthis, "TaskManager");
      this.callback = callback;
    }
    async handleEvent(cid, parents, dbMeta) {
      for (const parent of parents) {
        this.eventsWeHandled.add(parent.toString());
      }
      this.queue.push({ cid: cid.toString(), dbMeta, retries: 0 });
      this.queue = this.queue.filter(({ cid: cid2 }) => !this.eventsWeHandled.has(cid2));
      void this.processQueue();
    }
    async processQueue() {
      if (this.isProcessing) return;
      this.isProcessing = true;
      const filteredQueue = this.queue.filter(({ cid }) => !this.eventsWeHandled.has(cid));
      const first = filteredQueue[0];
      if (!first) {
        return;
      }
      try {
        await this.callback(first.dbMeta);
        this.eventsWeHandled.add(first.cid);
        this.queue = this.queue.filter(({ cid }) => !this.eventsWeHandled.has(cid));
      } catch (err) {
        if (first.retries++ > 3) {
          this.logger.Error().Str("cid", first.cid).Msg("failed to process event block after 3 retries");
          this.queue = this.queue.filter(({ cid }) => cid !== first.cid);
        }
        await new Promise((resolve9) => setTimeout(resolve9, 50));
        throw this.logger.Error().Err(err).Msg("failed to process event block").AsError();
      } finally {
        this.isProcessing = false;
        if (this.queue.length > 0) {
          void this.processQueue();
        }
      }
    }
  };
  function carLogIncludesGroup(list, cids) {
    return list.some((arr) => {
      return arr.toString() === cids.toString();
    });
  }
  function uniqueCids(list, remove3 = /* @__PURE__ */ new Set()) {
    const byString = /* @__PURE__ */ new Map();
    for (const cid of list) {
      if (remove3.has(cid.toString())) continue;
      byString.set(cid.toString(), cid);
    }
    return [...byString.values()];
  }
  var Loader = class {
    constructor(name8, ebOpts, sthis) {
      this.commitQueue = new CommitQueue();
      this.isCompacting = false;
      this.carReaders = /* @__PURE__ */ new Map();
      this.seenCompacted = /* @__PURE__ */ new Set();
      this.processedCars = /* @__PURE__ */ new Set();
      this.carLog = [];
      this.getBlockCache = /* @__PURE__ */ new Map();
      this.seenMeta = /* @__PURE__ */ new Set();
      this.writeLimit = pLimit(1);
      this.onceReady = new ResolveOnce();
      this.name = name8;
      this.sthis = sthis;
      this.ebOpts = defaultedBlockstoreRuntime(
        sthis,
        {
          ...ebOpts,
          name: name8
        },
        "Loader"
      );
      this.logger = this.ebOpts.logger;
      this.taskManager = new TaskManager(sthis, async (dbMeta) => {
        await this.handleDbMetasFromStore([dbMeta]);
      });
    }
    // readonly id = uuidv4();
    async keyBag() {
      return getKeyBag(this.sthis, this.ebOpts.keyBag);
    }
    async carStore() {
      return this.ebOpts.storeRuntime.makeDataStore(this);
    }
    async fileStore() {
      return this.ebOpts.storeRuntime.makeDataStore(this);
    }
    async WALStore() {
      return this.ebOpts.storeRuntime.makeWALStore(this);
    }
    async metaStore() {
      return this.ebOpts.storeRuntime.makeMetaStore(this);
    }
    async ready() {
      return this.onceReady.once(async () => {
        const metas = await (await this.metaStore()).load();
        if (this.ebOpts.meta) {
          await this.handleDbMetasFromStore([this.ebOpts.meta]);
        } else if (metas) {
          await this.handleDbMetasFromStore(metas);
        }
      });
    }
    async close() {
      const toClose = await Promise.all([this.carStore(), this.metaStore(), this.fileStore(), this.WALStore()]);
      await Promise.all(toClose.map((store) => store.close()));
    }
    async destroy() {
      const toDestroy = await Promise.all([this.carStore(), this.metaStore(), this.fileStore(), this.WALStore()]);
      await Promise.all(toDestroy.map((store) => store.destroy()));
    }
    // async snapToCar(carCid: AnyLink | string) {
    //   await this.ready
    //   if (typeof carCid === 'string') {
    //     carCid = CID.parse(carCid)
    //   }
    //   const carHeader = await this.loadCarHeaderFromMeta({ car: carCid, key: this.key || null })
    //   this.carLog = [carCid, ...carHeader.cars]
    //   await this.getMoreReaders(carHeader.cars)
    //   await this._applyCarHeader(carHeader, true)
    // }
    async handleDbMetasFromStore(metas) {
      this.logger.Debug().Any("metas", metas).Msg("handleDbMetasFromStore");
      for (const meta of metas) {
        await this.writeLimit(async () => {
          await this.mergeDbMetaIntoClock(meta);
        });
      }
    }
    async mergeDbMetaIntoClock(meta) {
      if (this.isCompacting) {
        throw this.logger.Error().Msg("cannot merge while compacting").AsError();
      }
      if (this.seenMeta.has(meta.cars.toString())) return;
      this.seenMeta.add(meta.cars.toString());
      if (carLogIncludesGroup(this.carLog, meta.cars)) {
        return;
      }
      const carHeader = await this.loadCarHeaderFromMeta(meta);
      carHeader.compact.map((c7) => c7.toString()).forEach(this.seenCompacted.add, this.seenCompacted);
      await this.getMoreReaders(carHeader.cars.flat());
      this.carLog = [...uniqueCids([meta.cars, ...this.carLog, ...carHeader.cars], this.seenCompacted)];
      await this.ebOpts.applyMeta?.(carHeader.meta);
    }
    // protected async ingestKeyFromMeta(meta: DbMeta): Promise<void> {
    //   const { key } = meta;
    //   if (key) {
    //     await this.setKey(key);
    //   }
    // }
    async loadCarHeaderFromMeta({ cars: cids }) {
      const reader = await this.loadCar(cids[0]);
      return await parseCarFile(reader, this.logger);
    }
    // async _getKey(): Promise<string | undefined> {
    //   if (this.key) return this.key;
    //   // generate a random key
    //   if (!this.ebOpts.public) {
    //     await this.setKey(toHexString(this.ebOpts.crypto.randomBytes(32)));
    //   }
    //   return this.key || undefined;
    // }
    async commitFiles(t8, done) {
      await this.ready();
      const fstore = await this.fileStore();
      const wstore = await this.WALStore();
      return this.commitQueue.enqueue(() => commitFiles(fstore, wstore, t8, done));
    }
    async loadFileCar(cid) {
      return await this.storesLoadCar(cid, await this.fileStore(), this.remoteFileStore);
    }
    async commit(t8, done, opts = { noLoader: false, compact: false }) {
      await this.ready();
      const fstore = await this.fileStore();
      const params = {
        encoder: (await fstore.keyedCrypto()).codec(),
        carLog: this.carLog,
        carStore: fstore,
        WALStore: await this.WALStore(),
        metaStore: await this.metaStore()
      };
      return this.commitQueue.enqueue(async () => {
        await this.cacheTransaction(t8);
        const ret = await commit2(params, t8, done, opts);
        await this.updateCarLog(ret.cgrp, ret.header, !!opts.compact);
        return ret.cgrp;
      });
    }
    async updateCarLog(cids, fp, compact) {
      if (compact) {
        const previousCompactCid = fp.compact[fp.compact.length - 1];
        fp.compact.map((c7) => c7.toString()).forEach(this.seenCompacted.add, this.seenCompacted);
        this.carLog = [...uniqueCids([...this.carLog, ...fp.cars, cids], this.seenCompacted)];
        await this.removeCidsForCompact(previousCompactCid[0]).catch((e9) => e9);
      } else {
        this.carLog.unshift(cids);
      }
    }
    async cacheTransaction(t8) {
      for await (const block of t8.entries()) {
        const sBlock = block.cid.toString();
        if (!this.getBlockCache.has(sBlock)) {
          this.getBlockCache.set(sBlock, block);
        }
      }
    }
    async cacheCarReader(carCidStr, reader) {
      if (this.processedCars.has(carCidStr)) return;
      this.processedCars.add(carCidStr);
      for await (const block of reader.blocks()) {
        const sBlock = block.cid.toString();
        if (!this.getBlockCache.has(sBlock)) {
          this.getBlockCache.set(sBlock, block);
        }
      }
    }
    async removeCidsForCompact(cid) {
      const carHeader = await this.loadCarHeaderFromMeta({
        cars: [cid]
      });
      for (const cids of carHeader.compact) {
        for (const cid2 of cids) {
          await (await this.carStore()).remove(cid2);
        }
      }
    }
    // async flushCars() {
    //   await this.ready
    //   // for each cid in car log, make a dbMeta
    //   for (const cid of this.carLog) {
    //     const dbMeta = { car: cid, key: this.key || null } as DbMeta
    //     await this.remoteWAL!.enqueue(dbMeta, { public: false })
    //   }
    // }
    async *entries(cache22 = true) {
      await this.ready();
      if (cache22) {
        for (const [, block] of this.getBlockCache) {
          yield block;
        }
      } else {
        for (const [, block] of this.getBlockCache) {
          yield block;
        }
        for (const cids of this.carLog) {
          for (const cid of cids) {
            const reader = await this.loadCar(cid);
            if (!reader) throw this.logger.Error().Ref("cid", cid).Msg("missing car reader").AsError();
            for await (const block of reader.blocks()) {
              const sCid = block.cid.toString();
              if (!this.getBlockCache.has(sCid)) {
                yield block;
              }
            }
          }
        }
      }
    }
    async getBlock(cid) {
      await this.ready();
      const sCid = cid.toString();
      if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);
      const getCarCid = async (carCid) => {
        if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);
        const reader = await this.loadCar(carCid);
        if (!reader) {
          throw this.logger.Error().Ref("cid", carCid).Msg("missing car reader").AsError();
        }
        await this.cacheCarReader(carCid.toString(), reader).catch(() => {
          return;
        });
        if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);
        throw this.logger.Error().Str("cid", sCid).Msg("block not in reader").AsError();
      };
      const getCompactCarCids = async (carCid) => {
        const reader = await this.loadCar(carCid);
        if (!reader) {
          throw this.logger.Error().Str("cid", carCid.toString()).Msg("missing car reader").AsError();
        }
        const header = await parseCarFile(reader, this.logger);
        const compacts = header.compact;
        let got2;
        const batchSize2 = 5;
        for (let i7 = 0; i7 < compacts.length; i7 += batchSize2) {
          const promises3 = [];
          for (let j4 = i7; j4 < Math.min(i7 + batchSize2, compacts.length); j4++) {
            for (const cid2 of compacts[j4]) {
              promises3.push(getCarCid(cid2));
            }
          }
          try {
            got2 = await Promise.any(promises3);
          } catch {
          }
          if (got2) break;
        }
        if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);
        throw this.logger.Error().Str("cid", sCid).Msg("block not in compact reader").AsError();
      };
      let got;
      const batchSize = 5;
      for (let i7 = 0; i7 < this.carLog.length; i7 += batchSize) {
        const batch2 = this.carLog.slice(i7, i7 + batchSize);
        const promises3 = batch2.flatMap((slice4) => slice4.map(getCarCid));
        try {
          got = await Promise.any(promises3);
        } catch {
        }
        if (got) break;
      }
      if (!got) {
        try {
          got = await getCompactCarCids(this.carLog[this.carLog.length - 1][0]);
        } catch {
        }
      }
      return got;
    }
    async loadCar(cid) {
      if (!this.carStore) {
        throw this.logger.Error().Msg("car store not initialized").AsError();
      }
      const loaded = await this.storesLoadCar(cid, await this.carStore(), this.remoteCarStore);
      return loaded;
    }
    async makeDecoderAndCarReader(cid, local, remote) {
      const cidsString = cid.toString();
      let loadedCar = void 0;
      let activeStore = local;
      try {
        this.logger.Debug().Str("cid", cidsString).Msg("loading car");
        loadedCar = await local.load(cid);
        this.logger.Debug().Bool("loadedCar", loadedCar).Msg("loaded");
      } catch (e9) {
        if (remote) {
          const remoteCar = await remote.load(cid);
          if (remoteCar) {
            this.logger.Debug().Ref("cid", remoteCar.cid).Msg("saving remote car locally");
            await local.save(remoteCar);
            loadedCar = remoteCar;
            activeStore = remote;
          }
        } else {
          this.logger.Error().Str("cid", cidsString).Err(e9).Msg("loading car");
        }
      }
      if (!loadedCar) {
        throw this.logger.Error().Url(local.url()).Str("cid", cidsString).Msg("missing car files").AsError();
      }
      const bytes = await decode20({ bytes: loadedCar.bytes, hasher: sha256, codec: (await activeStore.keyedCrypto()).codec() });
      const rawReader = await CarReader.fromBytes(bytes.value);
      const readerP = Promise.resolve(rawReader);
      const cachedReaderP = readerP.then(async (reader) => {
        await this.cacheCarReader(cidsString, reader).catch((e9) => {
          this.logger.Error().Err(e9).Str("cid", cidsString).Msg("error caching car reader");
          return;
        });
        return reader;
      });
      this.carReaders.set(cidsString, cachedReaderP);
      return readerP;
    }
    //What if instead it returns an Array of CarHeader
    async storesLoadCar(cid, local, remote) {
      const cidsString = cid.toString();
      let dacr = this.carReaders.get(cidsString);
      if (!dacr) {
        dacr = this.makeDecoderAndCarReader(cid, local, remote);
        this.carReaders.set(cidsString, dacr);
      }
      return dacr;
    }
    async getMoreReaders(cids) {
      const limit = pLimit(5);
      const missing = cids.filter((cid) => !this.carReaders.has(cid.toString()));
      await Promise.all(missing.map((cid) => limit(() => this.loadCar(cid))));
    }
  };
  var keyed_crypto_exports = {};
  __export3(keyed_crypto_exports, {
    BlockIvKeyIdCodec: () => BlockIvKeyIdCodec,
    keyedCryptoFactory: () => keyedCryptoFactory
  });
  var generateIV = {
    random: {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      calc: async (ko, crypto2, data) => {
        return crypto2.randomBytes(ko.ivLength);
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      verify: async (ko, crypto2, iv, data) => {
        return true;
      }
    },
    hash: {
      calc: async (ko, crypto2, data) => {
        const hash2 = await sha256.digest(data);
        const hashBytes = new Uint8Array(hash2.bytes);
        const hashArray = new Uint8Array(ko.ivLength);
        for (let i7 = 0; i7 < hashBytes.length; i7++) {
          hashArray[i7 % ko.ivLength] ^= hashBytes[i7];
        }
        return hashArray;
      },
      verify: async function(ko, crypto2, iv, data) {
        return ko.url.getParam("ivverify") !== "disable" && UInt8ArrayEqual(iv, await this.calc(ko, crypto2, data));
      }
    }
  };
  function getGenerateIVFn(url, opts) {
    const ivhash = opts.ivCalc || url.getParam("ivhash") || "hash";
    return generateIV[ivhash] || generateIV["hash"];
  }
  var BlockIvKeyIdCodec = class {
    constructor(ko, iv, opts) {
      this.code = 3147065;
      this.name = "Fireproof@encrypted-block:aes-gcm";
      this.ko = ko;
      this.iv = iv;
      this.opts = opts || {};
    }
    async encode(data) {
      const calcIv = this.iv || await getGenerateIVFn(this.ko.url, this.opts).calc(this.ko, this.ko.crypto, data);
      const { iv } = this.ko.algo(calcIv);
      const fprt = await this.ko.fingerPrint();
      const keyId = base58btc.decode(fprt);
      this.ko.logger.Debug().Str("fp", fprt).Msg("encode");
      return encode11({
        iv,
        keyId,
        data: await this.ko._encrypt({ iv, bytes: data })
      });
    }
    async decode(abytes) {
      let bytes;
      if (abytes instanceof Uint8Array) {
        bytes = abytes;
      } else {
        bytes = new Uint8Array(abytes);
      }
      const { iv, keyId, data } = decode15(bytes);
      const fprt = await this.ko.fingerPrint();
      this.ko.logger.Debug().Str("fp", base58btc.encode(keyId)).Msg("decode");
      if (base58btc.encode(keyId) !== fprt) {
        throw this.ko.logger.Error().Str("fp", fprt).Str("keyId", base58btc.encode(keyId)).Msg("keyId mismatch").AsError();
      }
      const result = await this.ko._decrypt({ iv, bytes: data });
      if (!this.opts?.noIVVerify && !await getGenerateIVFn(this.ko.url, this.opts).verify(this.ko, this.ko.crypto, iv, result)) {
        throw this.ko.logger.Error().Msg("iv missmatch").AsError();
      }
      return result;
    }
  };
  var keyedCrypto = class {
    constructor(url, key, cyopt, sthis) {
      this.ivLength = 12;
      this.isEncrypting = true;
      this.logger = ensureLogger(sthis, "keyedCrypto");
      this.crypto = cyopt;
      this.key = key;
      this.url = url;
    }
    fingerPrint() {
      return Promise.resolve(this.key.fingerPrint);
    }
    codec(iv, opts) {
      return new BlockIvKeyIdCodec(this, iv, opts);
    }
    algo(iv) {
      return {
        name: "AES-GCM",
        iv: iv || this.crypto.randomBytes(this.ivLength),
        tagLength: 128
      };
    }
    async _decrypt(data) {
      this.logger.Debug().Len(data.bytes, "bytes").Len(data.iv, "iv").Str("fp", this.key.fingerPrint).Msg("decrypting");
      return new Uint8Array(await this.crypto.decrypt(this.algo(data.iv), this.key.key, data.bytes));
    }
    async _encrypt(data) {
      this.logger.Debug().Len(data.bytes).Str("fp", this.key.fingerPrint).Msg("encrypting");
      const a7 = this.algo(data.iv);
      return new Uint8Array(await this.crypto.encrypt(a7, this.key.key, data.bytes));
    }
  };
  var nullCodec = class {
    constructor() {
      this.code = 0;
      this.name = "Fireproof@unencrypted-block";
    }
    encode(data) {
      return data;
    }
    decode(data) {
      return data;
    }
  };
  var noCrypto = class {
    constructor(url, cyrt, sthis) {
      this.ivLength = 0;
      this.code = 0;
      this.name = "Fireproof@unencrypted-block";
      this.isEncrypting = false;
      this._fingerPrint = "noCrypto:" + Math.random();
      this.logger = ensureLogger(sthis, "noCrypto");
      this.crypto = cyrt;
      this.url = url;
    }
    fingerPrint() {
      return Promise.resolve(this._fingerPrint);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    codec(iv) {
      return new nullCodec();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    algo(iv) {
      return {
        name: "noCrypto",
        iv: new Uint8Array(),
        tagLength: 0
      };
    }
    _decrypt() {
      throw this.logger.Error().Msg("noCrypto.decrypt not implemented").AsError();
    }
    _encrypt() {
      throw this.logger.Error().Msg("noCrypto.decrypt not implemented").AsError();
    }
  };
  async function keyedCryptoFactory(url, kb, sthis) {
    const storekey = url.getParam("storekey");
    if (storekey && storekey !== "insecure") {
      let rkey = await kb.getNamedKey(storekey, true);
      if (rkey.isErr()) {
        try {
          rkey = await kb.toKeyWithFingerPrint(storekey);
        } catch (e9) {
          throw sthis.logger.Error().Err(e9).Str("keybag", kb.rt.id()).Str("name", storekey).Msg("getNamedKey failed").AsError();
        }
      }
      return new keyedCrypto(url, rkey.Ok(), kb.rt.crypto, sthis);
    }
    return new noCrypto(url, kb.rt.crypto, sthis);
  }
  function getFragSize(url) {
    const fragSize = url.getParam("fragSize");
    let ret = 0;
    if (fragSize) {
      ret = parseInt(fragSize);
    }
    if (isNaN(ret) || ret <= 0) {
      ret = 0;
    }
    return ret;
  }
  async function getFrags(url, innerGW, headerSize, logger) {
    const fragSize = getFragSize(url);
    if (!fragSize) {
      const res = await innerGW.get(url);
      if (res.isErr()) {
        return [res];
      }
      const data = res.unwrap();
      return [
        Result.Ok({
          fid: new Uint8Array(0),
          ofs: 0,
          len: data.length,
          data
        })
      ];
    }
    const firstRaw = await innerGW.get(url.build().setParam("ofs", "0").URI());
    if (firstRaw.isErr()) {
      return [firstRaw];
    }
    const firstFragment = decode15(firstRaw.unwrap());
    const blockSize = firstFragment.data.length;
    const ops = [Promise.resolve(Result.Ok(firstFragment))];
    const fidStr = base58btc.encode(firstFragment.fid);
    const fragUrl = url.build().setParam("fid", fidStr).setParam("len", firstFragment.len.toString()).setParam("headerSize", headerSize.toString());
    for (let ofs = blockSize; ofs < firstFragment.len; ofs += blockSize) {
      ops.push(
        (async (furl, ofs2) => {
          const raw2 = await innerGW.get(furl);
          if (raw2.isErr()) {
            return raw2;
          }
          const fragment = decode15(raw2.unwrap());
          if (base58btc.encode(fragment.fid) !== fidStr) {
            return Result.Err(logger.Error().Msg("Fragment fid mismatch").AsError());
          }
          if (fragment.ofs !== ofs2) {
            return Result.Err(logger.Error().Uint64("ofs", ofs2).Msg("Fragment ofs mismatch").AsError());
          }
          return Result.Ok(fragment);
        })(fragUrl.setParam("ofs", ofs.toString()).URI(), ofs)
      );
    }
    return Promise.all(ops);
  }
  var FragmentGateway = class {
    constructor(sthis, innerGW) {
      this.fidLength = 4;
      this.headerSize = 32;
      this.sthis = ensureSuperLog(sthis, "FragmentGateway");
      this.logger = this.sthis.logger;
      this.innerGW = innerGW;
    }
    slicer(url, body) {
      const fragSize = getFragSize(url);
      if (!fragSize) {
        return [this.innerGW.put(url, body)];
      }
      const blocksize = fragSize - this.headerSize;
      if (blocksize <= 0) {
        throw this.logger.Error().Uint64("fragSize", fragSize).Uint64("headerSize", this.headerSize).Msg("Fragment size is too small").AsError();
      }
      const ops = [];
      const fid = this.sthis.nextId(this.fidLength);
      const fragUrl = url.build().setParam("fid", fid.str).setParam("len", body.length.toString()).setParam("headerSize", this.headerSize.toString());
      for (let ofs = 0; ofs < body.length; ofs += blocksize) {
        const block = encode11({
          fid: fid.bin,
          ofs,
          len: body.length,
          data: body.slice(ofs, ofs + blocksize)
        });
        if (block.length > fragSize) {
          throw this.logger.Error().Uint64("block", block.length).Uint64("fragSize", fragSize).Msg("Block size to big").AsError();
        }
        ops.push(this.innerGW.put(fragUrl.setParam("ofs", ofs.toString()).URI(), block));
      }
      return ops;
    }
    buildUrl(baseUrl, key) {
      return this.innerGW.buildUrl(baseUrl, key);
    }
    async destroy(iurl) {
      return this.innerGW.destroy(iurl);
    }
    async start(url) {
      this.headerSize = encode11({
        fid: this.sthis.nextId(this.fidLength).bin,
        ofs: 1024 * 1024,
        // 32bit
        len: 16 * 1024 * 1024,
        // 32bit
        data: new Uint8Array(1024)
      }).length - 1024;
      return this.innerGW.start(url);
    }
    async close(url) {
      return this.innerGW.close(url);
    }
    async put(url, body) {
      await Promise.all(this.slicer(url, body));
      return Result.Ok(void 0);
    }
    async get(url) {
      const rfrags = await getFrags(url, this.innerGW, this.headerSize, this.logger);
      let buffer4 = void 0;
      for (const rfrag of rfrags) {
        if (rfrag.isErr()) {
          return Result.Err(rfrag.Err());
        }
        const frag = rfrag.Ok();
        buffer4 = buffer4 || new Uint8Array(frag.len);
        buffer4.set(frag.data, frag.ofs);
      }
      return Result.Ok(buffer4 || new Uint8Array(0));
    }
    async subscribe(url, callback) {
      if (this.innerGW.subscribe) {
        return this.innerGW.subscribe(url, callback);
      } else {
        let lastData = void 0;
        let interval = 100;
        const fetchData = async () => {
          const result = await this.innerGW.get(url);
          if (result.isOk()) {
            const data = result.Ok();
            if (!lastData || !data.every((value, index2) => lastData && value === lastData[index2])) {
              lastData = data;
              callback(data);
              interval = 100;
            } else {
              interval *= 2;
            }
          }
          timeoutId = setTimeout(fetchData, interval);
        };
        let timeoutId = setTimeout(fetchData, interval);
        return Result.Ok(() => {
          clearTimeout(timeoutId);
        });
      }
    }
    async delete(url) {
      const rfrags = await getFrags(url, this.innerGW, this.headerSize, this.logger);
      for (const rfrag of rfrags) {
        if (rfrag.isErr()) {
          return Result.Err(rfrag.Err());
        }
        const frag = rfrag.Ok();
        const fidStr = base58btc.encode(frag.fid);
        const fragUrl = url.build().setParam("fid", fidStr).setParam("len", frag.len.toString()).setParam("headerSize", this.headerSize.toString()).URI();
        await this.innerGW.delete(fragUrl);
      }
      return Result.Ok(void 0);
    }
  };
  function guardVersion(url) {
    if (!url.hasParam("version")) {
      return Result.Err(`missing version: ${url.toString()}`);
    }
    return Result.Ok(url);
  }
  var BaseStoreImpl = class {
    constructor(name8, url, opts, sthis, logger) {
      this._onStarted = [];
      this._onClosed = [];
      this.name = name8;
      this._url = url;
      this.keybag = opts.keybag;
      this.sthis = sthis;
      this.logger = logger.With().Ref("url", () => this._url.toString()).Str("name", name8).Logger();
      this.gateway = new FragmentGateway(this.sthis, opts.gateway);
      this.loader = opts.loader;
    }
    url() {
      return this._url;
    }
    onStarted(fn) {
      this._onStarted.push(fn);
    }
    onClosed(fn) {
      this._onClosed.push(fn);
    }
    async keyedCrypto() {
      return keyedCryptoFactory(this._url, await this.keybag(), this.sthis);
    }
    async start() {
      this.logger.Debug().Str("storeType", this.storeType).Msg("starting-gateway-pre");
      this._url = this._url.build().setParam("store", this.storeType).URI();
      const res = await this.gateway.start(this._url);
      if (res.isErr()) {
        this.logger.Error().Result("gw-start", res).Msg("started-gateway");
        return res;
      }
      this._url = res.Ok();
      const kb = await this.keybag();
      const skRes = await kb.ensureKeyFromUrl(this._url, () => {
        const idx = this._url.getParam("index");
        const storeKeyName = [this.name];
        if (idx) {
          storeKeyName.push(idx);
        }
        storeKeyName.push(this.storeType);
        return storeKeyName.join(":");
      });
      if (skRes.isErr()) {
        return skRes;
      }
      this._url = skRes.Ok();
      const version2 = guardVersion(this._url);
      if (version2.isErr()) {
        this.logger.Error().Result("version", version2).Msg("guardVersion");
        await this.close();
        return version2;
      }
      if (this.ready) {
        const fn = this.ready.bind(this);
        const ready = await exception2Result(fn);
        if (ready.isErr()) {
          await this.close();
          return ready;
        }
      }
      this._onStarted.forEach((fn) => fn());
      this.logger.Debug().Msg("started");
      return version2;
    }
  };
  var DataStoreImpl = class extends BaseStoreImpl {
    // readonly tag: string = "car-base";
    constructor(sthis, name8, url, opts) {
      super(
        name8,
        url,
        {
          ...opts
        },
        sthis,
        ensureLogger(sthis, "DataStoreImpl")
      );
      this.storeType = "data";
    }
    async load(cid) {
      this.logger.Debug().Any("cid", cid).Msg("loading");
      const url = await this.gateway.buildUrl(this.url(), cid.toString());
      if (url.isErr()) {
        throw this.logger.Error().Err(url.Err()).Str("cid", cid.toString()).Msg("got error from gateway.buildUrl").AsError();
      }
      const res = await this.gateway.get(url.Ok());
      if (res.isErr()) {
        throw res.Err();
      }
      return { cid, bytes: res.Ok() };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async save(car, opts) {
      this.logger.Debug().Any("cid", car.cid.toString()).Msg("saving");
      const url = await this.gateway.buildUrl(this.url(), car.cid.toString());
      if (url.isErr()) {
        throw this.logger.Error().Err(url.Err()).Ref("cid", car.cid).Msg("got error from gateway.buildUrl").AsError();
      }
      const res = await this.gateway.put(url.Ok(), car.bytes);
      if (res.isErr()) {
        throw this.logger.Error().Err(res.Err()).Msg("got error from gateway.put").AsError();
      }
      return res.Ok();
    }
    async remove(cid) {
      const url = await this.gateway.buildUrl(this.url(), cid.toString());
      if (url.isErr()) {
        return url;
      }
      return this.gateway.delete(url.Ok());
    }
    async close() {
      await this.gateway.close(this.url());
      this._onClosed.forEach((fn) => fn());
      return Result.Ok(void 0);
    }
    destroy() {
      return this.gateway.destroy(this.url());
    }
  };
  var WALStoreImpl = class extends BaseStoreImpl {
    constructor(loader, url, opts) {
      super(
        loader.name,
        url,
        {
          ...opts
        },
        loader.sthis,
        ensureLogger(loader.sthis, "WALStoreImpl")
      );
      this.storeType = "wal";
      this._ready = new ResolveOnce();
      this.walState = { operations: [], noLoaderOps: [], fileOperations: [] };
      this.processing = void 0;
      this.processQueue = new CommitQueue();
      this.ready = async () => {
        return this._ready.once(async () => {
          const walState = await this.load().catch((e9) => {
            this.logger.Error().Any("error", e9).Msg("error loading wal");
            return void 0;
          });
          if (!walState) {
            this.walState.operations = [];
            this.walState.fileOperations = [];
          } else {
            this.walState.operations = walState.operations || [];
            this.walState.fileOperations = walState.fileOperations || [];
          }
        });
      };
      this.loader = loader;
    }
    async enqueue(dbMeta, opts) {
      await this.ready();
      if (opts.noLoader) {
        this.walState.noLoaderOps.push(dbMeta);
      } else {
        this.walState.operations.push(dbMeta);
      }
      await this.save(this.walState);
      void this.process();
    }
    async enqueueFile(fileCid, publicFile = false) {
      await this.ready();
      this.walState.fileOperations.push({ cid: fileCid, public: publicFile });
    }
    async process() {
      await this.ready();
      if (!this.loader.remoteCarStore) return;
      await this.processQueue.enqueue(async () => {
        try {
          await this._doProcess();
        } catch (e9) {
          this.logger.Error().Any("error", e9).Msg("error processing wal");
        }
        if (this.walState.operations.length || this.walState.fileOperations.length || this.walState.noLoaderOps.length) {
          setTimeout(() => void this.process(), 0);
        }
      });
    }
    async _doProcess() {
      if (!this.loader.remoteCarStore) return;
      const rmlp = (async () => {
        const operations = [...this.walState.operations];
        const fileOperations = [...this.walState.fileOperations];
        const uploads = [];
        const noLoaderOps = [...this.walState.noLoaderOps];
        const limit = pLimit(5);
        if (operations.length + fileOperations.length + noLoaderOps.length === 0) return;
        for (const dbMeta of noLoaderOps) {
          const uploadP = limit(async () => {
            for (const cid of dbMeta.cars) {
              const car = await (await this.loader.carStore()).load(cid);
              if (!car) {
                if (carLogIncludesGroup(this.loader.carLog, dbMeta.cars))
                  throw this.logger.Error().Ref("cid", cid).Msg("missing local car").AsError();
              } else {
                await throwFalsy(this.loader.remoteCarStore).save(car);
              }
              this.walState.noLoaderOps = this.walState.noLoaderOps.filter((op) => op !== dbMeta);
            }
          });
          uploads.push(uploadP);
        }
        for (const dbMeta of operations) {
          const uploadP = limit(async () => {
            for (const cid of dbMeta.cars) {
              const car = await (await this.loader.carStore()).load(cid).catch(() => null);
              if (!car) {
                if (carLogIncludesGroup(this.loader.carLog, dbMeta.cars))
                  throw this.logger.Error().Ref("cid", cid).Msg(`missing local car`).AsError();
              } else {
                await throwFalsy(this.loader.remoteCarStore).save(car);
              }
            }
            this.walState.operations = this.walState.operations.filter((op) => op !== dbMeta);
          });
          uploads.push(uploadP);
        }
        if (fileOperations.length) {
          const dbLoader = this.loader;
          for (const { cid: fileCid, public: publicFile } of fileOperations) {
            const uploadP = limit(async () => {
              const fileBlock = await (await dbLoader.fileStore()).load(fileCid);
              await dbLoader.remoteFileStore?.save(fileBlock, { public: publicFile });
              this.walState.fileOperations = this.walState.fileOperations.filter((op) => op.cid !== fileCid);
            });
            uploads.push(uploadP);
          }
        }
        try {
          const res = await Promise.allSettled(uploads);
          const errors = res.filter((r9) => r9.status === "rejected");
          if (errors.length) {
            throw this.logger.Error().Any("errors", errors).Msg("error uploading").AsError();
          }
          if (operations.length) {
            const lastOp = operations[operations.length - 1];
            await this.loader.remoteMetaStore?.save(lastOp).catch((e9) => {
              this.walState.operations.push(lastOp);
              throw this.logger.Error().Any("error", e9).Msg("error saving remote meta").AsError();
            });
          }
        } finally {
          await this.save(this.walState);
        }
      })();
      await rmlp;
    }
    async load() {
      this.logger.Debug().Msg("loading");
      const filepath = await this.gateway.buildUrl(this.url(), "main");
      if (filepath.isErr()) {
        throw this.logger.Error().Err(filepath.Err()).Url(this.url()).Msg("error building url").AsError();
      }
      const bytes = await this.gateway.get(filepath.Ok());
      if (bytes.isErr()) {
        if (isNotFoundError(bytes)) {
          return void 0;
        }
        throw this.logger.Error().Err(bytes.Err()).Msg("error get").AsError();
      }
      try {
        return bytes && parse6(this.sthis.txt.decode(bytes.Ok()));
      } catch (e9) {
        throw this.logger.Error().Err(e9).Msg("error parse").AsError();
      }
    }
    async save(state) {
      const filepath = await this.gateway.buildUrl(this.url(), "main");
      if (filepath.isErr()) {
        throw this.logger.Error().Err(filepath.Err()).Url(this.url()).Msg("error building url").AsError();
      }
      let encoded;
      try {
        encoded = format7(state);
      } catch (e9) {
        throw this.logger.Error().Err(e9).Any("state", state).Msg("error format").AsError();
      }
      const res = await this.gateway.put(filepath.Ok(), this.sthis.txt.encode(encoded));
      if (res.isErr()) {
        throw this.logger.Error().Err(res.Err()).Str("filePath", filepath.Ok().toString()).Msg("error saving").AsError();
      }
    }
    async close() {
      await this.gateway.close(this.url());
      this._onClosed.forEach((fn) => fn());
      return Result.Ok(void 0);
    }
    destroy() {
      return this.gateway.destroy(this.url());
    }
  };
  var runtime_exports = {};
  __export3(runtime_exports, {
    FILESTORE_VERSION: () => FILESTORE_VERSION,
    INDEXDB_VERSION: () => INDEXDB_VERSION,
    files: () => files_exports,
    getFileName: () => getFileName,
    getFileSystem: () => getFileSystem,
    getPath: () => getPath,
    kb: () => key_bag_exports,
    kc: () => keyed_crypto_exports,
    mf: () => wait_pr_multiformats_exports,
    runtimeFn: () => runtimeFn,
    toArrayBuffer: () => toArrayBuffer
  });
  var wait_pr_multiformats_exports = {};
  __export3(wait_pr_multiformats_exports, {
    block: () => block_exports,
    codec: () => codec_interface_exports
  });
  var codec_interface_exports = {};
  async function decodeGatewayMetaBytesToDbMeta(sthis, byteHeads) {
    const crdtEntries = JSON.parse(sthis.txt.decode(byteHeads));
    return Promise.all(
      crdtEntries.map(async (crdtEntry) => {
        const eventBlock = await decodeEventBlock(decodeFromBase64(crdtEntry.data));
        const dbMeta = parse6(sthis.txt.decode(eventBlock.value.data.dbMeta));
        return {
          eventCid: eventBlock.cid,
          parents: crdtEntry.parents,
          dbMeta
        };
      })
    );
  }
  async function setCryptoKeyFromGatewayMetaPayload(uri, sthis, data) {
    try {
      sthis.logger.Debug().Str("uri", uri.toString()).Msg("Setting crypto key from gateway meta payload");
      const keyInfo = await decodeGatewayMetaBytesToDbMeta(sthis, data);
      if (keyInfo.length) {
        const dbMeta = keyInfo[0].dbMeta;
        if (dbMeta.key) {
          const kb = await key_bag_exports.getKeyBag(sthis);
          const keyName = getStoreKeyName(uri);
          const res = await kb.setNamedKey(keyName, dbMeta.key);
          if (res.isErr()) {
            sthis.logger.Debug().Str("keyName", keyName).Str("dbMeta.key", dbMeta.key).Msg("Failed to set named key");
            throw res.Err();
          }
        }
        sthis.logger.Debug().Str("dbMeta.key", dbMeta.key).Str("uri", uri.toString()).Msg("Set crypto key from gateway meta payload");
        return Result.Ok(dbMeta);
      }
      sthis.logger.Debug().Str("data", new TextDecoder().decode(data)).Msg("No crypto in gateway meta payload");
      return Result.Ok(void 0);
    } catch (error) {
      sthis.logger.Debug().Err(error).Msg("Failed to set crypto key from gateway meta payload");
      return Result.Err(error);
    }
  }
  async function addCryptoKeyToGatewayMetaPayload(uri, sthis, body) {
    try {
      sthis.logger.Debug().Str("uri", uri.toString()).Msg("Adding crypto key to gateway meta payload");
      const keyName = getStoreKeyName(uri);
      const kb = await key_bag_exports.getKeyBag(sthis);
      const res = await kb.getNamedExtractableKey(keyName, true);
      if (res.isErr()) {
        sthis.logger.Error().Str("keyName", keyName).Msg("Failed to get named extractable key");
        throw res.Err();
      }
      const keyData = await res.Ok().extract();
      const dbMetas = await decodeGatewayMetaBytesToDbMeta(sthis, body);
      const { dbMeta, parents } = dbMetas[0];
      const parentLinks = parents.map((p7) => CID.parse(p7));
      dbMeta.key = keyData.keyStr;
      const events = await Promise.all([dbMeta].map((dbMeta2) => createDbMetaEventBlock(sthis, dbMeta2, parentLinks)));
      const encoded = await encodeEventsWithParents(sthis, events, parentLinks);
      sthis.logger.Debug().Str("uri", uri.toString()).Msg("Added crypto key to gateway meta payload");
      return Result.Ok(encoded);
    } catch (error) {
      sthis.logger.Error().Err(error).Msg("Failed to add crypto key to gateway meta payload");
      return Result.Err(error);
    }
  }
  function getStoreKeyName(url) {
    const storeKeyName = [url.getParam("localName") || url.getParam("name")];
    const idx = url.getParam("index");
    if (idx) {
      storeKeyName.push(idx);
    }
    storeKeyName.push("data");
    return `@${storeKeyName.join(":")}@`;
  }
  async function createDbMetaEventBlock(sthis, dbMeta, parents) {
    const event = await EventBlock.create(
      {
        dbMeta: sthis.txt.encode(format7(dbMeta))
      },
      parents
    );
    return event;
  }
  async function encodeEventsWithParents(sthis, events, parents) {
    const crdtEntries = events.map((event) => {
      const base64String = encodeToBase64(event.bytes);
      return {
        cid: event.cid.toString(),
        data: base64String,
        parents: parents.map((p7) => p7.toString())
      };
    });
    return sthis.txt.encode(JSON.stringify(crdtEntries));
  }
  var MetaStoreImpl = class extends BaseStoreImpl {
    constructor(sthis, name8, url, opts, remote) {
      super(
        name8,
        url,
        {
          ...opts
        },
        sthis,
        ensureLogger(sthis, "MetaStoreImpl")
      );
      this.storeType = "meta";
      this.subscribers = /* @__PURE__ */ new Map();
      this.parents = [];
      if (remote && opts.gateway.subscribe) {
        this.onStarted(async () => {
          this.logger.Debug().Str("url", this.url().toString()).Msg("Subscribing to the gateway");
          opts.gateway.subscribe?.(this.url(), async (message2) => {
            this.logger.Debug().Msg("Received message from gateway");
            const dbMetas = await decodeGatewayMetaBytesToDbMeta(this.sthis, message2);
            await Promise.all(
              dbMetas.map((dbMeta) => this.loader?.taskManager?.handleEvent(dbMeta.eventCid, dbMeta.parents, dbMeta.dbMeta))
            );
          });
        });
      }
    }
    async handleByteHeads(byteHeads) {
      return await decodeGatewayMetaBytesToDbMeta(this.sthis, byteHeads);
    }
    async load() {
      const branch = "main";
      const url = await this.gateway.buildUrl(this.url(), branch);
      if (url.isErr()) {
        throw this.logger.Error().Result("buildUrl", url).Str("branch", branch).Msg("got error from gateway.buildUrl").AsError();
      }
      const bytes = await this.gateway.get(url.Ok());
      if (bytes.isErr()) {
        if (isNotFoundError(bytes)) {
          return void 0;
        }
        throw this.logger.Error().Url(url.Ok()).Result("bytes:", bytes).Msg("gateway get").AsError();
      }
      const dbMetas = await this.handleByteHeads(bytes.Ok());
      await this.loader?.handleDbMetasFromStore(dbMetas.map((m6) => m6.dbMeta));
      const cids = dbMetas.map((m6) => m6.eventCid);
      const uniqueParentsMap = new Map([...this.parents, ...cids].map((p7) => [p7.toString(), p7]));
      this.parents = Array.from(uniqueParentsMap.values());
      return dbMetas.map((m6) => m6.dbMeta);
    }
    async save(meta, branch) {
      branch = branch || "main";
      this.logger.Debug().Str("branch", branch).Any("meta", meta).Msg("saving meta");
      const event = await createDbMetaEventBlock(this.sthis, meta, this.parents);
      const bytes = await encodeEventsWithParents(this.sthis, [event], this.parents);
      const url = await this.gateway.buildUrl(this.url(), branch);
      if (url.isErr()) {
        throw this.logger.Error().Err(url.Err()).Str("branch", branch).Msg("got error from gateway.buildUrl").AsError();
      }
      const res = await this.gateway.put(url.Ok(), bytes);
      if (res.isErr()) {
        throw this.logger.Error().Err(res.Err()).Msg("got error from gateway.put").AsError();
      }
      await this.loader?.handleDbMetasFromStore([meta]);
      this.parents = [event.cid];
      return res;
    }
    async close() {
      await this.gateway.close(this.url());
      this._onClosed.forEach((fn) => fn());
      return Result.Ok(void 0);
    }
    async destroy() {
      return this.gateway.destroy(this.url());
    }
  };
  function encodeToBase64(bytes) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let base643 = "";
    let i7;
    for (i7 = 0; i7 < bytes.length - 2; i7 += 3) {
      base643 += chars[bytes[i7] >> 2];
      base643 += chars[(bytes[i7] & 3) << 4 | bytes[i7 + 1] >> 4];
      base643 += chars[(bytes[i7 + 1] & 15) << 2 | bytes[i7 + 2] >> 6];
      base643 += chars[bytes[i7 + 2] & 63];
    }
    if (i7 < bytes.length) {
      base643 += chars[bytes[i7] >> 2];
      if (i7 === bytes.length - 1) {
        base643 += chars[(bytes[i7] & 3) << 4];
        base643 += "==";
      } else {
        base643 += chars[(bytes[i7] & 3) << 4 | bytes[i7 + 1] >> 4];
        base643 += chars[(bytes[i7 + 1] & 15) << 2];
        base643 += "=";
      }
    }
    return base643;
  }
  function decodeFromBase64(base643) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const bytes = new Uint8Array(base643.length * 3 / 4);
    let i7;
    let j4 = 0;
    for (i7 = 0; i7 < base643.length; i7 += 4) {
      const a7 = chars.indexOf(base643[i7]);
      const b5 = chars.indexOf(base643[i7 + 1]);
      const c7 = chars.indexOf(base643[i7 + 2]);
      const d6 = chars.indexOf(base643[i7 + 3]);
      bytes[j4++] = a7 << 2 | b5 >> 4;
      if (base643[i7 + 2] !== "=") {
        bytes[j4++] = (b5 & 15) << 4 | c7 >> 2;
      }
      if (base643[i7 + 3] !== "=") {
        bytes[j4++] = (c7 & 3) << 6 | d6;
      }
    }
    return bytes.slice(0, j4);
  }
  function ensureIsIndex(url, isIndex) {
    if (isIndex) {
      return url.build().setParam("index", isIndex).URI();
    }
    return url.build().delParam("index").URI();
  }
  function ensureName(name8, url) {
    if (!url.hasParam("name")) {
      return url.build().setParam("name", name8).URI();
    }
    return url;
  }
  var storeFactory = /* @__PURE__ */ new Map();
  function buildURL(optURL, loader) {
    const storeOpts = loader.ebOpts.store;
    const obuItem = Array.from(storeFactory.values()).find((items) => items.overrideBaseURL);
    let obuUrl;
    if (obuItem && obuItem.overrideBaseURL) {
      obuUrl = URI.from(obuItem.overrideBaseURL);
    }
    const ret = ensureIsIndex(
      URI.from(optURL || obuUrl || dataDir(loader.sthis, loader.name, storeOpts.stores?.base)),
      storeOpts.isIndex
    );
    return ret;
  }
  var onceGateway = new KeyedResolvOnce();
  async function getGatewayFromURL(url, sthis) {
    return onceGateway.get(url.toString()).once(async () => {
      const item = storeFactory.get(url.protocol);
      if (item) {
        const ret = {
          gateway: await item.gateway(sthis),
          test: await item.test(sthis)
        };
        const res = await ret.gateway.start(url);
        if (res.isErr()) {
          sthis.logger.Error().Result("start", res).Msg("start failed");
          return void 0;
        }
        return ret;
      }
      sthis.logger.Warn().Url(url).Msg("unsupported protocol");
      return void 0;
    });
  }
  function registerStoreProtocol(item) {
    let protocol = item.protocol;
    if (!protocol.endsWith(":")) {
      protocol += ":";
    }
    if (storeFactory.has(protocol)) {
      if (!item.overrideBaseURL && storeFactory.get(protocol) !== item) {
        throw new Error(`we need a logger here`);
        return () => {
        };
      }
    }
    if (item.overrideBaseURL) {
      Array.from(storeFactory.values()).forEach((items) => {
        items.overrideBaseURL = void 0;
      });
    }
    storeFactory.set(protocol, item);
    return () => {
      storeFactory.delete(protocol);
    };
  }
  var onceDataStoreFactory = new KeyedResolvOnce();
  async function dataStoreFactory(loader) {
    const url = ensureName(loader.name, buildURL(loader.ebOpts.store.stores?.data, loader)).build().setParam("store", "data").URI();
    const sthis = ensureSuperLog(loader.sthis, "dataStoreFactory", { url: url.toString() });
    return onceDataStoreFactory.get(url.toString()).once(async () => {
      const gateway = await getGatewayFromURL(url, sthis);
      if (!gateway) {
        throw sthis.logger.Error().Url(url).Msg("gateway not found").AsError();
      }
      const store = new DataStoreImpl(sthis, loader.name, url, {
        gateway: gateway.gateway,
        keybag: () => getKeyBag(loader.sthis, {
          ...loader.ebOpts.keyBag
        })
      });
      return store;
    });
  }
  var onceMetaStoreFactory = new KeyedResolvOnce();
  async function metaStoreFactory(loader) {
    const url = ensureName(loader.name, buildURL(loader.ebOpts.store.stores?.meta, loader)).build().setParam("store", "meta").URI();
    const sthis = ensureSuperLog(loader.sthis, "metaStoreFactory", { url: () => url.toString() });
    return onceMetaStoreFactory.get(url.toString()).once(async () => {
      sthis.logger.Debug().Str("protocol", url.protocol).Msg("pre-protocol switch");
      const gateway = await getGatewayFromURL(url, sthis);
      if (!gateway) {
        throw sthis.logger.Error().Url(url).Msg("gateway not found").AsError();
      }
      const store = new MetaStoreImpl(loader.sthis, loader.name, url, {
        gateway: gateway.gateway,
        keybag: () => getKeyBag(loader.sthis, {
          ...loader.ebOpts.keyBag
        })
      });
      return store;
    });
  }
  var onceRemoteWalFactory = new KeyedResolvOnce();
  async function remoteWalFactory(loader) {
    const url = ensureName(loader.name, buildURL(loader.ebOpts.store.stores?.wal, loader)).build().setParam("store", "wal").URI();
    const sthis = ensureSuperLog(loader.sthis, "remoteWalFactory", { url: url.toString() });
    return onceRemoteWalFactory.get(url.toString()).once(async () => {
      const gateway = await getGatewayFromURL(url, sthis);
      if (!gateway) {
        throw sthis.logger.Error().Url(url).Msg("gateway not found").AsError();
      }
      sthis.logger.Debug().Str("prepared", url.toString()).Msg("produced");
      const store = new WALStoreImpl(loader, url, {
        gateway: gateway.gateway,
        keybag: () => getKeyBag(loader.sthis, {
          ...loader.ebOpts.keyBag
        })
      });
      return store;
    });
  }
  async function testStoreFactory(url, sthis) {
    sthis = ensureSuperLog(sthis, "testStoreFactory");
    const gateway = await getGatewayFromURL(url, sthis);
    if (!gateway) {
      throw sthis.logger.Error().Url(url).Msg("gateway not found").AsError();
    }
    return gateway.test;
  }
  async function ensureStart(store, logger) {
    const ret = await store.start();
    if (ret.isErr()) {
      throw logger.Error().Result("start", ret).Msg("start failed").AsError();
    }
    logger.Debug().Url(ret.Ok(), "prepared").Msg("produced");
    return store;
  }
  function toStoreRuntime(opts, sthis) {
    const logger = ensureLogger(sthis, "toStoreRuntime", {});
    return {
      makeMetaStore: async (loader) => {
        logger.Debug().Str("fromOpts", "" + !!loader.ebOpts.store.makeMetaStore).Msg("makeMetaStore");
        return ensureStart(await (loader.ebOpts.store.makeMetaStore || metaStoreFactory)(loader), logger);
      },
      makeDataStore: async (loader) => {
        logger.Debug().Str("fromOpts", "" + !!loader.ebOpts.store.makeDataStore).Msg("makeDataStore");
        return ensureStart(await (loader.ebOpts.store.makeDataStore || dataStoreFactory)(loader), logger);
      },
      makeWALStore: async (loader) => {
        logger.Debug().Str("fromOpts", "" + !!loader.ebOpts.store.makeWALStore).Msg("makeRemoteWAL");
        return ensureStart(await (loader.ebOpts.store.makeWALStore || remoteWalFactory)(loader), logger);
      },
      encodeFile: opts.encodeFile || encodeFile2,
      decodeFile: opts.decodeFile || decodeFile
    };
  }
  registerStoreProtocol({
    protocol: "file:",
    gateway: async (sthis) => {
      const { FileGateway: FileGateway2 } = await Promise.resolve().then(() => (init_gateway_VWWKLHUI(), gateway_VWWKLHUI_exports));
      return new FileGateway2(sthis);
    },
    test: async (sthis) => {
      const { FileTestStore: FileTestStore2 } = await Promise.resolve().then(() => (init_gateway_VWWKLHUI(), gateway_VWWKLHUI_exports));
      return new FileTestStore2(sthis);
    }
  });
  registerStoreProtocol({
    protocol: "indexdb:",
    gateway: async (sthis) => {
      const { IndexDBGateway: IndexDBGateway2 } = await Promise.resolve().then(() => (init_gateway_7OM6OSYK(), gateway_7OM6OSYK_exports));
      return new IndexDBGateway2(sthis);
    },
    test: async (sthis) => {
      const { IndexDBTestStore: IndexDBTestStore2 } = await Promise.resolve().then(() => (init_gateway_7OM6OSYK(), gateway_7OM6OSYK_exports));
      return new IndexDBTestStore2(sthis);
    }
  });
  async function RemoteDataStore(sthis, name8, url, opts) {
    const ds = new DataStoreImpl(sthis, name8, url, opts);
    await ds.start();
    return ds;
  }
  async function RemoteMetaStore(sthis, name8, url, opts) {
    const ms = new MetaStoreImpl(sthis, name8, url, opts, true);
    await ms.start();
    return ms;
  }
  var ConnectionBase = class {
    constructor(url, logger) {
      this.loaded = Promise.resolve();
      this.logger = logger;
      this.url = url;
    }
    async refresh() {
      await throwFalsy(throwFalsy(this.loader).remoteMetaStore).load();
      await (await throwFalsy(this.loader).WALStore()).process();
    }
    async connect_X({ loader }) {
      if (!loader) throw this.logger.Error().Msg("loader is required").AsError();
      await this.connectMeta_X({ loader });
      await this.connectStorage_X({ loader });
    }
    async connectMeta_X({ loader }) {
      if (!loader) throw this.logger.Error().Msg("connectMeta_X: loader is required").AsError();
      this.loader = loader;
      await this.onConnect();
      const metaUrl = this.url.build().defParam("store", "meta").URI();
      const gateway = await getGatewayFromURL(metaUrl, this.loader.sthis);
      if (!gateway) throw this.logger.Error().Url(metaUrl).Msg("connectMeta_X: gateway is required").AsError();
      const dbName = metaUrl.getParam("name");
      if (!dbName) throw this.logger.Error().Url(metaUrl).Msg("connectMeta_X: name is required").AsError();
      const remote = await RemoteMetaStore(loader.sthis, dbName, metaUrl, {
        gateway: gateway.gateway,
        keybag: () => getKeyBag(loader.sthis, loader.ebOpts.keyBag),
        loader
      });
      this.loader.remoteMetaStore = remote;
      this.loaded = this.loader.ready().then(async () => {
        remote.load().then(async () => {
          (await throwFalsy(this.loader).WALStore()).process();
        });
      });
    }
    async connectStorage_X({ loader }) {
      if (!loader) throw this.logger.Error().Msg("connectStorage_X: loader is required").AsError();
      this.loader = loader;
      const dataUrl = this.url.build().defParam("store", "data").URI();
      const gateway = await getGatewayFromURL(dataUrl, this.loader.sthis);
      if (!gateway) throw this.logger.Error().Url(dataUrl).Msg("connectStorage_X: gateway is required").AsError();
      const name8 = dataUrl.getParam("name");
      if (!name8) throw this.logger.Error().Url(dataUrl).Msg("connectStorage_X: name is required").AsError;
      loader.remoteCarStore = await RemoteDataStore(loader.sthis, name8, this.url, {
        gateway: gateway.gateway,
        keybag: () => getKeyBag(loader.sthis, this.loader?.ebOpts.keyBag)
      });
      loader.remoteFileStore = loader.remoteCarStore;
    }
    // move this stuff to connect
    // async getDashboardURL(compact = true) {
    //   const baseUrl = 'https://dashboard.fireproof.storage/'
    //   if (!this.loader?.remoteCarStore) return new URL('/howto', baseUrl)
    //   // if (compact) {
    //   //   await this.compact()
    //   // }
    //   const currents = await this.loader?.metaStore?.load()
    //   if (!currents) throw new Error("Can't sync empty database: save data first")
    //   if (currents.length > 1)
    //     throw new Error("Can't sync database with split heads: make an update first")
    //   const current = currents[0]
    //   const params = {
    //     car: current.car.toString()
    //   }
    //   if (current.key) {
    //     // @ts-ignore
    //     params.key = current.key.toString()
    //   }
    //   // @ts-ignore
    //   if (this.name) {
    //     // @ts-ignore
    //     params.name = this.name
    //   }
    //   const url = new URL('/import#' + new URLSearchParams(params).toString(), baseUrl)
    //   console.log('Import to dashboard: ' + url.toString())
    //   return url
    // }
    // openDashboard() {
    //   void this.getDashboardURL().then(url => {
    //     if (url) window.open(url.toString(), '_blank')
    //   })
    // }
  };
  function time(tag2) {
  }
  function timeEnd(tag2) {
  }
  function toString5(key, logger) {
    switch (typeof key) {
      case "string":
      case "number":
        return key.toString();
      default:
        throw logger.Error().Msg("Invalid key type").AsError();
    }
  }
  async function applyBulkUpdateToCrdt(store, tblocks, head, updates, logger) {
    let result = null;
    if (updates.length > 1) {
      const batch2 = await create6(tblocks, head);
      for (const update2 of updates) {
        const link4 = await writeDocContent(store, tblocks, update2, logger);
        await batch2.put(toString5(update2.id, logger), link4);
      }
      result = await batch2.commit();
    } else if (updates.length === 1) {
      const link4 = await writeDocContent(store, tblocks, updates[0], logger);
      result = await put3(tblocks, head, toString5(updates[0].id, logger), link4);
    }
    if (!result) throw logger.Error().Uint64("updates.len", updates.length).Msg("Missing result").AsError();
    if (result.event) {
      for (const { cid, bytes } of [
        ...result.additions,
        // ...result.removals,
        result.event
      ]) {
        tblocks.putSync(cid, bytes);
      }
    }
    return { head: result.head };
  }
  async function writeDocContent(store, blocks, update2, logger) {
    let value;
    if (update2.del) {
      value = { del: true };
    } else {
      if (!update2.value) throw logger.Error().Msg("Missing value").AsError();
      await processFiles(store, blocks, update2.value, logger);
      value = { doc: update2.value };
    }
    const block = await encode17({ value, hasher: sha256, codec: src_exports });
    blocks.putSync(block.cid, block.bytes);
    return block.cid;
  }
  async function processFiles(store, blocks, doc, logger) {
    if (doc._files) {
      await processFileset(logger, store, blocks, doc._files);
    }
    if (doc._publicFiles) {
      await processFileset(
        logger,
        store,
        blocks,
        doc._publicFiles
        /*, true*/
      );
    }
  }
  async function processFileset(logger, store, blocks, files) {
    const dbBlockstore = blocks.parent;
    if (!dbBlockstore.loader) throw logger.Error().Msg("Missing loader, database name is required").AsError();
    const t8 = new CarTransaction(dbBlockstore);
    const didPut = [];
    for (const filename in files) {
      if (File === files[filename].constructor) {
        const file = files[filename];
        const { cid, blocks: fileBlocks } = await store.encodeFile(file);
        didPut.push(filename);
        for (const block of fileBlocks) {
          t8.putSync(block.cid, block.bytes);
        }
        files[filename] = { cid, type: file.type, size: file.size };
      } else {
        const { cid, type: type2, size, car } = files[filename];
        if (cid && type2 && size && car) {
          files[filename] = { cid, type: type2, size, car };
        }
      }
    }
    if (didPut.length) {
      const car = await dbBlockstore.loader.commitFiles(
        t8,
        { files }
      );
      if (car) {
        for (const name8 of didPut) {
          files[name8] = { car, ...files[name8] };
        }
      }
    }
  }
  async function getValueFromCrdt(blocks, head, key, logger) {
    if (!head.length) throw logger.Debug().Msg("Getting from an empty database").AsError();
    const link4 = await get4(blocks, head, key);
    if (!link4) throw logger.Error().Str("key", key).Msg(`Missing key`).AsError();
    return await getValueFromLink(blocks, link4, logger);
  }
  function readFiles(blocks, { doc }) {
    if (!doc) return;
    if (doc._files) {
      readFileset(blocks, doc._files);
    }
    if (doc._publicFiles) {
      readFileset(blocks, doc._publicFiles, true);
    }
  }
  function readFileset(blocks, files, isPublic = false) {
    for (const filename in files) {
      const fileMeta = files[filename];
      if (fileMeta.cid) {
        if (isPublic) {
          fileMeta.url = `https://${fileMeta.cid.toString()}.ipfs.w3s.link/`;
        }
        if (fileMeta.car) {
          fileMeta.file = async () => await blocks.ebOpts.storeRuntime.decodeFile(
            {
              get: async (cid) => {
                return await blocks.getFile(throwFalsy(fileMeta.car), cid);
              }
            },
            fileMeta.cid,
            fileMeta
          );
        }
      }
      files[filename] = fileMeta;
    }
  }
  async function getValueFromLink(blocks, link4, logger) {
    const block = await blocks.get(link4);
    if (!block) throw logger.Error().Str("link", link4.toString()).Msg(`Missing linked block`).AsError();
    const { value } = await decode20({ bytes: block.bytes, hasher: sha256, codec: src_exports });
    const cvalue = {
      ...value,
      cid: link4
    };
    readFiles(blocks, cvalue);
    return cvalue;
  }
  var DirtyEventFetcher = class extends EventFetcher {
    constructor(logger, blocks) {
      super(blocks);
      this.logger = logger;
    }
    async get(link4) {
      try {
        return super.get(link4);
      } catch (e9) {
        this.logger.Error().Ref("link", link4.toString()).Err(e9).Msg("Missing event");
        return { value: void 0 };
      }
    }
  };
  async function clockChangesSince(blocks, head, since, opts, logger) {
    const eventsFetcher = opts.dirty ? new DirtyEventFetcher(logger, blocks) : new EventFetcher(blocks);
    const keys = /* @__PURE__ */ new Set();
    const updates = await gatherUpdates(
      blocks,
      eventsFetcher,
      head,
      since,
      [],
      keys,
      /* @__PURE__ */ new Set(),
      opts.limit || Infinity,
      logger
    );
    return { result: updates.reverse(), head };
  }
  async function gatherUpdates(blocks, eventsFetcher, head, since, updates = [], keys, didLinks, limit, logger) {
    if (limit <= 0) return updates;
    const sHead = head.map((l7) => l7.toString());
    for (const link4 of since) {
      if (sHead.includes(link4.toString())) {
        return updates;
      }
    }
    for (const link4 of head) {
      if (didLinks.has(link4.toString())) continue;
      didLinks.add(link4.toString());
      const { value: event } = await eventsFetcher.get(link4);
      if (!event) continue;
      const { type: type2 } = event.data;
      let ops = [];
      if (type2 === "batch") {
        ops = event.data.ops;
      } else if (type2 === "put") {
        ops = [event.data];
      }
      for (let i7 = ops.length - 1; i7 >= 0; i7--) {
        const { key, value } = ops[i7];
        if (!keys.has(key)) {
          const docValue = await getValueFromLink(blocks, value, logger);
          updates.push({ id: key, value: docValue.doc, del: docValue.del, clock: link4 });
          limit--;
          keys.add(key);
        }
      }
      if (event.parents) {
        updates = await gatherUpdates(blocks, eventsFetcher, event.parents, since, updates, keys, didLinks, limit, logger);
      }
    }
    return updates;
  }
  async function* getAllEntries(blocks, head, logger) {
    for await (const [key, link4] of entries2(blocks, head)) {
      const docValue = await getValueFromLink(blocks, link4, logger);
      yield { id: key, value: docValue.doc, del: docValue.del };
    }
  }
  async function* clockVis(blocks, head) {
    for await (const line of vis(blocks, head)) {
      yield line;
    }
  }
  var isCompacting = false;
  async function doCompact(blockLog, head, logger) {
    if (isCompacting) {
      return;
    }
    isCompacting = true;
    time("compact head");
    for (const cid of head) {
      const bl = await blockLog.get(cid);
      if (!bl) throw logger.Error().Ref("cid", cid).Msg("Missing head block").AsError();
    }
    timeEnd("compact head");
    time("compact all entries");
    for await (const _entry of getAllEntries(blockLog, head, logger)) {
      continue;
    }
    timeEnd("compact all entries");
    time("compact clock vis");
    for await (const _line of vis(blockLog, head)) {
    }
    timeEnd("compact clock vis");
    time("compact root");
    const result = await root(blockLog, head);
    timeEnd("compact root");
    time("compact root blocks");
    for (const { cid, bytes } of [...result.additions, ...result.removals]) {
      blockLog.loggedBlocks.putSync(cid, bytes);
    }
    timeEnd("compact root blocks");
    time("compact changes");
    await clockChangesSince(blockLog, head, [], {}, logger);
    timeEnd("compact changes");
    isCompacting = false;
  }
  async function getBlock(blocks, cidString) {
    const block = await blocks.get(parse4(cidString));
    if (!block) throw new Error(`Missing block ${cidString}`);
    const { cid, value } = await decode20({ bytes: block.bytes, codec: src_exports, hasher: sha256 });
    return new Block3({ cid, value, bytes: block.bytes });
  }
  var IndexTree = class {
  };
  function refCompare2(aRef, bRef) {
    if (Number.isNaN(aRef)) return -1;
    if (Number.isNaN(bRef)) throw new Error("ref may not be Infinity or NaN");
    if (aRef === Infinity) return 1;
    return simpleCompare(aRef, bRef);
  }
  function compare4(a7, b5) {
    const [aKey, aRef] = a7;
    const [bKey, bRef] = b5;
    const comp = simpleCompare(aKey, bKey);
    if (comp !== 0) return comp;
    return refCompare2(aRef, bRef);
  }
  var byKeyOpts = { cache: nocache, chunker: bf(30), codec: src_exports, hasher: sha256, compare: compare4 };
  var byIdOpts = { cache: nocache, chunker: bf(30), codec: src_exports, hasher: sha256, compare: simpleCompare };
  function indexEntriesForChanges(changes, mapFn) {
    const indexEntries = [];
    changes.forEach(({ id: key, value, del: del2 }) => {
      if (del2 || !value) return;
      let mapCalled = false;
      const mapReturn = mapFn({ ...value, _id: key }, (k4, v6) => {
        mapCalled = true;
        if (typeof k4 === "undefined") return;
        indexEntries.push({
          key: [import_charwise.default.encode(k4), key],
          value: v6 || null
        });
      });
      if (!mapCalled && mapReturn) {
        indexEntries.push({
          key: [import_charwise.default.encode(mapReturn), key],
          value: null
        });
      }
    });
    return indexEntries;
  }
  function makeProllyGetBlock(blocks) {
    return async (address) => {
      const block = await blocks.get(address);
      if (!block) throw new Error(`Missing block ${address.toString()}`);
      const { cid, bytes } = block;
      return create15({ cid, bytes, hasher: sha256, codec: src_exports });
    };
  }
  async function bulkIndex(tblocks, inIndex, indexEntries, opts) {
    if (!indexEntries.length) return inIndex;
    if (!inIndex.root) {
      if (!inIndex.cid) {
        let returnRootBlock = void 0;
        let returnNode = void 0;
        for await (const node of await create14({
          get: makeProllyGetBlock(tblocks),
          list: indexEntries,
          ...opts
        })) {
          const block = await node.block;
          await tblocks.put(block.cid, block.bytes);
          returnRootBlock = block;
          returnNode = node;
        }
        if (!returnNode || !returnRootBlock) throw new Error("failed to create index");
        return { root: returnNode, cid: returnRootBlock.cid };
      } else {
        inIndex.root = await load2({ cid: inIndex.cid, get: makeProllyGetBlock(tblocks), ...opts });
      }
    }
    const { root: root3, blocks: newBlocks } = await inIndex.root.bulk(indexEntries);
    if (root3) {
      for await (const block of newBlocks) {
        await tblocks.put(block.cid, block.bytes);
      }
      return { root: root3, cid: (await root3.block).cid };
    } else {
      return { root: void 0, cid: void 0 };
    }
  }
  async function loadIndex(tblocks, cid, opts) {
    return await load2({ cid, get: makeProllyGetBlock(tblocks), ...opts });
  }
  async function applyQuery(crdt, resp, query) {
    if (query.descending) {
      resp.result = resp.result.reverse();
    }
    if (query.limit) {
      resp.result = resp.result.slice(0, query.limit);
    }
    if (query.includeDocs) {
      resp.result = await Promise.all(
        resp.result.map(async (row) => {
          const val = await crdt.get(row.id);
          const doc = val ? { ...val.doc, _id: row.id } : void 0;
          return { ...row, doc };
        })
      );
    }
    return {
      rows: resp.result.map(({ key, ...row }) => {
        return {
          key: import_charwise.default.decode(key),
          ...row
        };
      })
    };
  }
  function encodeRange(range) {
    return [import_charwise.default.encode(range[0]), import_charwise.default.encode(range[1])];
  }
  function encodeKey(key) {
    return import_charwise.default.encode(key);
  }
  function index(sthis, { _crdt }, name8, mapFn, meta) {
    if (mapFn && meta) throw _crdt.logger.Error().Msg("cannot provide both mapFn and meta").AsError();
    if (mapFn && mapFn.constructor.name !== "Function") throw _crdt.logger.Error().Msg("mapFn must be a function").AsError();
    if (_crdt.indexers.has(name8)) {
      const idx = _crdt.indexers.get(name8);
      idx.applyMapFn(name8, mapFn, meta);
    } else {
      const idx = new Index(sthis, _crdt, name8, mapFn, meta);
      _crdt.indexers.set(name8, idx);
    }
    return _crdt.indexers.get(name8);
  }
  var Index = class {
    constructor(sthis, crdt, name8, mapFn, meta) {
      this.mapFnString = "";
      this.byKey = new IndexTree();
      this.byId = new IndexTree();
      this.includeDocsDefault = false;
      this.logger = ensureLogger(sthis, "Index");
      this.blockstore = crdt.indexBlockstore;
      this.crdt = crdt;
      this.applyMapFn(name8, mapFn, meta);
      this.name = name8;
      if (!(this.mapFnString || this.initError)) throw this.logger.Error().Msg("missing mapFnString").AsError();
    }
    ready() {
      return Promise.all([this.blockstore.ready(), this.crdt.ready()]).then(() => {
      });
    }
    close() {
      return Promise.all([this.blockstore.close(), this.crdt.close()]).then(() => {
      });
    }
    destroy() {
      return Promise.all([this.blockstore.destroy(), this.crdt.destroy()]).then(() => {
      });
    }
    applyMapFn(name8, mapFn, meta) {
      if (mapFn && meta) throw this.logger.Error().Msg("cannot provide both mapFn and meta").AsError();
      if (this.name && this.name !== name8) throw this.logger.Error().Msg("cannot change name").AsError();
      this.name = name8;
      try {
        if (meta) {
          if (this.indexHead && this.indexHead.map((c7) => c7.toString()).join() !== meta.head.map((c7) => c7.toString()).join()) {
            throw this.logger.Error().Msg("cannot apply different head meta").AsError();
          }
          if (this.mapFnString) {
            if (this.mapFnString !== meta.map) {
              this.logger.Warn().Msg(`cannot apply different mapFn meta: old mapFnString ${this.mapFnString} new mapFnString ${meta.map}`);
            } else {
              this.byId.cid = meta.byId;
              this.byKey.cid = meta.byKey;
              this.indexHead = meta.head;
            }
          } else {
            this.mapFnString = meta.map;
            this.byId.cid = meta.byId;
            this.byKey.cid = meta.byKey;
            this.indexHead = meta.head;
          }
        } else {
          if (this.mapFn) {
            if (mapFn) {
              if (this.mapFn.toString() !== mapFn.toString()) {
                throw this.logger.Error().Msg("cannot apply different mapFn app2").AsError();
              }
            }
          } else {
            if (!mapFn) {
              mapFn = (doc) => doc[name8] ?? void 0;
            }
            if (this.mapFnString) {
              if (this.mapFnString !== mapFn.toString()) {
                throw this.logger.Error().Str("mapFnString", this.mapFnString).Str("mapFn", mapFn.toString()).Msg("cannot apply different mapFn app").AsError();
              }
            } else {
              this.mapFnString = mapFn.toString();
            }
            this.mapFn = mapFn;
          }
        }
        const matches = /=>\s*(.*)/.test(this.mapFnString);
        this.includeDocsDefault = matches;
      } catch (e9) {
        this.initError = e9;
      }
    }
    async query(opts = {}) {
      await this.ready();
      await this._updateIndex();
      await this._hydrateIndex();
      if (!this.byKey.root) {
        return await applyQuery(this.crdt, { result: [] }, opts);
      }
      if (this.includeDocsDefault && opts.includeDocs === void 0) opts.includeDocs = true;
      if (opts.range) {
        const eRange = encodeRange(opts.range);
        return await applyQuery(this.crdt, await throwFalsy(this.byKey.root).range(eRange[0], eRange[1]), opts);
      }
      if (opts.key) {
        const encodedKey = encodeKey(opts.key);
        return await applyQuery(this.crdt, await throwFalsy(this.byKey.root).get(encodedKey), opts);
      }
      if (Array.isArray(opts.keys)) {
        const results = await Promise.all(
          opts.keys.map(async (key) => {
            const encodedKey = encodeKey(key);
            return (await applyQuery(this.crdt, await throwFalsy(this.byKey.root).get(encodedKey), opts)).rows;
          })
        );
        return { rows: results.flat() };
      }
      if (opts.prefix) {
        if (!Array.isArray(opts.prefix)) opts.prefix = [opts.prefix];
        const start = [...opts.prefix, NaN];
        const end = [...opts.prefix, Infinity];
        const encodedR = encodeRange([start, end]);
        return await applyQuery(this.crdt, await this.byKey.root.range(...encodedR), opts);
      }
      const all = await this.byKey.root.getAllEntries();
      return await applyQuery(
        this.crdt,
        {
          // @ts-expect-error getAllEntries returns a different type than range
          result: all.result.map(({ key: [k4, id], value }) => ({
            key: k4,
            id,
            value
          }))
        },
        opts
      );
    }
    _resetIndex() {
      this.byId = new IndexTree();
      this.byKey = new IndexTree();
      this.indexHead = void 0;
    }
    async _hydrateIndex() {
      if (this.byId.root && this.byKey.root) return;
      if (!this.byId.cid || !this.byKey.cid) return;
      this.byId.root = await loadIndex(this.blockstore, this.byId.cid, byIdOpts);
      this.byKey.root = await loadIndex(this.blockstore, this.byKey.cid, byKeyOpts);
    }
    async _updateIndex() {
      await this.ready();
      if (this.initError) throw this.initError;
      if (!this.mapFn) throw this.logger.Error().Msg("No map function defined").AsError();
      let result, head;
      if (!this.indexHead || this.indexHead.length === 0) {
        ({ result, head } = await this.crdt.allDocs());
      } else {
        ({ result, head } = await this.crdt.changes(this.indexHead));
      }
      if (result.length === 0) {
        this.indexHead = head;
      }
      let staleKeyIndexEntries = [];
      let removeIdIndexEntries = [];
      if (this.byId.root) {
        const removeIds = result.map(({ id: key }) => key);
        const { result: oldChangeEntries } = await this.byId.root.getMany(removeIds);
        staleKeyIndexEntries = oldChangeEntries.map((key) => ({ key, del: true }));
        removeIdIndexEntries = oldChangeEntries.map((key) => ({ key: key[1], del: true }));
      }
      const indexEntries = indexEntriesForChanges(result, this.mapFn);
      const byIdIndexEntries = indexEntries.map(({ key }) => ({
        key: key[1],
        value: key
      }));
      const indexerMeta = { indexes: /* @__PURE__ */ new Map() };
      for (const [name8, indexer] of this.crdt.indexers) {
        if (indexer.indexHead) {
          indexerMeta.indexes?.set(name8, {
            byId: indexer.byId.cid,
            byKey: indexer.byKey.cid,
            head: indexer.indexHead,
            map: indexer.mapFnString,
            name: indexer.name
          });
        }
      }
      if (result.length === 0) {
        return indexerMeta;
      }
      const { meta } = await this.blockstore.transaction(async (tblocks) => {
        this.byId = await bulkIndex(tblocks, this.byId, removeIdIndexEntries.concat(byIdIndexEntries), byIdOpts);
        this.byKey = await bulkIndex(tblocks, this.byKey, staleKeyIndexEntries.concat(indexEntries), byKeyOpts);
        this.indexHead = head;
        if (this.byId.cid && this.byKey.cid) {
          const idxMeta = {
            byId: this.byId.cid,
            byKey: this.byKey.cid,
            head,
            map: this.mapFnString,
            name: this.name
          };
          indexerMeta.indexes?.set(this.name, idxMeta);
        }
        return indexerMeta;
      });
      return meta;
    }
  };
  function applyHeadQueue(worker, logger) {
    const queue2 = [];
    let isProcessing = false;
    async function* process4() {
      if (isProcessing || queue2.length === 0) return;
      isProcessing = true;
      const allUpdates = [];
      try {
        while (queue2.length > 0) {
          queue2.sort((a7, b5) => b5.updates ? 1 : -1);
          const task = queue2.shift();
          if (!task) continue;
          await worker(task.newHead, task.prevHead, task.updates !== null).catch((e9) => {
            throw logger.Error().Err(e9).Msg("int_applyHead worker error").AsError();
          });
          if (task.updates) {
            allUpdates.push(...task.updates);
          }
          if (!queue2.some((t8) => t8.updates) || task.updates) {
            const allTasksHaveUpdates = queue2.every((task2) => task2.updates !== null);
            yield { updates: allUpdates, all: allTasksHaveUpdates };
            allUpdates.length = 0;
          }
        }
      } finally {
        isProcessing = false;
        const generator = process4();
        let result = await generator.next();
        while (!result.done) {
          result = await generator.next();
        }
      }
    }
    return {
      push(task) {
        queue2.push(task);
        return process4();
      },
      size() {
        return queue2.length;
      }
    };
  }
  var CRDTClock = class {
    constructor(blockstore) {
      this.head = [];
      this.zoomers = /* @__PURE__ */ new Set();
      this.watchers = /* @__PURE__ */ new Set();
      this.emptyWatchers = /* @__PURE__ */ new Set();
      this._ready = new ResolveOnce();
      this.blockstore = blockstore;
      this.logger = ensureLogger(blockstore.sthis, "CRDTClock");
      this.applyHeadQueue = applyHeadQueue(this.int_applyHead.bind(this), this.logger);
    }
    async ready() {
      return this._ready.once(async () => {
        await this.blockstore.ready();
      });
    }
    async close() {
      await this.blockstore.close();
    }
    setHead(head) {
      this.head = head;
    }
    async applyHead(newHead, prevHead, updates) {
      for await (const { updates: updatesAcc, all } of this.applyHeadQueue.push({
        newHead,
        prevHead,
        updates
      })) {
        return this.processUpdates(updatesAcc, all, prevHead);
      }
    }
    async processUpdates(updatesAcc, all, prevHead) {
      let internalUpdates = updatesAcc;
      if (this.watchers.size && !all) {
        const changes = await clockChangesSince(throwFalsy(this.blockstore), this.head, prevHead, {}, this.logger);
        internalUpdates = changes.result;
      }
      this.zoomers.forEach((fn) => fn());
      this.notifyWatchers(internalUpdates || []);
    }
    notifyWatchers(updates) {
      this.emptyWatchers.forEach((fn) => fn());
      this.watchers.forEach((fn) => fn(updates || []));
    }
    onTick(fn) {
      this.watchers.add(fn);
    }
    onTock(fn) {
      this.emptyWatchers.add(fn);
    }
    onZoom(fn) {
      this.zoomers.add(fn);
    }
    async int_applyHead(newHead, prevHead, localUpdates) {
      const ogHead = sortClockHead(this.head);
      newHead = sortClockHead(newHead);
      if (compareClockHeads(ogHead, newHead)) {
        return;
      }
      const ogPrev = sortClockHead(prevHead);
      if (compareClockHeads(ogHead, ogPrev)) {
        this.setHead(newHead);
        return;
      }
      const noLoader = !localUpdates;
      if (!this.blockstore) {
        throw this.logger.Error().Msg("missing blockstore").AsError();
      }
      await validateBlocks(this.logger, newHead, this.blockstore);
      const { meta } = await this.blockstore.transaction(
        async (tblocks) => {
          const advancedHead = await advanceBlocks(this.logger, newHead, tblocks, this.head);
          const result = await root(tblocks, advancedHead);
          for (const { cid, bytes } of [
            ...result.additions
            // ...result.removals
          ]) {
            tblocks.putSync(cid, bytes);
          }
          return { head: advancedHead };
        },
        { noLoader, add: false }
      );
      this.setHead(meta.head);
    }
  };
  function sortClockHead(clockHead) {
    return clockHead.sort((a7, b5) => a7.toString().localeCompare(b5.toString()));
  }
  async function validateBlocks(logger, newHead, blockstore) {
    if (!blockstore) throw logger.Error().Msg("missing blockstore");
    newHead.map(async (cid) => {
      const got = await blockstore.get(cid);
      if (!got) {
        throw logger.Error().Str("cid", cid.toString()).Msg("int_applyHead missing block").AsError();
      }
    });
  }
  function compareClockHeads(head1, head2) {
    return head1.toString() === head2.toString();
  }
  async function advanceBlocks(logger, newHead, tblocks, head) {
    for (const cid of newHead) {
      try {
        head = await advance(tblocks, head, cid);
      } catch (e9) {
        logger.Debug().Err(e9).Msg("failed to advance head");
        continue;
      }
    }
    return head;
  }
  var CRDT = class {
    constructor(sthis, name8, opts = {}) {
      this.indexers = /* @__PURE__ */ new Map();
      this.onceReady = new ResolveOnce();
      this.sthis = sthis;
      this.name = name8;
      this.logger = ensureLogger(sthis, "CRDT");
      this.opts = opts;
      this.blockstore = blockstoreFactory(sthis, {
        name: name8,
        applyMeta: async (meta) => {
          const crdtMeta = meta;
          if (!crdtMeta.head) throw this.logger.Error().Msg("missing head").AsError();
          await this.clock.applyHead(crdtMeta.head, []);
        },
        compact: async (blocks) => {
          await doCompact(blocks, this.clock.head, this.logger);
          return { head: this.clock.head };
        },
        autoCompact: this.opts.autoCompact || 100,
        store: { ...this.opts.store, isIndex: void 0 },
        public: this.opts.public,
        meta: this.opts.meta,
        threshold: this.opts.threshold
      });
      this.indexBlockstore = blockstoreFactory(sthis, {
        name: name8,
        applyMeta: async (meta) => {
          const idxCarMeta = meta;
          if (!idxCarMeta.indexes) throw this.logger.Error().Msg("missing indexes").AsError();
          for (const [name22, idx] of Object.entries(idxCarMeta.indexes)) {
            index(this.sthis, { _crdt: this }, name22, void 0, idx);
          }
        },
        store: { ...this.opts.store, isIndex: this.opts.store?.isIndex || "idx" },
        public: this.opts.public
      });
      this.clock = new CRDTClock(this.blockstore);
      this.clock.onZoom(() => {
        for (const idx of this.indexers.values()) {
          idx._resetIndex();
        }
      });
    }
    async bulk(updates) {
      await this.ready();
      const prevHead = [...this.clock.head];
      const done = await this.blockstore.transaction(async (blocks) => {
        const { head } = await applyBulkUpdateToCrdt(
          this.blockstore.ebOpts.storeRuntime,
          blocks,
          this.clock.head,
          updates,
          this.logger
        );
        updates = updates.map((dupdate) => {
          readFiles(this.blockstore, { doc: dupdate.value });
          return dupdate;
        });
        return { head };
      });
      await this.clock.applyHead(done.meta.head, prevHead, updates);
      return done.meta;
    }
    async ready() {
      return this.onceReady.once(async () => {
        try {
          await Promise.all([this.blockstore.ready(), this.indexBlockstore.ready(), this.clock.ready()]);
        } catch (e9) {
          const ee2 = e9;
          throw this.logger.Error().Err(e9).Msg(`CRDT is not ready: ${ee2.stack}`).AsError();
        }
      });
    }
    async close() {
      await Promise.all([this.blockstore.close(), this.indexBlockstore.close(), this.clock.close()]);
    }
    async destroy() {
      await Promise.all([this.blockstore.destroy(), this.indexBlockstore.destroy()]);
    }
    // if (snap) await this.clock.applyHead(crdtMeta.head, this.clock.head)
    async allDocs() {
      await this.ready();
      const result = [];
      for await (const entry of getAllEntries(this.blockstore, this.clock.head, this.logger)) {
        result.push(entry);
      }
      return { result, head: this.clock.head };
    }
    async vis() {
      await this.ready();
      const txt = [];
      for await (const line of clockVis(this.blockstore, this.clock.head)) {
        txt.push(line);
      }
      return txt.join("\n");
    }
    async getBlock(cidString) {
      await this.ready();
      return await getBlock(this.blockstore, cidString);
    }
    async get(key) {
      await this.ready();
      const result = await getValueFromCrdt(this.blockstore, this.clock.head, key, this.logger);
      if (result.del) return void 0;
      return result;
    }
    async changes(since = [], opts = {}) {
      await this.ready();
      return await clockChangesSince(this.blockstore, this.clock.head, since, opts, this.logger);
    }
    async compact() {
      const blocks = this.blockstore;
      return await blocks.compact();
    }
  };
  var Database = class {
    constructor(name8, opts) {
      this.opts = {};
      this._listening = false;
      this._listeners = /* @__PURE__ */ new Set();
      this._noupdate_listeners = /* @__PURE__ */ new Set();
      this._ready = new ResolveOnce();
      this.name = name8;
      this.opts = opts || this.opts;
      this.sthis = ensureSuperThis(this.opts);
      this.logger = ensureLogger(this.sthis, "Database");
      this._crdt = new CRDT(this.sthis, name8, this.opts);
      this.blockstore = this._crdt.blockstore;
      this._writeQueue = writeQueue(async (updates) => {
        return await this._crdt.bulk(updates);
      });
      this._crdt.clock.onTock(() => {
        this._no_update_notify();
      });
    }
    static {
      this.databases = /* @__PURE__ */ new Map();
    }
    async close() {
      await this.ready();
      await this._crdt.close();
      await this.blockstore.close();
    }
    async destroy() {
      await this.ready();
      await this._crdt.destroy();
      await this.blockstore.destroy();
    }
    async ready() {
      return this._ready.once(async () => {
        await this.sthis.start();
        await this._crdt.ready();
        await this.blockstore.ready();
      });
    }
    async get(id) {
      if (!id) throw this.logger.Error().Str("db", this.name).Msg(`Doc id is required`).AsError();
      await this.ready();
      this.logger.Debug().Str("id", id).Msg("get");
      const got = await this._crdt.get(id).catch((e9) => {
        throw new NotFoundError(`Not found: ${id} - ${e9.message}`);
      });
      if (!got) throw new NotFoundError(`Not found: ${id}`);
      const { doc } = got;
      return { ...doc, _id: id };
    }
    async put(doc) {
      await this.ready();
      this.logger.Debug().Str("id", doc._id).Msg("put");
      const { _id, ...value } = doc;
      const docId = _id || this.sthis.nextId().str;
      const result = await this._writeQueue.push({
        id: docId,
        value: {
          ...value,
          _id: docId
        }
      });
      return { id: docId, clock: result?.head, name: this.name };
    }
    async del(id) {
      await this.ready();
      this.logger.Debug().Str("id", id).Msg("del");
      const result = await this._writeQueue.push({ id, del: true });
      return { id, clock: result?.head, name: this.name };
    }
    async changes(since = [], opts = {}) {
      await this.ready();
      this.logger.Debug().Any("since", since).Any("opts", opts).Msg("changes");
      const { result, head } = await this._crdt.changes(since, opts);
      const rows = result.map(({ id: key, value, del: del2, clock }) => ({
        key,
        value: del2 ? { _id: key, _deleted: true } : { _id: key, ...value },
        clock
      }));
      return { rows, clock: head, name: this.name };
    }
    async allDocs(opts = {}) {
      await this.ready();
      this.logger.Debug().Msg("allDocs");
      const { result, head } = await this._crdt.allDocs();
      const rows = result.map(({ id: key, value, del: del2 }) => ({
        key,
        value: del2 ? { _id: key, _deleted: true } : { _id: key, ...value }
      }));
      return { rows, clock: head, name: this.name };
    }
    async allDocuments() {
      return this.allDocs();
    }
    subscribe(listener, updates) {
      this.logger.Debug().Bool("updates", updates).Msg("subscribe");
      if (updates) {
        if (!this._listening) {
          this._listening = true;
          this._crdt.clock.onTick((updates2) => {
            void this._notify(updates2);
          });
        }
        this._listeners.add(listener);
        return () => {
          this._listeners.delete(listener);
        };
      } else {
        this._noupdate_listeners.add(listener);
        return () => {
          this._noupdate_listeners.delete(listener);
        };
      }
    }
    // todo if we add this onto dbs in fireproof.ts then we can make index.ts a separate package
    async query(field, opts = {}) {
      await this.ready();
      this.logger.Debug().Any("field", field).Any("opts", opts).Msg("query");
      const _crdt = this._crdt;
      const idx = typeof field === "string" ? index(this.sthis, { _crdt }, field) : index(this.sthis, { _crdt }, makeName(field.toString()), field);
      return await idx.query(opts);
    }
    async compact() {
      await this.ready();
      await this._crdt.compact();
    }
    async _notify(updates) {
      await this.ready();
      if (this._listeners.size) {
        const docs = updates.map(({ id, value }) => ({ ...value, _id: id }));
        for (const listener of this._listeners) {
          await (async () => await listener(docs))().catch((e9) => {
            this.logger.Error().Err(e9).Msg("subscriber error");
          });
        }
      }
    }
    async _no_update_notify() {
      await this.ready();
      if (this._noupdate_listeners.size) {
        for (const listener of this._noupdate_listeners) {
          await (async () => await listener([]))().catch((e9) => {
            this.logger.Error().Err(e9).Msg("subscriber error");
          });
        }
      }
    }
  };
  function makeName(fnString) {
    const regex = /\(([^,()]+,\s*[^,()]+|\[[^\]]+\],\s*[^,()]+)\)/g;
    let found = null;
    const matches = Array.from(fnString.matchAll(regex), (match) => match[1].trim());
    if (matches.length === 0) {
      found = /=>\s*{?\s*([^{}]+)\s*}?/.exec(fnString);
      if (found && found[1].includes("return")) {
        found = null;
      }
    }
    if (!found) {
      return fnString;
    } else {
      return found[1];
    }
  }
  var PACKAGE_VERSION = Object.keys({
    "0.0.0-smoke": "xxxx"
  })[0];

  // src/connection-from-store.ts
  var ConnectionFromStore = class extends blockstore_exports.ConnectionBase {
    constructor(sthis, url) {
      const logger = ensureLogger(sthis, "ConnectionFromStore", {
        url: () => url.toString(),
        this: 1,
        log: 1
      });
      super(url, logger);
      this.stores = void 0;
      this.sthis = sthis;
    }
    async onConnect() {
      this.logger.Debug().Msg("onConnect-start");
      const stores = {
        base: this.url
        // data: this.urlData,
        // meta: this.urlMeta,
      };
      const name8 = this.url.getParam("name");
      if (!name8) {
        throw this.logger.Error().Msg("name parameter is missing in the URL").AsError();
      }
      const storeRuntime = blockstore_exports.toStoreRuntime({ stores }, this.sthis);
      const loader = {
        name: name8,
        ebOpts: {
          logger: this.logger,
          store: { stores },
          storeRuntime
        },
        sthis: this.sthis
      };
      this.stores = {
        data: await storeRuntime.makeDataStore(loader),
        meta: await storeRuntime.makeMetaStore(loader)
      };
      this.logger.Debug().Msg("onConnect-done");
      return;
    }
  };
  function connectionFactory(sthis, iurl) {
    return new ConnectionFromStore(sthis, URI.from(iurl));
  }
  function makeKeyBagUrlExtractable(sthis) {
    let base3 = sthis.env.get("FP_KEYBAG_URL");
    if (!base3) {
      if (runtimeFn().isBrowser) {
        base3 = "indexdb://fp-keybag";
      } else {
        base3 = "file://./dist/kb-dir-partykit?fs=mem";
      }
    }
    const kbUrl = new URL(base3);
    kbUrl.searchParams.set("extractKey", "_deprecated_internal_api");
    sthis.env.set("FP_KEYBAG_URL", kbUrl.toString());
    sthis.logger.Debug().Str("keyBagUrl", kbUrl.toString()).Str("base", base3).Msg("Make keybag url extractable");
  }

  // src/partykit/gateway.ts
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/partysocket@1.0.2/node_modules/partysocket/dist/index.mjs
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/partysocket@1.0.2/node_modules/partysocket/dist/chunk-H3IJA3WK.mjs
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/.pnpm/partysocket@1.0.2/node_modules/partysocket/dist/chunk-4SNNYC7I.mjs
  init_dirname();
  init_buffer2();
  init_process2();
  if (!globalThis.EventTarget || !globalThis.Event) {
    console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);
  }
  var ErrorEvent = class extends Event {
    message;
    error;
    constructor(error, target) {
      super("error", target);
      this.message = error.message;
      this.error = error;
    }
  };
  var CloseEvent = class extends Event {
    code;
    reason;
    wasClean = true;
    constructor(code9 = 1e3, reason = "", target) {
      super("close", target);
      this.code = code9;
      this.reason = reason;
    }
  };
  var Events = {
    Event,
    ErrorEvent,
    CloseEvent
  };
  function assert2(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  function cloneEventBrowser(e9) {
    return new e9.constructor(e9.type, e9);
  }
  function cloneEventNode(e9) {
    if ("data" in e9) {
      const evt2 = new MessageEvent(e9.type, e9);
      return evt2;
    }
    if ("code" in e9 || "reason" in e9) {
      const evt2 = new CloseEvent(
        // @ts-expect-error we need to fix event/listener types
        e9.code || 1999,
        // @ts-expect-error we need to fix event/listener types
        e9.reason || "unknown reason",
        e9
      );
      return evt2;
    }
    if ("error" in e9) {
      const evt2 = new ErrorEvent(e9.error, e9);
      return evt2;
    }
    const evt = new Event(e9.type, e9);
    return evt;
  }
  var isNode2 = typeof process !== "undefined" && typeof process.versions?.node !== "undefined" && typeof document === "undefined";
  var cloneEvent = isNode2 ? cloneEventNode : cloneEventBrowser;
  var DEFAULT = {
    maxReconnectionDelay: 1e4,
    minReconnectionDelay: 1e3 + Math.random() * 4e3,
    minUptime: 5e3,
    reconnectionDelayGrowFactor: 1.3,
    connectionTimeout: 4e3,
    maxRetries: Infinity,
    maxEnqueuedMessages: Infinity,
    startClosed: false,
    debug: false
  };
  var didWarnAboutMissingWebSocket = false;
  var ReconnectingWebSocket = class _ReconnectingWebSocket extends EventTarget {
    _ws;
    _retryCount = -1;
    _uptimeTimeout;
    _connectTimeout;
    _shouldReconnect = true;
    _connectLock = false;
    _binaryType = "blob";
    _closeCalled = false;
    _messageQueue = [];
    _debugLogger = console.log.bind(console);
    _url;
    _protocols;
    _options;
    constructor(url, protocols, options = {}) {
      super();
      this._url = url;
      this._protocols = protocols;
      this._options = options;
      if (this._options.startClosed) {
        this._shouldReconnect = false;
      }
      if (this._options.debugLogger) {
        this._debugLogger = this._options.debugLogger;
      }
      this._connect();
    }
    static get CONNECTING() {
      return 0;
    }
    static get OPEN() {
      return 1;
    }
    static get CLOSING() {
      return 2;
    }
    static get CLOSED() {
      return 3;
    }
    get CONNECTING() {
      return _ReconnectingWebSocket.CONNECTING;
    }
    get OPEN() {
      return _ReconnectingWebSocket.OPEN;
    }
    get CLOSING() {
      return _ReconnectingWebSocket.CLOSING;
    }
    get CLOSED() {
      return _ReconnectingWebSocket.CLOSED;
    }
    get binaryType() {
      return this._ws ? this._ws.binaryType : this._binaryType;
    }
    set binaryType(value) {
      this._binaryType = value;
      if (this._ws) {
        this._ws.binaryType = value;
      }
    }
    /**
     * Returns the number or connection retries
     */
    get retryCount() {
      return Math.max(this._retryCount, 0);
    }
    /**
     * The number of bytes of data that have been queued using calls to send() but not yet
     * transmitted to the network. This value resets to zero once all queued data has been sent.
     * This value does not reset to zero when the connection is closed; if you keep calling send(),
     * this will continue to climb. Read only
     */
    get bufferedAmount() {
      const bytes = this._messageQueue.reduce((acc, message2) => {
        if (typeof message2 === "string") {
          acc += message2.length;
        } else if (message2 instanceof Blob) {
          acc += message2.size;
        } else {
          acc += message2.byteLength;
        }
        return acc;
      }, 0);
      return bytes + (this._ws ? this._ws.bufferedAmount : 0);
    }
    /**
     * The extensions selected by the server. This is currently only the empty string or a list of
     * extensions as negotiated by the connection
     */
    get extensions() {
      return this._ws ? this._ws.extensions : "";
    }
    /**
     * A string indicating the name of the sub-protocol the server selected;
     * this will be one of the strings specified in the protocols parameter when creating the
     * WebSocket object
     */
    get protocol() {
      return this._ws ? this._ws.protocol : "";
    }
    /**
     * The current state of the connection; this is one of the Ready state constants
     */
    get readyState() {
      if (this._ws) {
        return this._ws.readyState;
      }
      return this._options.startClosed ? _ReconnectingWebSocket.CLOSED : _ReconnectingWebSocket.CONNECTING;
    }
    /**
     * The URL as resolved by the constructor
     */
    get url() {
      return this._ws ? this._ws.url : "";
    }
    /**
     * Whether the websocket object is now in reconnectable state
     */
    get shouldReconnect() {
      return this._shouldReconnect;
    }
    /**
     * An event listener to be called when the WebSocket connection's readyState changes to CLOSED
     */
    onclose = null;
    /**
     * An event listener to be called when an error occurs
     */
    onerror = null;
    /**
     * An event listener to be called when a message is received from the server
     */
    onmessage = null;
    /**
     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
     * this indicates that the connection is ready to send and receive data
     */
    onopen = null;
    /**
     * Closes the WebSocket connection or connection attempt, if any. If the connection is already
     * CLOSED, this method does nothing
     */
    close(code9 = 1e3, reason) {
      this._closeCalled = true;
      this._shouldReconnect = false;
      this._clearTimeouts();
      if (!this._ws) {
        this._debug("close enqueued: no ws instance");
        return;
      }
      if (this._ws.readyState === this.CLOSED) {
        this._debug("close: already closed");
        return;
      }
      this._ws.close(code9, reason);
    }
    /**
     * Closes the WebSocket connection or connection attempt and connects again.
     * Resets retry counter;
     */
    reconnect(code9, reason) {
      this._shouldReconnect = true;
      this._closeCalled = false;
      this._retryCount = -1;
      if (!this._ws || this._ws.readyState === this.CLOSED) {
        this._connect();
      } else {
        this._disconnect(code9, reason);
        this._connect();
      }
    }
    /**
     * Enqueue specified data to be transmitted to the server over the WebSocket connection
     */
    send(data) {
      if (this._ws && this._ws.readyState === this.OPEN) {
        this._debug("send", data);
        this._ws.send(data);
      } else {
        const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;
        if (this._messageQueue.length < maxEnqueuedMessages) {
          this._debug("enqueue", data);
          this._messageQueue.push(data);
        }
      }
    }
    _debug(...args) {
      if (this._options.debug) {
        this._debugLogger("RWS>", ...args);
      }
    }
    _getNextDelay() {
      const {
        reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,
        minReconnectionDelay = DEFAULT.minReconnectionDelay,
        maxReconnectionDelay = DEFAULT.maxReconnectionDelay
      } = this._options;
      let delay = 0;
      if (this._retryCount > 0) {
        delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
        if (delay > maxReconnectionDelay) {
          delay = maxReconnectionDelay;
        }
      }
      this._debug("next delay", delay);
      return delay;
    }
    _wait() {
      return new Promise((resolve9) => {
        setTimeout(resolve9, this._getNextDelay());
      });
    }
    _getNextProtocols(protocolsProvider) {
      if (!protocolsProvider) return Promise.resolve(null);
      if (typeof protocolsProvider === "string" || Array.isArray(protocolsProvider)) {
        return Promise.resolve(protocolsProvider);
      }
      if (typeof protocolsProvider === "function") {
        const protocols = protocolsProvider();
        if (!protocols) return Promise.resolve(null);
        if (typeof protocols === "string" || Array.isArray(protocols)) {
          return Promise.resolve(protocols);
        }
        if (protocols.then) {
          return protocols;
        }
      }
      throw Error("Invalid protocols");
    }
    _getNextUrl(urlProvider) {
      if (typeof urlProvider === "string") {
        return Promise.resolve(urlProvider);
      }
      if (typeof urlProvider === "function") {
        const url = urlProvider();
        if (typeof url === "string") {
          return Promise.resolve(url);
        }
        if (url.then) {
          return url;
        }
      }
      throw Error("Invalid URL");
    }
    _connect() {
      if (this._connectLock || !this._shouldReconnect) {
        return;
      }
      this._connectLock = true;
      const {
        maxRetries = DEFAULT.maxRetries,
        connectionTimeout = DEFAULT.connectionTimeout
      } = this._options;
      if (this._retryCount >= maxRetries) {
        this._debug("max retries reached", this._retryCount, ">=", maxRetries);
        return;
      }
      this._retryCount++;
      this._debug("connect", this._retryCount);
      this._removeListeners();
      this._wait().then(
        () => Promise.all([
          this._getNextUrl(this._url),
          this._getNextProtocols(this._protocols || null)
        ])
      ).then(([url, protocols]) => {
        if (this._closeCalled) {
          this._connectLock = false;
          return;
        }
        if (!this._options.WebSocket && typeof WebSocket === "undefined" && !didWarnAboutMissingWebSocket) {
          console.error(`\u203C\uFE0F No WebSocket implementation available. You should define options.WebSocket. 

For example, if you're using node.js, run \`npm install ws\`, and then in your code:

import PartySocket from 'partysocket';
import WS from 'ws';

const partysocket = new PartySocket({
  host: "127.0.0.1:1999",
  room: "test-room",
  WebSocket: WS
});

`);
          didWarnAboutMissingWebSocket = true;
        }
        const WS = this._options.WebSocket || WebSocket;
        this._debug("connect", { url, protocols });
        this._ws = protocols ? new WS(url, protocols) : new WS(url);
        this._ws.binaryType = this._binaryType;
        this._connectLock = false;
        this._addListeners();
        this._connectTimeout = setTimeout(
          () => this._handleTimeout(),
          connectionTimeout
        );
      }).catch((err) => {
        this._connectLock = false;
        this._handleError(new Events.ErrorEvent(Error(err.message), this));
      });
    }
    _handleTimeout() {
      this._debug("timeout event");
      this._handleError(new Events.ErrorEvent(Error("TIMEOUT"), this));
    }
    _disconnect(code9 = 1e3, reason) {
      this._clearTimeouts();
      if (!this._ws) {
        return;
      }
      this._removeListeners();
      try {
        this._ws.close(code9, reason);
        this._handleClose(new Events.CloseEvent(code9, reason, this));
      } catch (error) {
      }
    }
    _acceptOpen() {
      this._debug("accept open");
      this._retryCount = 0;
    }
    _handleOpen = (event) => {
      this._debug("open event");
      const { minUptime = DEFAULT.minUptime } = this._options;
      clearTimeout(this._connectTimeout);
      this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);
      assert2(this._ws, "WebSocket is not defined");
      this._ws.binaryType = this._binaryType;
      this._messageQueue.forEach((message2) => this._ws?.send(message2));
      this._messageQueue = [];
      if (this.onopen) {
        this.onopen(event);
      }
      this.dispatchEvent(cloneEvent(event));
    };
    _handleMessage = (event) => {
      this._debug("message event");
      if (this.onmessage) {
        this.onmessage(event);
      }
      this.dispatchEvent(cloneEvent(event));
    };
    _handleError = (event) => {
      this._debug("error event", event.message);
      this._disconnect(
        void 0,
        event.message === "TIMEOUT" ? "timeout" : void 0
      );
      if (this.onerror) {
        this.onerror(event);
      }
      this._debug("exec error listeners");
      this.dispatchEvent(cloneEvent(event));
      this._connect();
    };
    _handleClose = (event) => {
      this._debug("close event");
      this._clearTimeouts();
      if (this._shouldReconnect) {
        this._connect();
      }
      if (this.onclose) {
        this.onclose(event);
      }
      this.dispatchEvent(cloneEvent(event));
    };
    _removeListeners() {
      if (!this._ws) {
        return;
      }
      this._debug("removeListeners");
      this._ws.removeEventListener("open", this._handleOpen);
      this._ws.removeEventListener("close", this._handleClose);
      this._ws.removeEventListener("message", this._handleMessage);
      this._ws.removeEventListener("error", this._handleError);
    }
    _addListeners() {
      if (!this._ws) {
        return;
      }
      this._debug("addListeners");
      this._ws.addEventListener("open", this._handleOpen);
      this._ws.addEventListener("close", this._handleClose);
      this._ws.addEventListener("message", this._handleMessage);
      this._ws.addEventListener("error", this._handleError);
    }
    _clearTimeouts() {
      clearTimeout(this._connectTimeout);
      clearTimeout(this._uptimeTimeout);
    }
  };

  // node_modules/.pnpm/partysocket@1.0.2/node_modules/partysocket/dist/chunk-H3IJA3WK.mjs
  var valueIsNotNil = (keyValuePair) => keyValuePair[1] !== null && keyValuePair[1] !== void 0;
  function generateUUID() {
    if (typeof crypto !== "undefined" && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    let d6 = (/* @__PURE__ */ new Date()).getTime();
    let d22 = typeof performance !== "undefined" && performance.now && performance.now() * 1e3 || 0;
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c7) {
      let r9 = Math.random() * 16;
      if (d6 > 0) {
        r9 = (d6 + r9) % 16 | 0;
        d6 = Math.floor(d6 / 16);
      } else {
        r9 = (d22 + r9) % 16 | 0;
        d22 = Math.floor(d22 / 16);
      }
      return (c7 === "x" ? r9 : r9 & 3 | 8).toString(16);
    });
  }
  function getPartyInfo(partySocketOptions, defaultProtocol, defaultParams = {}) {
    const {
      host: rawHost,
      path: rawPath,
      protocol: rawProtocol,
      room,
      party,
      prefix,
      query
    } = partySocketOptions;
    let host = rawHost.replace(/^(http|https|ws|wss):\/\//, "");
    if (host.endsWith("/")) {
      host = host.slice(0, -1);
    }
    if (rawPath && rawPath.startsWith("/")) {
      throw new Error("path must not start with a slash");
    }
    const name8 = party ?? "main";
    const path2 = rawPath ? `/${rawPath}` : "";
    const protocol = rawProtocol || (host.startsWith("localhost:") || host.startsWith("127.0.0.1:") || host.startsWith("192.168.") || host.startsWith("10.") || host.startsWith("172.") && host.split(".")[1] >= "16" && host.split(".")[1] <= "31" || host.startsWith("[::ffff:7f00:1]:") ? (
      // http / ws
      defaultProtocol
    ) : (
      // https / wss
      defaultProtocol + "s"
    ));
    const baseUrl = `${protocol}://${host}/${prefix || `parties/${name8}/${room}`}${path2}`;
    const makeUrl = (query2 = {}) => `${baseUrl}?${new URLSearchParams([
      ...Object.entries(defaultParams),
      ...Object.entries(query2).filter(valueIsNotNil)
    ])}`;
    const urlProvider = typeof query === "function" ? async () => makeUrl(await query()) : makeUrl(query);
    return {
      host,
      path: path2,
      room,
      name: name8,
      protocol,
      partyUrl: baseUrl,
      urlProvider
    };
  }
  var PartySocket = class extends ReconnectingWebSocket {
    constructor(partySocketOptions) {
      const wsOptions = getWSOptions(partySocketOptions);
      super(wsOptions.urlProvider, wsOptions.protocols, wsOptions.socketOptions);
      this.partySocketOptions = partySocketOptions;
      this.setWSProperties(wsOptions);
    }
    _pk;
    _pkurl;
    name;
    room;
    host;
    path;
    updateProperties(partySocketOptions) {
      const wsOptions = getWSOptions({
        ...this.partySocketOptions,
        ...partySocketOptions,
        host: partySocketOptions.host ?? this.host,
        room: partySocketOptions.room ?? this.room,
        path: partySocketOptions.path ?? this.path
      });
      this._url = wsOptions.urlProvider;
      this._protocols = wsOptions.protocols;
      this._options = wsOptions.socketOptions;
      this.setWSProperties(wsOptions);
    }
    setWSProperties(wsOptions) {
      const { _pk, _pkurl, name: name8, room, host, path: path2 } = wsOptions;
      this._pk = _pk;
      this._pkurl = _pkurl;
      this.name = name8;
      this.room = room;
      this.host = host;
      this.path = path2;
    }
    reconnect(code9, reason) {
      if (!this.room || !this.host) {
        throw new Error(
          "The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor."
        );
      }
      super.reconnect(code9, reason);
    }
    get id() {
      return this._pk;
    }
    /**
     * Exposes the static PartyKit room URL without applying query parameters.
     * To access the currently connected WebSocket url, use PartySocket#url.
     */
    get roomUrl() {
      return this._pkurl;
    }
    // a `fetch` method that uses (almost) the same options as `PartySocket`
    static async fetch(options, init3) {
      const party = getPartyInfo(options, "http");
      const url = typeof party.urlProvider === "string" ? party.urlProvider : await party.urlProvider();
      const doFetch = options.fetch ?? fetch;
      return doFetch(url, init3);
    }
  };
  function getWSOptions(partySocketOptions) {
    const {
      id,
      host: _host,
      path: _path,
      party: _party,
      room: _room,
      protocol: _protocol,
      query: _query,
      protocols,
      ...socketOptions
    } = partySocketOptions;
    const _pk = id || generateUUID();
    const party = getPartyInfo(partySocketOptions, "ws", { _pk });
    return {
      _pk,
      _pkurl: party.partyUrl,
      name: party.name,
      room: party.room,
      host: party.host,
      path: party.path,
      protocols,
      socketOptions,
      urlProvider: party.urlProvider
    };
  }

  // src/partykit/gateway.ts
  init_cement();
  var PartyKitGateway = class {
    constructor(sthis) {
      this.subscriberCallbacks = /* @__PURE__ */ new Set();
      this.sthis = sthis;
      this.id = sthis.nextId().str.toString();
      this.logger = ensureLogger(sthis, "PartyKitGateway", {
        url: () => this.url?.toString(),
        this: this.id
      });
      this.logger.Debug().Msg("constructor");
    }
    async buildUrl(baseUrl, key) {
      return Result.Ok(baseUrl.build().setParam("key", key).URI());
    }
    async start(uri) {
      this.logger.Debug().Msg("Starting PartyKitGateway with URI: " + uri.toString());
      await this.sthis.start();
      this.url = uri;
      const ret = uri.build().defParam("version", "v0.1-partykit").URI();
      let dbName = uri.getParam("name");
      if (!dbName) {
        this.logger.Error().Msg("Database name (name) parameter is missing in the URI");
        return Result.Err(this.logger.Error().Msg("name not found").AsError());
      }
      if (this.url.hasParam("index")) {
        dbName = dbName + "-idx";
      }
      const party = uri.getParam("party") || "fireproof";
      const proto = uri.getParam("protocol") || "wss";
      let possibleUndef = {};
      if (proto) {
        possibleUndef = { protocol: proto };
      }
      const protocolsStr = uri.getParam("protocols");
      if (protocolsStr) {
        const ps = protocolsStr.split(",").map((x4) => x4.trim()).filter((x4) => x4);
        if (ps.length > 0) {
          possibleUndef = { ...possibleUndef, protocols: ps };
        }
      }
      const prefixStr = uri.getParam("prefix");
      if (prefixStr) {
        possibleUndef = { ...possibleUndef, prefix: prefixStr };
      }
      const query = {};
      const partySockOpts = {
        id: this.id,
        host: this.url.host,
        room: dbName,
        party,
        ...possibleUndef,
        query,
        path: this.url.pathname.replace(/^\//, "")
      };
      if (runtimeFn().isNodeIsh) {
        const { WebSocket: WebSocket2 } = await Promise.resolve().then(() => __toESM(require_browser(), 1));
        partySockOpts.WebSocket = WebSocket2;
      }
      this.pso = partySockOpts;
      return Result.Ok(ret);
    }
    async ready() {
      this.logger.Debug().Msg("ready");
    }
    async connectPartyKit() {
      const pkKeyThis = pkKey(this.pso);
      return pkSockets.get(pkKeyThis).once(async () => {
        if (!this.pso) {
          throw new Error("Party socket options not found");
        }
        this.party = new PartySocket(this.pso);
        let exposedResolve;
        const openFn = () => {
          this.logger.Debug().Msg("party open");
          this.party?.addEventListener("message", async (event) => {
            this.logger.Debug().Msg(`got message: ${event.data}`);
            const enc = new TextEncoder();
            const mbin = enc.encode(event.data);
            this.notifySubscribers(mbin);
          });
          exposedResolve(true);
        };
        return await new Promise((resolve9) => {
          exposedResolve = resolve9;
          this.party?.addEventListener("open", openFn);
        });
      });
    }
    async close() {
      await this.ready();
      this.logger.Debug().Msg("close");
      this.party?.close();
      return Result.Ok(void 0);
    }
    async put(uri, body) {
      await this.ready();
      return exception2Result(async () => {
        const { store } = getStore(uri, this.sthis, (...args) => args.join("/"));
        if (store === "meta") {
          const bodyRes = await blockstore_exports.addCryptoKeyToGatewayMetaPayload(uri, this.sthis, body);
          if (bodyRes.isErr()) {
            this.logger.Error().Err(bodyRes.Err()).Msg("Error in addCryptoKeyToGatewayMetaPayload");
            throw bodyRes.Err();
          }
          body = bodyRes.Ok();
        }
        const key = uri.getParam("key");
        if (!key) throw new Error("key not found");
        const uploadUrl = store === "meta" ? pkMetaURL(uri, key) : pkCarURL(uri, key);
        const response = await fetch(uploadUrl.toString(), { method: "PUT", body });
        if (response.status === 404) {
          throw new Error(`Failure in uploading ${store}!`);
        }
      });
    }
    notifySubscribers(data) {
      for (const callback of this.subscriberCallbacks) {
        callback(data);
      }
    }
    async subscribe(uri, callback) {
      await this.ready();
      await this.connectPartyKit();
      return exception2Result(async () => {
        const store = uri.getParam("store");
        switch (store) {
          case "meta":
            this.subscriberCallbacks.add(callback);
            return Result.Ok(() => {
              this.subscriberCallbacks.delete(callback);
            });
          default:
            throw new Error("store must be meta");
        }
      });
    }
    async get(uri) {
      await this.ready();
      return exception2Result(async () => {
        const { store } = getStore(uri, this.sthis, (...args) => args.join("/"));
        const key = uri.getParam("key");
        if (!key) throw new Error("key not found");
        const downloadUrl = store === "meta" ? pkMetaURL(uri, key) : pkCarURL(uri, key);
        const response = await fetch(downloadUrl.toString(), { method: "GET" });
        if (response.status === 404) {
          throw new Error(`Failure in downloading ${store}!`);
        }
        const body = new Uint8Array(await response.arrayBuffer());
        if (store === "meta") {
          const resKeyInfo = await blockstore_exports.setCryptoKeyFromGatewayMetaPayload(uri, this.sthis, body);
          if (resKeyInfo.isErr()) {
            this.logger.Error().Err(resKeyInfo.Err()).Str("body", new TextDecoder().decode(body)).Msg("Error in setCryptoKeyFromGatewayMetaPayload");
            throw resKeyInfo.Err();
          }
        }
        return body;
      });
    }
    async delete(uri) {
      await this.ready();
      return exception2Result(async () => {
        const { store } = getStore(uri, this.sthis, (...args) => args.join("/"));
        const key = uri.getParam("key");
        if (!key) throw new Error("key not found");
        if (store === "meta") throw new Error("Cannot delete from meta store");
        const deleteUrl = pkCarURL(uri, key);
        const response = await fetch(deleteUrl.toString(), { method: "DELETE" });
        if (response.status === 404) {
          throw new Error(`Failure in deleting ${store}!`);
        }
      });
    }
    async destroy(uri) {
      await this.ready();
      return exception2Result(async () => {
        const deleteUrl = pkBaseURL(uri);
        const response = await fetch(deleteUrl.toString(), { method: "DELETE" });
        if (response.status === 404) {
          throw new Error("Failure in deleting data!");
        }
        return Result.Ok(void 0);
      });
    }
  };
  var pkSockets = new KeyedResolvOnce();
  function pkKey(set4) {
    const ret = JSON.stringify(
      Object.entries(set4 || {}).sort(([a7], [b5]) => a7.localeCompare(b5)).filter(([k4]) => k4 !== "id").map(([k4, v6]) => ({ [k4]: v6 }))
    );
    return ret;
  }
  function pkURL(uri, key, type2) {
    const host = uri.host;
    const name8 = uri.getParam("name");
    const idx = uri.getParam("index") || "";
    const protocol = uri.getParam("protocol") === "ws" ? "http" : "https";
    const path2 = `/parties/fireproof/${name8}${idx}`;
    return BuildURI.from(`${protocol}://${host}${path2}`).setParam(type2, key).URI();
  }
  function pkBaseURL(uri) {
    const host = uri.host;
    const name8 = uri.getParam("name");
    const idx = uri.getParam("index") || "";
    const protocol = uri.getParam("protocol") === "ws" ? "http" : "https";
    const path2 = `/parties/fireproof/${name8}${idx}`;
    return BuildURI.from(`${protocol}://${host}${path2}`).URI();
  }
  function pkCarURL(uri, key) {
    return pkURL(uri, key, "car");
  }
  function pkMetaURL(uri, key) {
    return pkURL(uri, key, "meta");
  }
  var PartyKitTestStore = class {
    constructor(gw, sthis) {
      this.sthis = sthis;
      this.logger = ensureLogger(sthis, "PartyKitTestStore");
      this.gateway = gw;
    }
    async get(uri, key) {
      const url = uri.build().setParam("key", key).URI();
      const dbFile = this.sthis.pathOps.join(runtime_exports.getPath(url, this.sthis), runtime_exports.getFileName(url, this.sthis));
      this.logger.Debug().Url(url.asURL()).Str("dbFile", dbFile).Msg("get");
      const buffer4 = await this.gateway.get(url);
      this.logger.Debug().Url(url).Str("dbFile", dbFile).Len(buffer4).Msg("got");
      return buffer4.Ok();
    }
  };
  var onceRegisterPartyKitStoreProtocol = new KeyedResolvOnce();
  function registerPartyKitStoreProtocol(protocol = "partykit:", overrideBaseURL) {
    return onceRegisterPartyKitStoreProtocol.get(protocol).once(() => {
      URI.protocolHasHostpart(protocol);
      return blockstore_exports.registerStoreProtocol({
        protocol,
        overrideBaseURL,
        gateway: async (sthis) => {
          return new PartyKitGateway(sthis);
        },
        test: async (sthis) => {
          const gateway = new PartyKitGateway(sthis);
          return new PartyKitTestStore(gateway, sthis);
        }
      });
    });
  }

  // src/partykit/index.ts
  init_cement();
  if (typeof process !== "undefined" && process.env && !process.env.FP_KEYBAG_URL?.includes("extractKey=_deprecated_internal_api")) {
    const url = new URL(process.env.FP_KEYBAG_URL || "file://./dist/kb-dir-partykit?fs=mem");
    url.searchParams.set("extractKey", "_deprecated_internal_api");
    process.env.FP_KEYBAG_URL = url.toString();
  }
  registerPartyKitStoreProtocol();
  var connectionCache = new KeyedResolvOnce();
  var connect = (db, remoteDbName = "", url = "http://localhost:1999?protocol=ws") => {
    const { sthis, blockstore, name: dbName } = db;
    if (!dbName) {
      throw new Error("dbName is required");
    }
    const urlObj = new URL(url);
    const existingName = urlObj.searchParams.get("name");
    urlObj.searchParams.set("name", remoteDbName || existingName || dbName);
    urlObj.searchParams.set("localName", dbName);
    urlObj.searchParams.set("storekey", `@${dbName}:data@`);
    const fpUrl = urlObj.toString().replace("http://", "partykit://").replace("https://", "partykit://");
    return connectionCache.get(fpUrl).once(() => {
      makeKeyBagUrlExtractable(sthis);
      const connection = connectionFactory(sthis, fpUrl);
      connection.connect_X(blockstore);
      return connection;
    });
  };
  return __toCommonJS(partykit_exports);
})();
/*! Bundled license information:

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/assert.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@jspm/core/nodelibs/browser/chunk-44e51b61.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

partysocket/dist/chunk-4SNNYC7I.mjs:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)
*/
//# sourceMappingURL=index.global.js.map