{"version":3,"sources":["../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/txt-en-decoder.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/utils/index.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/utils/stream-map.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/utils/rebuffer.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/utils/stream2string.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/utils/string2stream.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/utils/console-write-stream.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/utils/fanout-write-stream.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/sys-abstraction.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/time.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/base-sys-abstraction.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/future.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/resolve-once.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/sys-env.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/web/web-sys-abstraction.ts","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/identity.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/visit.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/directives.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/anchors.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/applyReviver.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/toJS.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Node.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Alias.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Scalar.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/createNode.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Collection.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyComment.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/foldFlowLines.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyString.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringify.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyPair.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/log.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/Pair.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyCollection.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/YAMLMap.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/map.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/nodes/YAMLSeq.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/seq.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/string.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/common/null.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/bool.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyNumber.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/float.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/int.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/core/schema.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/json/schema.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/tags.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/schema/Schema.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/stringify/stringifyDocument.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/doc/Document.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/errors.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-props.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-contains-newline.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-map-includes.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-block-map.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-block-seq.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-end.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-collection.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-scalar.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-node.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/compose-doc.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/compose/composer.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst-scalar.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst-stringify.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst-visit.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/cst.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/lexer.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/line-counter.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/parse/parser.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/public-api.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/dist/index.js","../../node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/browser/index.js","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/logger-impl.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/bin2text.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/logger.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/result.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/uri.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/runtime.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/log-writer-impl.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/log-level-impl.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/test/log-write-stream.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/test/mock-logger.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/option.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/tracer.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/crypto.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/version.ts","../../node_modules/.pnpm/@adviser+cement@0.2.31_typescript@5.6.2/node_modules/src/refcounted.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bytes.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/vendor/base-x.js","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base58.ts","../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js","../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js","../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js","../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js","../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js","../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js","../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/util/longbits.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/util/minimal.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/writer.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/writer_buffer.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/reader.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/reader_buffer.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/rpc/service.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/rpc.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/roots.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/index-minimal.js","../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js","../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js","../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js","../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js","../../node_modules/.pnpm/sparse-array@1.3.2/node_modules/sparse-array/index.js","../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js","../../src/utils.ts","../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js","../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js","../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js","../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js","../../src/bundle-not-impl.ts","../../node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js","../../src/runtime/gateways/file/node-filesystem.ts","../../src/runtime/gateways/file/utils.ts","../../src/runtime/key-bag-indexdb.ts","../../src/runtime/gateways/indexdb/version.ts","../../src/runtime/gateways/indexdb/gateway.ts","../../node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/number.js","../../node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/object.js","../../node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/index.js","../../src/index.ts","../../src/database.ts","../../node_modules/.pnpm/uuidv7@1.0.2/node_modules/uuidv7/dist/index.js","../../src/write-queue.ts","../../src/crdt.ts","../../src/runtime/wait-pr-multiformats/block.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/index.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base32.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base36.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/cid.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/hashes/digest.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/vendor/varint.js","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/varint.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/hashes/hasher.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/block.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/link.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/hashes/sha2-browser.ts","../../node_modules/.pnpm/@ipld+dag-cbor@9.2.1/node_modules/@ipld/dag-cbor/src/index.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/is.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/token.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/byte-utils.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/bl.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/common.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/0uint.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/1negint.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/2bytes.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/3string.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/4array.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/5map.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/6tag.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/7float.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/jump.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/encode.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/decode.js","../../node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/clock/index.js","../../node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/shard.js","../../node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/index.js","../../node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/block.js","../../node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/batch/shard.js","../../node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/batch/index.js","../../node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/crdt/index.js","../../node_modules/.pnpm/@web3-storage+pail@0.6.0/node_modules/@web3-storage/pail/src/crdt/batch/index.js","../../src/blockstore/index.ts","../../src/blockstore/types.ts","../../src/blockstore/store-factory.ts","../../src/runtime/files.ts","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/codec.js","../../node_modules/.pnpm/@ipld+dag-pb@4.0.8/node_modules/@ipld/dag-pb/src/pb-decode.js","../../node_modules/.pnpm/@ipld+dag-pb@4.0.8/node_modules/@ipld/dag-pb/src/pb-encode.js","../../node_modules/.pnpm/@ipld+dag-pb@4.0.8/node_modules/@ipld/dag-pb/src/util.js","../../node_modules/.pnpm/@ipld+dag-pb@4.0.8/node_modules/@ipld/dag-pb/src/index.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/gen/unixfs.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/unixfs.js","../../node_modules/.pnpm/actor@2.3.1/node_modules/actor/src/lib.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker/indexed.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker/buffer.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/writer/util.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/layout/queue.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/writer.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/chunker/fixed.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file/layout/balanced.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/file.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/directory.js","../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint32.js","../../node_modules/.pnpm/@multiformats+murmur3@2.1.8/node_modules/@multiformats/murmur3/src/index.js","../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint8Array.js","../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/lib.js","../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/InfiniteUint8Array.js","../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/unixfs.js","../../node_modules/.pnpm/@ipld+unixfs@3.0.0/node_modules/@ipld/unixfs/src/lib.js","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/codecs/raw.ts","../../node_modules/.pnpm/it-last@3.0.6/node_modules/it-last/src/index.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/errors.ts","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/json/encode.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/json/decode.js","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base64.ts","../../node_modules/.pnpm/@ipld+dag-json@10.2.2/node_modules/@ipld/dag-json/src/index.js","../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/pb-decode.js","../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/pb-encode.js","../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/util.js","../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/index.js","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/codecs/json.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/hashes/identity.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/utils/resolve-object-path.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/resolvers/dag-json.ts","../../node_modules/.pnpm/progress-events@1.0.1/node_modules/progress-events/src/index.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/resolvers/identity.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/resolvers/json.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/resolvers/raw.ts","../../node_modules/.pnpm/ipfs-unixfs@11.1.2/node_modules/ipfs-unixfs/src/index.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/utils/float.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/utils/longbits.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/utils/utf8.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/utils/reader.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/decode.ts","../../node_modules/.pnpm/uint8arrays@5.0.3/node_modules/uint8arrays/src/alloc.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base10.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base16.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base2.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base256emoji.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/basics.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base8.ts","../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/identity.ts","../../node_modules/.pnpm/uint8arrays@5.0.3/node_modules/uint8arrays/src/util/bases.ts","../../node_modules/.pnpm/uint8arrays@5.0.3/node_modules/uint8arrays/src/from-string.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/utils/pool.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/utils/writer.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/encode.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/codec.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/codecs/enum.ts","../../node_modules/.pnpm/protons-runtime@5.2.2/node_modules/protons-runtime/src/codecs/message.ts","../../node_modules/.pnpm/ipfs-unixfs@11.1.2/node_modules/ipfs-unixfs/src/unixfs.ts","../../node_modules/.pnpm/hamt-sharding@3.0.6/node_modules/hamt-sharding/src/bucket.ts","../../node_modules/.pnpm/uint8arrays@5.0.3/node_modules/uint8arrays/src/util/as-uint8array.ts","../../node_modules/.pnpm/uint8arrays@5.0.3/node_modules/uint8arrays/src/concat.ts","../../node_modules/.pnpm/hamt-sharding@3.0.6/node_modules/hamt-sharding/src/consumable-buffer.ts","../../node_modules/.pnpm/hamt-sharding@3.0.6/node_modules/hamt-sharding/src/consumable-hash.ts","../../node_modules/.pnpm/hamt-sharding@3.0.6/node_modules/hamt-sharding/src/index.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.ts","../../node_modules/.pnpm/it-peekable@3.0.3/node_modules/it-peekable/src/index.ts","../../node_modules/.pnpm/it-filter@3.1.1/node_modules/it-filter/src/index.ts","../../node_modules/.pnpm/it-map@3.1.1/node_modules/it-map/src/index.ts","../../node_modules/.pnpm/p-defer@4.0.1/node_modules/p-defer/index.js","../../node_modules/.pnpm/it-parallel@3.0.8/node_modules/it-parallel/src/index.ts","../../node_modules/.pnpm/p-defer@4.0.0/node_modules/p-defer/index.js","../../node_modules/.pnpm/it-pushable@3.2.3/node_modules/it-pushable/src/fifo.ts","../../node_modules/.pnpm/it-pushable@3.2.3/node_modules/it-pushable/src/index.ts","../../node_modules/.pnpm/it-merge@3.0.3/node_modules/it-merge/src/index.ts","../../node_modules/.pnpm/it-pipe@3.0.1/node_modules/it-pipe/src/index.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.ts","../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs","../../node_modules/.pnpm/p-timeout@6.1.2/node_modules/p-timeout/index.js","../../node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/lower-bound.js","../../node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/priority-queue.js","../../node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/index.js","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/resolvers/index.ts","../../node_modules/.pnpm/ipfs-unixfs-exporter@13.6.1/node_modules/ipfs-unixfs-exporter/src/index.ts","../../node_modules/.pnpm/yocto-queue@1.1.1/node_modules/yocto-queue/index.js","../../node_modules/.pnpm/p-limit@6.1.0/node_modules/p-limit/index.js","../../src/blockstore/store.ts","../../src/types.ts","../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/decoder-common.js","../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/header-validator.js","../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/length.js","../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-writer.js","../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/decoder.js","../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/reader-browser.js","../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/encoder.js","../../src/blockstore/loader.ts","../../src/blockstore/loader-helpers.ts","../../src/blockstore/transaction.ts","../../src/blockstore/commit-queue.ts","../../src/runtime/key-bag.ts","../../src/blockstore/commitor.ts","../../src/blockstore/task-manager.ts","../../src/runtime/keyed-crypto.ts","../../src/blockstore/fragment-gateway.ts","../../src/blockstore/store-meta.ts","../../src/runtime/index.ts","../../src/runtime/wait-pr-multiformats/index.ts","../../src/runtime/wait-pr-multiformats/codec-interface.ts","../../src/runtime/gateways/file/version.ts","../../src/blockstore/store-remote.ts","../../src/blockstore/connection-base.ts","../../src/crdt-helpers.ts","../../src/indexer-helpers.ts","../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/utils.js","../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/base.js","../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/map.js","../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/db-index.js","../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/cache.js","../../src/indexer.ts","../../src/crdt-clock.ts","../../src/apply-head-queue.ts","../../src/version.ts"],"sourcesContent":["export interface TxtEnDecoder {\n  encode(str: string): Uint8Array;\n  decode(data: Uint8Array): string;\n}\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nexport class Utf8EnDecoder implements TxtEnDecoder {\n  encode(str: string): Uint8Array {\n    return encoder.encode(str);\n  }\n  decode(data: Uint8Array): string {\n    return decoder.decode(data);\n  }\n}\n\nconst utf8EnDecoder = new Utf8EnDecoder();\nexport function Utf8EnDecoderSingleton(): TxtEnDecoder {\n  return utf8EnDecoder;\n}\n","export * from \"./rebuffer.js\";\nexport * from \"./stream-map.js\";\nexport * from \"./stream2string.js\";\nexport * from \"./string2stream.js\";\nexport * from \"./console-write-stream.js\";\nexport * from \"./fanout-write-stream.js\";\n","export interface StreamMap<T, U> {\n  Map(s: T, idx: number): U | Promise<U>;\n  readonly Close?: () => void;\n}\nexport function streamMap<T, U>(s: ReadableStream<T>, sm: StreamMap<T, U>): ReadableStream<U> {\n  const state = { reader: s.getReader(), streamMap: sm, idx: 0 };\n  return new ReadableStream<U>({\n    async pull(controller): Promise<void> {\n      const { done, value } = await state.reader.read();\n      if (done) {\n        if (state.streamMap.Close) {\n          state.streamMap.Close();\n        }\n        controller.close();\n        return;\n      }\n      const promiseOrU = state.streamMap.Map(value, state.idx++);\n      let mapped: U;\n      if (promiseOrU instanceof Promise || typeof (promiseOrU as { then: () => void }).then === \"function\") {\n        mapped = await promiseOrU;\n      } else {\n        mapped = promiseOrU;\n      }\n      controller.enqueue(mapped);\n    },\n  });\n}\n\nexport async function devnull<T>(a: ReadableStream<T>): Promise<number> {\n  const reader = a.getReader();\n  let cnt = 0;\n  while (true) {\n    const { done } = await reader.read();\n    if (done) {\n      break;\n    }\n    cnt++;\n  }\n  return cnt;\n}\n\nexport function array2stream<T>(a: T[]): ReadableStream<T> {\n  let i = 0;\n  return new ReadableStream<T>({\n    pull(controller): void {\n      if (i >= a.length) {\n        controller.close();\n        return;\n      }\n      controller.enqueue(a[i]);\n      i++;\n    },\n  });\n}\n\nexport async function stream2array<T>(a: ReadableStream<T>): Promise<T[]> {\n  const ret: T[] = [];\n  const reader = a.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    ret.push(value);\n  }\n  return ret;\n}\n","import { array2stream, stream2array } from \"./stream-map.js\";\n\ninterface ReChunkResult {\n  readonly rest: Uint8Array;\n  readonly chunk: Uint8Array;\n}\n\nexport async function rebufferArray(a: Uint8Array[], chunkSize: number): Promise<Uint8Array[]> {\n  return stream2array(rebuffer(array2stream(a), chunkSize));\n}\n\nfunction reChunk(cs: Uint8Array[], chunkSize: number): ReChunkResult {\n  const len = cs.reduce((acc, v) => acc + v.length, 0);\n  const last = cs[cs.length - 1];\n  const lastOfs = len - last.length;\n  // console.log(\"reChunk\", len, lastOfs, last.length, chunkSize, chunkSize - lastOfs)\n  const rest = last.subarray(chunkSize - lastOfs);\n  cs[cs.length - 1] = last.subarray(0, chunkSize - lastOfs);\n  const chunk = new Uint8Array(chunkSize);\n  let ofs = 0;\n  for (const c of cs) {\n    chunk.set(c, ofs);\n    ofs += c.length;\n  }\n  return { rest, chunk };\n}\n\ninterface pumpState {\n  readonly reader: ReadableStreamDefaultReader<Uint8Array>;\n  tmp: Uint8Array[];\n  tmpLen: number;\n  readonly chunkSize: number;\n}\n\nfunction pump(ps: pumpState, controller: ReadableStreamDefaultController<Uint8Array>, next: () => void): void {\n  ps.reader.read().then(({ done, value }) => {\n    if (done) {\n      if (ps.tmpLen > 0) {\n        controller.enqueue(reChunk(ps.tmp, ps.tmpLen).chunk);\n      }\n      controller.close();\n      next();\n      return;\n    }\n    if (ps.tmpLen + value.length > ps.chunkSize) {\n      ps.tmp.push(value);\n      const res = reChunk(ps.tmp, ps.chunkSize);\n      controller.enqueue(res.chunk);\n      ps.tmp = [res.rest];\n      ps.tmpLen = res.rest.length;\n      next();\n      return;\n    } else if (value.length) {\n      ps.tmp.push(value);\n      ps.tmpLen += value.length;\n    }\n    pump(ps, controller, next);\n  });\n}\n\nexport function rebuffer(a: ReadableStream<Uint8Array>, chunkSize: number): ReadableStream<Uint8Array> {\n  const state: pumpState = {\n    reader: a.getReader(),\n    tmp: [],\n    tmpLen: 0,\n    chunkSize,\n  };\n  return new ReadableStream<Uint8Array>({\n    async pull(controller): Promise<void> {\n      return new Promise<void>((resolve) => {\n        pump(state, controller, resolve);\n      });\n    },\n  });\n}\n","export async function stream2string(stream?: ReadableStream<Uint8Array> | null, maxSize?: number): Promise<string> {\n  if (!stream) {\n    return Promise.resolve(\"\");\n  }\n  const reader = stream.getReader();\n  let res = \"\";\n  const decoder = new TextDecoder();\n  let rSize = 0;\n  while (typeof maxSize === \"undefined\" || rSize < maxSize) {\n    try {\n      const read = await reader.read();\n      if (read.done) {\n        break;\n      }\n      if (maxSize && rSize + read.value.length > maxSize) {\n        read.value = read.value.slice(0, maxSize - rSize);\n      }\n      const block = decoder.decode(read.value, { stream: true });\n      rSize += read.value.length;\n      res += block;\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  return Promise.resolve(res);\n}\n\nexport async function stream2uint8array(stream?: ReadableStream<Uint8Array> | null): Promise<Uint8Array> {\n  if (!stream) {\n    return Promise.resolve(new Uint8Array());\n  }\n  const reader = stream.getReader();\n  let res = new Uint8Array();\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    try {\n      const { done, value } = await reader.read();\n      if (done) {\n        break;\n      }\n      res = new Uint8Array([...res, ...value]);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  return Promise.resolve(res);\n}\n","import { TxtEnDecoder, Utf8EnDecoderSingleton } from \"../txt-en-decoder.js\";\n\nexport function string2stream(str: string, ende: TxtEnDecoder = Utf8EnDecoderSingleton()): ReadableStream<Uint8Array> {\n  return uint8array2stream(ende.encode(str));\n}\n\nexport function uint8array2stream(str: Uint8Array): ReadableStream<Uint8Array> {\n  return new ReadableStream<Uint8Array>({\n    start(controller): void {\n      controller.enqueue(str);\n      controller.close();\n    },\n  });\n}\n","export class ConsoleWriterStreamDefaultWriter implements WritableStreamDefaultWriter<Uint8Array> {\n  readonly desiredSize: number | null = null;\n  readonly decoder: TextDecoder = new TextDecoder();\n\n  closed: Promise<undefined>;\n  ready: Promise<undefined>;\n  readonly _stream: ConsoleWriterStream;\n\n  constructor(private stream: ConsoleWriterStream) {\n    this._stream = stream;\n    this.ready = Promise.resolve(undefined);\n    this.closed = Promise.resolve(undefined);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any\n  abort(reason?: any): Promise<void> {\n    throw new Error(\"Method not implemented.\");\n  }\n  async close(): Promise<void> {\n    // noop\n  }\n  releaseLock(): void {\n    this._stream.locked = false;\n    this.ready = Promise.resolve(undefined);\n    this.closed = Promise.resolve(undefined);\n  }\n  async write(chunk?: Uint8Array | undefined): Promise<void> {\n    const str = this.decoder.decode(chunk).trimEnd();\n    let output = \"log\";\n    try {\n      const decode = JSON.parse(str);\n      output = decode.level;\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (e) {\n      /* noop */\n    }\n    switch (output) {\n      case \"error\":\n        // eslint-disable-next-line no-console\n        console.error(str);\n        break;\n      case \"warn\":\n        // eslint-disable-next-line no-console\n        console.warn(str);\n        break;\n      default:\n        // eslint-disable-next-line no-console\n        console.log(str);\n    }\n  }\n}\n\nexport class ConsoleWriterStream implements WritableStream<Uint8Array> {\n  locked = false;\n  _writer?: WritableStreamDefaultWriter<Uint8Array>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars\n  abort(reason?: any): Promise<void> {\n    throw new Error(\"Method not implemented.\");\n  }\n  async close(): Promise<void> {\n    return;\n  }\n  getWriter(): WritableStreamDefaultWriter<Uint8Array> {\n    if (this.locked) {\n      throw new Error(\"Stream is locked\");\n    }\n    this.locked = true;\n    if (!this._writer) {\n      this._writer = new ConsoleWriterStreamDefaultWriter(this);\n    }\n    return this._writer;\n  }\n}\n","export class FanoutWriteStream implements WritableStreamDefaultWriter<Uint8Array> {\n  readonly _writers: WritableStreamDefaultWriter<Uint8Array>[];\n  readonly ready: Promise<undefined>;\n  readonly closed: Promise<undefined>;\n  readonly desiredSize: number | null = null;\n  constructor(writers: WritableStreamDefaultWriter<Uint8Array>[]) {\n    this._writers = writers;\n    this.ready = Promise.all(this._writers.map((w) => w.ready)).then(() => undefined);\n    this.closed = Promise.all(this._writers.map((w) => w.closed)).then(() => undefined);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  abort(reason?: any): Promise<void> {\n    return Promise.all(this._writers.map((w) => w.abort(reason))).then(() => {\n      /* do nothing */\n    });\n  }\n  close(): Promise<void> {\n    return Promise.all(this._writers.map((w) => w.close())).then(() => {\n      /* do nothing */\n    });\n  }\n  releaseLock(): void {\n    this._writers.map((w) => w.releaseLock());\n  }\n\n  write(chunk?: Uint8Array | undefined): Promise<void> {\n    return Promise.all(this._writers.map((w) => w.write(chunk))).then(() => {\n      /* do nothing */\n    });\n  }\n}\n","import { FileService } from \"./file-service.js\";\nimport { Env } from \"./sys-env.js\";\nimport { Time } from \"./time.js\";\n\nexport enum TimeMode {\n  REAL = \"real\",\n  CONST = \"const\",\n  STEP = \"step\",\n}\n\nexport enum RandomMode {\n  CONST = \"const\",\n  STEP = \"step\",\n  RANDOM = \"random\",\n}\n\nexport enum IDMode {\n  UUID = \"uuid\",\n  CONST = \"const\",\n  STEP = \"step\",\n}\n\nexport function String2TimeMode(s?: string): TimeMode {\n  switch (s?.toLowerCase()) {\n    case \"real\":\n      return TimeMode.REAL;\n    case \"const\":\n      return TimeMode.CONST;\n    case \"step\":\n      return TimeMode.STEP;\n    default:\n      return TimeMode.REAL;\n  }\n}\n\nexport type VoidFunc = () => void | Promise<void>;\n\nexport interface SystemService {\n  Env(): Env;\n  Args(): string[];\n  OnExit(hdl: VoidFunc): VoidFunc;\n  Exit(code: number): void;\n}\n\nexport interface SysAbstraction {\n  Time(): Time;\n  Stdout(): WritableStream<Uint8Array>;\n  Stderr(): WritableStream<Uint8Array>;\n  NextId(): string;\n  Random0ToValue(value: number): number;\n  System(): SystemService;\n  FileSystem(): FileService;\n}\n","export abstract class Time {\n  abstract Now(add?: number): Date;\n  abstract Sleep(duration: Duration): Promise<void>;\n  TimeSince(start: Date): Duration {\n    const now = this.Now();\n    return now.getTime() - start.getTime();\n  }\n}\n\nexport type Duration = number;\n\nexport enum TimeUnits {\n  Microsecond = 1,\n  // eslint-disable-next-line @typescript-eslint/prefer-literal-enum-member\n  Second = 1000 * Microsecond,\n  // eslint-disable-next-line @typescript-eslint/prefer-literal-enum-member\n  Minute = 60 * Second,\n  // eslint-disable-next-line @typescript-eslint/prefer-literal-enum-member\n  Hour = 60 * Minute,\n}\n","import { FileService } from \"./file-service.js\";\nimport { TimeMode, RandomMode, IDMode, SystemService, VoidFunc, SysAbstraction } from \"./sys-abstraction.js\";\nimport { Time } from \"./time.js\";\nimport { TxtEnDecoder } from \"./txt-en-decoder.js\";\n\nexport class SysTime extends Time {\n  Now(): Date {\n    return new Date();\n  }\n  Sleep(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve();\n      }, duration);\n    });\n  }\n}\n\nexport class ConstTime extends Time {\n  Now(): Date {\n    return new Date(2021, 1, 1, 0, 0, 0, 0);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Sleep(duration: number): Promise<void> {\n    return Promise.resolve();\n  }\n}\n\nexport class StepTime extends Time {\n  _step: Date;\n  readonly _start: Date;\n  constructor() {\n    super();\n    this._step = new ConstTime().Now();\n    this._start = this._step;\n  }\n  Now(steps = 1): Date {\n    // if (this._step.getTime() === 0) {\n    //   this._step = new ConstTime().Now();\n    //   return this._step;\n    // }\n    for (let i = 0; steps > 0 && i < steps; i++) {\n      this._step = new Date(this._step.getTime() + 1000);\n    }\n    if (steps < 1) {\n      this._step = new Date(this._start.getTime() + steps * -1000);\n    }\n    // this._step = new Date(this._step.getTime() + 1000);\n    return this._step;\n  }\n  Sleep(duration: number): Promise<void> {\n    this._step = new Date(this._step.getTime() + duration);\n    return Promise.resolve();\n  }\n}\n\nexport function TimeFactory(timeMode: TimeMode): Time {\n  switch (timeMode) {\n    case TimeMode.REAL:\n      return new SysTime();\n    case TimeMode.CONST:\n      return new ConstTime();\n    case TimeMode.STEP:\n      return new StepTime();\n  }\n  return new SysTime();\n}\n\nexport class RandomService {\n  readonly _mode: RandomMode;\n  _step = 0;\n  constructor(mode: RandomMode) {\n    this._mode = mode;\n  }\n  Random0ToValue(value: number): number {\n    switch (this._mode) {\n      case RandomMode.CONST:\n        return 0.5 * value;\n      case RandomMode.STEP:\n        this._step += 0.0001;\n        return this._step * value;\n      case RandomMode.RANDOM:\n        return Math.random() * value;\n      default:\n        throw new Error(\"Unknown RandomMode\");\n    }\n  }\n}\n\nexport class IdService {\n  readonly _mode: IDMode;\n  _step = 0;\n  constructor(mode?: IDMode) {\n    if (!mode) {\n      mode = IDMode.UUID;\n    }\n    this._mode = mode;\n  }\n  NextId(): string {\n    switch (this._mode) {\n      case IDMode.UUID:\n        return crypto.randomUUID();\n      case IDMode.CONST:\n        return \"VeryUniqueID\";\n      case IDMode.STEP:\n        return `STEPId-${this._step++}`;\n      default:\n        throw new Error(\"Unknown IDMode\");\n    }\n  }\n}\n\nexport interface BaseSysAbstractionParams {\n  readonly TxtEnDecoder: TxtEnDecoder;\n  readonly FileSystem: FileService;\n  readonly SystemService: SystemService;\n}\n\nexport interface ExitHandler {\n  readonly hdl: VoidFunc;\n  readonly id: string;\n}\n\nexport interface ExitService {\n  injectExitHandlers(hdls: ExitHandler[]): void;\n  exit(code: number): void;\n}\n\nexport class BaseSysAbstraction {\n  readonly _time: SysTime = new SysTime();\n  readonly _stdout: WritableStream;\n  readonly _stderr: WritableStream;\n\n  readonly _idService: IdService = new IdService();\n  readonly _randomService: RandomService = new RandomService(RandomMode.RANDOM);\n  readonly _fileSystem: FileService;\n  readonly _systemService: SystemService;\n  readonly _txtEnDe: TxtEnDecoder;\n\n  constructor(params: BaseSysAbstractionParams) {\n    this._fileSystem = params.FileSystem;\n    this._systemService = params.SystemService;\n    this._txtEnDe = params.TxtEnDecoder;\n    const decoder = this._txtEnDe;\n    this._stdout = new WritableStream({\n      write(chunk): Promise<void> {\n        return new Promise((resolve) => {\n          const decoded = decoder.decode(chunk);\n          // eslint-disable-next-line no-console\n          console.log(decoded.trimEnd());\n          resolve();\n        });\n      },\n    });\n    this._stderr = new WritableStream({\n      write(chunk): Promise<void> {\n        return new Promise((resolve) => {\n          const decoded = decoder.decode(chunk);\n          // eslint-disable-next-line no-console\n          console.error(decoded.trimEnd());\n          resolve();\n        });\n      },\n    });\n  }\n}\n\nexport interface WrapperSysAbstractionParams {\n  readonly TimeMode?: TimeMode;\n  readonly IdMode?: IDMode;\n  readonly Stdout?: WritableStream<Uint8Array>;\n  readonly Stderr?: WritableStream<Uint8Array>;\n  readonly RandomMode?: RandomMode;\n  readonly FileSystem?: FileService;\n  readonly SystemService?: SystemService;\n  readonly TxtEnDecoder?: TxtEnDecoder;\n}\n\nexport class WrapperSysAbstraction implements SysAbstraction {\n  readonly _time: Time;\n  readonly _stdout: WritableStream<Uint8Array>;\n  readonly _stderr: WritableStream<Uint8Array>;\n  readonly _idService: IdService;\n  readonly _randomService: RandomService;\n  readonly _fileSystem: FileService;\n  readonly _systemService: SystemService;\n  constructor(base: BaseSysAbstraction, params?: WrapperSysAbstractionParams) {\n    this._time = base._time;\n    this._stdout = base._stdout;\n    this._stderr = base._stderr;\n    this._idService = base._idService;\n    this._randomService = base._randomService;\n    this._fileSystem = base._fileSystem;\n    this._systemService = base._systemService;\n    if (params) {\n      if (params.TimeMode) {\n        this._time = TimeFactory(params.TimeMode);\n      }\n      if (params.Stdout) {\n        this._stdout = params.Stdout;\n      }\n      if (params.Stderr) {\n        this._stderr = params.Stderr;\n      }\n      if (params.IdMode) {\n        this._idService = new IdService(params.IdMode);\n      }\n      if (params.RandomMode) {\n        this._randomService = new RandomService(params.RandomMode);\n      }\n      if (params.FileSystem) {\n        this._fileSystem = params.FileSystem;\n      }\n      if (params.SystemService) {\n        this._systemService = params.SystemService;\n      }\n    }\n  }\n  Time(): Time {\n    return this._time;\n  }\n  NextId(): string {\n    return this._idService.NextId();\n  }\n  Random0ToValue(value: number): number {\n    return this._randomService.Random0ToValue(value);\n  }\n  Stdout(): WritableStream {\n    return this._stdout;\n  }\n  Stderr(): WritableStream {\n    return this._stderr;\n  }\n\n  System(): SystemService {\n    return this._systemService;\n  }\n  FileSystem(): FileService {\n    return this._fileSystem;\n  }\n}\n// export const BaseSysAbstraction = new BaseSysAbstractionImpl()\n","export class Future<T> {\n  readonly #promise: Promise<T>;\n  #resolveFn: (value: T) => void = () => {\n    throw new Error(\"This Promise is not working as expected.\");\n  };\n  #rejectFn: (reason: unknown) => void = () => {\n    throw new Error(\"This Promise is not working as expected.\");\n  };\n\n  constructor() {\n    this.#promise = new Promise<T>((resolve, reject) => {\n      this.#resolveFn = resolve;\n      this.#rejectFn = reject;\n    });\n  }\n\n  async asPromise(): Promise<T> {\n    return this.#promise;\n  }\n\n  resolve(value: T): void {\n    this.#resolveFn(value);\n  }\n  reject(reason: unknown): void {\n    this.#rejectFn(reason);\n  }\n}\n","import { Future } from \"./future.js\";\n\ninterface ResolveSeqItem<T, C> {\n  readonly future: Future<T>;\n  readonly fn: (c: C) => Promise<T>;\n  readonly id?: number;\n}\n\nexport class ResolveSeq<T, C = void> {\n  readonly ctx: C;\n  constructor(ctx?: C) {\n    this.ctx = ctx as C;\n  }\n  reset(): void {\n    /* noop */\n  }\n  async _step(item?: ResolveSeqItem<T, C> | undefined): Promise<void> {\n    if (!item) {\n      // done\n      return;\n    }\n    item\n      .fn(this.ctx)\n      .then((value) => item.future.resolve(value))\n      .catch((e) => item.future.reject(e as Error))\n      .finally(() => {\n        this._seqFutures.shift();\n        this._step(this._seqFutures[0]);\n      });\n  }\n  readonly _seqFutures: ResolveSeqItem<T, C>[] = [];\n  async add(fn: (c: C) => Promise<T>, id?: number): Promise<T> {\n    const future = new Future<T>();\n    this._seqFutures.push({ future, fn, id });\n    if (this._seqFutures.length === 1) {\n      this._step(this._seqFutures[0]);\n    }\n    return future.asPromise();\n  }\n}\n\nexport class ResolveOnce<T, CTX = void> {\n  _onceDone = false;\n  readonly _onceFutures: Future<T>[] = [];\n  _onceOk = false;\n  _onceValue?: T;\n  _onceError?: Error;\n  _isPromise = false;\n\n  readonly ctx: CTX;\n\n  constructor(ctx?: CTX) {\n    this.ctx = ctx as CTX;\n  }\n\n  get ready(): boolean {\n    return this._onceDone;\n  }\n\n  reset(): void {\n    this._onceDone = false;\n    this._onceOk = false;\n    this._onceValue = undefined;\n    this._onceError = undefined;\n    this._onceFutures.length = 0;\n  }\n\n  // T extends Option<infer U> ? U : T\n  once<R>(fn: (c: CTX) => R): R {\n    if (this._onceDone) {\n      if (this._onceError) {\n        if (this._isPromise) {\n          return Promise.reject(this._onceError) as unknown as R;\n        } else {\n          throw this._onceError;\n        }\n      }\n      if (this._onceOk) {\n        if (this._isPromise) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          return Promise.resolve(this._onceValue!) as unknown as R;\n        } else {\n          return this._onceValue as unknown as R;\n        }\n      }\n      throw new Error(\"ResolveOnce.once impossible\");\n    }\n    const future = new Future<T>();\n    this._onceFutures.push(future);\n    if (this._onceFutures.length === 1) {\n      const okFn = (value: T): void => {\n        this._onceValue = value;\n        this._onceOk = true;\n        this._onceDone = true;\n        if (this._isPromise) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this._onceFutures.forEach((f) => f.resolve(this._onceValue!));\n        }\n        this._onceFutures.length = 0;\n      };\n      const catchFn = (e: Error): void => {\n        this._onceError = e as Error;\n        this._onceOk = false;\n        this._onceValue = undefined;\n        this._onceDone = true;\n        if (this._isPromise) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this._onceFutures.forEach((f) => f.reject(this._onceError!));\n        }\n        this._onceFutures.length = 0;\n      };\n      try {\n        const ret = fn(this.ctx);\n        if (typeof (ret as Promise<T>).then === \"function\") {\n          this._isPromise = true;\n          (ret as Promise<T>).then(okFn).catch(catchFn);\n        } else {\n          okFn(ret as unknown as T);\n        }\n      } catch (e) {\n        catchFn(e as Error);\n      }\n    }\n    if (this._isPromise) {\n      return future.asPromise() as unknown as R;\n    } else {\n      // abit funky but i don't want to impl the return just once\n      return this.once(fn);\n    }\n  }\n}\n\nexport class Keyed<T extends { reset: () => void }, K = string> {\n  private readonly _map = new Map<K, T>();\n\n  readonly factory: (key: K) => T;\n  constructor(factory: (key: K) => T) {\n    this.factory = factory;\n  }\n\n  async asyncGet(key: () => Promise<K>): Promise<T> {\n    return this.get(await key());\n  }\n\n  get(key: K | (() => K)): T {\n    if (typeof key === \"function\") {\n      key = (key as () => K)();\n    }\n    let keyed = this._map.get(key);\n    if (!keyed) {\n      keyed = this.factory(key);\n      this._map.set(key, keyed);\n    }\n    return keyed;\n  }\n\n  unget(key: K): void {\n    const keyed = this._map.get(key);\n    keyed?.reset();\n    this._map.delete(key);\n  }\n\n  reset(): void {\n    this._map.forEach((keyed) => keyed.reset());\n    this._map.clear();\n  }\n}\n\nexport class KeyedResolvOnce<T, K = string> extends Keyed<ResolveOnce<T, K>, K> {\n  constructor() {\n    super((key) => new ResolveOnce<T, K>(key));\n  }\n}\n\nexport class KeyedResolvSeq<T, K = string> extends Keyed<ResolveSeq<T, K>, K> {\n  constructor() {\n    super((key) => new ResolveSeq<T, K>(key));\n  }\n}\n","import { ResolveOnce } from \"./resolve-once.js\";\n\nexport interface EnvMap {\n  get(key: string): string | undefined;\n  set(key: string, value?: string): void;\n  delete(key: string): void;\n  keys(): string[];\n}\nexport interface EnvActions extends EnvMap {\n  active(): boolean;\n  register(env: Env): Env;\n}\n\nclass NodeEnvActions implements EnvActions {\n  readonly #node = globalThis as unknown as { process: { env: Record<string, string> } };\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor, @typescript-eslint/no-unused-vars\n  constructor(opts: Partial<EnvFactoryOpts>) {\n    // do nothing\n  }\n\n  register(env: Env): Env {\n    return env;\n  }\n\n  active(): boolean {\n    return typeof this.#node === \"object\" && typeof this.#node.process === \"object\" && typeof this.#node.process.env === \"object\";\n  }\n  readonly _env = this.active() ? this.#node.process.env : {};\n  keys(): string[] {\n    return Object.keys(this._env);\n  }\n  get(key: string): string | undefined {\n    return this._env[key];\n  }\n  set(key: string, value?: string): void {\n    if (value) {\n      this._env[key] = value;\n    }\n  }\n  delete(key: string): void {\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete this._env[key];\n  }\n}\n\nclass DenoEnvActions implements EnvActions {\n  readonly #deno = globalThis as unknown as { Deno: { env: Map<string, string> } };\n\n  get _env(): Map<string, string> {\n    return this.#deno.Deno.env;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor, @typescript-eslint/no-unused-vars\n  constructor(opts: Partial<EnvFactoryOpts>) {\n    // do nothing\n  }\n\n  register(env: Env): Env {\n    return env;\n  }\n  active(): boolean {\n    return typeof this.#deno === \"object\" && typeof this.#deno.Deno === \"object\" && typeof this.#deno.Deno.env === \"object\";\n  }\n  keys(): string[] {\n    return Array.from(this._env.keys());\n  }\n  get(key: string): string | undefined {\n    return this._env.get(key);\n  }\n  set(key: string, value?: string): void {\n    if (value) {\n      this._env.set(key, value);\n    }\n  }\n  delete(key: string): void {\n    this._env.delete(key);\n  }\n}\n\nexport class BrowserEnvActions implements EnvActions {\n  readonly env: Map<string, string> = new Map<string, string>();\n  readonly opts: Partial<EnvFactoryOpts>;\n  constructor(opts: Partial<EnvFactoryOpts>) {\n    this.opts = opts;\n  }\n\n  get(key: string): string | undefined {\n    return this.env.get(key);\n  }\n  set(key: string, value?: string): void {\n    if (value) {\n      this.env.set(key, value);\n    }\n  }\n  delete(key: string): void {\n    this.env.delete(key);\n  }\n  keys(): string[] {\n    return Array.from(this.env.keys());\n  }\n  active(): boolean {\n    return true; // that should work on every runtime\n  }\n\n  register(env: Env): Env {\n    const sym = Symbol.for(this.opts.symbol || \"CP_ENV\");\n    const browser = globalThis as unknown as Record<symbol, Env>;\n    browser[sym] = env;\n    return env;\n  }\n}\n\nexport interface EnvFactoryOpts {\n  readonly symbol: string; // default \"CP_ENV\" used by BrowserEnvActions\n  readonly presetEnv: Map<string, string>;\n}\n\ntype OnSetFn = (key: string, value?: string) => void;\nexport interface OnSetItem {\n  readonly filter: Set<string>;\n  readonly fn: OnSetFn;\n}\n\nexport interface Env extends EnvMap {\n  onSet(fn: OnSetFn, ...filter: string[]): void;\n}\n\nconst _envFactory = new ResolveOnce<Env>();\nexport function envFactory(opts: Partial<EnvFactoryOpts> = {}): Env {\n  return _envFactory.once(() => {\n    const found = [new NodeEnvActions(opts), new DenoEnvActions(opts), new BrowserEnvActions(opts)].find((env) => env.active());\n    if (!found) {\n      throw new Error(\"SysContainer:envFactory: no env available\");\n    }\n    const ret = new EnvImpl(found, opts);\n    found.register(ret);\n    return ret;\n  });\n}\n\nexport class EnvImpl implements Env {\n  readonly _map: EnvMap;\n  constructor(map: EnvMap, opts: Partial<EnvFactoryOpts> = {}) {\n    this._map = map;\n    this._updatePresets(opts.presetEnv);\n  }\n  _updatePresets(presetEnv?: Map<string, string>): void {\n    if (!presetEnv) {\n      return;\n    }\n    for (const [key, value] of presetEnv) {\n      this._map.set(key, value);\n    }\n  }\n  _applyOnSet(onSet: OnSetItem[], key?: string, value?: string): void {\n    onSet.forEach((item) => {\n      let keys: string[] = [];\n      if (key) {\n        keys = [key];\n      } else {\n        keys = this._map.keys();\n      }\n      keys\n        .filter((k) => {\n          if (item.filter.size === 0) {\n            return true;\n          }\n          if (item.filter.has(k)) {\n            return true;\n          }\n          return false;\n        })\n        .forEach((k) => {\n          let v;\n          if (!key && !value) {\n            // init\n            v = this._map.get(k);\n          } else if (key && !value) {\n            // del\n            v = undefined;\n          } else {\n            // set\n            v = value;\n          }\n          item.fn(k, v);\n        });\n    });\n  }\n  readonly _onSet: OnSetItem[] = [];\n  keys(): string[] {\n    return this._map.keys();\n  }\n  // filter is not set all sets passed\n  onSet(fn: OnSetFn, ...filter: string[]): void {\n    const item: OnSetItem = { filter: new Set(filter), fn };\n    this._onSet.push(item);\n    this._applyOnSet([item]);\n  }\n  get(key: string): string | undefined {\n    return this._map.get(key);\n  }\n  set(key: string, value?: string): void {\n    if (!value) {\n      return;\n    }\n    this._map.set(key, value);\n    this._applyOnSet(this._onSet, key, value);\n  }\n  delete(key: string): void {\n    this._map.delete(key);\n    this._applyOnSet(this._onSet, key);\n  }\n}\n\n// export const envImpl = new EnvImpl();\n","import { BaseSysAbstraction, WrapperSysAbstraction, WrapperSysAbstractionParams } from \"../base-sys-abstraction.js\";\nimport { FileService, NamedWritableStream } from \"../file-service.js\";\nimport { SysAbstraction, SystemService, VoidFunc } from \"../sys-abstraction.js\";\nimport { Env, envFactory } from \"../sys-env.js\";\nimport { Utf8EnDecoderSingleton } from \"../txt-en-decoder.js\";\n\nclass WebFileService implements FileService {\n  get baseDir(): string {\n    throw new Error(\"basedir-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  create(fname: string): Promise<NamedWritableStream> {\n    throw new Error(\"create-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  readFileString(fname: string): Promise<string> {\n    throw new Error(\"readFileString-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  writeFileString(fname: string, content: string): Promise<void> {\n    throw new Error(\"writeFileString-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  abs(fname: string): string {\n    throw new Error(\"abs-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  join(...paths: string[]): string {\n    throw new Error(\"join-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  relative(from: string, to?: string | undefined): string {\n    throw new Error(\"relative-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  dirname(fname: string): string {\n    throw new Error(\"dirname-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  basename(fname: string): string {\n    throw new Error(\"basename-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  nodeImport(fname: string): string {\n    throw new Error(\"nodeImport-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isAbsolute(fname: string): boolean {\n    throw new Error(\"isAbsolute-Method not implemented.\");\n  }\n}\n\nclass WebSystemService implements SystemService {\n  Env(): Env {\n    return envFactory();\n  }\n  Args(): string[] {\n    throw new Error(\"Args-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  OnExit(hdl: VoidFunc): VoidFunc {\n    throw new Error(\"OnExit-Method not implemented.\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Exit(code: number): void {\n    throw new Error(\"Exit-Method not implemented.\");\n  }\n}\n\nlet my: BaseSysAbstraction | undefined = undefined;\nexport function WebSysAbstraction(param?: WrapperSysAbstractionParams): SysAbstraction {\n  if (!my) {\n    my = new BaseSysAbstraction({\n      TxtEnDecoder: param?.TxtEnDecoder || Utf8EnDecoderSingleton(),\n      FileSystem: new WebFileService(),\n      SystemService: new WebSystemService(),\n    });\n  }\n  return new WrapperSysAbstraction(my, param);\n}\n","const ALIAS = Symbol.for('yaml.alias');\nconst DOC = Symbol.for('yaml.document');\nconst MAP = Symbol.for('yaml.map');\nconst PAIR = Symbol.for('yaml.pair');\nconst SCALAR = Symbol.for('yaml.scalar');\nconst SEQ = Symbol.for('yaml.seq');\nconst NODE_TYPE = Symbol.for('yaml.node.type');\nconst isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;\nconst isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;\nconst isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;\nconst isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;\nconst isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;\nconst isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;\nfunction isCollection(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case MAP:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nfunction isNode(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case ALIAS:\n            case MAP:\n            case SCALAR:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nconst hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;\n\nexport { ALIAS, DOC, MAP, NODE_TYPE, PAIR, SCALAR, SEQ, hasAnchor, isAlias, isCollection, isDocument, isMap, isNode, isPair, isScalar, isSeq };\n","import { isDocument, isNode, isPair, isCollection, isMap, isSeq, isScalar, isAlias } from './nodes/identity.js';\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (isDocument(node)) {\n        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n    const ctrl = callVisitor(key, node, visitor, path);\n    if (isNode(ctrl) || isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visit_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = visit_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = visit_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = visit_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nasync function visitAsync(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (isDocument(node)) {\n        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        await visitAsync_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisitAsync.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisitAsync.SKIP = SKIP;\n/** Remove the current node */\nvisitAsync.REMOVE = REMOVE;\nasync function visitAsync_(key, node, visitor, path) {\n    const ctrl = await callVisitor(key, node, visitor, path);\n    if (isNode(ctrl) || isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visitAsync_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = await visitAsync_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = await visitAsync_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = await visitAsync_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\nfunction initVisitor(visitor) {\n    if (typeof visitor === 'object' &&\n        (visitor.Collection || visitor.Node || visitor.Value)) {\n        return Object.assign({\n            Alias: visitor.Node,\n            Map: visitor.Node,\n            Scalar: visitor.Node,\n            Seq: visitor.Node\n        }, visitor.Value && {\n            Map: visitor.Value,\n            Scalar: visitor.Value,\n            Seq: visitor.Value\n        }, visitor.Collection && {\n            Map: visitor.Collection,\n            Seq: visitor.Collection\n        }, visitor);\n    }\n    return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n    if (typeof visitor === 'function')\n        return visitor(key, node, path);\n    if (isMap(node))\n        return visitor.Map?.(key, node, path);\n    if (isSeq(node))\n        return visitor.Seq?.(key, node, path);\n    if (isPair(node))\n        return visitor.Pair?.(key, node, path);\n    if (isScalar(node))\n        return visitor.Scalar?.(key, node, path);\n    if (isAlias(node))\n        return visitor.Alias?.(key, node, path);\n    return undefined;\n}\nfunction replaceNode(key, path, node) {\n    const parent = path[path.length - 1];\n    if (isCollection(parent)) {\n        parent.items[key] = node;\n    }\n    else if (isPair(parent)) {\n        if (key === 'key')\n            parent.key = node;\n        else\n            parent.value = node;\n    }\n    else if (isDocument(parent)) {\n        parent.contents = node;\n    }\n    else {\n        const pt = isAlias(parent) ? 'alias' : 'scalar';\n        throw new Error(`Cannot replace node with ${pt} parent`);\n    }\n}\n\nexport { visit, visitAsync };\n","import { isNode } from '../nodes/identity.js';\nimport { visit } from '../visit.js';\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix) {\n            try {\n                return prefix + decodeURIComponent(suffix);\n            }\n            catch (error) {\n                onError(String(error));\n                return null;\n            }\n        }\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {\n            const tags = {};\n            visit(doc.contents, (_key, node) => {\n                if (isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\nexport { Directives };\n","import { isScalar, isCollection } from '../nodes/identity.js';\nimport { visit } from '../visit.js';\n\n/**\n * Verify that the input string is a valid anchor.\n *\n * Will throw on errors.\n */\nfunction anchorIsValid(anchor) {\n    if (/[\\x00-\\x19\\s,[\\]{}]/.test(anchor)) {\n        const sa = JSON.stringify(anchor);\n        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;\n        throw new Error(msg);\n    }\n    return true;\n}\nfunction anchorNames(root) {\n    const anchors = new Set();\n    visit(root, {\n        Value(_key, node) {\n            if (node.anchor)\n                anchors.add(node.anchor);\n        }\n    });\n    return anchors;\n}\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\nfunction findNewAnchor(prefix, exclude) {\n    for (let i = 1; true; ++i) {\n        const name = `${prefix}${i}`;\n        if (!exclude.has(name))\n            return name;\n    }\n}\nfunction createNodeAnchors(doc, prefix) {\n    const aliasObjects = [];\n    const sourceObjects = new Map();\n    let prevAnchors = null;\n    return {\n        onAnchor: (source) => {\n            aliasObjects.push(source);\n            if (!prevAnchors)\n                prevAnchors = anchorNames(doc);\n            const anchor = findNewAnchor(prefix, prevAnchors);\n            prevAnchors.add(anchor);\n            return anchor;\n        },\n        /**\n         * With circular references, the source node is only resolved after all\n         * of its child nodes are. This is why anchors are set only after all of\n         * the nodes have been created.\n         */\n        setAnchors: () => {\n            for (const source of aliasObjects) {\n                const ref = sourceObjects.get(source);\n                if (typeof ref === 'object' &&\n                    ref.anchor &&\n                    (isScalar(ref.node) || isCollection(ref.node))) {\n                    ref.node.anchor = ref.anchor;\n                }\n                else {\n                    const error = new Error('Failed to resolve repeated object (this should not happen)');\n                    error.source = source;\n                    throw error;\n                }\n            }\n        },\n        sourceObjects\n    };\n}\n\nexport { anchorIsValid, anchorNames, createNodeAnchors, findNewAnchor };\n","/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */\nfunction applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === 'object') {\n        if (Array.isArray(val)) {\n            for (let i = 0, len = val.length; i < len; ++i) {\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                // eslint-disable-next-line @typescript-eslint/no-array-delete\n                if (v1 === undefined)\n                    delete val[i];\n                else if (v1 !== v0)\n                    val[i] = v1;\n            }\n        }\n        else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())) {\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    val.delete(k);\n                else if (v1 !== v0)\n                    val.set(k, v1);\n            }\n        }\n        else if (val instanceof Set) {\n            for (const v0 of Array.from(val)) {\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined)\n                    val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        }\n        else {\n            for (const [k, v0] of Object.entries(val)) {\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    delete val[k];\n                else if (v1 !== v0)\n                    val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\n\nexport { applyReviver };\n","import { hasAnchor } from './identity.js';\n\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */\nfunction toJS(value, arg, ctx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    if (Array.isArray(value))\n        return value.map((v, i) => toJS(v, String(i), ctx));\n    if (value && typeof value.toJSON === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        if (!ctx || !hasAnchor(value))\n            return value.toJSON(arg, ctx);\n        const data = { aliasCount: 0, count: 1, res: undefined };\n        ctx.anchors.set(value, data);\n        ctx.onCreate = res => {\n            data.res = res;\n            delete ctx.onCreate;\n        };\n        const res = value.toJSON(arg, ctx);\n        if (ctx.onCreate)\n            ctx.onCreate(res);\n        return res;\n    }\n    if (typeof value === 'bigint' && !ctx?.keep)\n        return Number(value);\n    return value;\n}\n\nexport { toJS };\n","import { applyReviver } from '../doc/applyReviver.js';\nimport { NODE_TYPE, isDocument } from './identity.js';\nimport { toJS } from './toJS.js';\n\nclass NodeBase {\n    constructor(type) {\n        Object.defineProperty(this, NODE_TYPE, { value: type });\n    }\n    /** Create a copy of this node.  */\n    clone() {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** A plain JavaScript representation of this node. */\n    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        if (!isDocument(doc))\n            throw new TypeError('A document argument is required');\n        const ctx = {\n            anchors: new Map(),\n            doc,\n            keep: true,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS(this, '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n}\n\nexport { NodeBase };\n","import { anchorIsValid } from '../doc/anchors.js';\nimport { visit } from '../visit.js';\nimport { ALIAS, isAlias, isCollection, isPair } from './identity.js';\nimport { NodeBase } from './Node.js';\nimport { toJS } from './toJS.js';\n\nclass Alias extends NodeBase {\n    constructor(source) {\n        super(ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc) {\n        let found = undefined;\n        visit(doc, {\n            Node: (_key, node) => {\n                if (node === this)\n                    return visit.BREAK;\n                if (node.anchor === this.source)\n                    found = node;\n            }\n        });\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        let data = anchors.get(source);\n        if (!data) {\n            // Resolve anchors for Node.prototype.toJS()\n            toJS(source, null, ctx);\n            data = anchors.get(source);\n        }\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexport { Alias };\n","import { SCALAR } from './identity.js';\nimport { NodeBase } from './Node.js';\nimport { toJS } from './toJS.js';\n\nconst isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');\nclass Scalar extends NodeBase {\n    constructor(value) {\n        super(SCALAR);\n        this.value = value;\n    }\n    toJSON(arg, ctx) {\n        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nScalar.BLOCK_FOLDED = 'BLOCK_FOLDED';\nScalar.BLOCK_LITERAL = 'BLOCK_LITERAL';\nScalar.PLAIN = 'PLAIN';\nScalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';\nScalar.QUOTE_SINGLE = 'QUOTE_SINGLE';\n\nexport { Scalar, isScalarValue };\n","import { Alias } from '../nodes/Alias.js';\nimport { isNode, isPair, MAP, SEQ, isDocument } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\n\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter(t => t.tag === tagName);\n        const tagObj = match.find(t => !t.format) ?? match[0];\n        if (!tagObj)\n            throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (isDocument(value))\n        value = value.contents;\n    if (isNode(value))\n        return value;\n    if (isPair(value)) {\n        const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);\n        map.items.push(value);\n        return map;\n    }\n    if (value instanceof String ||\n        value instanceof Number ||\n        value instanceof Boolean ||\n        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere\n    ) {\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\n        value = value.valueOf();\n    }\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\n    // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `ref` wrapper allows for circular references to resolve.\n    let ref = undefined;\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\n        ref = sourceObjects.get(value);\n        if (ref) {\n            if (!ref.anchor)\n                ref.anchor = onAnchor(value);\n            return new Alias(ref.anchor);\n        }\n        else {\n            ref = { anchor: null, node: null };\n            sourceObjects.set(value, ref);\n        }\n    }\n    if (tagName?.startsWith('!!'))\n        tagName = defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, schema.tags);\n    if (!tagObj) {\n        if (value && typeof value.toJSON === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            value = value.toJSON();\n        }\n        if (!value || typeof value !== 'object') {\n            const node = new Scalar(value);\n            if (ref)\n                ref.node = node;\n            return node;\n        }\n        tagObj =\n            value instanceof Map\n                ? schema[MAP]\n                : Symbol.iterator in Object(value)\n                    ? schema[SEQ]\n                    : schema[MAP];\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    }\n    const node = tagObj?.createNode\n        ? tagObj.createNode(ctx.schema, value, ctx)\n        : typeof tagObj?.nodeClass?.from === 'function'\n            ? tagObj.nodeClass.from(ctx.schema, value, ctx)\n            : new Scalar(value);\n    if (tagName)\n        node.tag = tagName;\n    else if (!tagObj.default)\n        node.tag = tagObj.tag;\n    if (ref)\n        ref.node = node;\n    return node;\n}\n\nexport { createNode };\n","import { createNode } from '../doc/createNode.js';\nimport { isNode, isPair, isCollection, isScalar } from './identity.js';\nimport { NodeBase } from './Node.js';\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => isNode(it) || isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && isScalar(node) ? node.value : node;\n        else\n            return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\n\nexport { Collection, collectionFromPath, isEmptyPath };\n","/**\n * Stringifies a comment.\n *\n * Empty comment lines are left empty,\n * lines consisting of a single space are replaced by `#`,\n * and all other lines are prefixed with a `#`.\n */\nconst stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');\nfunction indentComment(comment, indent) {\n    if (/^\\n+$/.test(comment))\n        return comment.substring(1);\n    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;\n}\nconst lineComment = (str, indent, comment) => str.endsWith('\\n')\n    ? indentComment(comment, indent)\n    : comment.includes('\\n')\n        ? '\\n' + indentComment(comment, indent)\n        : (str.endsWith(' ') ? '' : ' ') + comment;\n\nexport { indentComment, lineComment, stringifyComment };\n","const FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    if (lineWidth < minContentWidth)\n        minContentWidth = 0;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i, indent.length);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i, indent.length);\n            end = i + indent.length + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i, indent) {\n    let end = i;\n    let start = i + 1;\n    let ch = text[start];\n    while (ch === ' ' || ch === '\\t') {\n        if (i < start + indent) {\n            ch = text[++i];\n        }\n        else {\n            do {\n                ch = text[++i];\n            } while (ch && ch !== '\\n');\n            end = i;\n            start = i + 1;\n            ch = text[start];\n        }\n    }\n    return end;\n}\n\nexport { FOLD_BLOCK, FOLD_FLOW, FOLD_QUOTED, foldFlowLines };\n","import { Scalar } from '../nodes/Scalar.js';\nimport { foldFlowLines, FOLD_QUOTED, FOLD_FLOW, FOLD_BLOCK } from './foldFlowLines.js';\n\nconst getFoldOptions = (ctx, isBlock) => ({\n    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n});\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n    if (!lineWidth || lineWidth < 0)\n        return false;\n    const limit = lineWidth - indentLength;\n    const strLen = str.length;\n    if (strLen <= limit)\n        return false;\n    for (let i = 0, start = 0; i < strLen; ++i) {\n        if (str[i] === '\\n') {\n            if (i - start > limit)\n                return true;\n            start = i + 1;\n            if (strLen - start <= limit)\n                return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const json = JSON.stringify(value);\n    if (ctx.options.doubleQuotedAsJSON)\n        return json;\n    const { implicitKey } = ctx;\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    let str = '';\n    let start = 0;\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + '\\\\ ';\n            i += 1;\n            start = i;\n            ch = '\\\\';\n        }\n        if (ch === '\\\\')\n            switch (json[i + 1]) {\n                case 'u':\n                    {\n                        str += json.slice(start, i);\n                        const code = json.substr(i + 2, 4);\n                        switch (code) {\n                            case '0000':\n                                str += '\\\\0';\n                                break;\n                            case '0007':\n                                str += '\\\\a';\n                                break;\n                            case '000b':\n                                str += '\\\\v';\n                                break;\n                            case '001b':\n                                str += '\\\\e';\n                                break;\n                            case '0085':\n                                str += '\\\\N';\n                                break;\n                            case '00a0':\n                                str += '\\\\_';\n                                break;\n                            case '2028':\n                                str += '\\\\L';\n                                break;\n                            case '2029':\n                                str += '\\\\P';\n                                break;\n                            default:\n                                if (code.substr(0, 2) === '00')\n                                    str += '\\\\x' + code.substr(2);\n                                else\n                                    str += json.substr(i, 6);\n                        }\n                        i += 5;\n                        start = i + 1;\n                    }\n                    break;\n                case 'n':\n                    if (implicitKey ||\n                        json[i + 2] === '\"' ||\n                        json.length < minMultiLineLength) {\n                        i += 1;\n                    }\n                    else {\n                        // folding will eat first newline\n                        str += json.slice(start, i) + '\\n\\n';\n                        while (json[i + 2] === '\\\\' &&\n                            json[i + 3] === 'n' &&\n                            json[i + 4] !== '\"') {\n                            str += '\\n';\n                            i += 2;\n                        }\n                        str += indent;\n                        // space after newline needs to be escaped to not be folded\n                        if (json[i + 2] === ' ')\n                            str += '\\\\';\n                        i += 1;\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    i += 1;\n            }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey\n        ? str\n        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.options.singleQuote === false ||\n        (ctx.implicitKey && value.includes('\\n')) ||\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\n    )\n        return doubleQuotedString(value, ctx);\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey\n        ? res\n        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction quotedString(value, ctx) {\n    const { singleQuote } = ctx.options;\n    let qs;\n    if (singleQuote === false)\n        qs = doubleQuotedString;\n    else {\n        const hasDouble = value.includes('\"');\n        const hasSingle = value.includes(\"'\");\n        if (hasDouble && !hasSingle)\n            qs = singleQuotedString;\n        else if (hasSingle && !hasDouble)\n            qs = doubleQuotedString;\n        else\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\n    }\n    return qs(value, ctx);\n}\n// The negative lookbehind avoids a polynomial search,\n// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind\nlet blockEndNewlines;\ntry {\n    blockEndNewlines = new RegExp('(^|(?<!\\n))\\n+(?!\\n|$)', 'g');\n}\ncatch {\n    blockEndNewlines = /\\n+(?!\\n|$)/g;\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    const { blockQuote, commentString, lineWidth } = ctx.options;\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n        return quotedString(value, ctx);\n    }\n    const indent = ctx.indent ||\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n    const literal = blockQuote === 'literal'\n        ? true\n        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED\n            ? false\n            : type === Scalar.BLOCK_LITERAL\n                ? true\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\n    if (!value)\n        return literal ? '|\\n' : '>\\n';\n    // determine chomping from whitespace at value end\n    let chomp;\n    let endStart;\n    for (endStart = value.length; endStart > 0; --endStart) {\n        const ch = value[endStart - 1];\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\n            break;\n    }\n    let end = value.substring(endStart);\n    const endNlPos = end.indexOf('\\n');\n    if (endNlPos === -1) {\n        chomp = '-'; // strip\n    }\n    else if (value === end || endNlPos !== end.length - 1) {\n        chomp = '+'; // keep\n        if (onChompKeep)\n            onChompKeep();\n    }\n    else {\n        chomp = ''; // clip\n    }\n    if (end) {\n        value = value.slice(0, -end.length);\n        if (end[end.length - 1] === '\\n')\n            end = end.slice(0, -1);\n        end = end.replace(blockEndNewlines, `$&${indent}`);\n    }\n    // determine indent indicator from whitespace at value start\n    let startWithSpace = false;\n    let startEnd;\n    let startNlPos = -1;\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\n        const ch = value[startEnd];\n        if (ch === ' ')\n            startWithSpace = true;\n        else if (ch === '\\n')\n            startNlPos = startEnd;\n        else\n            break;\n    }\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n    if (start) {\n        value = value.substring(start.length);\n        start = start.replace(/\\n+/g, `$&${indent}`);\n    }\n    const indentSize = indent ? '2' : '1'; // root is at -1\n    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;\n    if (comment) {\n        header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n        if (onComment)\n            onComment();\n    }\n    if (literal) {\n        value = value.replace(/\\n+/g, `$&${indent}`);\n        return `${header}\\n${indent}${start}${value}${end}`;\n    }\n    value = value\n        .replace(/\\n+/g, '\\n$&')\n        .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\n        .replace(/\\n+/g, `$&${indent}`);\n    const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));\n    return `${header}\\n${indent}${body}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { type, value } = item;\n    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;\n    if ((implicitKey && value.includes('\\n')) ||\n        (inFlow && /[[\\]{},]/.test(value))) {\n        return quotedString(value, ctx);\n    }\n    if (!value ||\n        /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        // not allowed:\n        // - empty string, '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || !value.includes('\\n')\n            ? quotedString(value, ctx)\n            : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey &&\n        !inFlow &&\n        type !== Scalar.PLAIN &&\n        value.includes('\\n')) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (containsDocumentMarker(value)) {\n        if (indent === '') {\n            ctx.forceBlockIndent = true;\n            return blockString(item, ctx, onComment, onChompKeep);\n        }\n        else if (implicitKey && indent === indentStep) {\n            return quotedString(value, ctx);\n        }\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);\n        const { compat, tags } = ctx.doc.schema;\n        if (tags.some(test) || compat?.some(test))\n            return quotedString(value, ctx);\n    }\n    return implicitKey\n        ? str\n        : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { implicitKey, inFlow } = ctx;\n    const ss = typeof item.value === 'string'\n        ? item\n        : Object.assign({}, item, { value: String(item.value) });\n    let { type } = item;\n    if (type !== Scalar.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\n            type = Scalar.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type) => {\n        switch (_type) {\n            case Scalar.BLOCK_FOLDED:\n            case Scalar.BLOCK_LITERAL:\n                return implicitKey || inFlow\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\n                    : blockString(ss, ctx, onComment, onChompKeep);\n            case Scalar.QUOTE_DOUBLE:\n                return doubleQuotedString(ss.value, ctx);\n            case Scalar.QUOTE_SINGLE:\n                return singleQuotedString(ss.value, ctx);\n            case Scalar.PLAIN:\n                return plainString(ss, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const { defaultKeyType, defaultStringType } = ctx.options;\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\n        res = _stringify(t);\n        if (res === null)\n            throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\n\nexport { stringifyString };\n","import { anchorIsValid } from '../doc/anchors.js';\nimport { isPair, isAlias, isNode, isScalar, isCollection } from '../nodes/identity.js';\nimport { stringifyComment } from './stringifyComment.js';\nimport { stringifyString } from './stringifyString.js';\n\nfunction createStringifyContext(doc, options) {\n    const opt = Object.assign({\n        blockQuote: true,\n        commentString: stringifyComment,\n        defaultKeyType: null,\n        defaultStringType: 'PLAIN',\n        directives: null,\n        doubleQuotedAsJSON: false,\n        doubleQuotedMinMultiLineLength: 40,\n        falseStr: 'false',\n        flowCollectionPadding: true,\n        indentSeq: true,\n        lineWidth: 80,\n        minContentWidth: 20,\n        nullStr: 'null',\n        simpleKeys: false,\n        singleQuote: null,\n        trueStr: 'true',\n        verifyAliasOrder: true\n    }, doc.schema.toStringOptions, options);\n    let inFlow;\n    switch (opt.collectionStyle) {\n        case 'block':\n            inFlow = false;\n            break;\n        case 'flow':\n            inFlow = true;\n            break;\n        default:\n            inFlow = null;\n    }\n    return {\n        anchors: new Set(),\n        doc,\n        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',\n        indent: '',\n        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',\n        inFlow,\n        options: opt\n    };\n}\nfunction getTagObject(tags, item) {\n    if (item.tag) {\n        const match = tags.filter(t => t.tag === item.tag);\n        if (match.length > 0)\n            return match.find(t => t.format === item.format) ?? match[0];\n    }\n    let tagObj = undefined;\n    let obj;\n    if (isScalar(item)) {\n        obj = item.value;\n        const match = tags.filter(t => t.identify?.(obj));\n        tagObj =\n            match.find(t => t.format === item.format) ?? match.find(t => !t.format);\n    }\n    else {\n        obj = item;\n        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n    }\n    if (!tagObj) {\n        const name = obj?.constructor?.name ?? typeof obj;\n        throw new Error(`Tag not resolved for ${name} value`);\n    }\n    return tagObj;\n}\n// needs to be called before value stringifier to allow for circular anchor refs\nfunction stringifyProps(node, tagObj, { anchors, doc }) {\n    if (!doc.directives)\n        return '';\n    const props = [];\n    const anchor = (isScalar(node) || isCollection(node)) && node.anchor;\n    if (anchor && anchorIsValid(anchor)) {\n        anchors.add(anchor);\n        props.push(`&${anchor}`);\n    }\n    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;\n    if (tag)\n        props.push(doc.directives.tagString(tag));\n    return props.join(' ');\n}\nfunction stringify(item, ctx, onComment, onChompKeep) {\n    if (isPair(item))\n        return item.toString(ctx, onComment, onChompKeep);\n    if (isAlias(item)) {\n        if (ctx.doc.directives)\n            return item.toString(ctx);\n        if (ctx.resolvedAliases?.has(item)) {\n            throw new TypeError(`Cannot stringify circular structure without alias nodes`);\n        }\n        else {\n            if (ctx.resolvedAliases)\n                ctx.resolvedAliases.add(item);\n            else\n                ctx.resolvedAliases = new Set([item]);\n            item = item.resolve(ctx.doc);\n        }\n    }\n    let tagObj = undefined;\n    const node = isNode(item)\n        ? item\n        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });\n    if (!tagObj)\n        tagObj = getTagObject(ctx.doc.schema.tags, node);\n    const props = stringifyProps(node, tagObj, ctx);\n    if (props.length > 0)\n        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;\n    const str = typeof tagObj.stringify === 'function'\n        ? tagObj.stringify(node, ctx, onComment, onChompKeep)\n        : isScalar(node)\n            ? stringifyString(node, ctx, onComment, onChompKeep)\n            : node.toString(ctx, onComment, onChompKeep);\n    if (!props)\n        return str;\n    return isScalar(node) || str[0] === '{' || str[0] === '['\n        ? `${props} ${str}`\n        : `${props}\\n${ctx.indent}${str}`;\n}\n\nexport { createStringifyContext, stringify };\n","import { isCollection, isNode, isScalar, isSeq } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { stringify } from './stringify.js';\nimport { lineComment, indentComment } from './stringifyComment.js';\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (isCollection(key) || (!isNode(key) && typeof key === 'object')) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            isCollection(key) ||\n            (isScalar(key)\n                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vsb, vcb, valueComment;\n    if (isNode(value)) {\n        vsb = !!value.spaceBefore;\n        vcb = value.commentBefore;\n        valueComment = value.comment;\n    }\n    else {\n        vsb = false;\n        vcb = null;\n        valueComment = null;\n        if (value && typeof value === 'object')\n            value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substring(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (keyComment || vsb || vcb) {\n        ws = vsb ? '\\n' : '';\n        if (vcb) {\n            const cs = commentString(vcb);\n            ws += `\\n${indentComment(cs, ctx.indent)}`;\n        }\n        if (valueStr === '' && !ctx.inFlow) {\n            if (ws === '\\n')\n                ws = '\\n\\n';\n        }\n        else {\n            ws += `\\n${ctx.indent}`;\n        }\n    }\n    else if (!explicitKey && isCollection(value)) {\n        const vs0 = valueStr[0];\n        const nl0 = valueStr.indexOf('\\n');\n        const hasNewline = nl0 !== -1;\n        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n        if (hasNewline || !flow) {\n            let hasPropsLine = false;\n            if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n                let sp0 = valueStr.indexOf(' ');\n                if (vs0 === '&' &&\n                    sp0 !== -1 &&\n                    sp0 < nl0 &&\n                    valueStr[sp0 + 1] === '!') {\n                    sp0 = valueStr.indexOf(' ', sp0 + 1);\n                }\n                if (sp0 === -1 || nl0 < sp0)\n                    hasPropsLine = true;\n            }\n            if (!hasPropsLine)\n                ws = `\\n${ctx.indent}`;\n        }\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n') {\n        ws = '';\n    }\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nexport { stringifyPair };\n","function debug(logLevel, ...messages) {\n    if (logLevel === 'debug')\n        console.log(...messages);\n}\nfunction warn(logLevel, warning) {\n    if (logLevel === 'debug' || logLevel === 'warn') {\n        if (typeof process !== 'undefined' && process.emitWarning)\n            process.emitWarning(warning);\n        else\n            console.warn(warning);\n    }\n}\n\nexport { debug, warn };\n","import { warn } from '../log.js';\nimport { createStringifyContext } from '../stringify/stringify.js';\nimport { isAlias, isSeq, isScalar, isMap, isNode } from './identity.js';\nimport { Scalar } from './Scalar.js';\nimport { toJS } from './toJS.js';\n\nconst MERGE_KEY = '<<';\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (ctx?.doc.schema.merge && isMergeKey(key)) {\n        value = isAlias(value) ? value.resolve(ctx.doc) : value;\n        if (isSeq(value))\n            for (const it of value.items)\n                mergeToJSMap(ctx, map, it);\n        else if (Array.isArray(value))\n            for (const it of value)\n                mergeToJSMap(ctx, map, it);\n        else\n            mergeToJSMap(ctx, map, value);\n    }\n    else {\n        const jsKey = toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nconst isMergeKey = (key) => key === MERGE_KEY ||\n    (isScalar(key) &&\n        key.value === MERGE_KEY &&\n        (!key.type || key.type === Scalar.PLAIN));\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nfunction mergeToJSMap(ctx, map, value) {\n    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (isNode(key) && ctx?.doc) {\n        const strCtx = createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nexport { addPairToJSMap };\n","import { createNode } from '../doc/createNode.js';\nimport { stringifyPair } from '../stringify/stringifyPair.js';\nimport { addPairToJSMap } from './addPairToJSMap.js';\nimport { NODE_TYPE, PAIR, isNode } from './identity.js';\n\nfunction createPair(key, value, ctx) {\n    const k = createNode(key, undefined, ctx);\n    const v = createNode(value, undefined, ctx);\n    return new Pair(k, v);\n}\nclass Pair {\n    constructor(key, value = null) {\n        Object.defineProperty(this, NODE_TYPE, { value: PAIR });\n        this.key = key;\n        this.value = value;\n    }\n    clone(schema) {\n        let { key, value } = this;\n        if (isNode(key))\n            key = key.clone(schema);\n        if (isNode(value))\n            value = value.clone(schema);\n        return new Pair(key, value);\n    }\n    toJSON(_, ctx) {\n        const pair = ctx?.mapAsMap ? new Map() : {};\n        return addPairToJSMap(ctx, pair, this);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        return ctx?.doc\n            ? stringifyPair(this, ctx, onComment, onChompKeep)\n            : JSON.stringify(this);\n    }\n}\n\nexport { Pair, createPair };\n","import { isNode, isPair } from '../nodes/identity.js';\nimport { stringify } from './stringify.js';\nimport { lineComment, indentComment } from './stringifyComment.js';\n\nfunction stringifyCollection(collection, ctx, options) {\n    const flow = ctx.inFlow ?? collection.flow;\n    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;\n    return stringify(collection, ctx, options);\n}\nfunction stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {\n    const { indent, options: { commentString } } = ctx;\n    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });\n    let chompKeep = false; // flag for the preceding node's status\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (isNode(item)) {\n            if (!chompKeep && item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (isPair(item)) {\n            const ik = isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (!chompKeep && ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);\n            }\n        }\n        chompKeep = false;\n        let str = stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));\n        if (comment)\n            str += lineComment(str, itemIndent, commentString(comment));\n        if (chompKeep && comment)\n            chompKeep = false;\n        lines.push(blockItemPrefix + str);\n    }\n    let str;\n    if (lines.length === 0) {\n        str = flowChars.start + flowChars.end;\n    }\n    else {\n        str = lines[0];\n        for (let i = 1; i < lines.length; ++i) {\n            const line = lines[i];\n            str += line ? `\\n${indent}${line}` : '\\n';\n        }\n    }\n    if (comment) {\n        str += '\\n' + indentComment(commentString(comment), indent);\n        if (onComment)\n            onComment();\n    }\n    else if (chompKeep && onChompKeep)\n        onChompKeep();\n    return str;\n}\nfunction stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {\n    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;\n    itemIndent += indentStep;\n    const itemCtx = Object.assign({}, ctx, {\n        indent: itemIndent,\n        inFlow: true,\n        type: null\n    });\n    let reqNewline = false;\n    let linesAtValue = 0;\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (isNode(item)) {\n            if (item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, false);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (isPair(item)) {\n            const ik = isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, false);\n                if (ik.comment)\n                    reqNewline = true;\n            }\n            const iv = isNode(item.value) ? item.value : null;\n            if (iv) {\n                if (iv.comment)\n                    comment = iv.comment;\n                if (iv.commentBefore)\n                    reqNewline = true;\n            }\n            else if (item.value == null && ik?.comment) {\n                comment = ik.comment;\n            }\n        }\n        if (comment)\n            reqNewline = true;\n        let str = stringify(item, itemCtx, () => (comment = null));\n        if (i < items.length - 1)\n            str += ',';\n        if (comment)\n            str += lineComment(str, itemIndent, commentString(comment));\n        if (!reqNewline && (lines.length > linesAtValue || str.includes('\\n')))\n            reqNewline = true;\n        lines.push(str);\n        linesAtValue = lines.length;\n    }\n    const { start, end } = flowChars;\n    if (lines.length === 0) {\n        return start + end;\n    }\n    else {\n        if (!reqNewline) {\n            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);\n            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;\n        }\n        if (reqNewline) {\n            let str = start;\n            for (const line of lines)\n                str += line ? `\\n${indentStep}${indent}${line}` : '\\n';\n            return `${str}\\n${indent}${end}`;\n        }\n        else {\n            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;\n        }\n    }\n}\nfunction addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {\n    if (comment && chompKeep)\n        comment = comment.replace(/^\\n+/, '');\n    if (comment) {\n        const ic = indentComment(commentString(comment), indent);\n        lines.push(ic.trimStart()); // Avoid double indent on first line\n    }\n}\n\nexport { stringifyCollection };\n","import { stringifyCollection } from '../stringify/stringifyCollection.js';\nimport { addPairToJSMap } from './addPairToJSMap.js';\nimport { Collection } from './Collection.js';\nimport { isPair, isScalar, MAP } from './identity.js';\nimport { Pair, createPair } from './Pair.js';\nimport { isScalarValue } from './Scalar.js';\n\nfunction findPair(items, key) {\n    const k = isScalar(key) ? key.value : key;\n    for (const it of items) {\n        if (isPair(it)) {\n            if (it.key === key || it.key === k)\n                return it;\n            if (isScalar(it.key) && it.key.value === k)\n                return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:map';\n    }\n    constructor(schema) {\n        super(MAP, schema);\n        this.items = [];\n    }\n    /**\n     * A generic collection parsing method that can be extended\n     * to other node classes that inherit from YAMLMap\n     */\n    static from(schema, obj, ctx) {\n        const { keepUndefined, replacer } = ctx;\n        const map = new this(schema);\n        const add = (key, value) => {\n            if (typeof replacer === 'function')\n                value = replacer.call(obj, key, value);\n            else if (Array.isArray(replacer) && !replacer.includes(key))\n                return;\n            if (value !== undefined || keepUndefined)\n                map.items.push(createPair(key, value, ctx));\n        };\n        if (obj instanceof Map) {\n            for (const [key, value] of obj)\n                add(key, value);\n        }\n        else if (obj && typeof obj === 'object') {\n            for (const key of Object.keys(obj))\n                add(key, obj[key]);\n        }\n        if (typeof schema.sortMapEntries === 'function') {\n            map.items.sort(schema.sortMapEntries);\n        }\n        return map;\n    }\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair, overwrite) {\n        let _pair;\n        if (isPair(pair))\n            _pair = pair;\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n            // In TypeScript, this never happens.\n            _pair = new Pair(pair, pair?.value);\n        }\n        else\n            _pair = new Pair(pair.key, pair.value);\n        const prev = findPair(this.items, _pair.key);\n        const sortEntries = this.schema?.sortMapEntries;\n        if (prev) {\n            if (!overwrite)\n                throw new Error(`Key ${_pair.key} already set`);\n            // For scalars, keep the old node & its comments and anchors\n            if (isScalar(prev.value) && isScalarValue(_pair.value))\n                prev.value.value = _pair.value;\n            else\n                prev.value = _pair.value;\n        }\n        else if (sortEntries) {\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n            if (i === -1)\n                this.items.push(_pair);\n            else\n                this.items.splice(i, 0, _pair);\n        }\n        else {\n            this.items.push(_pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it)\n            return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it?.value;\n        return (!keepScalar && isScalar(node) ? node.value : node) ?? undefined;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair(key, value), true);\n    }\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const item of this.items)\n            addPairToJSMap(ctx, map, item);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        for (const item of this.items) {\n            if (!isPair(item))\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\n            ctx = Object.assign({}, ctx, { allNullValues: true });\n        return stringifyCollection(this, ctx, {\n            blockItemPrefix: '',\n            flowChars: { start: '{', end: '}' },\n            itemIndent: ctx.indent || '',\n            onChompKeep,\n            onComment\n        });\n    }\n}\n\nexport { YAMLMap, findPair };\n","import { isMap } from '../../nodes/identity.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\n\nconst map = {\n    collection: 'map',\n    default: true,\n    nodeClass: YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode: (schema, obj, ctx) => YAMLMap.from(schema, obj, ctx)\n};\n\nexport { map };\n","import { createNode } from '../doc/createNode.js';\nimport { stringifyCollection } from '../stringify/stringifyCollection.js';\nimport { Collection } from './Collection.js';\nimport { SEQ, isScalar } from './identity.js';\nimport { isScalarValue } from './Scalar.js';\nimport { toJS } from './toJS.js';\n\nclass YAMLSeq extends Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:seq';\n    }\n    constructor(schema) {\n        super(SEQ, schema);\n        this.items = [];\n    }\n    add(value) {\n        this.items.push(value);\n    }\n    /**\n     * Removes a value from the collection.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     *\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return false;\n        const del = this.items.splice(idx, 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return undefined;\n        const it = this.items[idx];\n        return !keepScalar && isScalar(it) ? it.value : it;\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    has(key) {\n        const idx = asItemIndex(key);\n        return typeof idx === 'number' && idx < this.items.length;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     *\n     * If `key` does not contain a representation of an integer, this will throw.\n     * It may be wrapped in a `Scalar`.\n     */\n    set(key, value) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            throw new Error(`Expected a valid index, not ${key}.`);\n        const prev = this.items[idx];\n        if (isScalar(prev) && isScalarValue(value))\n            prev.value = value;\n        else\n            this.items[idx] = value;\n    }\n    toJSON(_, ctx) {\n        const seq = [];\n        if (ctx?.onCreate)\n            ctx.onCreate(seq);\n        let i = 0;\n        for (const item of this.items)\n            seq.push(toJS(item, String(i++), ctx));\n        return seq;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        return stringifyCollection(this, ctx, {\n            blockItemPrefix: '- ',\n            flowChars: { start: '[', end: ']' },\n            itemIndent: (ctx.indent || '') + '  ',\n            onChompKeep,\n            onComment\n        });\n    }\n    static from(schema, obj, ctx) {\n        const { replacer } = ctx;\n        const seq = new this(schema);\n        if (obj && Symbol.iterator in Object(obj)) {\n            let i = 0;\n            for (let it of obj) {\n                if (typeof replacer === 'function') {\n                    const key = obj instanceof Set ? it : String(i++);\n                    it = replacer.call(obj, key, it);\n                }\n                seq.items.push(createNode(it, undefined, ctx));\n            }\n        }\n        return seq;\n    }\n}\nfunction asItemIndex(key) {\n    let idx = isScalar(key) ? key.value : key;\n    if (idx && typeof idx === 'string')\n        idx = Number(idx);\n    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0\n        ? idx\n        : null;\n}\n\nexport { YAMLSeq };\n","import { isSeq } from '../../nodes/identity.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\n\nconst seq = {\n    collection: 'seq',\n    default: true,\n    nodeClass: YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    },\n    createNode: (schema, obj, ctx) => YAMLSeq.from(schema, obj, ctx)\n};\n\nexport { seq };\n","import { stringifyString } from '../../stringify/stringifyString.js';\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { string };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nexport { nullTag };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nexport { boolTag };\n","function stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nexport { stringifyNumber };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nexport { float, floatExp, floatNaN };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber(node);\n}\nconst intOct = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\n    stringify: node => intStringify(node, 8, '0o')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexport { int, intHex, intOct };\n","import { map } from '../common/map.js';\nimport { nullTag } from '../common/null.js';\nimport { seq } from '../common/seq.js';\nimport { string } from '../common/string.js';\nimport { boolTag } from './bool.js';\nimport { floatNaN, floatExp, float } from './float.js';\nimport { intOct, int, intHex } from './int.js';\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    boolTag,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float\n];\n\nexport { schema };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { map } from '../common/map.js';\nimport { seq } from '../common/seq.js';\n\nfunction intIdentify(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true|false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema = [map, seq].concat(jsonScalars, jsonError);\n\nexport { schema };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyString } from '../../stringify/stringifyString.js';\n\nconst binary = {\n    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof Buffer === 'function') {\n            return Buffer.from(src, 'base64');\n        }\n        else if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof Buffer === 'function') {\n            str =\n                buf instanceof Buffer\n                    ? buf.toString('base64')\n                    : Buffer.from(buf.buffer).toString('base64');\n        }\n        else if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        if (!type)\n            type = Scalar.BLOCK_LITERAL;\n        if (type !== Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { binary };\n","import { isSeq, isPair, isMap } from '../../nodes/identity.js';\nimport { Pair, createPair } from '../../nodes/Pair.js';\nimport { Scalar } from '../../nodes/Scalar.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\n\nfunction resolvePairs(seq, onError) {\n    if (isSeq(seq)) {\n        for (let i = 0; i < seq.items.length; ++i) {\n            let item = seq.items[i];\n            if (isPair(item))\n                continue;\n            else if (isMap(item)) {\n                if (item.items.length > 1)\n                    onError('Each pair must have its own sequence indicator');\n                const pair = item.items[0] || new Pair(new Scalar(null));\n                if (item.commentBefore)\n                    pair.key.commentBefore = pair.key.commentBefore\n                        ? `${item.commentBefore}\\n${pair.key.commentBefore}`\n                        : item.commentBefore;\n                if (item.comment) {\n                    const cn = pair.value ?? pair.key;\n                    cn.comment = cn.comment\n                        ? `${item.comment}\\n${cn.comment}`\n                        : item.comment;\n                }\n                item = pair;\n            }\n            seq.items[i] = isPair(item) ? item : new Pair(item);\n        }\n    }\n    else\n        onError('Expected a sequence for this tag');\n    return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const pairs = new YAMLSeq(schema);\n    pairs.tag = 'tag:yaml.org,2002:pairs';\n    let i = 0;\n    if (iterable && Symbol.iterator in Object(iterable))\n        for (let it of iterable) {\n            if (typeof replacer === 'function')\n                it = replacer.call(iterable, String(i++), it);\n            let key, value;\n            if (Array.isArray(it)) {\n                if (it.length === 2) {\n                    key = it[0];\n                    value = it[1];\n                }\n                else\n                    throw new TypeError(`Expected [key, value] tuple: ${it}`);\n            }\n            else if (it && it instanceof Object) {\n                const keys = Object.keys(it);\n                if (keys.length === 1) {\n                    key = keys[0];\n                    value = it[key];\n                }\n                else {\n                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);\n                }\n            }\n            else {\n                key = it;\n            }\n            pairs.items.push(createPair(key, value, ctx));\n        }\n    return pairs;\n}\nconst pairs = {\n    collection: 'seq',\n    default: false,\n    tag: 'tag:yaml.org,2002:pairs',\n    resolve: resolvePairs,\n    createNode: createPairs\n};\n\nexport { createPairs, pairs, resolvePairs };\n","import { isScalar, isPair } from '../../nodes/identity.js';\nimport { toJS } from '../../nodes/toJS.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\nimport { resolvePairs, createPairs } from './pairs.js';\n\nclass YAMLOMap extends YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (isPair(pair)) {\n                key = toJS(pair.key, '', ctx);\n                value = toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n    static from(schema, iterable, ctx) {\n        const pairs = createPairs(schema, iterable, ctx);\n        const omap = new this();\n        omap.items = pairs.items;\n        return omap;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs = resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs.items) {\n            if (isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs);\n    },\n    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)\n};\n\nexport { YAMLOMap, omap };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,\n    resolve: () => new Scalar(false),\n    stringify: boolStringify\n};\n\nexport { falseTag, trueTag };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nexport { float, floatExp, floatNaN };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexport { int, intBin, intHex, intOct };\n","import { isMap, isPair, isScalar } from '../../nodes/identity.js';\nimport { Pair, createPair } from '../../nodes/Pair.js';\nimport { YAMLMap, findPair } from '../../nodes/YAMLMap.js';\n\nclass YAMLSet extends YAMLMap {\n    constructor(schema) {\n        super(schema);\n        this.tag = YAMLSet.tag;\n    }\n    add(key) {\n        let pair;\n        if (isPair(key))\n            pair = key;\n        else if (key &&\n            typeof key === 'object' &&\n            'key' in key &&\n            'value' in key &&\n            key.value === null)\n            pair = new Pair(key.key, null);\n        else\n            pair = new Pair(key, null);\n        const prev = findPair(this.items, pair.key);\n        if (!prev)\n            this.items.push(pair);\n    }\n    /**\n     * If `keepPair` is `true`, returns the Pair matching `key`.\n     * Otherwise, returns the value of that Pair's key.\n     */\n    get(key, keepPair) {\n        const pair = findPair(this.items, key);\n        return !keepPair && isPair(pair)\n            ? isScalar(pair.key)\n                ? pair.key.value\n                : pair.key\n            : pair;\n    }\n    set(key, value) {\n        if (typeof value !== 'boolean')\n            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n        const prev = findPair(this.items, key);\n        if (prev && !value) {\n            this.items.splice(this.items.indexOf(prev), 1);\n        }\n        else if (!prev && value) {\n            this.items.push(new Pair(key));\n        }\n    }\n    toJSON(_, ctx) {\n        return super.toJSON(_, ctx, Set);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        if (this.hasAllNullValues(true))\n            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);\n        else\n            throw new Error('Set items must all have null values');\n    }\n    static from(schema, iterable, ctx) {\n        const { replacer } = ctx;\n        const set = new this(schema);\n        if (iterable && Symbol.iterator in Object(iterable))\n            for (let value of iterable) {\n                if (typeof replacer === 'function')\n                    value = replacer.call(iterable, value, value);\n                set.items.push(createPair(value, null, ctx));\n            }\n        return set;\n    }\n}\nYAMLSet.tag = 'tag:yaml.org,2002:set';\nconst set = {\n    collection: 'map',\n    identify: value => value instanceof Set,\n    nodeClass: YAMLSet,\n    default: false,\n    tag: 'tag:yaml.org,2002:set',\n    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),\n    resolve(map, onError) {\n        if (isMap(map)) {\n            if (map.hasAllNullValues(true))\n                return Object.assign(new YAMLSet(), map);\n            else\n                onError('Set items must all have null values');\n        }\n        else\n            onError('Expected a mapping for this tag');\n        return map;\n    }\n};\n\nexport { YAMLSet, set };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => String(n).padStart(2, '0'))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\nexport { floatTime, intTime, timestamp };\n","import { map } from '../common/map.js';\nimport { nullTag } from '../common/null.js';\nimport { seq } from '../common/seq.js';\nimport { string } from '../common/string.js';\nimport { binary } from './binary.js';\nimport { trueTag, falseTag } from './bool.js';\nimport { floatNaN, floatExp, float } from './float.js';\nimport { intBin, intOct, int, intHex } from './int.js';\nimport { omap } from './omap.js';\nimport { pairs } from './pairs.js';\nimport { set } from './set.js';\nimport { intTime, floatTime, timestamp } from './timestamp.js';\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    trueTag,\n    falseTag,\n    intBin,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float,\n    binary,\n    omap,\n    pairs,\n    set,\n    intTime,\n    floatTime,\n    timestamp\n];\n\nexport { schema };\n","import { map } from './common/map.js';\nimport { nullTag } from './common/null.js';\nimport { seq } from './common/seq.js';\nimport { string } from './common/string.js';\nimport { boolTag } from './core/bool.js';\nimport { float, floatExp, floatNaN } from './core/float.js';\nimport { int, intHex, intOct } from './core/int.js';\nimport { schema } from './core/schema.js';\nimport { schema as schema$1 } from './json/schema.js';\nimport { binary } from './yaml-1.1/binary.js';\nimport { omap } from './yaml-1.1/omap.js';\nimport { pairs } from './yaml-1.1/pairs.js';\nimport { schema as schema$2 } from './yaml-1.1/schema.js';\nimport { set } from './yaml-1.1/set.js';\nimport { timestamp, floatTime, intTime } from './yaml-1.1/timestamp.js';\n\nconst schemas = new Map([\n    ['core', schema],\n    ['failsafe', [map, seq, string]],\n    ['json', schema$1],\n    ['yaml11', schema$2],\n    ['yaml-1.1', schema$2]\n]);\nconst tagsByName = {\n    binary,\n    bool: boolTag,\n    float,\n    floatExp,\n    floatNaN,\n    floatTime,\n    int,\n    intHex,\n    intOct,\n    intTime,\n    map,\n    null: nullTag,\n    omap,\n    pairs,\n    seq,\n    set,\n    timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary,\n    'tag:yaml.org,2002:omap': omap,\n    'tag:yaml.org,2002:pairs': pairs,\n    'tag:yaml.org,2002:set': set,\n    'tag:yaml.org,2002:timestamp': timestamp\n};\nfunction getTags(customTags, schemaName) {\n    let tags = schemas.get(schemaName);\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    return tags.map(tag => {\n        if (typeof tag !== 'string')\n            return tag;\n        const tagObj = tagsByName[tag];\n        if (tagObj)\n            return tagObj;\n        const keys = Object.keys(tagsByName)\n            .map(key => JSON.stringify(key))\n            .join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n    });\n}\n\nexport { coreKnownTags, getTags };\n","import { MAP, SCALAR, SEQ } from '../nodes/identity.js';\nimport { map } from './common/map.js';\nimport { seq } from './common/seq.js';\nimport { string } from './common/string.js';\nimport { getTags, coreKnownTags } from './tags.js';\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? getTags(compat, 'compat')\n            : compat\n                ? getTags(null, compat)\n                : null;\n        this.merge = !!merge;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? coreKnownTags : {};\n        this.tags = getTags(customTags, this.name);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, MAP, { value: map });\n        Object.defineProperty(this, SCALAR, { value: string });\n        Object.defineProperty(this, SEQ, { value: seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nexport { Schema };\n","import { isNode } from '../nodes/identity.js';\nimport { createStringifyContext, stringify } from './stringify.js';\nimport { indentComment, lineComment } from './stringifyComment.js';\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nexport { stringifyDocument };\n","import { Alias } from '../nodes/Alias.js';\nimport { isEmptyPath, collectionFromPath } from '../nodes/Collection.js';\nimport { NODE_TYPE, DOC, isNode, isCollection, isScalar } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { toJS } from '../nodes/toJS.js';\nimport { Schema } from '../schema/Schema.js';\nimport { stringifyDocument } from '../stringify/stringifyDocument.js';\nimport { anchorNames, findNewAnchor, createNodeAnchors } from './anchors.js';\nimport { applyReviver } from './applyReviver.js';\nimport { createNode } from './createNode.js';\nimport { Directives } from './directives.js';\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, NODE_TYPE, { value: DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new Directives({ version });\n        this.setSchema(version, options);\n        // @ts-expect-error We can't really know that this matches Contents.\n        this.contents =\n            value === undefined ? null : this.createNode(value, _replacer, options);\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [NODE_TYPE]: { value: DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        // @ts-expect-error We can't really know that this matches Contents.\n        copy.contents = isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode(value, tag, ctx);\n        if (flow && isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            // @ts-expect-error Presumed impossible if Strict extends false\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (isEmptyPath(path))\n            return !keepScalar && isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (isEmptyPath(path))\n            return this.contents !== undefined;\n        return isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (isEmptyPath(path)) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = value;\n        }\n        else if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new Directives({ version: '1.1' });\n                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new Directives({ version });\n                opt = { merge: false, resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexport { Document };\n","class YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '…' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '…';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '…\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end && end.line === line && end.col > col) {\n            count = Math.max(1, Math.min(end.col - col, 80 - ci));\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nexport { YAMLError, YAMLParseError, YAMLWarning, prettifyError };\n","function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let reqSpace = false;\n    let tab = null;\n    let anchor = null;\n    let tag = null;\n    let newlineAfterProp = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        if (tab) {\n            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {\n                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n            }\n            tab = null;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&\n                    token.source.includes('\\t')) {\n                    tab = token;\n                }\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    newlineAfterProp = token;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline =\n                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== '')) {\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    }\n    if (tab &&\n        ((atNewline && tab.indent <= parentIndent) ||\n            next?.type === 'block-map' ||\n            next?.type === 'block-seq'))\n        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        anchor,\n        tag,\n        newlineAfterProp,\n        end,\n        start: start ?? end\n    };\n}\n\nexport { resolveProps };\n","function containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nexport { containsNewline };\n","import { containsNewline } from './util-contains-newline.js';\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nexport { flowIndentCheck };\n","import { isScalar } from '../nodes/identity.js';\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b ||\n            (isScalar(a) &&\n                isScalar(b) &&\n                a.value === b.value &&\n                !(a.value === '<<' && ctx.schema.merge));\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nexport { mapIncludes };\n","import { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.newlineAfterProp || containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bm.indent, key, onError);\n        if (mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexport { resolveBlockMap };\n","import { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveProps } from './resolve-props.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLSeq;\n    const seq = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bs.offset;\n    let commentEnd = null;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            parentIndent: bs.indent,\n            startOnNewline: true\n        });\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value && value.type === 'block-seq')\n                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                commentEnd = props.end;\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, props.end, start, null, props, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, commentEnd ?? offset];\n    return seq;\n}\n\nexport { resolveBlockSeq };\n","function resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nexport { resolveEnd };\n","import { isPair } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq));\n    const coll = new NodeClass(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: fc.indent,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            // → key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            // value properties\n            const valueProps = resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                parentIndent: fc.indent,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source && value.source[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                const endRange = (valueNode ?? keyNode).range;\n                map.range = [keyNode.range[0], endRange[1], endRange[2]];\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce && ce.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexport { resolveFlowCollection };\n","import { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, props, onError) {\n    const tagToken = props.tag;\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (token.type === 'block-seq') {\n        const { anchor, newlineAfterProp: nl } = props;\n        const lastProp = anchor && tagToken\n            ? anchor.offset > tagToken.offset\n                ? anchor\n                : tagToken\n            : (anchor ?? tagToken);\n        if (lastProp && (!nl || nl.offset < lastProp.offset)) {\n            const message = 'Missing newline after block sequence props';\n            onError(lastProp, 'MISSING_CHAR', message);\n        }\n    }\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.tagName && expType === 'seq')) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt?.collection) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = isNode(res)\n        ? res\n        : new Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexport { composeCollection };\n","import { Scalar } from '../nodes/Scalar.js';\n\nfunction resolveBlockScalar(ctx, scalar, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            if (trimIndent === 0 && !ctx.atRoot) {\n                const message = 'Block scalar values in collections must be indented';\n                onError(offset, 'BAD_INDENT', message);\n            }\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexport { resolveBlockScalar };\n","import { Scalar } from '../nodes/Scalar.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0', // null character\n    a: '\\x07', // bell character\n    b: '\\b', // backspace\n    e: '\\x1b', // escape character\n    f: '\\f', // form feed\n    n: '\\n', // line feed\n    r: '\\r', // carriage return\n    t: '\\t', // horizontal tab\n    v: '\\v', // vertical tab\n    N: '\\u0085', // Unicode next line\n    _: '\\u00a0', // Unicode non-breaking space\n    L: '\\u2028', // Unicode line separator\n    P: '\\u2029', // Unicode paragraph separator\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexport { resolveFlowScalar };\n","import { SCALAR, isScalar } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { resolveBlockScalar } from './resolve-block-scalar.js';\nimport { resolveFlowScalar } from './resolve-flow-scalar.js';\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar(ctx, token, onError)\n        : resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    const tag = tagToken && tagName\n        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)\n        : token.type === 'scalar'\n            ? findScalarTagByTest(ctx, value, token, onError)\n            : ctx.schema[SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = isScalar(res) ? res : new Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[SCALAR];\n}\nfunction findScalarTagByTest({ directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexport { composeScalar };\n","function emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        if (pos === null)\n            pos = before.length;\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nexport { emptyScalarPosition };\n","import { Alias } from '../nodes/Alias.js';\nimport { composeCollection } from './compose-collection.js';\nimport { composeScalar } from './compose-scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { emptyScalarPosition } from './util-empty-scalar-position.js';\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection(CN, ctx, token, props, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexport { composeEmptyNode, composeNode };\n","import { Document } from '../doc/Document.js';\nimport { composeNode, composeEmptyNode } from './compose-node.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document(undefined, opts);\n    const ctx = {\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        parentIndent: 0,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    // @ts-expect-error If Contents is set, let's trust the user\n    doc.contents = value\n        ? composeNode(ctx, value, props, onError)\n        : composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nexport { composeDoc };\n","import { Directives } from '../doc/directives.js';\nimport { Document } from '../doc/Document.js';\nimport { YAMLWarning, YAMLParseError } from '../errors.js';\nimport { isCollection, isPair } from '../nodes/identity.js';\nimport { composeDoc } from './compose-doc.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexport { Composer };\n","import { resolveBlockScalar } from '../compose/resolve-block-scalar.js';\nimport { resolveFlowScalar } from '../compose/resolve-flow-scalar.js';\nimport { YAMLParseError } from '../errors.js';\nimport { stringifyString } from '../stringify/stringifyString.js';\n\nfunction resolveAsScalar(token, strict = true, onError) {\n    if (token) {\n        const _onError = (pos, code, message) => {\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n            if (onError)\n                onError(offset, code, message);\n            else\n                throw new YAMLParseError([offset, offset + 1], code, message);\n        };\n        switch (token.type) {\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return resolveFlowScalar(token, strict, _onError);\n            case 'block-scalar':\n                return resolveBlockScalar({ options: { strict } }, token, _onError);\n        }\n    }\n    return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\n    const source = stringifyString({ type, value }, {\n        implicitKey,\n        indent: indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    const end = context.end ?? [\n        { type: 'newline', offset: -1, indent, source: '\\n' }\n    ];\n    switch (source[0]) {\n        case '|':\n        case '>': {\n            const he = source.indexOf('\\n');\n            const head = source.substring(0, he);\n            const body = source.substring(he + 1) + '\\n';\n            const props = [\n                { type: 'block-scalar-header', offset, indent, source: head }\n            ];\n            if (!addEndtoBlockProps(props, end))\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n            return { type: 'block-scalar', offset, indent, props, source: body };\n        }\n        case '\"':\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\n        case \"'\":\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\n        default:\n            return { type: 'scalar', offset, indent, source, end };\n    }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\n    let indent = 'indent' in token ? token.indent : null;\n    if (afterKey && typeof indent === 'number')\n        indent += 2;\n    if (!type)\n        switch (token.type) {\n            case 'single-quoted-scalar':\n                type = 'QUOTE_SINGLE';\n                break;\n            case 'double-quoted-scalar':\n                type = 'QUOTE_DOUBLE';\n                break;\n            case 'block-scalar': {\n                const header = token.props[0];\n                if (header.type !== 'block-scalar-header')\n                    throw new Error('Invalid block scalar header');\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n                break;\n            }\n            default:\n                type = 'PLAIN';\n        }\n    const source = stringifyString({ type, value }, {\n        implicitKey: implicitKey || indent === null,\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    switch (source[0]) {\n        case '|':\n        case '>':\n            setBlockScalarValue(token, source);\n            break;\n        case '\"':\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\n            break;\n        case \"'\":\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\n            break;\n        default:\n            setFlowScalarValue(token, source, 'scalar');\n    }\n}\nfunction setBlockScalarValue(token, source) {\n    const he = source.indexOf('\\n');\n    const head = source.substring(0, he);\n    const body = source.substring(he + 1) + '\\n';\n    if (token.type === 'block-scalar') {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header')\n            throw new Error('Invalid block scalar header');\n        header.source = head;\n        token.source = body;\n    }\n    else {\n        const { offset } = token;\n        const indent = 'indent' in token ? token.indent : -1;\n        const props = [\n            { type: 'block-scalar-header', offset, indent, source: head }\n        ];\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n        for (const key of Object.keys(token))\n            if (key !== 'type' && key !== 'offset')\n                delete token[key];\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\n    }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n    if (end)\n        for (const st of end)\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                    props.push(st);\n                    break;\n                case 'newline':\n                    props.push(st);\n                    return true;\n            }\n    return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n    switch (token.type) {\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            token.type = type;\n            token.source = source;\n            break;\n        case 'block-scalar': {\n            const end = token.props.slice(1);\n            let oa = source.length;\n            if (token.props[0].type === 'block-scalar-header')\n                oa -= token.props[0].source.length;\n            for (const tok of end)\n                tok.offset += oa;\n            delete token.props;\n            Object.assign(token, { type, source, end });\n            break;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            const offset = token.offset + source.length;\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\n            delete token.items;\n            Object.assign(token, { type, source, end: [nl] });\n            break;\n        }\n        default: {\n            const indent = 'indent' in token ? token.indent : -1;\n            const end = 'end' in token && Array.isArray(token.end)\n                ? token.end.filter(st => st.type === 'space' ||\n                    st.type === 'comment' ||\n                    st.type === 'newline')\n                : [];\n            for (const key of Object.keys(token))\n                if (key !== 'type' && key !== 'offset')\n                    delete token[key];\n            Object.assign(token, { type, indent, source, end });\n        }\n    }\n}\n\nexport { createScalarToken, resolveAsScalar, setScalarValue };\n","/**\n * Stringify a CST document, token, or collection item\n *\n * Fair warning: This applies no validation whatsoever, and\n * simply concatenates the sources in their logical order.\n */\nconst stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);\nfunction stringifyToken(token) {\n    switch (token.type) {\n        case 'block-scalar': {\n            let res = '';\n            for (const tok of token.props)\n                res += stringifyToken(tok);\n            return res + token.source;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            let res = '';\n            for (const item of token.items)\n                res += stringifyItem(item);\n            return res;\n        }\n        case 'flow-collection': {\n            let res = token.start.source;\n            for (const item of token.items)\n                res += stringifyItem(item);\n            for (const st of token.end)\n                res += st.source;\n            return res;\n        }\n        case 'document': {\n            let res = stringifyItem(token);\n            if (token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n        default: {\n            let res = token.source;\n            if ('end' in token && token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n    }\n}\nfunction stringifyItem({ start, key, sep, value }) {\n    let res = '';\n    for (const st of start)\n        res += st.source;\n    if (key)\n        res += stringifyToken(key);\n    if (sep)\n        for (const st of sep)\n            res += st.source;\n    if (value)\n        res += stringifyToken(value);\n    return res;\n}\n\nexport { stringify };\n","const BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove item');\n/**\n * Apply a visitor to a CST document or item.\n *\n * Walks through the tree (depth-first) starting from the root, calling a\n * `visitor` function with two arguments when entering each item:\n *   - `item`: The current item, which included the following members:\n *     - `start: SourceToken[]` – Source tokens before the key or value,\n *       possibly including its anchor or tag.\n *     - `key?: Token | null` – Set for pair values. May then be `null`, if\n *       the key before the `:` separator is empty.\n *     - `sep?: SourceToken[]` – Source tokens between the key and the value,\n *       which should include the `:` map value indicator if `value` is set.\n *     - `value?: Token` – The value of a sequence item, or of a map pair.\n *   - `path`: The steps from the root to the current node, as an array of\n *     `['key' | 'value', number]` tuples.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\n *      next sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\n *   - `number`: Set the index of the next step. This is useful especially if\n *     the index of the current token has changed.\n *   - `function`: Define the next visitor for this item. After the original\n *     visitor is called on item entry, next visitors are called after handling\n *     a non-empty `key` and when exiting the item.\n */\nfunction visit(cst, visitor) {\n    if ('type' in cst && cst.type === 'document')\n        cst = { start: cst.start, value: cst.value };\n    _visit(Object.freeze([]), cst, visitor);\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current item */\nvisit.SKIP = SKIP;\n/** Remove the current item */\nvisit.REMOVE = REMOVE;\n/** Find the item at `path` from `cst` as the root */\nvisit.itemAtPath = (cst, path) => {\n    let item = cst;\n    for (const [field, index] of path) {\n        const tok = item?.[field];\n        if (tok && 'items' in tok) {\n            item = tok.items[index];\n        }\n        else\n            return undefined;\n    }\n    return item;\n};\n/**\n * Get the immediate parent collection of the item at `path` from `cst` as the root.\n *\n * Throws an error if the collection is not found, which should never happen if the item itself exists.\n */\nvisit.parentCollection = (cst, path) => {\n    const parent = visit.itemAtPath(cst, path.slice(0, -1));\n    const field = path[path.length - 1][0];\n    const coll = parent?.[field];\n    if (coll && 'items' in coll)\n        return coll;\n    throw new Error('Parent collection not found');\n};\nfunction _visit(path, item, visitor) {\n    let ctrl = visitor(item, path);\n    if (typeof ctrl === 'symbol')\n        return ctrl;\n    for (const field of ['key', 'value']) {\n        const token = item[field];\n        if (token && 'items' in token) {\n            for (let i = 0; i < token.items.length; ++i) {\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    token.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n            if (typeof ctrl === 'function' && field === 'key')\n                ctrl = ctrl(item, path);\n        }\n    }\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\n\nexport { visit };\n","export { createScalarToken, resolveAsScalar, setScalarValue } from './cst-scalar.js';\nexport { stringify } from './cst-stringify.js';\nexport { visit } from './cst-visit.js';\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = (token) => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = (token) => !!token &&\n    (token.type === 'scalar' ||\n        token.type === 'single-quoted-scalar' ||\n        token.type === 'double-quoted-scalar' ||\n        token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n    switch (token) {\n        case BOM:\n            return '<BOM>';\n        case DOCUMENT:\n            return '<DOC>';\n        case FLOW_END:\n            return '<FLOW_END>';\n        case SCALAR:\n            return '<SCALAR>';\n        default:\n            return JSON.stringify(token);\n    }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n    switch (source) {\n        case BOM:\n            return 'byte-order-mark';\n        case DOCUMENT:\n            return 'doc-mode';\n        case FLOW_END:\n            return 'flow-error-end';\n        case SCALAR:\n            return 'scalar';\n        case '---':\n            return 'doc-start';\n        case '...':\n            return 'doc-end';\n        case '':\n        case '\\n':\n        case '\\r\\n':\n            return 'newline';\n        case '-':\n            return 'seq-item-ind';\n        case '?':\n            return 'explicit-key-ind';\n        case ':':\n            return 'map-value-ind';\n        case '{':\n            return 'flow-map-start';\n        case '}':\n            return 'flow-map-end';\n        case '[':\n            return 'flow-seq-start';\n        case ']':\n            return 'flow-seq-end';\n        case ',':\n            return 'comma';\n    }\n    switch (source[0]) {\n        case ' ':\n        case '\\t':\n            return 'space';\n        case '#':\n            return 'comment';\n        case '%':\n            return 'directive-line';\n        case '*':\n            return 'alias';\n        case '&':\n            return 'anchor';\n        case '!':\n            return 'tag';\n        case \"'\":\n            return 'single-quoted-scalar';\n        case '\"':\n            return 'double-quoted-scalar';\n        case '|':\n        case '>':\n            return 'block-scalar-header';\n    }\n    return null;\n}\n\nexport { BOM, DOCUMENT, FLOW_END, SCALAR, isCollection, isScalar, prettyToken, tokenType };\n","import { BOM, DOCUMENT, FLOW_END, SCALAR } from './cst.js';\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = new Set('0123456789ABCDEFabcdef');\nconst tagChars = new Set(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\");\nconst flowIndicatorChars = new Set(',[]{}');\nconst invalidAnchorChars = new Set(' ,[]{}\\n\\r\\t');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            if (typeof source !== 'string')\n                throw TypeError('source is not a string');\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            let cs = line.indexOf('#');\n            while (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t') {\n                    dirEnd = cs - 1;\n                    break;\n                }\n                else {\n                    cs = line.indexOf('#', cs + 1);\n                }\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return s === '---' ? 'doc' : 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else {\n                this.indentNext =\n                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);\n            }\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        // Trailing insufficiently indented tabs are invalid.\n        // To catch that during parsing, we include them in the block scalar value.\n        let i = nl + 1;\n        ch = this.buffer[i];\n        while (ch === ' ')\n            ch = this.buffer[++i];\n        if (ch === '\\t') {\n            while (ch === '\\t' || ch === ' ' || ch === '\\r' || ch === '\\n')\n                ch = this.buffer[++i];\n            nl = i - 1;\n        }\n        else if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && flowIndicatorChars.has(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.has(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.has(this.buffer[i + 1]) &&\n                    hexDigits.has(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexport { Lexer };\n","/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nexport { LineCounter };\n","import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !it.explicitKey;\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atMapIndent = !this.onKeyLine && this.indent === map.indent;\n            const atNextItem = atMapIndent &&\n                (it.sep || it.explicitKey) &&\n                this.type !== 'seq-item-ind';\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !it.explicitKey) {\n                        it.start.push(this.sourceToken);\n                        it.explicitKey = true;\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start, explicitKey: true });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken], explicitKey: true }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (it.explicitKey) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key;\n                            // @ts-expect-error type guard is wrong here\n                            delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (atMapIndent && bv.type !== 'block-seq') {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, explicitKey: true }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexport { Parser };\n","import { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;\n    return { lineCounter, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    const docs = Array.from(composer.compose(parser.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(prettifyError(source, lineCounter));\n            doc.warnings.forEach(prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(prettifyError(source, lineCounter));\n        doc.warnings.forEach(prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    return new Document(value, _replacer, options).toString(options);\n}\n\nexport { parse, parseAllDocuments, parseDocument, stringify };\n","export { Composer } from './compose/composer.js';\nexport { Document } from './doc/Document.js';\nexport { Schema } from './schema/Schema.js';\nexport { YAMLError, YAMLParseError, YAMLWarning } from './errors.js';\nexport { Alias } from './nodes/Alias.js';\nexport { isAlias, isCollection, isDocument, isMap, isNode, isPair, isScalar, isSeq } from './nodes/identity.js';\nexport { Pair } from './nodes/Pair.js';\nexport { Scalar } from './nodes/Scalar.js';\nexport { YAMLMap } from './nodes/YAMLMap.js';\nexport { YAMLSeq } from './nodes/YAMLSeq.js';\nimport * as cst from './parse/cst.js';\nexport { cst as CST };\nexport { Lexer } from './parse/lexer.js';\nexport { LineCounter } from './parse/line-counter.js';\nexport { Parser } from './parse/parser.js';\nexport { parse, parseAllDocuments, parseDocument, stringify } from './public-api.js';\nexport { visit, visitAsync } from './visit.js';\n","// `export * as default from ...` fails on Webpack v4\n// https://github.com/eemeli/yaml/issues/228\nimport * as YAML from './dist/index.js'\nexport default YAML\nexport * from './dist/index.js'\n","// import { v4 } from \"uuid\";\nimport YAML from \"yaml\";\nimport {\n  AsError,\n  FnSerialized,\n  LogSerializable,\n  Level,\n  Logger,\n  logValue,\n  Serialized,\n  WithLogger,\n  removeSelfRef,\n  Sized,\n  Lengthed,\n  LogValue,\n  asyncLogValue,\n  LevelHandler,\n  LogFormatter,\n  LogValueArg,\n} from \"./logger.js\";\nimport { WebSysAbstraction } from \"./web/web-sys-abstraction.js\";\nimport { SysAbstraction } from \"./sys-abstraction.js\";\nimport { Result } from \"./result.js\";\nimport { CoerceURI, URI } from \"./uri.js\";\nimport { runtimeFn } from \"./runtime.js\";\nimport { ConsoleWriterStream } from \"./utils/console-write-stream.js\";\nimport { LogWriterStream } from \"./log-writer-impl.js\";\nimport { TxtEnDecoder, Utf8EnDecoderSingleton } from \"./txt-en-decoder.js\";\nimport { LevelHandlerSingleton } from \"./log-level-impl.js\";\n\nfunction getLen(value: unknown): LogValue {\n  if (Array.isArray(value)) {\n    return logValue(() => value.length);\n  } else if (typeof value === \"string\") {\n    return logValue(() => value.length);\n  } else if (typeof value === \"object\" && value !== null) {\n    if (typeof (value as Sized).size === \"number\") {\n      return logValue(() => (value as Sized).size);\n    } else if (typeof (value as Lengthed).length === \"number\") {\n      return logValue(() => (value as Lengthed).length);\n    }\n    return logValue(() => Object.keys(value).length);\n  }\n  return logValue(() => -1);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction hash(value: unknown): string {\n  // const hasher = createHash(\"sha256\");\n  // hasher.update(JSON.stringify(value, removeSelfRef()));\n  // return hasher.digest(\"hex\");\n  return \"not implemented\";\n}\n\nfunction toLogValue(lop: LogValue | Promise<LogValue>): LogValue | undefined {\n  if (lop && typeof (lop as Promise<LogValue>).then === \"function\") {\n    throw new Error(\"async logValue Not implemented\");\n  }\n  return lop as LogValue;\n}\n\nexport class JSONFormatter implements LogFormatter {\n  private readonly _txtEnDe: TxtEnDecoder;\n  private readonly _space?: number;\n  constructor(txtEnde: TxtEnDecoder, space?: number) {\n    this._txtEnDe = txtEnde;\n    this._space = space;\n  }\n  format(attr: LogSerializable): Uint8Array {\n    return this._txtEnDe.encode(JSON.stringify(attr, removeSelfRef(), this._space) + \"\\n\");\n  }\n}\n\nexport class YAMLFormatter implements LogFormatter {\n  private readonly _txtEnDe: TxtEnDecoder;\n  private readonly _space?: number;\n  constructor(txtEnde: TxtEnDecoder, space?: number) {\n    this._txtEnDe = txtEnde;\n    this._space = space;\n  }\n  format(attr: LogSerializable): Uint8Array {\n    return this._txtEnDe.encode(\"---\\n\" + YAML.stringify(attr, removeSelfRef(), this._space) + \"\\n\");\n  }\n}\n\nexport interface LoggerImplParams {\n  readonly out?: WritableStream<Uint8Array>;\n  readonly logWriter?: LogWriterStream;\n  readonly sys?: SysAbstraction;\n  readonly withAttributes?: LogSerializable;\n  readonly levelHandler?: LevelHandler;\n  readonly txtEnDe?: TxtEnDecoder;\n  readonly formatter?: LogFormatter;\n}\n\nexport class LoggerImpl implements Logger {\n  readonly _sys: SysAbstraction;\n  readonly _attributes: LogSerializable = {};\n  readonly _withAttributes: LogSerializable;\n  readonly _logWriter: LogWriterStream;\n  readonly _levelHandler: LevelHandler;\n  readonly _txtEnDe: TxtEnDecoder;\n  _formatter: LogFormatter;\n  // readonly _id: string = \"logger-\" + Math.random().toString(36)\n\n  constructor(params?: LoggerImplParams) {\n    if (!params) {\n      params = {};\n    }\n    if (!params.sys) {\n      this._sys = WebSysAbstraction();\n    } else {\n      this._sys = params.sys;\n    }\n    if (!params.txtEnDe) {\n      this._txtEnDe = Utf8EnDecoderSingleton();\n    } else {\n      this._txtEnDe = params.txtEnDe;\n    }\n    if (!params.formatter) {\n      this._formatter = new JSONFormatter(this._txtEnDe);\n    } else {\n      this._formatter = params.formatter;\n    }\n\n    if (params.logWriter) {\n      this._logWriter = params.logWriter;\n    } else {\n      if (!params.out) {\n        const rt = runtimeFn();\n        let stream: WritableStream<Uint8Array>;\n        if (rt.isBrowser) {\n          stream = new ConsoleWriterStream();\n        } else {\n          if (rt.isNodeIsh || rt.isReactNative || rt.isDeno) {\n            stream = this._sys.Stdout();\n          } else {\n            throw new Error(\"No output defined for runtime\");\n          }\n        }\n        this._logWriter = new LogWriterStream(stream);\n      } else {\n        this._logWriter = new LogWriterStream(params.out);\n      }\n    }\n    if (!params.withAttributes) {\n      this._withAttributes = {};\n    } else {\n      this._withAttributes = { ...params.withAttributes };\n    }\n    this._attributes = { ...this._withAttributes };\n    if (params.levelHandler) {\n      this._levelHandler = params.levelHandler;\n    } else {\n      this._levelHandler = LevelHandlerSingleton();\n    }\n    // console.log(\"LoggerImpl\", this._id, this._attributes, this._withAttributes)\n  }\n\n  TxtEnDe(): TxtEnDecoder {\n    return this._txtEnDe;\n  }\n\n  Attributes(): Record<string, unknown> {\n    return JSON.parse(JSON.stringify(this._attributes, removeSelfRef()));\n    // return Array.from(Object.entries(this._attributes)).reduce(\n    //   (acc, [key, value]) => {\n    //     if (value instanceof LogValue) {\n    //       acc[key] = value.value();\n    //     }\n    //     return acc;\n    //   },\n    //   {} as Record<string, unknown>,\n    // );\n  }\n\n  SetExposeStack(enable?: boolean): Logger {\n    this._levelHandler.setExposeStack(enable);\n    return this;\n  }\n\n  EnableLevel(level: Level, ...modules: string[]): Logger {\n    this._levelHandler.enableLevel(level, ...modules);\n    return this;\n  }\n  DisableLevel(level: Level, ...modules: string[]): Logger {\n    this._levelHandler.disableLevel(level, ...modules);\n    return this;\n  }\n\n  Module(key: string): Logger {\n    this._attributes[\"module\"] = logValue(key);\n    this._withAttributes[\"module\"] = logValue(key);\n    return this;\n  }\n  // if the string is \"*\" it will enable for all modules\n  SetDebug(...modules: (string | string[])[]): Logger {\n    this._levelHandler.setDebug(...modules);\n    return this;\n  }\n\n  SetFormatter(formatter: LogFormatter): Logger {\n    this._formatter = formatter;\n    return this;\n  }\n\n  Timestamp(): Logger {\n    this._attributes[\"ts\"] = logValue(() => this._sys.Time().Now().toISOString());\n    return this;\n  }\n  Warn(): Logger {\n    this._attributes[\"level\"] = logValue(Level.WARN);\n    return this;\n  }\n  Log(): Logger {\n    return this;\n  }\n  Debug(): Logger {\n    this._attributes[\"level\"] = logValue(Level.DEBUG);\n    return this;\n  }\n  Error(): Logger {\n    this._attributes[\"level\"] = logValue(Level.ERROR);\n    return this;\n  }\n  Info(): Logger {\n    this._attributes[\"level\"] = logValue(Level.INFO);\n    return this;\n  }\n  Err(err: unknown | Result<unknown> | Error): Logger {\n    if (Result.Is(err)) {\n      if (err.isOk()) {\n        this.Result(\"noerror\", err);\n      } else {\n        this.Result(\"error\", err);\n      }\n    } else if (err instanceof Error) {\n      this._attributes[\"error\"] = logValue(err.message);\n      if (this._levelHandler.isStackExposed) {\n        this._attributes[\"stack\"] = logValue(err.stack?.split(\"\\n\").map((s) => s.trim()));\n      }\n    } else {\n      this._attributes[\"error\"] = logValue(\"\" + err);\n    }\n    return this;\n  }\n  WithLevel(l: Level): Logger {\n    this._attributes[\"level\"] = logValue(l);\n    return this;\n  }\n\n  Ref(key: string, action: { toString: () => string } | FnSerialized): Logger {\n    if (typeof action === \"function\") {\n      this._attributes[key] = logValue(action as FnSerialized);\n    } else if (typeof action.toString === \"function\") {\n      this._attributes[key] = logValue(() => action.toString());\n    } else {\n      this._attributes[key] = logValue(\"INVALID REF\");\n    }\n    return this;\n  }\n  Bool(key: string, value: unknown): Logger {\n    this._attributes[key] = logValue(!!value);\n    return this;\n  }\n  Result<T>(key: string, res: Result<T, Error>): Logger {\n    if (res.isOk()) {\n      this._attributes[key] = logValue(res.Ok() as Serialized);\n    } else {\n      this.Err(res.Err());\n    }\n    return this;\n  }\n\n  Len(value: unknown, key = \"len\"): Logger {\n    this._attributes[key] = getLen(value);\n    return this;\n  }\n\n  Hash(value: unknown, key = \"hash\"): Logger {\n    this._attributes[key] = asyncLogValue(async () => `${getLen(value).value()}:${await hash(value)}`);\n    return this;\n  }\n\n  Url(url: CoerceURI, key = \"url\"): Logger {\n    this.Ref(key, () => URI.from(url).toString());\n    return this;\n  }\n\n  Str(key: string, value?: string): Logger {\n    this._attributes[key] = logValue(value);\n    return this;\n  }\n\n  Any(key: string, value?: string | number | boolean | LogSerializable): Logger {\n    this._attributes[key] = logValue(value as LogValueArg);\n    return this;\n  }\n  Dur(key: string, nsec: number): Logger {\n    this._attributes[key] = logValue(`${nsec}ms`);\n    // new Intl.DurationFormat(\"en\", { style: \"narrow\" }).format(nsec);\n    return this;\n  }\n  Uint64(key: string, value: number): Logger {\n    this._attributes[key] = logValue(value);\n    return this;\n  }\n  Int(key: string, value: number): Logger {\n    return this.Uint64(key, value);\n  }\n\n  async Flush(): Promise<void> {\n    return new Promise((resolve) => {\n      this._logWriter._flush(undefined, resolve);\n    });\n  }\n\n  With(): WithLogger {\n    // console.log(\"WithLoggerBuilder.With\", this._id, this._attributes, this._withAttributes);\n    return new WithLoggerBuilder(\n      new LoggerImpl({\n        logWriter: this._logWriter,\n        sys: this._sys,\n        levelHandler: this._levelHandler,\n        formatter: this._formatter,\n        withAttributes: {\n          module: this._attributes[\"module\"],\n          ...this._withAttributes,\n        },\n      }),\n    );\n  }\n\n  _resetAttributes(fn: () => () => Uint8Array): () => Uint8Array {\n    const ret = fn();\n    Object.keys(this._attributes).forEach((key) => {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._attributes[key];\n    });\n    Object.assign(this._attributes, this._withAttributes);\n    return ret;\n  }\n\n  Msg(...args: string[]): AsError {\n    const fnError = this._resetAttributes(() => {\n      const doWrite = this._levelHandler.isEnabled(\n        toLogValue(this._attributes[\"level\"])?.value(),\n        toLogValue(this._attributes[\"module\"])?.value(),\n      );\n      this._attributes[\"msg\"] = logValue(args.join(\" \"));\n      const msg = this._attributes[\"msg\"].value();\n      if (typeof msg === \"string\" && !msg.trim().length) {\n        delete this._attributes[\"msg\"];\n      }\n      let fnRet = (): Uint8Array => this._formatter.format({ ...this._attributes });\n      if (doWrite) {\n        const encoded = fnRet();\n        this._logWriter.write(encoded);\n        fnRet = (): Uint8Array => encoded;\n      }\n      return fnRet;\n    });\n    return {\n      AsError: () => new Error(this._txtEnDe.decode(fnError())),\n    };\n  }\n}\n\nclass WithLoggerBuilder implements WithLogger {\n  readonly _li: LoggerImpl;\n  constructor(li: LoggerImpl) {\n    this._li = li;\n  }\n\n  TxtEnDe(): TxtEnDecoder {\n    return this._li.TxtEnDe();\n  }\n\n  Logger(): Logger {\n    Object.assign(this._li._withAttributes, this._li._attributes);\n    return this._li;\n  }\n\n  Attributes(): Record<string, unknown> {\n    return { ...this._li._attributes };\n  }\n\n  SetExposeStack(enable?: boolean): WithLogger {\n    this._li._levelHandler.setExposeStack(enable);\n    return this;\n  }\n\n  SetFormatter(fmt: LogFormatter): WithLogger {\n    this._li.SetFormatter(fmt);\n    return this;\n  }\n\n  EnableLevel(level: Level, ...modules: string[]): WithLogger {\n    this._li._levelHandler.enableLevel(level, ...modules);\n    return this;\n  }\n  DisableLevel(level: Level, ...modules: string[]): WithLogger {\n    this._li._levelHandler.enableLevel(level, ...modules);\n    return this;\n  }\n\n  Module(key: string): WithLogger {\n    this._li.Module(key);\n    return this;\n  }\n  SetDebug(...modules: (string | string[])[]): WithLogger {\n    this._li.SetDebug(...modules);\n    return this;\n  }\n\n  Str(key: string, value?: string): WithLogger {\n    this._li.Str(key, value);\n    return this;\n  }\n\n  Len(value: unknown, key?: string): WithLogger {\n    this._li.Len(value, key);\n    return this;\n  }\n\n  Hash(value: unknown, key?: string): WithLogger {\n    this._li.Hash(value, key);\n    return this;\n  }\n\n  Ref(key: string, action: Serialized | FnSerialized): WithLogger {\n    this._li.Ref(key, action);\n    return this;\n  }\n  Bool(key: string, value: unknown): WithLogger {\n    this._li.Bool(key, value);\n    return this;\n  }\n  Result<T>(key: string, res: Result<T, Error>): WithLogger {\n    this._li.Result(key, res);\n    return this;\n  }\n  Url(url: CoerceURI, key?: string): WithLogger {\n    this._li.Url(url, key);\n    return this;\n  }\n  Int(key: string, value: number): WithLogger {\n    this._li.Int(key, value);\n    return this;\n  }\n\n  Log(): WithLogger {\n    this._li.Log();\n    return this;\n  }\n\n  WithLevel(level: Level): WithLogger {\n    this._li.WithLevel(level);\n    return this;\n  }\n\n  Error(): WithLogger {\n    this._li.Error();\n    return this;\n  }\n  Warn(): WithLogger {\n    this._li.Error();\n    return this;\n  }\n  Debug(): WithLogger {\n    this._li.Debug();\n    return this;\n  }\n  Err(err: unknown): WithLogger {\n    this._li.Err(err);\n    return this;\n  }\n  Info(): WithLogger {\n    this._li.Info();\n    return this;\n  }\n  Timestamp(): WithLogger {\n    this._li.Timestamp();\n    return this;\n  }\n  Any(key: string, value: LogSerializable): WithLogger {\n    this._li.Any(key, value);\n    return this;\n  }\n  Dur(key: string, nsec: number): WithLogger {\n    this._li.Dur(key, nsec);\n    return this;\n  }\n  Uint64(key: string, value: number): WithLogger {\n    this._li.Uint64(key, value);\n    return this;\n  }\n}\n","export function bin2text(hex: ArrayBufferView, lineFn: (line: string) => void, size = 0): void {\n  const arr = new Uint8Array(hex.buffer, hex.byteOffset, hex.byteLength);\n  let cutted = \"  \";\n  if (size == 0) {\n    size = arr.length;\n  }\n  size = Math.min(size, arr.length);\n  const cols = 16;\n  for (let line = 0; line < size; line += cols) {\n    if (line + cols <= size || arr.length == size) {\n      // normal line\n    } else {\n      line = arr.length - (arr.length % cols);\n      size = arr.length;\n      cutted = \">>\";\n    }\n    const l: string[] = [line.toString(16).padStart(4, \"0\"), cutted];\n    for (let col = 0; col < cols; col++) {\n      if (line + col < size) {\n        l.push(arr[line + col].toString(16).padStart(2, \"0\"));\n      } else {\n        l.push(\"  \");\n      }\n      // l.push((col > 0 && col % 4 === 3) ? \" \" : \" \");\n      l.push(\" \");\n    }\n    for (let col = 0; col < cols; col++) {\n      if (line + col < size) {\n        const ch = arr[line + col];\n        l.push(ch >= 32 && ch < 127 ? String.fromCharCode(ch) : \".\");\n      }\n    }\n    lineFn(l.join(\"\"));\n  }\n}\n\nexport function bin2string(hex: ArrayBufferView, size = 0): string {\n  const collector: string[] = [];\n  bin2text(\n    hex,\n    (line) => {\n      collector.push(line);\n    },\n    size,\n  );\n  return collector.join(\"\\n\");\n}\n","import { bin2string } from \"./bin2text.js\";\nimport { Result } from \"./result.js\";\nimport { TxtEnDecoder } from \"./txt-en-decoder.js\";\nimport { CoerceURI } from \"./uri.js\";\n\nexport enum Level {\n  WARN = \"warn\",\n  DEBUG = \"debug\",\n  INFO = \"info\",\n  ERROR = \"error\",\n}\n\nexport type Serialized = string | number | boolean;\nexport type FnSerialized = () => Serialized | Serialized[];\n\nexport class LogValue {\n  constructor(readonly fn: FnSerialized) {}\n  value(): Serialized | Serialized[] {\n    return this.fn();\n  }\n  toJSON(): Serialized | Serialized[] {\n    return this.value();\n  }\n}\n\nexport type LogSerializable = Record<string, LogValue | Promise<LogValue>>;\n\nexport function removeSelfRef(lineEnd?: string): (key: unknown, val: unknown) => unknown {\n  const cache = new Set();\n  return function (key: unknown, value: unknown) {\n    if (typeof value === \"object\" && value !== null) {\n      // Duplicate reference found, discard key\n      if (cache.has(value)) return \"...\";\n      cache.add(value);\n    }\n    return lineEnd ? value + lineEnd : value;\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function asyncLogValue(val: () => Promise<Serialized>): Promise<LogValue> {\n  // return Promise.resolve(logValue(val));\n  throw new Error(\"Not implemented\");\n}\n\nexport type LogValueArg = LogValue | Serialized | Serialized[] | FnSerialized | undefined | null;\n\nexport function logValue(val: LogValueArg, state: Set<unknown> = new Set<unknown>([Math.random()])): LogValue {\n  switch (typeof val) {\n    case \"function\":\n      return new LogValue(val);\n    case \"string\": {\n      try {\n        const ret = JSON.parse(val);\n        if (typeof ret === \"object\" && ret !== null) {\n          return logValue(ret, state);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (e) {\n        if (val.match(/[\\n\\r]/)) {\n          const lines = val.trimEnd().split(/[\\n\\r]/);\n          return new LogValue(() => lines);\n        }\n      }\n      return new LogValue(() => val.toString());\n    }\n    case \"number\":\n      return new LogValue(() => val);\n    case \"boolean\":\n      return new LogValue(() => val);\n    case \"object\": {\n      if (ArrayBuffer.isView(val)) {\n        return logValue(bin2string(val, 512));\n      }\n      if (Array.isArray(val)) {\n        return new LogValue(() => val.map((v) => logValue(v).value() as Serialized));\n      }\n      if (val === null) {\n        return new LogValue(() => \"null\");\n      }\n      // Duplicate reference found, discard key\n      if (state.has(val)) {\n        return new LogValue(() => \"...\");\n      }\n      state.add(val);\n\n      const res: Record<string, LogValue> = {};\n      const typedVal = val as unknown as Record<string, LogValueArg>;\n      for (const key in typedVal) {\n        const element = typedVal[key];\n        if (element instanceof LogValue) {\n          res[key] = element;\n        } else {\n          res[key] = logValue(element, state);\n        }\n      }\n      // ugly as hell cast but how declare a self-referencing type?\n      return new LogValue(() => res as unknown as Serialized);\n    }\n    default:\n      if (!val) {\n        return new LogValue(() => \"--Falsy--\");\n      }\n      throw new Error(`Invalid type:${typeof val}`);\n  }\n}\n\nexport interface Sized {\n  size: number;\n}\nexport interface Lengthed {\n  length: number;\n}\nexport type SizeOrLength = Sized | Lengthed;\n\nexport interface LogFormatter {\n  format(attr: LogSerializable): Uint8Array;\n}\n\nexport interface LevelHandler {\n  enableLevel(level: Level, ...modules: string[]): void;\n  disableLevel(level: Level, ...modules: string[]): void;\n  setExposeStack(enable?: boolean): void;\n  isStackExposed: boolean;\n  setDebug(...modules: (string | string[])[]): void;\n  isEnabled(ilevel: unknown, module: unknown): boolean;\n}\n\nexport interface LoggerInterface<R> {\n  TxtEnDe(): TxtEnDecoder;\n  Module(key: string): R;\n  // if modules is empty, set for all Levels\n  EnableLevel(level: Level, ...modules: string[]): R;\n  DisableLevel(level: Level, ...modules: string[]): R;\n\n  Attributes(): Record<string, unknown>;\n\n  SetDebug(...modules: (string | string[])[]): R;\n  SetExposeStack(enable?: boolean): R;\n  SetFormatter(fmt: LogFormatter): R;\n\n  Ref(key: string, action: { toString: () => string } | FnSerialized): R;\n  Result<T>(key: string, res: Result<T>): R;\n  // default key url\n  Url(url: CoerceURI, key?: string): R;\n  // len\n  Len(value: unknown, key?: string): R;\n\n  Hash(value: unknown, key?: string): R;\n\n  Str(key: string, value?: string): R;\n  Error(): R;\n  Warn(): R;\n  Debug(): R;\n  Log(): R;\n  WithLevel(level: Level): R;\n\n  Err(err: unknown | Result<unknown> | Error): R; // could be Error, or something which coerces to string\n  Info(): R;\n  Timestamp(): R;\n  Any(key: string, value: unknown): R;\n  Dur(key: string, nsec: number): R;\n  Uint64(key: string, value: number): R;\n  Int(key: string, value: number): R;\n  Bool(key: string, value: unknown): R;\n}\n\nexport function IsLogger(obj: unknown): obj is Logger {\n  return (\n    typeof obj === \"object\" &&\n    [\n      \"Module\",\n      \"EnableLevel\",\n      \"DisableLevel\",\n      \"SetDebug\",\n      \"Str\",\n      \"Error\",\n      \"Warn\",\n      \"Debug\",\n      \"Log\",\n      \"WithLevel\",\n      \"Err\",\n      \"Info\",\n      \"Timestamp\",\n      \"Any\",\n      \"Dur\",\n      \"Uint64\",\n    ]\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      .map((fn) => typeof (obj as any)[fn] === \"function\")\n      .reduce((a, b) => a && b, true)\n  );\n}\n\nexport interface WithLogger extends LoggerInterface<WithLogger> {\n  Logger(): Logger;\n}\n\nexport interface AsError {\n  AsError(): Error;\n}\n\nexport interface Logger extends LoggerInterface<Logger> {\n  With(): WithLogger;\n\n  Msg(...args: string[]): AsError;\n  Flush(): Promise<void>;\n}\n","export abstract class Result<T, E = Error> {\n  static Ok<T = void>(t: T): Result<T, Error> {\n    return new ResultOK(t);\n  }\n  static Err<T, E extends Error = Error>(t: E | string): Result<T, E> {\n    if (typeof t === \"string\") {\n      return new ResultError(new Error(t) as E);\n    }\n    return new ResultError(t);\n  }\n  static Is<T>(t: unknown): t is Result<T> {\n    if (!t) {\n      return false;\n    }\n    if (t instanceof Result) {\n      return true;\n    }\n    const rt = t as Result<T>;\n    if ([typeof rt.is_ok, typeof rt.is_err, typeof rt.unwrap, typeof rt.unwrap_err].every((x) => x === \"function\")) {\n      return true;\n    }\n    return false;\n  }\n\n  isOk(): boolean {\n    return this.is_ok();\n  }\n  isErr(): boolean {\n    return this.is_err();\n  }\n\n  Ok(): T {\n    return this.unwrap();\n  }\n  Err(): E {\n    return this.unwrap_err();\n  }\n\n  abstract is_ok(): boolean;\n  abstract is_err(): boolean;\n  abstract unwrap(): T;\n  abstract unwrap_err(): E;\n}\n\nexport class ResultOK<T> extends Result<T, Error> {\n  private _t: T;\n  constructor(t: T) {\n    super();\n    this._t = t;\n  }\n  is_ok(): boolean {\n    return true;\n  }\n  is_err(): boolean {\n    return false;\n  }\n  unwrap_err(): Error {\n    throw new Error(\"Result is Ok\");\n  }\n  unwrap(): T {\n    return this._t;\n  }\n}\n\nexport class ResultError<T extends Error> extends Result<never, T> {\n  private _error: T;\n  constructor(t: T) {\n    super();\n    this._error = t;\n  }\n  is_ok(): boolean {\n    return false;\n  }\n  is_err(): boolean {\n    return true;\n  }\n  unwrap(): never {\n    throw new Error(`Result is Err: ${this._error}`);\n  }\n  unwrap_err(): T {\n    return this._error;\n  }\n}\n\nexport type WithoutResult<T> = T extends Result<infer U> ? U : T;\n\n// type WithoutPromise<T> = T extends Promise<infer U> ? U : T;\ntype WithResult<T> = T extends Promise<infer U> ? Promise<Result<U>> : Result<T>;\n\nexport function exception2Result<FN extends () => Promise<T> | T, T>(fn: FN): WithResult<ReturnType<FN>> {\n  try {\n    const res = fn();\n    if (res instanceof Promise) {\n      return res.then((value) => Result.Ok(value)).catch((e) => Result.Err(e)) as WithResult<ReturnType<FN>>;\n    }\n    return Result.Ok(res) as WithResult<ReturnType<FN>>;\n  } catch (e) {\n    return Result.Err(e as Error) as WithResult<ReturnType<FN>>;\n  }\n}\n\n/*\n\ntype FinalizedResult<T> = {\n  result: T;\n  scopeResult?: Result<void>;\n  finally: () => Promise<void>;\n}\n\ntype exection2ResultParam<T> = {\n  init: () => Promise<T>;\n  inScope?: (t: T) => Promise<void>;\n  cleanup: (t: T) => Promise<void>;\n\n}\n\nasync function expection2Result<T>({fn, inScope, cleanup}: exection2ResultParam<T>): Promise<Result<FinalizedResult<T>>> {\n  try {\n    const res = await fn();\n    if (inScope) {\n      try {\n        await inScope?.(res)\n      } catch (err) {\n        return Result.Err(err as Error)\n      }\n      await cleanup(res)\n      return Result.Ok({\n        result: res,\n        finally: async () => { }\n      })\n    }\n    return Result.Ok({\n      result: res ,\n      finally: async () => {\n        return cleanup(res)\n      }\n    })\n  } catch (err) {\n    return Result.Err(err as Error)\n  }\n}\n*/\n\n// await expection2Result({\n//   init: openDB,\n//   inScope: (res) => {\n//     res.query()\n//   },\n//   cleanup: async (y) => {\n//     await y.close()\n//  }\n// })\n// async function openDB() {\n//   try {\n//     const opendb = await openDB()\n//     return Result.Ok({\n//       openDB,\n//       finally: async () => {\n//         await opendb.close()\n//     }})\n//   } catch (err) {\n//     return Result.Err(err)\n//   }\n// }\n// }\n","import { exception2Result, Result } from \"./result.js\";\n\ntype NullOrUndef = null | undefined;\n\nexport interface URIObject {\n  readonly style: \"host\" | \"path\";\n  readonly protocol: string;\n  readonly pathname: string;\n  readonly searchParams: Record<string, string>;\n}\n\nexport interface PathURIObject extends URIObject {\n  readonly style: \"path\";\n}\n\nexport interface HostURIObject extends URIObject {\n  readonly style: \"host\";\n  readonly hostname: string;\n  readonly port: string;\n}\n\nfunction falsy2undef<T>(value: T | NullOrUndef): T | undefined {\n  return value === undefined || value === null ? undefined : value;\n}\n\nfunction ensureURLWithDefaultProto(url: string | URL, defaultProtocol: string): MutableURL {\n  if (!url) {\n    return new MutableURL(`${defaultProtocol}//`);\n  }\n  if (typeof url === \"string\") {\n    try {\n      return new MutableURL(url);\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (e) {\n      return new MutableURL(`${defaultProtocol}//${url}`);\n    }\n  } else {\n    return new MutableURL(url.toString());\n  }\n}\n\nexport function isURL(value: unknown): value is URL {\n  return (\n    value instanceof URL ||\n    (!!value &&\n      typeof (value as URL).searchParams === \"object\" &&\n      typeof (value as URL).searchParams.sort === \"function\" &&\n      typeof (value as URL).hash === \"string\")\n  );\n}\n\n// due to that the System URL class is has a strange behavior\n// on different platforms, we need to implement our own URL class\nexport class MutableURL extends URL {\n  private readonly _sysURL: URL;\n  // private readonly _urlStr: string;\n\n  private _protocol: string;\n  private _pathname: string;\n  private _hasHostpart: boolean;\n\n  readonly hash: string;\n\n  constructor(urlStr: string) {\n    super(\"defect://does.not.exist\");\n    const partedURL = urlStr.split(\":\");\n    this._hasHostpart = hasHostPartProtocols.has(partedURL[0]);\n    let hostPartUrl = [\"http\", ...partedURL.slice(1)].join(\":\");\n    if (!this._hasHostpart) {\n      const pathname = hostPartUrl.replace(/http:\\/\\/[/]*/, \"\").replace(/[#?].*$/, \"\");\n      hostPartUrl = hostPartUrl.replace(/http:\\/\\//, `http://localhost/${pathname}`);\n    }\n    try {\n      this._sysURL = new URL(hostPartUrl);\n    } catch (ie) {\n      const e = ie as Error;\n      e.message = `${e.message} for URL: ${urlStr}`;\n      throw e;\n    }\n    this._protocol = `${partedURL[0]}:`; // this._sysURL.protocol.replace(new RegExp(\"^cement-\"), \"\");\n    if (this._hasHostpart) {\n      this._pathname = this._sysURL.pathname;\n    } else {\n      this._pathname = urlStr.replace(new RegExp(`^${this._protocol}//`), \"\").replace(/[#?].*$/, \"\");\n    }\n    this.hash = this._sysURL.hash;\n  }\n\n  clone(): MutableURL {\n    return new MutableURL(this.toString());\n  }\n\n  get host(): string {\n    if (!this._hasHostpart) {\n      throw new Error(\n        `you can use hostname only if protocol is ${this.toString()} ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`,\n      );\n    }\n    return this._sysURL.host;\n  }\n\n  get port(): string {\n    if (!this._hasHostpart) {\n      throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);\n    }\n    return this._sysURL.port;\n  }\n\n  set port(p: string) {\n    if (!this._hasHostpart) {\n      throw new Error(`you can use port only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);\n    }\n    this._sysURL.port = p;\n  }\n\n  get hostname(): string {\n    if (!this._hasHostpart) {\n      throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);\n    }\n    return this._sysURL.hostname;\n  }\n\n  set hostname(h: string) {\n    if (!this._hasHostpart) {\n      throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);\n    }\n    this._sysURL.hostname = h;\n  }\n\n  set pathname(p: string) {\n    this._pathname = p;\n  }\n\n  get pathname(): string {\n    return this._pathname;\n  }\n\n  get protocol(): string {\n    return this._protocol;\n  }\n\n  set protocol(p: string) {\n    if (!p.endsWith(\":\")) {\n      p = `${p}:`;\n    }\n    this._protocol = p;\n  }\n\n  get searchParams(): URLSearchParams {\n    return this._sysURL.searchParams;\n  }\n\n  toString(): string {\n    let search = \"\";\n    if (this._sysURL.searchParams.size) {\n      for (const [key, value] of Array.from(this._sysURL.searchParams.entries()).sort((a, b) => a[0].localeCompare(b[0]))) {\n        search += `${!search.length ? \"?\" : \"&\"}${key}=${encodeURIComponent(value)}`;\n      }\n    }\n    let hostpart = \"\";\n    if (this._hasHostpart) {\n      hostpart = this._sysURL.hostname;\n      if (this._sysURL.port) {\n        hostpart += `:${this._sysURL.port}`;\n      }\n      if (!this._pathname.startsWith(\"/\")) {\n        hostpart += \"/\";\n      }\n    }\n    return `${this._protocol}//${hostpart}${this._pathname}${search}`;\n  }\n}\n\nfunction from<T>(fac: (url: MutableURL) => T, strURLUri: CoerceURI | undefined, defaultProtocol: string): T {\n  switch (typeof falsy2undef(strURLUri)) {\n    case \"undefined\":\n      return fac(new MutableURL(`${defaultProtocol}///`));\n    case \"string\":\n      return fac(ensureURLWithDefaultProto(strURLUri as string, defaultProtocol));\n    case \"object\":\n      if (BuildURI.is(strURLUri)) {\n        return fac(new MutableURL(strURLUri._url.toString()));\n      } else if (URI.is(strURLUri)) {\n        return fac(new MutableURL(strURLUri._url.toString()));\n      } else if (isURL(strURLUri)) {\n        return fac(new MutableURL(strURLUri.toString()));\n      }\n      throw new Error(`unknown object type: ${strURLUri}`);\n    default:\n      throw new Error(`Invalid argument: ${typeof strURLUri}`);\n  }\n}\n\nexport class BuildURI {\n  _url: MutableURL; // pathname needs this\n  private constructor(url: MutableURL) {\n    this._url = url;\n  }\n\n  static is(value: unknown): value is BuildURI {\n    return (\n      value instanceof BuildURI ||\n      (!!value && typeof (value as BuildURI).delParam === \"function\" && typeof (value as BuildURI).setParam === \"function\")\n    );\n  }\n  static from(strURLUri?: CoerceURI, defaultProtocol = \"file:\"): BuildURI {\n    return from((url) => new BuildURI(url), strURLUri, defaultProtocol);\n  }\n\n  port(p: string): BuildURI {\n    this._url.port = p;\n    return this;\n  }\n\n  hostname(h: string): BuildURI {\n    this._url.hostname = h;\n    return this;\n  }\n\n  // password(p: string) {\n  //   this._url.password = p;\n  //   return this;\n  // }\n\n  // port(p: string) {\n  //   this._url.port = p;\n  //   return this;\n  // }\n\n  // username(u: string) {\n  //   this._url.username = u;\n  //   return this;\n  // }\n\n  // search(s: string) {\n  //   this._url.search = s;\n  //   return this;\n  // }\n\n  protocol(p: string): BuildURI {\n    this._url.protocol = p;\n    // if (!p.endsWith(\":\")) {\n    //   p = `${p}:`;\n    // }\n    // const mySrc = this._url.toString();\n    // const myDst = mySrc.replace(new RegExp(`^${this._url.protocol}`), `${p}`);\n    // this._url = new URL(myDst);\n    return this;\n  }\n\n  pathname(p: string): BuildURI {\n    // const myp = this.URI().pathname;\n    // const mySrc = this._url.toString();\n    // const myDst = mySrc.replace(new RegExp(`^${this._url.protocol}//${myp}`), `${this._url.protocol}//${p}`);\n    // this._url = new URL(myDst);\n    this._url.pathname = p;\n    return this;\n  }\n\n  // hash(h: string) {\n  //   this._url.hash = h;\n  //   return this;\n  // }\n\n  // host(h: string) {\n  //   this._url.host = h;\n  //   return this;\n  // }\n\n  delParam(key: string): BuildURI {\n    this._url.searchParams.delete(key);\n    return this;\n  }\n\n  defParam(key: string, str: string): BuildURI {\n    if (!this._url.searchParams.has(key)) {\n      this._url.searchParams.set(key, str);\n    }\n    return this;\n  }\n\n  setParam(key: string, str: string): BuildURI {\n    this._url.searchParams.set(key, str);\n    return this;\n  }\n\n  hasParam(key: string): boolean {\n    return this._url.searchParams.has(key);\n  }\n\n  getParam(key: string): string | undefined {\n    return falsy2undef(this._url.searchParams.get(key));\n  }\n\n  toString(): string {\n    this._url.searchParams.sort();\n    return this._url.toString();\n  }\n  toJSON(): string {\n    return this.toString();\n  }\n\n  URI(): URI {\n    return URI.from(this._url);\n  }\n}\n\nexport type CoerceURI = string | URI | MutableURL | URL | BuildURI | NullOrUndef;\n\nexport const hasHostPartProtocols: Set<string> = new Set<string>([\"http\", \"https\", \"ws\", \"wss\"]);\n\n// non mutable URL Implementation\nexport class URI {\n  static protocolHasHostpart(protocol: string): () => void {\n    protocol = protocol.replace(/:$/, \"\");\n    hasHostPartProtocols.add(protocol);\n    return () => {\n      hasHostPartProtocols.delete(protocol);\n    };\n  }\n\n  // if no protocol is provided, default to file:\n  static merge(into: CoerceURI, from: CoerceURI, defaultProtocol = \"file:\"): URI {\n    const intoUrl = BuildURI.from(into, defaultProtocol);\n    const fromUrl = URI.from(from, defaultProtocol);\n\n    intoUrl.protocol(fromUrl.protocol);\n    const fPath = fromUrl.pathname;\n    if (!(fPath.length === 0 || fPath === \"/\" || fPath === \"./\")) {\n      intoUrl.pathname(fromUrl.pathname);\n    }\n    for (const [key, value] of fromUrl.getParams) {\n      intoUrl.setParam(key, value);\n    }\n    return intoUrl.URI();\n  }\n\n  static is(value: unknown): value is URI {\n    return (\n      value instanceof URI ||\n      (!!value &&\n        typeof (value as URI).asURL === \"function\" &&\n        typeof (value as URI).getParam === \"function\" &&\n        typeof (value as URI).hasParam === \"function\")\n    );\n  }\n\n  // if no protocol is provided, default to file:\n  static from(strURLUri?: CoerceURI, defaultProtocol = \"file:\"): URI {\n    return from((url) => new URI(url), strURLUri, defaultProtocol);\n  }\n\n  static fromResult(strURLUri?: CoerceURI, defaultProtocol = \"file:\"): Result<URI> {\n    return exception2Result(() => from((url) => new URI(url), strURLUri, defaultProtocol)) as Result<URI>;\n  }\n\n  readonly _url: MutableURL;\n  private constructor(url: MutableURL) {\n    this._url = url.clone();\n  }\n\n  build(): BuildURI {\n    return BuildURI.from(this._url);\n  }\n\n  get hostname(): string {\n    return this._url.hostname;\n  }\n\n  // get password(): string {\n  //   return this._url.password;\n  // }\n\n  get port(): string {\n    return this._url.port;\n  }\n\n  get host(): string {\n    return this._url.host;\n  }\n\n  // get username(): string {\n  //   return this._url.username;\n  // }\n\n  // get search(): string {\n  //   return this._url.search;\n  // }\n\n  get protocol(): string {\n    return this._url.protocol;\n  }\n\n  get pathname(): string {\n    return this._url.pathname;\n    // return this._url\n    //   .toString()\n    //   .replace(/^.*:\\/\\//, \"\")\n    //   .replace(/\\?.*$/, \"\");\n  }\n\n  // get hash(): string {\n  //   return this._url.hash;\n  // }\n\n  // get host(): string {\n  //   return this._url.host;\n  // }\n\n  get getParams(): Iterable<[string, string]> {\n    return this._url.searchParams.entries();\n  }\n\n  hasParam(key: string): boolean {\n    return this._url.searchParams.has(key);\n  }\n  getParam(key: string): string | undefined {\n    return falsy2undef(this._url.searchParams.get(key));\n  }\n\n  clone(): URI {\n    return new URI(this._url);\n  }\n\n  asURL(): URL {\n    // const url = new URL(this._url.toString());\n    // url.searchParams.sort();\n    return this._url.clone() as unknown as URL;\n  }\n\n  toString(): string {\n    // this._url.searchParams.sort();\n    return this._url.toString();\n  }\n  toJSON(): string {\n    return this.toString();\n  }\n  asObj(): HostURIObject | PathURIObject {\n    const pathURI: PathURIObject = {\n      style: \"path\",\n      protocol: this.protocol,\n      pathname: this.pathname,\n      searchParams: Object.fromEntries(this.getParams),\n    };\n    if (hasHostPartProtocols.has(this.protocol.replace(/:$/, \"\"))) {\n      return {\n        ...pathURI,\n        style: \"host\",\n        hostname: this.hostname,\n        port: this.port,\n      } as HostURIObject;\n    }\n    return pathURI;\n  }\n}\n","export interface Runtime {\n  isNodeIsh: boolean;\n  isBrowser: boolean;\n  isDeno: boolean;\n  isReactNative: boolean;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isSet(value: string, ref: any = globalThis): boolean {\n  const [head, ...tail] = value.split(\".\");\n  if ([\"object\", \"function\"].includes(typeof ref) && ref && [\"object\", \"function\"].includes(typeof ref[head]) && ref[head]) {\n    if (tail.length <= 1) {\n      return true;\n    }\n    return isSet(tail.join(\".\"), ref[head]);\n  }\n  return false;\n}\n\nexport function runtimeFn(): Runtime {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const gt: any = globalThis;\n  const isReactNative =\n    isSet(\"navigator.product\") && typeof gt[\"navigator\"] === \"object\" && gt[\"navigator\"][\"product\"] === \"ReactNative\";\n  let isNodeIsh = false;\n  if (!isSet(\"Deno\")) {\n    isNodeIsh = isSet(\"process.versions.node\") && !isReactNative;\n  }\n  const isDeno = isSet(\"Deno\");\n  return {\n    isNodeIsh,\n    isBrowser: !(isNodeIsh || isDeno) && !isReactNative,\n    isDeno,\n    isReactNative,\n  };\n}\n","export class LogWriterStream {\n  readonly _out: WritableStream<Uint8Array>;\n  readonly _toFlush: (() => Promise<void>)[] = [];\n\n  constructor(out: WritableStream<Uint8Array>) {\n    this._out = out;\n  }\n\n  write(encoded: Uint8Array): void {\n    const my = async (): Promise<void> => {\n      // const val = Math.random();\n      // console.log(\">>>My:\", val)\n      try {\n        const writer = this._out.getWriter();\n        await writer.ready;\n        await writer.write(encoded);\n        await writer.releaseLock();\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error(\"Chunk error:\", err);\n      }\n      // console.log(\"<<<My:\", val)\n    };\n    this._toFlush.push(my);\n    this._flush();\n  }\n\n  _flushIsRunning = false;\n  _flushDoneFns: (() => void)[] = [];\n  _flush(toFlush: (() => Promise<void>)[] | undefined = undefined, done?: () => void): void {\n    if (done) {\n      this._flushDoneFns.push(done);\n    }\n\n    if (this._toFlush.length == 0) {\n      // console.log(\"Flush is stopped\", this._toFlush.length)\n      this._flushIsRunning = false;\n      this._flushDoneFns.forEach((fn) => fn());\n      this._flushDoneFns = [];\n      return;\n    }\n\n    if (!toFlush && this._toFlush.length == 1 && !this._flushIsRunning) {\n      this._flushIsRunning = true;\n      // console.log(\"Flush is started\", this._toFlush.length)\n    } else if (!toFlush) {\n      // console.log(\"flush queue check but is running\", this._toFlush.length)\n      return;\n    }\n\n    // console.log(\">>>Msg:\", this._toFlush.length)\n    const my = this._toFlush.shift();\n    my?.().finally(() => {\n      // console.log(\"<<<Msg:\", this._toFlush.length)\n      this._flush(this._toFlush);\n    });\n  }\n}\n","import { LevelHandler, Level } from \"./logger.js\";\n\nexport class LevelHandlerImpl implements LevelHandler {\n  readonly _globalLevels: Set<Level> = new Set<Level>([Level.INFO, Level.ERROR, Level.WARN]);\n  readonly _modules: Map<string, Set<Level>> = new Map<string, Set<Level>>();\n  isStackExposed = false;\n  enableLevel(level: Level, ...modules: string[]): void {\n    if (modules.length == 0) {\n      this._globalLevels.add(level);\n      return;\n    }\n    this.forModules(\n      level,\n      (p) => {\n        this._modules.set(p, new Set([...this._globalLevels, level]));\n      },\n      ...modules,\n    );\n  }\n  disableLevel(level: Level, ...modules: string[]): void {\n    if (modules.length == 0) {\n      this._globalLevels.delete(level);\n      return;\n    }\n    this.forModules(\n      level,\n      (p) => {\n        this._modules.delete(p);\n      },\n      ...modules,\n    );\n  }\n\n  setExposeStack(enable?: boolean): void {\n    this.isStackExposed = !!enable;\n  }\n\n  forModules(level: Level, fnAction: (p: string) => void, ...modules: (string | string[])[]): void {\n    for (const m of modules.flat()) {\n      if (typeof m !== \"string\") {\n        continue;\n      }\n      const parts = m\n        .split(\",\")\n        .map((s) => s.trim())\n        .filter((s) => s.length);\n      for (const p of parts) {\n        fnAction(p);\n      }\n    }\n  }\n  setDebug(...modules: (string | string[])[]): void {\n    this.forModules(\n      Level.DEBUG,\n      (p) => {\n        this._modules.set(p, new Set([...this._globalLevels, Level.DEBUG]));\n      },\n      ...modules,\n    );\n  }\n  isEnabled(ilevel: unknown, module: unknown): boolean {\n    const level = ilevel as Level; // what if it's not a level?\n    if (typeof module === \"string\") {\n      const levels = this._modules.get(module);\n      if (levels && levels.has(level)) {\n        return true;\n      }\n    }\n    const wlevel = this._modules.get(\"*\");\n    if (wlevel && typeof level === \"string\") {\n      if (wlevel.has(level)) {\n        return true;\n      }\n    }\n    if (typeof level !== \"string\") {\n      // this is a plain log\n      return true;\n    }\n    return this._globalLevels.has(level);\n  }\n}\n\nconst levelSingleton = new LevelHandlerImpl();\n\nexport function LevelHandlerSingleton(): LevelHandler {\n  return levelSingleton;\n}\n","import { FanoutWriteStream } from \"../utils/fanout-write-stream.js\";\nimport { Future } from \"../future.js\";\nimport { TxtEnDecoder, Utf8EnDecoderSingleton } from \"../txt-en-decoder.js\";\n\nexport class LogWriteStream implements WritableStreamDefaultWriter<Uint8Array> {\n  private readonly _bufferArr: Uint8Array[];\n\n  constructor(bufferArr: Uint8Array[]) {\n    this._bufferArr = bufferArr;\n  }\n\n  readonly _resolveClosed: Future<undefined> = new Future<undefined>();\n  readonly closed: Promise<undefined> = this._resolveClosed.asPromise();\n  readonly desiredSize: number | null = null;\n  readonly ready: Promise<undefined> = Promise.resolve(undefined);\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any\n  abort(reason?: any): Promise<void> {\n    throw new Error(\"Method not implemented.\");\n  }\n  async close(): Promise<void> {\n    await this.closed;\n    return Promise.resolve(undefined);\n  }\n  releaseLock(): void {\n    // do nothing\n  }\n  async write(chunk?: Uint8Array): Promise<void> {\n    if (chunk) {\n      this._bufferArr.push(chunk);\n    }\n    return Promise.resolve(undefined);\n  }\n}\n\nexport class LogCollector implements WritableStream<Uint8Array> {\n  readonly locked: boolean = false;\n  private _writer?: FanoutWriteStream;\n  private readonly _pass?: WritableStreamDefaultWriter<Uint8Array>;\n  private readonly _bufferArr: Uint8Array[] = [];\n  private readonly _txtEnDe: TxtEnDecoder;\n\n  constructor(pass?: WritableStreamDefaultWriter<Uint8Array>, txtEnDe?: TxtEnDecoder) {\n    this._pass = pass;\n    this._txtEnDe = txtEnDe || Utf8EnDecoderSingleton();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  abort(reason?: Uint8Array): Promise<void> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  async close(): Promise<void> {\n    if (this._writer) {\n      const ret = await this._writer.close();\n      this._writer = undefined;\n      return ret;\n    }\n    return Promise.resolve(undefined);\n  }\n\n  getWriter(): WritableStreamDefaultWriter<Uint8Array> {\n    if (!this._writer) {\n      const dests: WritableStreamDefaultWriter[] = [new LogWriteStream(this._bufferArr)];\n      if (this._pass) {\n        dests.push(this._pass);\n      }\n      this._writer = new FanoutWriteStream(dests);\n    }\n    return this._writer;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Logs(notJsonLine = false): any[] {\n    if (!this._writer) {\n      return [];\n    }\n    const jsonNlStr = this._txtEnDe.decode(\n      new Uint8Array(\n        (function* (res: Uint8Array[]): Generator<number, void, undefined> {\n          for (const x of res) {\n            yield* x;\n          }\n        })(this._bufferArr),\n      ),\n    );\n    if (!notJsonLine) {\n      const splitStr = jsonNlStr.split(\"\\n\");\n      const filterStr = splitStr.filter((a) => a.length);\n      const mapStr = filterStr.map((a) => JSON.parse(a));\n      return mapStr;\n    }\n    return jsonNlStr.split(\"\\n\").filter((a) => a.length);\n  }\n}\n","import { LevelHandlerImpl } from \"../log-level-impl.js\";\nimport { Logger } from \"../logger.js\";\nimport { LoggerImpl } from \"../logger-impl.js\";\nimport { SysAbstraction } from \"../sys-abstraction.js\";\nimport { LogCollector } from \"./log-write-stream.js\";\n\nexport interface MockLoggerReturn {\n  readonly logger: Logger;\n  readonly logCollector: LogCollector;\n}\n\nexport function MockLogger(params?: {\n  readonly sys?: SysAbstraction;\n  readonly pass?: WritableStreamDefaultWriter<Uint8Array>;\n  moduleName?: string | string[];\n  readonly disableDebug?: boolean;\n}): MockLoggerReturn {\n  const lc = new LogCollector(params?.pass);\n  let modNames = [\"MockLogger\"];\n  if (typeof params?.moduleName === \"string\") {\n    modNames = [params?.moduleName];\n  } else if (Array.isArray(params?.moduleName)) {\n    modNames = [...params.moduleName, ...modNames];\n  }\n  const logger = new LoggerImpl({\n    out: lc,\n    sys: params?.sys,\n    levelHandler: new LevelHandlerImpl(),\n  })\n    .With()\n    .Module(modNames[0])\n    .Logger();\n  if (!params?.disableDebug) {\n    logger.SetDebug(...modNames);\n  }\n  return {\n    logCollector: lc,\n    logger,\n  };\n}\n","export abstract class Option<T> {\n  static Some<T>(t: T): Option<T> {\n    return new Some(t);\n  }\n\n  static None<T>(): Option<T> {\n    return new None();\n  }\n\n  static Is<T>(t: unknown): t is Option<T> {\n    return t instanceof Option;\n  }\n\n  IsNone(): boolean {\n    return this.is_none();\n  }\n\n  IsSome(): boolean {\n    return this.is_some();\n  }\n  Unwrap(): T {\n    return this.unwrap();\n  }\n\n  abstract is_none(): boolean;\n  abstract is_some(): boolean;\n  abstract unwrap(): T;\n}\n\nexport class Some<T> extends Option<T> {\n  private _t: T;\n  constructor(_t: T) {\n    super();\n    this._t = _t;\n  }\n\n  is_none(): boolean {\n    return false;\n  }\n  is_some(): boolean {\n    return true;\n  }\n  unwrap(): T {\n    return this._t;\n  }\n}\n\nexport class None<T> extends Option<T> {\n  is_none(): boolean {\n    return true;\n  }\n  is_some(): boolean {\n    return false;\n  }\n  unwrap(): T {\n    throw new Error(\"None.unwrap\");\n  }\n}\n\nexport type WithoutOption<T> = T extends Option<infer U> ? U : T;\n","import type { MarkWritable } from \"ts-essentials\";\nimport { Time } from \"./time.js\";\nimport { Logger } from \"./logger.js\";\n\nexport type TraceCtx = {\n  readonly spanId: string;\n  readonly time: Time;\n  readonly parent: TraceNode;\n  readonly metrics: Map<string, Metric<unknown>>;\n  readonly logger?: Logger;\n} & Record<string, unknown>;\n\nexport type CleanCtx = {\n  readonly spanId: string;\n} & Record<string, unknown>;\n\nexport type TraceCtxParam = {\n  readonly spanId: string;\n} & Partial<{\n  readonly time: Time;\n  readonly parent: TraceNode;\n  readonly logger: Logger;\n}> &\n  Record<string, unknown>;\n\nexport class Metric<T> {\n  value?: T;\n  readonly path: string;\n\n  constructor(path: string) {\n    this.path = path;\n  }\n\n  set(value: T): void {\n    this.value = value;\n  }\n\n  add<R extends number | ArrayLike<T>>(value: R): void {\n    if (typeof value === \"number\") {\n      if (this.value === undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.value = 0 as any;\n      }\n      (this.value as number) = ((this.value as number) + value) as number;\n    } else if (Array.isArray(value)) {\n      if (!Array.isArray(this.value)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.value = [] as any;\n      }\n      (this.value as T[]).push(...value);\n    } else {\n      throw new Error(\"add only support number or array\");\n    }\n  }\n}\n\nexport type MetricMap = Map<string, Metric<unknown>>;\n\nexport class Metrics {\n  readonly tracenode: TraceNode;\n  private readonly map: MetricMap;\n\n  readonly spanRefs: MetricMap = new Map<string, Metric<unknown>>();\n  constructor(tracenode: TraceNode) {\n    this.tracenode = tracenode;\n    this.map = tracenode.ctx.metrics;\n  }\n\n  toJSON(): Record<string, unknown> {\n    const obj: Record<string, unknown> = {};\n    for (const [key, value] of this.map) {\n      obj[key] = value.value;\n    }\n    return obj;\n  }\n\n  get<T>(ipath: string): Metric<T> {\n    const path = ipath.replace(/[/]+/g, \"/\").trim();\n    if (path.startsWith(\"/\")) {\n      if (path.slice(1).length === 0) {\n        throw new Error(`Metrics path must contain value /:${path}`);\n      }\n      let metric = this.map.get(path);\n      if (!metric) {\n        metric = new Metric<T>(path);\n        this.map.set(path, metric);\n      }\n      this.spanRefs.set(path, metric);\n      return metric as Metric<T>;\n    } else if (path.includes(\"/\")) {\n      throw new Error(`Metrics path must start with /:${path}`);\n    }\n    const rootPath = this.tracenode.getRootPath();\n    return this.get(`${rootPath}/${path}`);\n  }\n}\n\nexport interface Invokaction {\n  readonly result: \"success\" | \"error\";\n  readonly start: number;\n  readonly end: number;\n  readonly metrics?: Metrics;\n}\n\nexport type TraceNodeMap = Map<string, TraceNode>;\n\nexport class TraceNode {\n  readonly childs: TraceNodeMap = new Map<string, TraceNode>();\n\n  readonly invokations: Invokaction[] = [];\n\n  readonly spanId: string;\n  readonly ctx: TraceCtx;\n  readonly metrics: Metrics;\n\n  static root(time: Time, logger?: Logger): TraceNode {\n    return new TraceNode({\n      spanId: \"root\",\n      time,\n      logger,\n      metrics: new Map(),\n      parent: undefined as unknown as TraceNode,\n    });\n  }\n\n  constructor(ctx: TraceCtx) {\n    this.spanId = ctx.spanId;\n    this.ctx = ctx;\n    this.metrics = new Metrics(this);\n  }\n\n  getRootPath(rpath: string[] = []): string {\n    if (!this.ctx.parent) {\n      return \"/\" + rpath.reverse().join(\"/\");\n    }\n    return this.ctx.parent.getRootPath(rpath.concat(this.ctx.spanId));\n  }\n\n  invokes(): { ctx: CleanCtx; invokations: Invokaction[] } {\n    const cleanCtx = { ...this.ctx } as CleanCtx;\n    delete cleanCtx.parent;\n    delete cleanCtx.time;\n    delete cleanCtx.logger;\n    delete cleanCtx.metrics;\n    const spanRefs = this.metrics.toJSON.call({ map: this.metrics.spanRefs });\n    const metricsRefs = Object.keys(spanRefs).length > 0 ? { metricRefs: spanRefs } : {};\n    return {\n      ctx: cleanCtx as CleanCtx,\n      invokations: this.invokations,\n      ...metricsRefs,\n    };\n  }\n\n  ctxWith(spanId: string, logger?: Logger): TraceCtxParam {\n    const ctx = {\n      ...this.ctx,\n      spanId,\n    };\n    if (logger) {\n      ctx.logger = logger;\n    }\n    return ctx;\n  }\n\n  // <V extends () => Promise<T> | T, T>(id: string, fn: V): ReturnType<V>\n  span<V extends (trace: TraceNode) => Promise<T> | T, T>(inSpanId: string | TraceCtxParam, fn: V): ReturnType<V> {\n    let ctx: TraceCtx;\n    if (typeof inSpanId === \"string\") {\n      ctx = {\n        ...this.ctx,\n        spanId: inSpanId,\n        parent: this,\n      };\n    } else {\n      ctx = {\n        ...this.ctx,\n        ...inSpanId,\n        parent: this,\n      };\n    }\n    if (ctx.logger) {\n      ctx = {\n        ...ctx,\n        ...ctx.logger.Attributes(),\n      };\n    }\n    const spanId = ctx.spanId;\n    let spanTrace = this.childs.get(spanId);\n    if (!spanTrace) {\n      spanTrace = new TraceNode(ctx);\n      this.childs.set(spanId.toString(), spanTrace);\n    }\n    const invokation: MarkWritable<MarkWritable<Invokaction, \"end\">, \"result\"> = {\n      start: this.ctx.time.Now().getTime(),\n      end: 0,\n      result: \"success\",\n    };\n    spanTrace.invokations.push(invokation);\n    try {\n      const possiblePromise = fn(spanTrace);\n      if (possiblePromise instanceof Promise) {\n        return possiblePromise\n          .then((v) => {\n            return v;\n          })\n          .catch((e) => {\n            invokation.result = \"error\";\n            throw e;\n          })\n          .finally(() => {\n            invokation.end = this.ctx.time.Now().getTime();\n          }) as ReturnType<V>;\n      }\n      invokation.end = this.ctx.time.Now().getTime();\n      return possiblePromise as ReturnType<V>;\n    } catch (e) {\n      invokation.result = \"error\";\n      invokation.end = this.ctx.time.Now().getTime();\n      throw e;\n    }\n  }\n}\n","export interface CTJsonWebKey {\n  alg?: string;\n  crv?: string;\n  d?: string;\n  dp?: string;\n  dq?: string;\n  e?: string;\n  ext?: boolean;\n  k?: string;\n  key_ops?: string[];\n  kty?: string;\n  n?: string;\n  oth?: RsaOtherPrimesInfo[];\n  p?: string;\n  q?: string;\n  qi?: string;\n  use?: string;\n  x?: string;\n  y?: string;\n}\n\nexport type CTKeyFormat = \"jwk\" | \"pkcs8\" | \"raw\" | \"spki\";\nexport type CTKeyUsage = \"decrypt\" | \"deriveBits\" | \"deriveKey\" | \"encrypt\" | \"sign\" | \"unwrapKey\" | \"verify\" | \"wrapKey\";\n\nexport interface CTAlgorithm {\n  name: string;\n}\nexport type CTAlgorithmIdentifier = CTAlgorithm | string;\n\nexport interface CTRsaHashedImportParams extends CTAlgorithm {\n  hash: CTAlgorithmIdentifier;\n}\n\nexport type CTNamedCurve = string;\nexport interface CTEcKeyImportParams extends CTAlgorithm {\n  namedCurve: CTNamedCurve;\n}\n\nexport interface CTHmacImportParams extends CTAlgorithm {\n  hash: CTAlgorithmIdentifier;\n  length?: number;\n}\n\nexport interface CTAesKeyAlgorithm extends CTAlgorithm {\n  length: number;\n}\n\nexport type CTKeyType = \"private\" | \"public\" | \"secret\";\n\nexport interface CTCryptoKey {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/algorithm) */\n  readonly algorithm: CTAlgorithm;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/extractable) */\n  readonly extractable: boolean;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/type) */\n  readonly type: CTKeyType;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/usages) */\n  readonly usages: CTKeyUsage[];\n}\n\ninterface CTArrayBufferTypes {\n  ArrayBuffer: ArrayBuffer;\n}\ntype CTArrayBufferLike = CTArrayBufferTypes[keyof CTArrayBufferTypes];\n\nexport interface CTArrayBufferView {\n  /**\n   * The ArrayBuffer instance referenced by the array.\n   */\n  buffer: CTArrayBufferLike;\n\n  /**\n   * The length in bytes of the array.\n   */\n  byteLength: number;\n\n  /**\n   * The offset in bytes of the array.\n   */\n  byteOffset: number;\n}\n\nexport type CTBufferSource = CTArrayBufferView | ArrayBuffer;\n\nexport interface CryptoRuntime {\n  importKey(\n    format: CTKeyFormat,\n    keyData: CTJsonWebKey | CTBufferSource,\n    algorithm: CTAlgorithmIdentifier | CTRsaHashedImportParams | CTEcKeyImportParams | CTHmacImportParams | CTAesKeyAlgorithm,\n    extractable: boolean,\n    keyUsages: CTKeyUsage[],\n  ): Promise<CTCryptoKey>;\n  exportKey(format: CTKeyFormat, key: CTCryptoKey): Promise<CTJsonWebKey | ArrayBuffer>;\n\n  //(format: \"raw\", key: ArrayBuffer, algo: string, extractable: boolean, usages: string[]) => Promise<CryptoKey>;\n  decrypt(algo: { name: string; iv: Uint8Array; tagLength: number }, key: CTCryptoKey, data: Uint8Array): Promise<ArrayBuffer>;\n  encrypt(algo: { name: string; iv: Uint8Array; tagLength: number }, key: CTCryptoKey, data: Uint8Array): Promise<ArrayBuffer>;\n  digestSHA256(data: Uint8Array): Promise<ArrayBuffer>;\n  randomBytes(size: number): Uint8Array;\n}\n\nfunction randomBytes(size: number): Uint8Array {\n  const bytes = new Uint8Array(size);\n  if (size > 0) {\n    crypto.getRandomValues(bytes);\n  }\n  return bytes;\n}\n\nfunction digestSHA256(data: Uint8Array): Promise<ArrayBuffer> {\n  return Promise.resolve(crypto.subtle.digest(\"SHA-256\", data));\n}\n\nexport function toCryptoRuntime(cryptoOpts: Partial<CryptoRuntime> = {}): CryptoRuntime {\n  const runtime = {\n    importKey: cryptoOpts.importKey || crypto.subtle.importKey.bind(crypto.subtle),\n    exportKey: cryptoOpts.exportKey || crypto.subtle.exportKey.bind(crypto.subtle),\n    encrypt: cryptoOpts.encrypt || crypto.subtle.encrypt.bind(crypto.subtle),\n    decrypt: cryptoOpts.decrypt || crypto.subtle.decrypt.bind(crypto.subtle),\n    randomBytes: cryptoOpts.randomBytes || randomBytes,\n    digestSHA256: cryptoOpts.digestSHA256 || digestSHA256,\n  };\n  // console.log(\"cryptoOpts\", cryptoOpts, opts)\n  return runtime;\n}\n","export const VERSION = Object.keys({\n  __packageVersion__: \"xxxx\",\n})[0] as string;\n","type Refcounted<T, M extends string> = T & {\n  __refcounted: number;\n  __unrefcounted: () => void;\n} & Record<M, () => void>;\n\nexport function wrapRefcounted<T, M extends string>(t: T, method: M): T {\n  const my = t as Refcounted<T, M>;\n  my.__refcounted = (my.__refcounted || 0) + 1;\n  if (my.__refcounted === 1) {\n    my.__unrefcounted = my[method];\n    const mRec = my as Record<string, () => void>;\n    mRec[method] = function (this: Refcounted<T, M>): void {\n      this.__refcounted--;\n      if (this.__refcounted === 0) {\n        this.__unrefcounted();\n      }\n      if (this.__refcounted < 0) {\n        throw new Error(\"already closed\");\n      }\n    };\n  }\n  return t;\n}\n","export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabet: string, bitsPerChar: number, name: string): Uint8Array {\n  // Build the character lookup table:\n  const codes: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n","/* jshint -W086: true */\n// +----------------------------------------------------------------------+\n// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js\n// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |\n// |----------------------------------------------------------------------|\n// | Copyright (c) 2012-2015 Karan Lyons                                       |\n// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |\n// | Freely distributable under the MIT license.                          |\n// +----------------------------------------------------------------------+\n\n;(function (root, undefined) {\n    'use strict';\n\n    // Create a local object that'll be exported or referenced globally.\n    var library = {\n        'version': '3.0.0',\n        'x86': {},\n        'x64': {},\n        'inputValidation': true\n    };\n\n    // PRIVATE FUNCTIONS\n    // -----------------\n\n    function _validBytes(bytes) {\n        // check the input is an array or a typed array\n        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {\n            return false;\n        }\n\n        // check all bytes are actually bytes\n        for (var i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _x86Multiply(m, n) {\n        //\n        // Given two 32bit ints, returns the two multiplied together as a\n        // 32bit int.\n        //\n\n        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\n    }\n\n    function _x86Rotl(m, n) {\n        //\n        // Given a 32bit int and an int representing a number of bit positions,\n        // returns the 32bit int rotated left by that number of positions.\n        //\n\n        return (m << n) | (m >>> (32 - n));\n    }\n\n    function _x86Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x86 mix of that block.\n        //\n\n        h ^= h >>> 16;\n        h = _x86Multiply(h, 0x85ebca6b);\n        h ^= h >>> 13;\n        h = _x86Multiply(h, 0xc2b2ae35);\n        h ^= h >>> 16;\n\n        return h;\n    }\n\n    function _x64Add(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // added together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] + n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] + n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] + n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += m[0] + n[0];\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Multiply(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // multiplied together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] * n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] * n[3];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[2] += m[3] * n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] * n[3];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[2] * n[2];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[3] * n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Rotl(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) rotated left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 32) {\n            return [m[1], m[0]];\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];\n        } else {\n            n -= 32;\n            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];\n        }\n    }\n\n    function _x64LeftShift(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) shifted left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 0) {\n            return m;\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];\n        } else {\n            return [m[1] << (n - 32), 0];\n        }\n    }\n\n    function _x64Xor(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // xored together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        return [m[0] ^ n[0], m[1] ^ n[1]];\n    }\n\n    function _x64Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x64 mix of that block.\n        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the\n        // only place where we need to right shift 64bit ints.)\n        //\n\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n\n        return h;\n    }\n\n    // PUBLIC FUNCTIONS\n    // ----------------\n\n    library.x86.hash32 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 32 bit hash\n        // using the x86 flavor of MurmurHash3, as an unsigned int.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 4;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n\n        var k1 = 0;\n\n        var c1 = 0xcc9e2d51;\n        var c2 = 0x1b873593;\n\n        for (var i = 0; i < blocks; i = i + 4) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n\n            h1 ^= k1;\n            h1 = _x86Rotl(h1, 13);\n            h1 = _x86Multiply(h1, 5) + 0xe6546b64;\n        }\n\n        k1 = 0;\n\n        switch (remainder) {\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h1 = _x86Fmix(h1);\n\n        return h1 >>> 0;\n    };\n\n    library.x86.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n\n        seed = seed || 0;\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n        var h2 = seed;\n        var h3 = seed;\n        var h4 = seed;\n\n        var k1 = 0;\n        var k2 = 0;\n        var k3 = 0;\n        var k4 = 0;\n\n        var c1 = 0x239b961b;\n        var c2 = 0xab0e9789;\n        var c3 = 0x38b34ae5;\n        var c4 = 0xa1e38b93;\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);\n            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);\n            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n            h1 ^= k1;\n\n            h1 = _x86Rotl(h1, 19);\n            h1 += h2;\n            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;\n\n            k2 = _x86Multiply(k2, c2);\n            k2 = _x86Rotl(k2, 16);\n            k2 = _x86Multiply(k2, c3);\n            h2 ^= k2;\n\n            h2 = _x86Rotl(h2, 17);\n            h2 += h3;\n            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;\n\n            k3 = _x86Multiply(k3, c3);\n            k3 = _x86Rotl(k3, 17);\n            k3 = _x86Multiply(k3, c4);\n            h3 ^= k3;\n\n            h3 = _x86Rotl(h3, 15);\n            h3 += h4;\n            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;\n\n            k4 = _x86Multiply(k4, c4);\n            k4 = _x86Rotl(k4, 18);\n            k4 = _x86Multiply(k4, c1);\n            h4 ^= k4;\n\n            h4 = _x86Rotl(h4, 13);\n            h4 += h1;\n            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;\n        }\n\n        k1 = 0;\n        k2 = 0;\n        k3 = 0;\n        k4 = 0;\n\n        switch (remainder) {\n            case 15:\n                k4 ^= bytes[i + 14] << 16;\n\n            case 14:\n                k4 ^= bytes[i + 13] << 8;\n\n            case 13:\n                k4 ^= bytes[i + 12];\n                k4 = _x86Multiply(k4, c4);\n                k4 = _x86Rotl(k4, 18);\n                k4 = _x86Multiply(k4, c1);\n                h4 ^= k4;\n\n            case 12:\n                k3 ^= bytes[i + 11] << 24;\n\n            case 11:\n                k3 ^= bytes[i + 10] << 16;\n\n            case 10:\n                k3 ^= bytes[i + 9] << 8;\n\n            case 9:\n                k3 ^= bytes[i + 8];\n                k3 = _x86Multiply(k3, c3);\n                k3 = _x86Rotl(k3, 17);\n                k3 = _x86Multiply(k3, c4);\n                h3 ^= k3;\n\n            case 8:\n                k2 ^= bytes[i + 7] << 24;\n\n            case 7:\n                k2 ^= bytes[i + 6] << 16;\n\n            case 6:\n                k2 ^= bytes[i + 5] << 8;\n\n            case 5:\n                k2 ^= bytes[i + 4];\n                k2 = _x86Multiply(k2, c2);\n                k2 = _x86Rotl(k2, 16);\n                k2 = _x86Multiply(k2, c3);\n                h2 ^= k2;\n\n            case 4:\n                k1 ^= bytes[i + 3] << 24;\n\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h2 ^= bytes.length;\n        h3 ^= bytes.length;\n        h4 ^= bytes.length;\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        h1 = _x86Fmix(h1);\n        h2 = _x86Fmix(h2);\n        h3 = _x86Fmix(h3);\n        h4 = _x86Fmix(h4);\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        return (\"00000000\" + (h1 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h3 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h4 >>> 0).toString(16)).slice(-8);\n    };\n\n    library.x64.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = [0, seed];\n        var h2 = [0, seed];\n\n        var k1 = [0, 0];\n        var k2 = [0, 0];\n\n        var c1 = [0x87c37b91, 0x114253d5];\n        var c2 = [0x4cf5ad43, 0x2745937f];\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |\n                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];\n            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |\n                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];\n\n            k1 = _x64Multiply(k1, c1);\n            k1 = _x64Rotl(k1, 31);\n            k1 = _x64Multiply(k1, c2);\n            h1 = _x64Xor(h1, k1);\n\n            h1 = _x64Rotl(h1, 27);\n            h1 = _x64Add(h1, h2);\n            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);\n\n            k2 = _x64Multiply(k2, c2);\n            k2 = _x64Rotl(k2, 33);\n            k2 = _x64Multiply(k2, c1);\n            h2 = _x64Xor(h2, k2);\n\n            h2 = _x64Rotl(h2, 31);\n            h2 = _x64Add(h2, h1);\n            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);\n        }\n\n        k1 = [0, 0];\n        k2 = [0, 0];\n\n        switch (remainder) {\n            case 15:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));\n\n            case 14:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));\n\n            case 13:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));\n\n            case 12:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));\n\n            case 11:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));\n\n            case 10:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));\n\n            case 9:\n                k2 = _x64Xor(k2, [0, bytes[i + 8]]);\n                k2 = _x64Multiply(k2, c2);\n                k2 = _x64Rotl(k2, 33);\n                k2 = _x64Multiply(k2, c1);\n                h2 = _x64Xor(h2, k2);\n\n            case 8:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));\n\n            case 7:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));\n\n            case 6:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));\n\n            case 5:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));\n\n            case 4:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));\n\n            case 3:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));\n\n            case 2:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));\n\n            case 1:\n                k1 = _x64Xor(k1, [0, bytes[i]]);\n                k1 = _x64Multiply(k1, c1);\n                k1 = _x64Rotl(k1, 31);\n                k1 = _x64Multiply(k1, c2);\n                h1 = _x64Xor(h1, k1);\n        }\n\n        h1 = _x64Xor(h1, [0, bytes.length]);\n        h2 = _x64Xor(h2, [0, bytes.length]);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        h1 = _x64Fmix(h1);\n        h2 = _x64Fmix(h2);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        return (\"00000000\" + (h1[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h1[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[1] >>> 0).toString(16)).slice(-8);\n    };\n\n    // INITIALIZATION\n    // --------------\n\n    // Export murmurHash3 for CommonJS, either as an AMD module or just as part\n    // of the global object.\n    if (typeof exports !== 'undefined') {\n\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = library;\n        }\n\n        exports.murmurHash3 = library;\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        define([], function () {\n            return library;\n        });\n    } else {\n\n        // Use murmurHash3.noConflict to restore `murmurHash3` back to its\n        // original value. Returns a reference to the library object, to allow\n        // it to be used under a different name.\n        library._murmurHash3 = root.murmurHash3;\n\n        library.noConflict = function () {\n            root.murmurHash3 = library._murmurHash3;\n            library._murmurHash3 = undefined;\n            library.noConflict = undefined;\n\n            return library;\n        };\n\n        root.murmurHash3 = library;\n    }\n})(this);\n","module.exports = require('./lib/murmurHash3js');\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","'use strict'\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import {\n  Logger,\n  LoggerImpl,\n  IsLogger,\n  Result,\n  ResolveOnce,\n  isURL,\n  URI,\n  CoerceURI,\n  runtimeFn,\n  envFactory,\n  Env,\n  toCryptoRuntime,\n  CryptoRuntime,\n  JSONFormatter,\n  YAMLFormatter,\n} from \"@adviser/cement\";\nimport { PathOps, StoreType, SuperThis, SuperThisOpts, TextEndeCoder } from \"./types\";\nimport { base58btc } from \"multiformats/bases/base58\";\n\nexport type { Logger };\nexport { Result };\n\nconst globalLogger: Logger = new LoggerImpl();\n\nconst registerFP_DEBUG = new ResolveOnce();\n\ninterface superThisOpts {\n  readonly logger: Logger;\n  readonly env: Env;\n  readonly pathOps: PathOps;\n  readonly crypto: CryptoRuntime;\n  readonly ctx: Record<string, unknown>;\n  readonly txt: TextEndeCoder;\n}\n\nclass superThis implements SuperThis {\n  readonly logger: Logger;\n  readonly env: Env;\n  readonly pathOps: PathOps;\n  readonly ctx: Record<string, unknown>;\n  readonly txt: TextEndeCoder;\n  readonly crypto: CryptoRuntime;\n\n  constructor(opts: superThisOpts) {\n    this.logger = opts.logger;\n    this.env = opts.env;\n    this.crypto = opts.crypto;\n    this.pathOps = opts.pathOps;\n    this.txt = opts.txt;\n    this.ctx = { ...opts.ctx };\n    // console.log(\"superThis\", this);\n  }\n\n  nextId(bytes = 6): { str: string; bin: Uint8Array } {\n    const bin = this.crypto.randomBytes(bytes);\n    return {\n      str: base58btc.encode(bin),\n      bin,\n    };\n  }\n\n  start(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  clone(override: Partial<SuperThisOpts>): SuperThis {\n    return new superThis({\n      logger: override.logger || this.logger,\n      env: envFactory(override.env) || this.env,\n      crypto: override.crypto || this.crypto,\n      pathOps: override.pathOps || this.pathOps,\n      txt: override.txt || this.txt,\n      ctx: { ...this.ctx, ...override.ctx },\n    });\n  }\n}\n\n// const pathOps =\nfunction presetEnv() {\n  const penv = new Map([\n    // [\"FP_DEBUG\", \"xxx\"],\n    // [\"FP_ENV\", \"development\"],\n    ...Array.from(\n      Object.entries(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ((globalThis as any)[Symbol.for(\"FP_PRESET_ENV\")] || {}) as Record<string, string>,\n      ),\n    ), // .map(([k, v]) => [k, v as string])\n  ]);\n  // console.log(\">>>>>>\", penv)\n  return penv;\n}\n// const envImpl = envFactory({\n//   symbol: \"FP_ENV\",\n//   presetEnv: presetEnv(),\n// });\nclass pathOpsImpl implements PathOps {\n  join(...paths: string[]): string {\n    return paths.map((i) => i.replace(/\\/+$/, \"\")).join(\"/\");\n  }\n  dirname(path: string) {\n    return path.split(\"/\").slice(0, -1).join(\"/\");\n  }\n  // homedir() {\n  //     throw new Error(\"SysContainer:homedir is not available in seeded state\");\n  //   }\n}\nconst pathOps = new pathOpsImpl();\nconst txtOps = {\n  encode: (input: string) => new TextEncoder().encode(input),\n  decode: (input: Uint8Array) => new TextDecoder().decode(input),\n};\n\nexport function ensureSuperThis(osthis?: Partial<SuperThisOpts>): SuperThis {\n  const env = envFactory({\n    symbol: osthis?.env?.symbol || \"FP_ENV\",\n    presetEnv: osthis?.env?.presetEnv || presetEnv(),\n  });\n  return new superThis({\n    logger: osthis?.logger || globalLogger,\n    env,\n    crypto: osthis?.crypto || toCryptoRuntime(),\n    ctx: osthis?.ctx || {},\n    pathOps,\n    txt: osthis?.txt || txtOps,\n  });\n}\n\n// // eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function ensureSuperLog(sthis: SuperThis, componentName: string, ctx?: Record<string, unknown>): SuperThis {\n  return sthis.clone({\n    logger: ensureLogger(sthis, componentName, ctx),\n  });\n}\n\nexport function ensureLogger(\n  sthis: SuperThis /* Partial<LoggerOpts> | Logger */,\n  componentName: string,\n  ctx?: Record<string, unknown>,\n): Logger {\n  // if (!opts?.logger) {\n  //   throw new Error(\"logger is required\");\n  // }\n  let logger = globalLogger;\n  if (IsLogger(sthis)) {\n    logger = sthis;\n  } else if (sthis && IsLogger(sthis.logger)) {\n    logger = sthis.logger;\n  }\n  const cLogger = logger.With().Module(componentName); //.Str(\"this\", uuidv7());\n  const debug: string[] = [];\n  let exposeStack = false;\n  if (ctx) {\n    if (\"debug\" in ctx) {\n      if (typeof ctx.debug === \"string\" && ctx.debug.length > 0) {\n        debug.push(ctx.debug);\n      } else {\n        debug.push(componentName);\n      }\n      delete ctx.debug;\n    }\n    if (\"exposeStack\" in ctx) {\n      exposeStack = true;\n      delete ctx.exposeStack;\n    }\n    if (\"this\" in ctx) {\n      cLogger.Str(\"this\", sthis.nextId(4).str);\n      delete ctx.this;\n    }\n    for (const [key, value] of Object.entries(ctx)) {\n      switch (typeof value) {\n        case \"string\":\n          cLogger.Str(key, value);\n          break;\n        case \"number\":\n          cLogger.Uint64(key, value);\n          break;\n        default:\n          if (value instanceof Date) {\n            cLogger.Str(key, value.toISOString());\n          } else if (isURL(value)) {\n            cLogger.Str(key, value.toString());\n          } else if (typeof value === \"function\") {\n            cLogger.Ref(key, value);\n          } else {\n            cLogger.Any(key, value);\n          }\n          break;\n      }\n    }\n  }\n  registerFP_DEBUG\n    .once(async () => {\n      // console.log(\"registerFP_DEBUG\", SysContainer.env)\n      sthis.env.onSet(\n        (key, value) => {\n          // console.log(\"FP_DEBUG\", key, value, debug)\n          switch (key) {\n            case \"FP_FORMAT\": {\n              switch (value) {\n                case \"jsonice\":\n                  logger.SetFormatter(new JSONFormatter(logger.TxtEnDe(), 2));\n                  break;\n                case \"yaml\":\n                  logger.SetFormatter(new YAMLFormatter(logger.TxtEnDe(), 2));\n                  break;\n                case \"json\":\n                default:\n                  logger.SetFormatter(new JSONFormatter(logger.TxtEnDe()));\n                  break;\n              }\n              break;\n            }\n            case \"FP_DEBUG\":\n              logger.SetDebug(value || []);\n              break;\n            case \"FP_STACK\":\n              logger.SetExposeStack(!!value);\n              break;\n          }\n        },\n        \"FP_FORMAT\",\n        \"FP_DEBUG\",\n        \"FP_STACK\",\n      );\n    })\n    .finally(() => {\n      /* do nothing */\n    });\n\n  if (debug.length > 0) {\n    logger.SetDebug(debug);\n  }\n  if (exposeStack) {\n    logger.SetExposeStack(true);\n  }\n  const out = cLogger.Logger();\n  // out.Debug().Msg(\"logger ready\");\n  return out;\n}\n\nexport type Joiner = (...toJoin: string[]) => string;\n\nexport interface Store {\n  readonly store: StoreType;\n  readonly name: string;\n}\n\nexport function getStore(url: URI, sthis: SuperThis, joiner: Joiner): Store {\n  const store = url.getParam(\"store\");\n  switch (store) {\n    case \"data\":\n    case \"wal\":\n    case \"meta\":\n      break;\n    default:\n      throw sthis.logger.Error().Url(url).Msg(`store not found`).AsError();\n  }\n  let name: string = store;\n  if (url.hasParam(\"index\")) {\n    name = joiner(url.getParam(\"index\") || \"idx\", name);\n  }\n  return { store, name };\n}\n\nexport function getKey(url: URI, logger: Logger): string {\n  const result = url.getParam(\"key\");\n  if (!result) throw logger.Error().Str(\"url\", url.toString()).Msg(`key not found`).AsError();\n  return result;\n}\n\nexport function getName(sthis: SuperThis, url: URI): string {\n  let result = url.getParam(\"name\");\n  if (!result) {\n    result = sthis.pathOps.dirname(url.pathname);\n    if (result.length === 0) {\n      throw sthis.logger.Error().Str(\"url\", url.toString()).Msg(`name not found`).AsError();\n    }\n  }\n  return result;\n}\n\n// export function exception2Result<T = void>(fn: () => Promise<T>): Promise<Result<T>> {\n//   return fn()\n//     .then((value) => Result.Ok(value))\n//     .catch((e) => Result.Err(e));\n// }\n\nexport async function exceptionWrapper<T, E extends Error>(fn: () => Promise<Result<T, E>>): Promise<Result<T, E>> {\n  return fn().catch((e) => Result.Err(e));\n}\n\n// // the big side effect party --- hate it\n// export function sanitizeURL(url: URL) {\n//   url.searchParams.sort();\n//   // const searchParams = Object.entries(url.searchParams).sort(([a], [b]) => a.localeCompare(b));\n//   // console.log(\"searchParams\", searchParams);\n//   // for (const [key] of searchParams) {\n//   //   url.searchParams.delete(key);\n//   // }\n//   // for (const [key, value] of searchParams) {\n//   //   url.searchParams.set(key, value);\n//   // }\n// }\n\nexport class NotFoundError extends Error {\n  readonly code = \"ENOENT\";\n}\n\nexport function isNotFoundError(e: Error | Result<unknown> | unknown): e is NotFoundError {\n  if (Result.Is(e)) {\n    if (e.isOk()) return false;\n    e = e.Err();\n  }\n  if ((e as NotFoundError).code === \"ENOENT\") return true;\n  return false;\n}\n\nexport function dataDir(sthis: SuperThis, name?: string, base?: CoerceURI): URI {\n  if (!base) {\n    if (!runtimeFn().isBrowser) {\n      const home = sthis.env.get(\"HOME\") || \"./\";\n      base = sthis.env.get(\"FP_STORAGE_URL\") || `file://${sthis.pathOps.join(home, \".fireproof\")}`;\n    } else {\n      base = sthis.env.get(\"FP_STORAGE_URL\") || `indexdb://fp`;\n    }\n  }\n  return URI.from(base.toString())\n    .build()\n    .setParam(\"name\", name || \"\")\n    .URI();\n}\n\nexport function UInt8ArrayEqual(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n","module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {\n    encode.bytes = 0\n    throw new RangeError('Could not encode varint')\n  }\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n","module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n","\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","const err = new Error(\"store-file not implemented\");\n// eslint-disable-next-line no-console\nconsole.error(err.stack);\nthrow err;\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","import type { PathLike, MakeDirectoryOptions, Stats, ObjectEncodingOptions } from \"node:fs\";\nimport type { mkdir, readdir, rm, copyFile, readFile, stat, unlink, writeFile } from \"node:fs/promises\";\nimport { toArrayBuffer } from \"./utils.js\";\nimport { SysFileSystem } from \"../../../types.js\";\nimport { runtimeFn } from \"@adviser/cement\";\n\nexport class NodeFileSystem implements SysFileSystem {\n  fs?: {\n    mkdir: typeof mkdir;\n    readdir: typeof readdir;\n    rm: typeof rm;\n    copyFile: typeof copyFile;\n    readFile: typeof readFile;\n    stat: typeof stat;\n    unlink: typeof unlink;\n    writeFile: typeof writeFile;\n  };\n\n  async start(): Promise<SysFileSystem> {\n    this.fs = await import(\"node:fs/promises\");\n    return this;\n  }\n  async mkdir(path: PathLike, options?: { recursive: boolean }): Promise<string | undefined> {\n    return this.fs?.mkdir(path, options);\n  }\n  async readdir(path: PathLike, options?: ObjectEncodingOptions): Promise<string[]> {\n    return this.fs?.readdir(path, options) as Promise<string[]>;\n  }\n  async rm(path: PathLike, options?: MakeDirectoryOptions & { recursive: boolean }): Promise<void> {\n    return this.fs?.rm(path, options);\n  }\n  async copyFile(source: PathLike, destination: PathLike): Promise<void> {\n    return this.fs?.copyFile(source, destination);\n  }\n  async readfile(path: PathLike, options?: { encoding: BufferEncoding; flag?: string }): Promise<Uint8Array> {\n    const ret = (await this.fs?.readFile(path, options)) as Buffer;\n    return toArrayBuffer(ret);\n  }\n  stat(path: PathLike): Promise<Stats> {\n    return this.fs?.stat(path) as Promise<Stats>;\n  }\n  async unlink(path: PathLike): Promise<void> {\n    return this.fs?.unlink(path);\n  }\n  async writefile(path: PathLike, data: Uint8Array | string): Promise<void> {\n    if (runtimeFn().isDeno) {\n      return this.fs?.writeFile(path, data);\n    }\n    return this.fs?.writeFile(path, Buffer.from(data));\n  }\n}\n\n// import { type NodeMap, join } from \"../../sys-container.js\";\n// import type { ObjectEncodingOptions, PathLike } from \"fs\";\n// import * as fs from \"fs/promises\";\n// import * as path from \"path\";\n// import * as os from \"os\";\n// import * as url from \"url\";\n// import { toArrayBuffer } from \"./utils.js\";\n\n// export async function createNodeSysContainer(): Promise<NodeMap> {\n//   // const nodePath = \"node:path\";\n//   // const nodeOS = \"node:os\";\n//   // const nodeURL = \"node:url\";\n//   // const nodeFS = \"node:fs\";\n//   // const fs = (await import(\"node:fs\")).promises;\n//   // const assert = \"assert\";\n//   // const path = await import(\"node:path\");\n//   return {\n//     state: \"node\",\n//     ...path,\n//     // ...(await import(\"node:os\")),\n//     // ...(await import(\"node:url\")),\n//     ...os,\n//     ...url,\n//     ...fs,\n//     join,\n//     stat: fs.stat as NodeMap[\"stat\"],\n//     readdir: fs.readdir as NodeMap[\"readdir\"],\n//     readfile: async (path: PathLike, options?: ObjectEncodingOptions): Promise<Uint8Array> => {\n//       const rs = await fs.readFile(path, options);\n//       return toArrayBuffer(rs);\n//     },\n//     writefile: fs.writeFile as NodeMap[\"writefile\"],\n//   };\n// }\n","import { URI } from \"@adviser/cement\";\nimport { getStore } from \"../../../utils.js\";\nimport { SuperThis, SysFileSystem } from \"../../../types.js\";\n\nexport async function getFileSystem(url: URI): Promise<SysFileSystem> {\n  const name = url.getParam(\"fs\");\n  let fs: SysFileSystem;\n  switch (name) {\n    case \"mem\":\n      {\n        const { MemFileSystem } = await import(\"./mem-filesystem.js\");\n        fs = new MemFileSystem();\n      }\n      break;\n    // case 'deno': {\n    //   const { DenoFileSystem } = await import(\"./deno-filesystem.js\");\n    //   fs = new DenoFileSystem();\n    //   break;\n    // }\n    case \"node\": {\n      const { NodeFileSystem } = await import(\"./node-filesystem.js\");\n      fs = new NodeFileSystem();\n      break;\n    }\n    case \"sys\":\n    default: {\n      // if (runtimeFn().isDeno) {\n      //   return getFileSystem(url.build().setParam(\"fs\", \"deno\").URI());\n      // } else  {\n      return getFileSystem(url.build().setParam(\"fs\", \"node\").URI());\n      // }\n    }\n  }\n  return fs.start();\n}\n\nexport function getPath(url: URI, sthis: SuperThis): string {\n  const basePath = url.pathname;\n  // .toString()\n  // .replace(new RegExp(`^${url.protocol}//`), \"\")\n  // .replace(/\\?.*$/, \"\");\n  const name = url.getParam(\"name\");\n  if (name) {\n    const version = url.getParam(\"version\");\n    if (!version) throw sthis.logger.Error().Url(url).Msg(`version not found`).AsError();\n    return sthis.pathOps.join(basePath, version, name);\n  }\n  return sthis.pathOps.join(basePath);\n}\n\nexport function getFileName(url: URI, sthis: SuperThis): string {\n  const key = url.getParam(\"key\");\n  if (!key) throw sthis.logger.Error().Url(url).Msg(`key not found`).AsError();\n  const res = getStore(url, sthis, (...a: string[]) => a.join(\"-\"));\n  switch (res.store) {\n    case \"data\":\n      return sthis.pathOps.join(res.name, key + \".car\");\n    case \"wal\":\n    case \"meta\":\n      return sthis.pathOps.join(res.name, key + \".json\");\n    default:\n      throw sthis.logger.Error().Url(url).Msg(`unsupported store type`).AsError();\n  }\n}\n\nexport function toArrayBuffer(buffer: Buffer | string): Uint8Array {\n  if (typeof buffer === \"string\") {\n    buffer = Buffer.from(buffer);\n  }\n  const ab = new ArrayBuffer(buffer.length);\n  const view = new Uint8Array(ab);\n  for (let i = 0; i < buffer.length; ++i) {\n    view[i] = buffer[i];\n  }\n  return view;\n}\n","import { IDBPDatabase, openDB } from \"idb\";\nimport { KeyBagProvider, KeyItem } from \"./key-bag.js\";\nimport { getPath } from \"./gateways/file/utils.js\";\nimport { Logger, ResolveOnce, URI } from \"@adviser/cement\";\nimport { SuperThis } from \"use-fireproof\";\n\nexport class KeyBagProviderIndexDB implements KeyBagProvider {\n  readonly _db: ResolveOnce<IDBPDatabase<unknown>> = new ResolveOnce<IDBPDatabase<unknown>>();\n\n  readonly dbName: string;\n  readonly url: URI;\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n  constructor(url: URI, sthis: SuperThis) {\n    this.sthis = sthis;\n    this.logger = sthis.logger;\n    this.url = url;\n    this.dbName = getPath(this.url, this.sthis);\n  }\n\n  async _prepare(): Promise<IDBPDatabase<unknown>> {\n    return this._db.once(async () => {\n      return await openDB(this.dbName, 1, {\n        upgrade(db) {\n          // console.log('upgrade:', dbName);\n          [\"bag\"].map((store) => {\n            db.createObjectStore(store, {\n              autoIncrement: false,\n            });\n          });\n        },\n      });\n    });\n  }\n\n  async get(id: string): Promise<KeyItem | undefined> {\n    const db = await this._prepare();\n    const tx = db.transaction([\"bag\"], \"readonly\");\n    const keyItem = await tx.objectStore(\"bag\").get(id);\n    await tx.done;\n    if (!keyItem) {\n      return undefined;\n    }\n    return keyItem;\n  }\n\n  async set(id: string, item: KeyItem): Promise<void> {\n    const db = await this._prepare();\n    const tx = db.transaction([\"bag\"], \"readwrite\");\n    await tx.objectStore(\"bag\").put(item, id);\n    await tx.done;\n  }\n}\n","export const INDEXDB_VERSION = \"v0.19-indexdb\";\n","import { openDB, IDBPDatabase } from \"idb\";\nimport { exception2Result, KeyedResolvOnce, Logger, Result, URI } from \"@adviser/cement\";\n\nimport { INDEXDB_VERSION } from \"./version.js\";\nimport { ensureLogger, exceptionWrapper, getKey, getStore, NotFoundError } from \"../../../utils.js\";\nimport { Gateway, GetResult, TestGateway } from \"../../../blockstore/gateway.js\";\nimport { SuperThis } from \"../../../types.js\";\n\nfunction ensureVersion(url: URI): URI {\n  return url.build().defParam(\"version\", INDEXDB_VERSION).URI();\n}\n\ninterface IDBConn {\n  readonly db: IDBPDatabase<unknown>;\n  readonly dbName: DbName;\n  readonly version: string;\n  readonly url: URI;\n}\nconst onceIndexDB = new KeyedResolvOnce<IDBConn>();\n\nfunction sanitzeKey(key: string | string[]): string | string[] {\n  if (key.length === 1) {\n    key = key[0];\n  }\n  return key;\n}\n\nasync function connectIdb(url: URI, sthis: SuperThis): Promise<IDBConn> {\n  const dbName = getIndexDBName(url, sthis);\n  const once = await onceIndexDB.get(dbName.fullDb).once(async () => {\n    const db = await openDB(dbName.fullDb, 1, {\n      upgrade(db) {\n        [\"version\", \"data\", \"wal\", \"meta\", \"idx.data\", \"idx.wal\", \"idx.meta\"].map((store) => {\n          db.createObjectStore(store, {\n            autoIncrement: false,\n          });\n        });\n      },\n    });\n    const found = await db.get(\"version\", \"version\");\n    const version = ensureVersion(url).getParam(\"version\") as string;\n    if (!found) {\n      await db.put(\"version\", { version }, \"version\");\n    } else if (found.version !== version) {\n      sthis.logger.Warn().Str(\"url\", url.toString()).Str(\"version\", version).Str(\"found\", found.version).Msg(\"version mismatch\");\n    }\n    return { db, dbName, version, url };\n  });\n  return {\n    ...once,\n    url: url.build().setParam(\"version\", once.version).URI(),\n  };\n}\n\nexport interface DbName {\n  readonly fullDb: string;\n  readonly objStore: string;\n  readonly connectionKey: string;\n  readonly dbName: string;\n}\n\nfunction joinDBName(...names: string[]): string {\n  return names\n    .map((i) => i.replace(/^[^a-zA-Z0-9]+/g, \"\").replace(/[^a-zA-Z0-9]+/g, \"_\"))\n    .filter((i) => i.length)\n    .join(\".\");\n}\n\n// const schemaVersion = new Map<string, number>();\nexport function getIndexDBName(iurl: URI, sthis: SuperThis): DbName {\n  const url = ensureVersion(iurl);\n  const fullDb = url.pathname.replace(/^\\/+/, \"\").replace(/\\?.*$/, \"\"); // cut leading slashes\n  // const type = getStore(url);\n  // const storageVersion = url.searchParams.get(\"version\");\n  // not nice but we need to pass the version to the db name\n  // url.searchParams.set(\"version\", storageVersion);\n  // console.log(\"getIndexDBName:\", url.toString(), { fullDb, type, branch });\n  // const dbName = fullDb.replace(new RegExp(`^fp.${storageVersion}.`), \"\"); // cut fp prefix\n  const dbName = url.getParam(\"name\");\n  if (!dbName) throw sthis.logger.Error().Str(\"url\", url.toString()).Msg(`name not found`).AsError();\n  const result = joinDBName(fullDb, dbName);\n  const objStore = getStore(url, sthis, joinDBName).name;\n  const connectionKey = [result, objStore].join(\":\");\n  return {\n    fullDb: result,\n    objStore,\n    connectionKey,\n    dbName,\n  };\n}\n\nexport class IndexDBGateway implements Gateway {\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n  constructor(sthis: SuperThis) {\n    this.logger = ensureLogger(sthis, \"IndexDBGateway\");\n    this.sthis = sthis;\n  }\n  _db: IDBPDatabase<unknown> = {} as IDBPDatabase<unknown>;\n\n  async start(baseURL: URI): Promise<Result<URI>> {\n    return exception2Result(async () => {\n      this.logger.Debug().Url(baseURL).Msg(\"starting\");\n      await this.sthis.start();\n      const ic = await connectIdb(baseURL, this.sthis);\n      this._db = ic.db;\n      this.logger.Debug().Url(ic.url).Msg(\"started\");\n      return ic.url;\n    });\n  }\n  async close(): Promise<Result<void>> {\n    return Result.Ok(undefined);\n  }\n  async destroy(baseUrl: URI): Promise<Result<void>> {\n    return exception2Result(async () => {\n      // return deleteDB(getIndexDBName(this.url).fullDb);\n      const type = getStore(baseUrl, this.sthis, joinDBName).name;\n      // console.log(\"IndexDBDataStore:destroy\", type);\n      const idb = this._db;\n      const trans = idb.transaction(type, \"readwrite\");\n      const object_store = trans.objectStore(type);\n      const toDelete = [];\n      for (let cursor = await object_store.openCursor(); cursor; cursor = await cursor.continue()) {\n        toDelete.push(cursor.primaryKey);\n      }\n      for (const key of toDelete) {\n        await trans.db.delete(type, key);\n      }\n      await trans.done;\n    });\n  }\n\n  buildUrl(baseUrl: URI, key: string): Promise<Result<URI>> {\n    return Promise.resolve(Result.Ok(baseUrl.build().setParam(\"key\", key).URI()));\n  }\n\n  async get(url: URI): Promise<GetResult> {\n    return exceptionWrapper(async () => {\n      const key = getKey(url, this.logger);\n      const store = getStore(url, this.sthis, joinDBName).name;\n      this.logger.Debug().Url(url).Str(\"key\", key).Str(\"store\", store).Msg(\"getting\");\n      const tx = this._db.transaction([store], \"readonly\");\n      const bytes = await tx.objectStore(store).get(sanitzeKey(key));\n      await tx.done;\n      if (!bytes) {\n        return Result.Err(new NotFoundError(`missing ${key}`));\n      }\n      return Result.Ok(bytes as Uint8Array);\n    });\n  }\n  async put(url: URI, value: Uint8Array) {\n    return exception2Result(async () => {\n      const key = getKey(url, this.logger);\n      const store = getStore(url, this.sthis, joinDBName).name;\n      this.logger.Debug().Url(url).Str(\"key\", key).Str(\"store\", store).Msg(\"putting\");\n      const tx = this._db.transaction([store], \"readwrite\");\n      await tx.objectStore(store).put(value, sanitzeKey(key));\n      await tx.done;\n    });\n  }\n  async delete(url: URI) {\n    return exception2Result(async () => {\n      const key = getKey(url, this.logger);\n      const store = getStore(url, this.sthis, joinDBName).name;\n      this.logger.Debug().Url(url).Str(\"key\", key).Str(\"store\", store).Msg(\"deleting\");\n      const tx = this._db.transaction([store], \"readwrite\");\n      await tx.objectStore(store).delete(sanitzeKey(key));\n      await tx.done;\n      return Result.Ok(undefined);\n    });\n  }\n}\n\n// export class IndexDBDataGateway extends IndexDBGateway {\n//   readonly storeType = \"data\";\n//   constructor(logger: Logger) {\n//     super(ensureLogger(logger, \"IndexDBDataGateway\"));\n//   }\n// }\n\n// export class IndexDBWalGateway extends IndexDBGateway {\n//   readonly storeType = \"wal\";\n//   constructor(logger: Logger) {\n//     super(ensureLogger(logger, \"IndexDBWalGateway\"));\n//   }\n// }\n// export class IndexDBMetaGateway extends IndexDBGateway {\n//   readonly storeType = \"meta\";\n//   constructor(logger: Logger) {\n//     super(ensureLogger(logger, \"IndexDBMetaGateway\"));\n//   }\n// }\n\nexport class IndexDBTestStore implements TestGateway {\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n  constructor(sthis: SuperThis) {\n    this.sthis = sthis;\n    this.logger = ensureLogger(sthis, \"IndexDBTestStore\", {});\n  }\n  async get(url: URI, key: string) {\n    const ic = await connectIdb(url, this.sthis);\n    const store = getStore(ic.url, this.sthis, joinDBName).name;\n    this.logger.Debug().Str(\"key\", key).Str(\"store\", store).Msg(\"getting\");\n    let bytes = await ic.db.get(store, sanitzeKey(key));\n    this.logger.Debug().Str(\"key\", key).Str(\"store\", store).Int(\"len\", bytes.length).Msg(\"got\");\n    if (typeof bytes === \"string\") {\n      bytes = this.sthis.txt.encode(bytes);\n    }\n    return bytes as Uint8Array;\n  }\n}\n","// Number is encoded in scientific notation.\n// A Number is composed of an exponent and a mantissa. The exponent isan integer\n// in [-324, 308] and the mantissa is a decimal in ]-10, 10[.\n// First we encode the sign as N or P, then E marking the start of the exponent.\n// The exponent is offseted of 500 to be positive and startpadded to 3 chars.\n// We endpad mantissa with enough zero to exceed mantissa precision.\n// Then negative numbers' mantissa and exponent are flipped (nines' complement)\n\nexports.encode = function (number) {\n    if (isNaN(number)) { return \"DaN\"; }\n    if (number === 0) { return \"FE  0M0\"; }\n    if (number === Infinity) { return \"FF\"; }\n    if (number === -Infinity) { return \"DD\"; }\n\n    var splitScientificNotation = number.toExponential().split('e');\n    var exponent = Number(splitScientificNotation[1]) + 500;\n    var mantissa = splitScientificNotation[0] + (splitScientificNotation[0].indexOf('.') === -1 ? '.' : '') + '0'.repeat(20);\n    var encoded = 'E' + padStart(String(exponent), 3) + 'M' + String(mantissa);\n    if (number > 0) {\n        return 'F' + encoded;\n    } else {\n        return 'D' + flip(encoded);\n    }\n}\n\nexports.decode = function (encoded) {\n    if (encoded === 'DaN') { return NaN; }\n    if (encoded === 'FF') { return Infinity; }\n    if (encoded === 'DD') { return -Infinity; }\n\n    var isNegative = encoded[0] === 'D';\n    var splitEncoded = (isNegative ? flip(encoded) : encoded).slice(2).split('M');\n    return Number((isNegative ? '-':'') + splitEncoded[1] + 'e' + String(Number(splitEncoded[0])-500));\n}\n\nfunction flip(number) {\n    var flipped = '';\n    for (var i = 0; i < number.length; i++) {\n        var digit = number[i];\n        if (isNaN(Number(digit)) || digit === ' ') {\n            if (digit !== '-') { flipped += digit; }\n        } else {\n            flipped += String(9 - Number(digit));\n        }\n    }\n    return flipped;\n}\n\nfunction padStart (str, count) {\n  return (' ').repeat(count - str.length).substr(0,count) + str;\n};\n","var dictEscape = { '?': '?@', '!': '??', '\"': '?%' };\nfunction escape(str) {\n    if (!/[!\"]/.test(str)) { return str; }\n    return str.replace(/[\\?!\"]/g, function (match) {\n        return dictEscape[match];\n    });\n\n}\n\nvar dictUnescape = { '?@': '?', '??': '!', '?%': '\"' };\nfunction unescape(str) {\n    if (!/\\?[%\\?@]/.test(str)) { return str; }\n    return str.replace(/\\?[%\\?@]/g, function (match) {\n        return dictUnescape[match];\n    });\n}\n\nexports.factory = function (codec) {\n\n    return {\n        encode: encode,\n        decode: decode\n    };\n\n    function encode(array) {\n        if (array === null) { return 'A'; }\n        if (!Array.isArray(array)) { throw new Error('can only encode arrays'); }\n        var l = array.length;\n        if (l == 0) { return 'K!'; }\n\n        var s = encodeItem(array[0]);\n        for (var i = 1; i < l; i++) {\n            s += '\"' + encodeItem(array[i]);\n        }\n\n        return 'K'+ s + '!';\n    }\n\n    function encodeItem(item) {\n        if (typeof item === 'object') {\n            return encode(item);\n        }\n        return escape(codec.encode(item));\n    }\n\n    function decode(encoded) {\n        if (encoded === 'A') { return null; }\n        if (encoded === 'K!') { return []; }\n        var items = encoded.split('\"');\n\n        var pointers = [[]];\n        var array;\n        var depth = 0;\n\n        var l = items.length;\n        for (var i = 0; i < l; i++) {\n            var item = items[i];\n            var itemLength = item.length;\n\n            var open = 0;\n            while (item[open] == 'K') { open++; }\n\n            var close = 0;\n            while (item[itemLength-close - 1] == '!') { close++; }\n\n            var content = item.slice(open, itemLength-close);\n\n            var newdepth = depth + open;\n            for (var j = depth; j < newdepth; j++) {\n                pointers[j + 1] = [];\n                pointers[j].push(pointers[j + 1]);\n                depth = newdepth;\n                array = pointers[depth];\n            }\n\n            if (content.length !== 0) {\n                array.push(codec.decode(unescape(content)));\n            }\n\n            var newdepth = depth - close;\n            for (var j = newdepth; j < depth; j++) {\n                pointers[j + 1] = [];\n                depth = newdepth;\n                array = pointers[depth];\n            }\n\n        }\n        return pointers[0][0];\n    }\n}\n","var number = require('./codec/number.js');\nvar object = require('./codec/object.js');\n\nvar flip = exports.flip = function (n) {\n  var s = n.toString()\n  var f = ''\n  for(var i in s) {\n    f += s[i] == '.' ? '.' : (9 - +s[i])\n  }\n  return f\n}\n\nfunction round (n) {\n  return n < 0 ? Math.ceil(n) : Math.floor(n)\n}\n\nfunction fraction (f) {\n  return f - round(f)\n}\n\nexports.number = number;\n\nexports.string = {\n  encode: function (s) {\n    //we'll need to escape the separators\n    if(!/\\x00|\\x01/.test(s))\n      return 'J'+s\n    else {\n      return 'J'+s.replace(/\\x01/g, '\\x01\\x01').replace(/\\x00/g, '\\x01')\n    }\n  },\n  decode: function (s) {\n    if('J' === s[0])\n      return s.substring(1) //TODO, unescape things...\n  }\n}\n\nexports.encode = function (t) {\n  return exports[typeof t].encode(t)\n}\n\nexports.decode = function (s) {\n  if(s === '') return s\n\n  if(!decoders[s[0]])\n    throw new Error('no decoder for:'+JSON.stringify(s))\n  return decoders[s[0]](s)\n}\n\nexports.object = object.factory(exports);\n\nexports.boolean = {\n  encode: function (b) {\n    return b ? 'C' : 'B'\n  },\n  decode: function (b) {\n    return 'C' === b\n  }\n}\n\nexports.undefined = {\n  encode: function (b) {\n    return 'L'\n  },\n  decode: function () {\n    return undefined\n  }\n}\n\nvar decoders = {\n  A: exports.object.decode, //null\n  B: exports.boolean.decode, // false\n  C: exports.boolean.decode, // true\n  D: exports.number.decode, // number\n  F: exports.number.decode, // number\n  // G Date\n  // H Date\n  // I Buffer\n  J: exports.string.decode, // String\n  K: exports.object.decode, // Array\n  L: exports.undefined.decode, // undefined\n}\n\n\n//for leveldb, request strings\nexports.buffer = false\nexports.type = 'charwise'\n","export * from \"./database.js\";\nexport * from \"./types.js\";\n\nexport * from \"./crdt.js\";\n\nexport * from \"./indexer.js\";\n\nexport * as bs from \"./blockstore/index.js\";\nexport * as blockstore from \"./blockstore/index.js\";\n\nimport { type Connectable } from \"./blockstore\";\nexport { Connectable };\n\nexport * as rt from \"./runtime/index.js\";\nexport * as runtime from \"./runtime/index.js\";\n\nexport * from \"./utils.js\";\n\nexport * from \"./version.js\";\n","import { Logger, ResolveOnce } from \"@adviser/cement\";\nimport { uuidv7 } from \"uuidv7\";\n\nimport { WriteQueue, writeQueue } from \"./write-queue.js\";\nimport { CRDT } from \"./crdt.js\";\nimport { index } from \"./indexer.js\";\nimport type {\n  DocUpdate,\n  ClockHead,\n  ConfigOpts,\n  MapFn,\n  QueryOpts,\n  ChangesOptions,\n  DocSet,\n  DocWithId,\n  IndexKeyType,\n  ListenerFn,\n  DocResponse,\n  ChangesResponse,\n  DocTypes,\n  IndexRows,\n  DocFragment,\n  ChangesResponseRow,\n  CRDTMeta,\n  AllDocsQueryOpts,\n  AllDocsResponse,\n  SuperThis,\n} from \"./types.js\";\nimport { BaseBlockstore, Connectable } from \"./blockstore/index.js\";\nimport { ensureLogger, ensureSuperThis, NotFoundError } from \"./utils.js\";\n\nexport class Database<DT extends DocTypes = NonNullable<unknown>> implements Connectable {\n  static databases: Map<string, Database> = new Map<string, Database>();\n\n  readonly name?: string;\n  readonly opts: ConfigOpts = {};\n\n  _listening = false;\n  readonly _listeners: Set<ListenerFn<DT>> = new Set<ListenerFn<DT>>();\n  readonly _noupdate_listeners: Set<ListenerFn<DT>> = new Set<ListenerFn<DT>>();\n  readonly _crdt: CRDT<DT>;\n  readonly _writeQueue: WriteQueue<DT>;\n  readonly blockstore: BaseBlockstore;\n\n  async close() {\n    await this.ready();\n    await this._crdt.close();\n    await this.blockstore.close();\n  }\n\n  async destroy() {\n    await this.ready();\n    await this._crdt.destroy();\n    await this.blockstore.destroy();\n  }\n\n  readonly _ready: ResolveOnce<void> = new ResolveOnce<void>();\n  async ready(): Promise<void> {\n    return this._ready.once(async () => {\n      await this.sthis.start();\n      await this._crdt.ready();\n      await this.blockstore.ready();\n    });\n  }\n\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n\n  constructor(name?: string, opts?: ConfigOpts) {\n    this.name = name;\n    this.opts = opts || this.opts;\n    this.sthis = ensureSuperThis(this.opts);\n    this.logger = ensureLogger(this.sthis, \"Database\");\n    // this.logger.SetDebug(\"Database\")\n    this._crdt = new CRDT(this.sthis, name, this.opts);\n    this.blockstore = this._crdt.blockstore; // for connector compatibility\n    this._writeQueue = writeQueue(async (updates: DocUpdate<DT>[]) => {\n      return await this._crdt.bulk(updates);\n    }); //, Infinity)\n    this._crdt.clock.onTock(() => {\n      this._no_update_notify();\n    });\n  }\n\n  async get<T extends DocTypes>(id: string): Promise<DocWithId<T>> {\n    if (!id) throw this.logger.Error().Str(\"db\", this.name).Msg(`Doc id is required`).AsError();\n\n    await this.ready();\n    this.logger.Debug().Str(\"id\", id).Msg(\"get\");\n    const got = await this._crdt.get(id).catch((e) => {\n      throw new NotFoundError(`Not found: ${id} - ${e.message}`);\n    });\n    if (!got) throw new NotFoundError(`Not found: ${id}`);\n    const { doc } = got;\n    return { ...(doc as unknown as DocWithId<T>), _id: id };\n  }\n\n  async put<T extends DocTypes>(doc: DocSet<T>): Promise<DocResponse> {\n    await this.ready();\n    this.logger.Debug().Str(\"id\", doc._id).Msg(\"put\");\n    const { _id, ...value } = doc;\n    const docId = _id || uuidv7();\n    const result = (await this._writeQueue.push({\n      id: docId,\n      value: {\n        ...(value as unknown as DocSet<DT>),\n        _id: docId,\n      },\n    })) as CRDTMeta;\n    return { id: docId, clock: result?.head, name: this.name } as DocResponse;\n  }\n\n  async del(id: string): Promise<DocResponse> {\n    await this.ready();\n    this.logger.Debug().Str(\"id\", id).Msg(\"del\");\n    const result = (await this._writeQueue.push({ id: id, del: true })) as CRDTMeta;\n    return { id, clock: result?.head, name: this.name } as DocResponse;\n  }\n\n  async changes<T extends DocTypes>(since: ClockHead = [], opts: ChangesOptions = {}): Promise<ChangesResponse<T>> {\n    await this.ready();\n    this.logger.Debug().Any(\"since\", since).Any(\"opts\", opts).Msg(\"changes\");\n    const { result, head } = await this._crdt.changes(since, opts);\n    const rows: ChangesResponseRow<T>[] = result.map(({ id: key, value, del, clock }) => ({\n      key,\n      value: (del ? { _id: key, _deleted: true } : { _id: key, ...value }) as DocWithId<T>,\n      clock,\n    }));\n    return { rows, clock: head, name: this.name };\n  }\n\n  async allDocs<T extends DocTypes>(opts: AllDocsQueryOpts = {}): Promise<AllDocsResponse<T>> {\n    await this.ready();\n    void opts;\n    this.logger.Debug().Msg(\"allDocs\");\n    const { result, head } = await this._crdt.allDocs();\n    const rows = result.map(({ id: key, value, del }) => ({\n      key,\n      value: (del ? { _id: key, _deleted: true } : { _id: key, ...value }) as DocWithId<T>,\n    }));\n    return { rows, clock: head, name: this.name };\n  }\n\n  async allDocuments<T extends DocTypes>(): Promise<{\n    rows: {\n      key: string;\n      value: DocWithId<T>;\n    }[];\n    clock: ClockHead;\n  }> {\n    return this.allDocs<T>();\n  }\n\n  subscribe<T extends DocTypes>(listener: ListenerFn<T>, updates?: boolean): () => void {\n    this.logger.Debug().Bool(\"updates\", updates).Msg(\"subscribe\");\n    if (updates) {\n      if (!this._listening) {\n        this._listening = true;\n        this._crdt.clock.onTick((updates: DocUpdate<NonNullable<unknown>>[]) => {\n          void this._notify(updates);\n        });\n      }\n      this._listeners.add(listener as ListenerFn<NonNullable<unknown>>);\n      return () => {\n        this._listeners.delete(listener as ListenerFn<NonNullable<unknown>>);\n      };\n    } else {\n      this._noupdate_listeners.add(listener as ListenerFn<NonNullable<unknown>>);\n      return () => {\n        this._noupdate_listeners.delete(listener as ListenerFn<NonNullable<unknown>>);\n      };\n    }\n  }\n\n  // todo if we add this onto dbs in fireproof.ts then we can make index.ts a separate package\n  async query<K extends IndexKeyType, T extends DocTypes, R extends DocFragment = T>(\n    field: string | MapFn<T>,\n    opts: QueryOpts<K> = {},\n  ): Promise<IndexRows<K, T, R>> {\n    await this.ready();\n    this.logger.Debug().Any(\"field\", field).Any(\"opts\", opts).Msg(\"query\");\n    const _crdt = this._crdt as unknown as CRDT<T>;\n    const idx =\n      typeof field === \"string\"\n        ? index<K, T, R>(this.sthis, { _crdt }, field)\n        : index<K, T, R>(this.sthis, { _crdt }, makeName(field.toString()), field);\n    return await idx.query(opts);\n  }\n\n  async compact() {\n    await this.ready();\n    await this._crdt.compact();\n  }\n\n  async _notify(updates: DocUpdate<NonNullable<unknown>>[]) {\n    await this.ready();\n    if (this._listeners.size) {\n      const docs: DocWithId<NonNullable<unknown>>[] = updates.map(({ id, value }) => ({ ...value, _id: id }));\n      for (const listener of this._listeners) {\n        await (async () => await listener(docs as DocWithId<DT>[]))().catch((e: Error) => {\n          this.logger.Error().Err(e).Msg(\"subscriber error\");\n        });\n      }\n    }\n  }\n\n  async _no_update_notify() {\n    await this.ready();\n    if (this._noupdate_listeners.size) {\n      for (const listener of this._noupdate_listeners) {\n        await (async () => await listener([]))().catch((e: Error) => {\n          this.logger.Error().Err(e).Msg(\"subscriber error\");\n        });\n      }\n    }\n  }\n}\n\nfunction toSortedArray(set?: Record<string, unknown>): Record<string, unknown>[] {\n  if (!set) return [];\n  return Object.entries(set)\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([k, v]) => ({ [k]: v }));\n}\n\nexport function fireproof(name: string, opts?: ConfigOpts): Database {\n  const key = JSON.stringify(\n    toSortedArray({\n      name,\n      stores: toSortedArray(opts?.store?.stores),\n    }),\n  );\n  let db = Database.databases.get(key);\n  if (!db) {\n    db = new Database(name, opts);\n    Database.databases.set(key, db);\n  }\n  return db;\n}\n\nfunction makeName(fnString: string) {\n  const regex = /\\(([^,()]+,\\s*[^,()]+|\\[[^\\]]+\\],\\s*[^,()]+)\\)/g;\n  let found: RegExpExecArray | null = null;\n  const matches = Array.from(fnString.matchAll(regex), (match) => match[1].trim());\n  if (matches.length === 0) {\n    found = /=>\\s*{?\\s*([^{}]+)\\s*}?/.exec(fnString);\n    if (found && found[1].includes(\"return\")) {\n      found = null;\n    }\n  }\n  if (!found) {\n    return fnString;\n  } else {\n    // it's a consise arrow function, match everything after the arrow\n    return found[1];\n  }\n}\n","/**\n * uuidv7: A JavaScript implementation of UUID version 7\n *\n * Copyright 2021-2024 LiosK\n *\n * @license Apache-2.0\n * @packageDocumentation\n */\nconst DIGITS = \"0123456789abcdef\";\n/** Represents a UUID as a 16-byte byte array. */\nexport class UUID {\n    /** @param bytes - The 16-byte byte array representation. */\n    constructor(bytes) {\n        this.bytes = bytes;\n    }\n    /**\n     * Creates an object from the internal representation, a 16-byte byte array\n     * containing the binary UUID representation in the big-endian byte order.\n     *\n     * This method does NOT shallow-copy the argument, and thus the created object\n     * holds the reference to the underlying buffer.\n     *\n     * @throws TypeError if the length of the argument is not 16.\n     */\n    static ofInner(bytes) {\n        if (bytes.length !== 16) {\n            throw new TypeError(\"not 128-bit length\");\n        }\n        else {\n            return new UUID(bytes);\n        }\n    }\n    /**\n     * Builds a byte array from UUIDv7 field values.\n     *\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\n     * @param randA - A 12-bit `rand_a` field value.\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\n     * @throws RangeError if any field value is out of the specified range.\n     */\n    static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\n        if (!Number.isInteger(unixTsMs) ||\n            !Number.isInteger(randA) ||\n            !Number.isInteger(randBHi) ||\n            !Number.isInteger(randBLo) ||\n            unixTsMs < 0 ||\n            randA < 0 ||\n            randBHi < 0 ||\n            randBLo < 0 ||\n            unixTsMs > 281474976710655 ||\n            randA > 0xfff ||\n            randBHi > 1073741823 ||\n            randBLo > 4294967295) {\n            throw new RangeError(\"invalid field value\");\n        }\n        const bytes = new Uint8Array(16);\n        bytes[0] = unixTsMs / 2 ** 40;\n        bytes[1] = unixTsMs / 2 ** 32;\n        bytes[2] = unixTsMs / 2 ** 24;\n        bytes[3] = unixTsMs / 2 ** 16;\n        bytes[4] = unixTsMs / 2 ** 8;\n        bytes[5] = unixTsMs;\n        bytes[6] = 0x70 | (randA >>> 8);\n        bytes[7] = randA;\n        bytes[8] = 0x80 | (randBHi >>> 24);\n        bytes[9] = randBHi >>> 16;\n        bytes[10] = randBHi >>> 8;\n        bytes[11] = randBHi;\n        bytes[12] = randBLo >>> 24;\n        bytes[13] = randBLo >>> 16;\n        bytes[14] = randBLo >>> 8;\n        bytes[15] = randBLo;\n        return new UUID(bytes);\n    }\n    /**\n     * Builds a byte array from a string representation.\n     *\n     * This method accepts the following formats:\n     *\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\n     * - RFC 9562 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     *\n     * Leading and trailing whitespaces represents an error.\n     *\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\n     */\n    static parse(uuid) {\n        var _a, _b, _c, _d;\n        let hex = undefined;\n        switch (uuid.length) {\n            case 32:\n                hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];\n                break;\n            case 36:\n                hex =\n                    (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join(\"\");\n                break;\n            case 38:\n                hex =\n                    (_c = /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i\n                        .exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join(\"\");\n                break;\n            case 45:\n                hex =\n                    (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join(\"\");\n                break;\n            default:\n                break;\n        }\n        if (hex) {\n            const inner = new Uint8Array(16);\n            for (let i = 0; i < 16; i += 4) {\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\n                inner[i + 0] = n >>> 24;\n                inner[i + 1] = n >>> 16;\n                inner[i + 2] = n >>> 8;\n                inner[i + 3] = n;\n            }\n            return new UUID(inner);\n        }\n        else {\n            throw new SyntaxError(\"could not parse UUID string\");\n        }\n    }\n    /**\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\n     */\n    toString() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                text += \"-\";\n            }\n        }\n        return text;\n    }\n    /**\n     * @returns The 32-digit hexadecimal representation without hyphens\n     * (`0189dcd553117d408db09496a2eef37b`).\n     */\n    toHex() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n        }\n        return text;\n    }\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\n     * \"MAX\".\n     *\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\n     * subsumed under the variants `0b0` and `0b111`, respectively.\n     */\n    getVariant() {\n        const n = this.bytes[8] >>> 4;\n        if (n < 0) {\n            throw new Error(\"unreachable\");\n        }\n        else if (n <= 0b0111) {\n            return this.bytes.every((e) => e === 0) ? \"NIL\" : \"VAR_0\";\n        }\n        else if (n <= 0b1011) {\n            return \"VAR_10\";\n        }\n        else if (n <= 0b1101) {\n            return \"VAR_110\";\n        }\n        else if (n <= 0b1111) {\n            return this.bytes.every((e) => e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\n        }\n        else {\n            throw new Error(\"unreachable\");\n        }\n    }\n    /**\n     * Returns the version field value of the UUID or `undefined` if the UUID does\n     * not have the variant field value of `0b10`.\n     */\n    getVersion() {\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\n    }\n    /** Creates an object from `this`. */\n    clone() {\n        return new UUID(this.bytes.slice(0));\n    }\n    /** Returns true if `this` is equivalent to `other`. */\n    equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Returns a negative integer, zero, or positive integer if `this` is less\n     * than, equal to, or greater than `other`, respectively.\n     */\n    compareTo(other) {\n        for (let i = 0; i < 16; i++) {\n            const diff = this.bytes[i] - other.bytes[i];\n            if (diff !== 0) {\n                return Math.sign(diff);\n            }\n        }\n        return 0;\n    }\n}\n/**\n * Encapsulates the monotonic counter state.\n *\n * This class provides APIs to utilize a separate counter state from that of the\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\n * the default {@link generate} method, this class has {@link generateOrAbort}\n * that is useful to absolutely guarantee the monotonically increasing order of\n * generated UUIDs. See their respective documentation for details.\n */\nexport class V7Generator {\n    /**\n     * Creates a generator object with the default random number generator, or\n     * with the specified one if passed as an argument. The specified random\n     * number generator should be cryptographically strong and securely seeded.\n     */\n    constructor(randomNumberGenerator) {\n        this.timestamp = 0;\n        this.counter = 0;\n        this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method resets the\n     * generator and returns a new UUID based on the given timestamp, breaking the\n     * increasing order of UUIDs.\n     *\n     * See {@link generateOrAbort} for the other mode of generation and\n     * {@link generateOrResetCore} for the low-level primitive.\n     */\n    generate() {\n        return this.generateOrResetCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method aborts and\n     * returns `undefined` immediately.\n     *\n     * See {@link generate} for the other mode of generation and\n     * {@link generateOrAbortCore} for the low-level primitive.\n     */\n    generateOrAbort() {\n        return this.generateOrAbortCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generate} except that it takes a custom\n     * timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrResetCore(unixTsMs, rollbackAllowance) {\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        if (value === undefined) {\n            // reset state and resume\n            this.timestamp = 0;\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        }\n        return value;\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\n     * custom timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrAbortCore(unixTsMs, rollbackAllowance) {\n        const MAX_COUNTER = 4398046511103;\n        if (!Number.isInteger(unixTsMs) ||\n            unixTsMs < 1 ||\n            unixTsMs > 281474976710655) {\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\n        }\n        else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\n        }\n        if (unixTsMs > this.timestamp) {\n            this.timestamp = unixTsMs;\n            this.resetCounter();\n        }\n        else if (unixTsMs + rollbackAllowance >= this.timestamp) {\n            // go on with previous timestamp if new one is not much smaller\n            this.counter++;\n            if (this.counter > MAX_COUNTER) {\n                // increment timestamp at counter overflow\n                this.timestamp++;\n                this.resetCounter();\n            }\n        }\n        else {\n            // abort if clock went backwards to unbearable extent\n            return undefined;\n        }\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & (2 ** 30 - 1), this.random.nextUint32());\n    }\n    /** Initializes the counter at a 42-bit random integer. */\n    resetCounter() {\n        this.counter =\n            this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\n    }\n    /**\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\n     *\n     * @internal\n     */\n    generateV4() {\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\n        bytes[6] = 0x40 | (bytes[6] >>> 4);\n        bytes[8] = 0x80 | (bytes[8] >>> 2);\n        return UUID.ofInner(bytes);\n    }\n}\n/** Returns the default random number generator available in the environment. */\nconst getDefaultRandom = () => {\n    // detect Web Crypto API\n    if (typeof crypto !== \"undefined\" &&\n        typeof crypto.getRandomValues !== \"undefined\") {\n        return new BufferedCryptoRandom();\n    }\n    else {\n        // fall back on Math.random() unless the flag is set to true\n        if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\n            throw new Error(\"no cryptographically strong RNG available\");\n        }\n        return {\n            nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 +\n                Math.trunc(Math.random() * 65536),\n        };\n    }\n};\n/**\n * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\n * buffer by default to avoid both unbearable throughput decline in some\n * environments and the waste of time and space for unused values.\n */\nclass BufferedCryptoRandom {\n    constructor() {\n        this.buffer = new Uint32Array(8);\n        this.cursor = 0xffff;\n    }\n    nextUint32() {\n        if (this.cursor >= this.buffer.length) {\n            crypto.getRandomValues(this.buffer);\n            this.cursor = 0;\n        }\n        return this.buffer[this.cursor++];\n    }\n}\nlet defaultGenerator;\n/**\n * Generates a UUIDv7 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nexport const uuidv7 = () => uuidv7obj().toString();\n/** Generates a UUIDv7 object. */\nexport const uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();\n/**\n * Generates a UUIDv4 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nexport const uuidv4 = () => uuidv4obj().toString();\n/** Generates a UUIDv4 object. */\nexport const uuidv4obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generateV4();\n","import { DocTypes, MetaType, DocUpdate } from \"./types.js\";\n\ntype WorkerFunction<T extends DocTypes> = (tasks: DocUpdate<T>[]) => Promise<MetaType>;\n\nexport interface WriteQueue<T extends DocTypes> {\n  push(task: DocUpdate<T>): Promise<MetaType>;\n}\n\ninterface WriteQueueItem<T extends DocTypes> {\n  readonly task: DocUpdate<T>;\n  resolve(result: MetaType): void;\n  reject(error: Error): void;\n}\n\nexport function writeQueue<T extends DocTypes>(worker: WorkerFunction<T>, payload = Infinity, unbounded = false): WriteQueue<T> {\n  const queue: WriteQueueItem<T>[] = [];\n  let isProcessing = false;\n\n  async function process() {\n    if (isProcessing || queue.length === 0) return;\n    isProcessing = true;\n\n    const tasksToProcess = queue.splice(0, payload);\n    const updates = tasksToProcess.map((item) => item.task);\n\n    if (unbounded) {\n      // Run all updates in parallel and resolve/reject them individually\n      const promises = updates.map(async (update, index) => {\n        try {\n          const result = await worker([update]);\n          tasksToProcess[index].resolve(result);\n        } catch (error) {\n          tasksToProcess[index].reject(error as Error);\n        }\n      });\n\n      await Promise.all(promises);\n    } else {\n      // Original logic: Run updates in a batch and resolve/reject them together\n      try {\n        const result = await worker(updates);\n        tasksToProcess.forEach((task) => task.resolve(result));\n      } catch (error) {\n        tasksToProcess.forEach((task) => task.reject(error as Error));\n      }\n    }\n\n    isProcessing = false;\n    void process();\n  }\n\n  return {\n    push(task: DocUpdate<T>): Promise<MetaType> {\n      return new Promise<MetaType>((resolve, reject) => {\n        queue.push({ task, resolve, reject });\n        void process();\n      });\n    },\n  };\n}\n","import { Block } from \"multiformats\";\nimport { Logger, ResolveOnce } from \"@adviser/cement\";\n\nimport {\n  EncryptedBlockstore,\n  type TransactionMeta,\n  type CarTransaction,\n  BaseBlockstore,\n  CompactFetcher,\n} from \"./blockstore/index.js\";\nimport {\n  clockChangesSince,\n  applyBulkUpdateToCrdt,\n  getValueFromCrdt,\n  readFiles,\n  getAllEntries,\n  clockVis,\n  getBlock,\n  doCompact,\n} from \"./crdt-helpers.js\";\nimport type {\n  DocUpdate,\n  CRDTMeta,\n  ClockHead,\n  ConfigOpts,\n  ChangesOptions,\n  IdxMetaMap,\n  DocValue,\n  IndexKeyType,\n  DocWithId,\n  DocTypes,\n  Falsy,\n  SuperThis,\n} from \"./types.js\";\nimport { index, type Index } from \"./indexer.js\";\nimport { CRDTClock } from \"./crdt-clock.js\";\nimport { blockstoreFactory } from \"./blockstore/transaction.js\";\nimport { ensureLogger } from \"./utils.js\";\n\nexport class CRDT<T extends DocTypes> {\n  readonly name?: string;\n  readonly opts: ConfigOpts;\n\n  readonly blockstore: BaseBlockstore;\n  readonly indexBlockstore: BaseBlockstore;\n  readonly indexers: Map<string, Index<IndexKeyType, NonNullable<unknown>>> = new Map<\n    string,\n    Index<IndexKeyType, NonNullable<unknown>>\n  >();\n  readonly clock: CRDTClock<T>;\n\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n\n  constructor(sthis: SuperThis, name?: string, opts: ConfigOpts = {}) {\n    this.sthis = sthis;\n    this.name = name;\n    this.logger = ensureLogger(sthis, \"CRDT\");\n    this.opts = opts;\n    this.blockstore = blockstoreFactory(sthis, {\n      name: name,\n      applyMeta: async (meta: TransactionMeta) => {\n        const crdtMeta = meta as CRDTMeta;\n        if (!crdtMeta.head) throw this.logger.Error().Msg(\"missing head\").AsError();\n        await this.clock.applyHead(crdtMeta.head, []);\n      },\n      compact: async (blocks: CompactFetcher) => {\n        await doCompact(blocks, this.clock.head, this.logger);\n        return { head: this.clock.head } as TransactionMeta;\n      },\n      autoCompact: this.opts.autoCompact || 100,\n      store: { ...this.opts.store, isIndex: undefined },\n      public: this.opts.public,\n      meta: this.opts.meta,\n      threshold: this.opts.threshold,\n    });\n    this.indexBlockstore = blockstoreFactory(sthis, {\n      name: name,\n      applyMeta: async (meta: TransactionMeta) => {\n        const idxCarMeta = meta as IdxMetaMap;\n        if (!idxCarMeta.indexes) throw this.logger.Error().Msg(\"missing indexes\").AsError();\n        for (const [name, idx] of Object.entries(idxCarMeta.indexes)) {\n          index(this.sthis, { _crdt: this }, name, undefined, idx);\n        }\n      },\n      store: { ...this.opts.store, isIndex: this.opts.store?.isIndex || \"idx\" },\n      public: this.opts.public,\n    });\n    this.clock = new CRDTClock<T>(this.blockstore);\n    this.clock.onZoom(() => {\n      for (const idx of this.indexers.values()) {\n        idx._resetIndex();\n      }\n    });\n  }\n\n  async bulk(updates: DocUpdate<T>[]): Promise<CRDTMeta> {\n    await this.ready();\n    const prevHead = [...this.clock.head];\n\n    const done = await this.blockstore.transaction<CRDTMeta>(async (blocks: CarTransaction): Promise<CRDTMeta> => {\n      const { head } = await applyBulkUpdateToCrdt<T>(\n        this.blockstore.ebOpts.storeRuntime,\n        blocks,\n        this.clock.head,\n        updates,\n        this.logger,\n      );\n      updates = updates.map((dupdate: DocUpdate<T>) => {\n        // if (!dupdate.value) throw new Error(\"missing value\");\n        readFiles(this.blockstore, { doc: dupdate.value as DocWithId<T> });\n        return dupdate;\n      });\n      return { head };\n    });\n    await this.clock.applyHead(done.meta.head, prevHead, updates);\n    return done.meta;\n  }\n\n  readonly onceReady: ResolveOnce<void> = new ResolveOnce<void>();\n  async ready(): Promise<void> {\n    return this.onceReady.once(async () => {\n      try {\n        // await this.blockstore.ready();\n        // await this.indexBlockstore.ready();\n        // await this.clock.ready();\n        await Promise.all([this.blockstore.ready(), this.indexBlockstore.ready(), this.clock.ready()]);\n      } catch (e) {\n        const ee = e as Error;\n        throw this.logger.Error().Err(e).Msg(`CRDT is not ready: ${ee.stack}`).AsError();\n      }\n    });\n  }\n\n  async close(): Promise<void> {\n    await Promise.all([this.blockstore.close(), this.indexBlockstore.close(), this.clock.close()]);\n  }\n\n  async destroy(): Promise<void> {\n    await Promise.all([this.blockstore.destroy(), this.indexBlockstore.destroy()]);\n  }\n\n  // if (snap) await this.clock.applyHead(crdtMeta.head, this.clock.head)\n\n  async allDocs(): Promise<{ result: DocUpdate<T>[]; head: ClockHead }> {\n    await this.ready();\n    const result: DocUpdate<T>[] = [];\n    for await (const entry of getAllEntries<T>(this.blockstore, this.clock.head, this.logger)) {\n      result.push(entry);\n    }\n    return { result, head: this.clock.head };\n  }\n\n  async vis(): Promise<string> {\n    await this.ready();\n    const txt: string[] = [];\n    for await (const line of clockVis(this.blockstore, this.clock.head)) {\n      txt.push(line);\n    }\n    return txt.join(\"\\n\");\n  }\n\n  async getBlock(cidString: string): Promise<Block> {\n    await this.ready();\n    return await getBlock(this.blockstore, cidString);\n  }\n\n  async get(key: string): Promise<DocValue<T> | Falsy> {\n    await this.ready();\n    const result = await getValueFromCrdt<T>(this.blockstore, this.clock.head, key, this.logger);\n    if (result.del) return undefined;\n    return result;\n  }\n\n  async changes(\n    since: ClockHead = [],\n    opts: ChangesOptions = {},\n  ): Promise<{\n    result: DocUpdate<T>[];\n    head: ClockHead;\n  }> {\n    await this.ready();\n    return await clockChangesSince<T>(this.blockstore, this.clock.head, since, opts, this.logger);\n  }\n\n  async compact(): Promise<void> {\n    const blocks = this.blockstore as EncryptedBlockstore;\n    return await blocks.compact();\n  }\n}\n","// this enable async codec\n// it should be gone if this in multiformats is merged:\n// https://github.com/multiformats/js-multiformats/pull/305\nimport { bytes as binary, CID, MultihashHasher, BlockView, ByteView, Version, Link } from \"multiformats\";\nimport { Block as mfBlock } from \"multiformats/block\";\nimport { BlockDecoder, BlockEncoder } from \"./codec-interface\";\n\n// export type Block<T, C extends number, A extends number, V extends Version> = mfBlock<T, C, A, V>\n\nexport const Block = mfBlock;\n\ninterface DecodeInput<T, Code extends number, Alg extends number> {\n  bytes: ByteView<T>;\n  codec: BlockDecoder<Code, T>;\n  hasher: MultihashHasher<Alg>;\n}\n\nexport async function decode<T, Code extends number, Alg extends number>({\n  bytes,\n  codec,\n  hasher,\n}: DecodeInput<T, Code, Alg>): Promise<BlockView<T, Code, Alg>> {\n  if (bytes == null) throw new Error('Missing required argument \"bytes\"');\n  if (codec == null || hasher == null) throw new Error(\"Missing required argument: codec or hasher\");\n\n  const value = await Promise.resolve(codec.decode(bytes));\n  const hash = await hasher.digest(bytes);\n  const cid = CID.create(1, codec.code, hash) as CID<T, Code, Alg, 1>;\n\n  return new mfBlock({ value, bytes, cid });\n}\n\ninterface EncodeInput<T, Code extends number, Alg extends number> {\n  value: T;\n  codec: BlockEncoder<Code, T>;\n  hasher: MultihashHasher<Alg>;\n}\n\nexport async function encode<T, Code extends number, Alg extends number>({\n  value,\n  codec,\n  hasher,\n}: EncodeInput<T, Code, Alg>): Promise<BlockView<T, Code, Alg>> {\n  if (typeof value === \"undefined\") throw new Error('Missing required argument \"value\"');\n  if (codec == null || hasher == null) throw new Error(\"Missing required argument: codec or hasher\");\n\n  const bytes = await Promise.resolve(codec.encode(value));\n  const hash = await hasher.digest(bytes);\n  const cid = CID.create(1, codec.code, hash) as CID<T, Code, Alg, 1>;\n\n  return new mfBlock({ value, bytes, cid });\n}\n\ninterface CreateInput<T, Code extends number, Alg extends number, V extends Version> {\n  bytes: ByteView<T>;\n  cid: Link<T, Code, Alg, V>;\n  hasher: MultihashHasher<Alg>;\n  codec: BlockDecoder<Code, T>;\n}\n\nexport async function create<T, Code extends number, Alg extends number, V extends Version>({\n  bytes,\n  cid,\n  hasher,\n  codec,\n}: CreateInput<T, Code, Alg, V>): Promise<BlockView<T, Code, Alg, V>> {\n  if (bytes == null) throw new Error('Missing required argument \"bytes\"');\n  if (hasher == null) throw new Error('Missing required argument \"hasher\"');\n  const value = await Promise.resolve(codec.decode(bytes));\n  const hash = await hasher.digest(bytes);\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error(\"CID hash does not match bytes\");\n  }\n\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec,\n  });\n}\n\ntype CreateUnsafeInput<T, Code extends number, Alg extends number, V extends Version> =\n  | {\n      cid: Link<T, Code, Alg, V>;\n      value: T;\n      codec?: BlockDecoder<Code, T>;\n      bytes: ByteView<T>;\n    }\n  | {\n      cid: Link<T, Code, Alg, V>;\n      value?: undefined;\n      codec: BlockDecoder<Code, T>;\n      bytes: ByteView<T>;\n    };\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template Code - multicodec code corresponding to codec used to encode the block\n * @template Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template V - CID version\n */\nexport async function createUnsafe<T, Code extends number, Alg extends number, V extends Version>({\n  bytes,\n  cid,\n  value: maybeValue,\n  codec,\n}: CreateUnsafeInput<T, Code, Alg, V>): Promise<BlockView<T, Code, Alg, V>> {\n  const value = await Promise.resolve(maybeValue !== undefined ? maybeValue : codec?.decode(bytes));\n\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"');\n\n  return new Block({\n    cid: cid as CID<T, Code, Alg, V>,\n    bytes,\n    value,\n  });\n}\n","/**\n * @packageDocumentation\n *\n * This library defines common interfaces and low level building blocks for various interrelated multiformat technologies (multicodec, multihash, multibase, and CID). They can be used to implement custom base encoders / decoders / codecs, codec encoders /decoders and multihash hashers that comply to the interface that layers above assume.\n *\n * This library provides implementations for most basics and many others can be found in linked repositories.\n *\n * ```TypeScript\n * import { CID } from 'multiformats/cid'\n * import * as json from 'multiformats/codecs/json'\n * import { sha256 } from 'multiformats/hashes/sha2'\n *\n * const bytes = json.encode({ hello: 'world' })\n *\n * const hash = await sha256.digest(bytes)\n * const cid = CID.create(1, json.code, hash)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * ## Creating Blocks\n *\n * ```TypeScript\n * import * as Block from 'multiformats/block'\n * import * as codec from '@ipld/dag-cbor'\n * import { sha256 as hasher } from 'multiformats/hashes/sha2'\n *\n * const value = { hello: 'world' }\n *\n * // encode a block\n * let block = await Block.encode({ value, codec, hasher })\n *\n * block.value // { hello: 'world' }\n * block.bytes // Uint8Array\n * block.cid   // CID() w/ sha2-256 hash address and dag-cbor codec\n *\n * // you can also decode blocks from their binary state\n * block = await Block.decode({ bytes: block.bytes, codec, hasher })\n *\n * // if you have the cid you can also verify the hash on decode\n * block = await Block.create({ bytes: block.bytes, cid: block.cid, codec, hasher })\n * ```\n *\n * ## Multibase Encoders / Decoders / Codecs\n *\n * CIDs can be serialized to string representation using multibase encoders that implement [`MultibaseEncoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides quite a few implementations that can be imported:\n *\n * ```TypeScript\n * import { base64 } from \"multiformats/bases/base64\"\n * cid.toString(base64.encoder)\n * //> 'mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA'\n * ```\n *\n * Parsing CID string serialized CIDs requires multibase decoder that implements [`MultibaseDecoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides a decoder for every encoder it provides:\n *\n * ```TypeScript\n * CID.parse('mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA', base64.decoder)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * Dual of multibase encoder & decoder is defined as multibase codec and it exposes\n * them as `encoder` and `decoder` properties. For added convenience codecs also\n * implement `MultibaseEncoder` and `MultibaseDecoder` interfaces so they could be\n * used as either or both:\n *\n * ```TypeScript\n * cid.toString(base64)\n * CID.parse(cid.toString(base64), base64)\n * ```\n *\n * **Note:** CID implementation comes bundled with `base32` and `base58btc`\n * multibase codecs so that CIDs can be base serialized to (version specific)\n * default base encoding and parsed without having to supply base encoders/decoders:\n *\n * ```TypeScript\n * const v1 = CID.parse('bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea')\n * v1.toString()\n * //> 'bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea'\n *\n * const v0 = CID.parse('QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n')\n * v0.toString()\n * //> 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'\n * v0.toV1().toString()\n * //> 'bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku'\n * ```\n *\n * ## Multicodec Encoders / Decoders / Codecs\n *\n * This library defines [`BlockEncoder`, `BlockDecoder` and `BlockCodec` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts).\n * Codec implementations should conform to the `BlockCodec` interface which implements both `BlockEncoder` and `BlockDecoder`.\n * Here is an example implementation of JSON `BlockCodec`.\n *\n * ```TypeScript\n * export const { name, code, encode, decode } = {\n *   name: 'json',\n *   code: 0x0200,\n *   encode: json => new TextEncoder().encode(JSON.stringify(json)),\n *   decode: bytes => JSON.parse(new TextDecoder().decode(bytes))\n * }\n * ```\n *\n * ## Multihash Hashers\n *\n * This library defines [`MultihashHasher` and `MultihashDigest` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/hashes/interface.ts) and convinient function for implementing them:\n *\n * ```TypeScript\n * import * as hasher from 'multiformats/hashes/hasher'\n *\n * const sha256 = hasher.from({\n *   // As per multiformats table\n *   // https://github.com/multiformats/multicodec/blob/master/table.csv#L9\n *   name: 'sha2-256',\n *   code: 0x12,\n *\n *   encode: (input) => new Uint8Array(crypto.createHash('sha256').update(input).digest())\n * })\n *\n * const hash = await sha256.digest(json.encode({ hello: 'world' }))\n * CID.create(1, json.code, hash)\n *\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * ## Traversal\n *\n * This library contains higher-order functions for traversing graphs of data easily.\n *\n * `walk()` walks through the links in each block of a DAG calling a user-supplied loader function for each one, in depth-first order with no duplicate block visits. The loader should return a `Block` object and can be used to inspect and collect block ordering for a full DAG walk. The loader should `throw` on error, and return `null` if a block should be skipped by `walk()`.\n *\n * ```TypeScript\n * import { walk } from 'multiformats/traversal'\n * import * as Block from 'multiformats/block'\n * import * as codec from 'multiformats/codecs/json'\n * import { sha256 as hasher } from 'multiformats/hashes/sha2'\n *\n * // build a DAG (a single block for this simple example)\n * const value = { hello: 'world' }\n * const block = await Block.encode({ value, codec, hasher })\n * const { cid } = block\n * console.log(cid)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n *\n * // create a loader function that also collects CIDs of blocks in\n * // their traversal order\n * const load = (cid, blocks) => async (cid) => {\n *   // fetch a block using its cid\n *   // e.g.: const block = await fetchBlockByCID(cid)\n *   blocks.push(cid)\n *   return block\n * }\n *\n * // collect blocks in this DAG starting from the root `cid`\n * const blocks = []\n * await walk({ cid, load: load(cid, blocks) })\n *\n * console.log(blocks)\n * //> [CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)]\n * ```\n *\n * ## Legacy interface\n *\n * [`blockcodec-to-ipld-format`](https://github.com/ipld/js-blockcodec-to-ipld-format) converts a multiformats [`BlockCodec`](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts#L21) into an\n * [`interface-ipld-format`](https://github.com/ipld/interface-ipld-format) for use with the [`ipld`](https://github.com/ipld/ipld) package. This can help bridge IPLD codecs implemented using the structure and interfaces defined here to existing code that assumes, or requires `interface-ipld-format`. This bridge also includes the relevant TypeScript definitions.\n *\n * ## Implementations\n *\n * By default, no base encodings (other than base32 & base58btc), hash functions,\n * or codec implementations are exposed by `multiformats`, you need to\n * import the ones you need yourself.\n *\n * ### Multibase codecs\n *\n * | bases                                                         | import                      | repo                                                                                              |\n * | ------------------------------------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------- |\n * | `base16`                                                      | `multiformats/bases/base16` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base32`, `base32pad`, `base32hex`, `base32hexpad`, `base32z` | `multiformats/bases/base32` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base64`, `base64pad`, `base64url`, `base64urlpad`            | `multiformats/bases/base64` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base58btc`, `base58flick4`                                   | `multiformats/bases/base58` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n *\n * Other (less useful) bases implemented in [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) include: `base2`, `base8`, `base10`, `base36` and `base256emoji`.\n *\n * ### Multihash hashers\n *\n * | hashes                                                                                                                          | import                         | repo                                                                                                               |\n * | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------ |\n * | `sha2-256`, `sha2-512`                                                                                                          | `multiformats/hashes/sha2`     | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes)             |\n * | `sha3-224`, `sha3-256`, `sha3-384`,`sha3-512`, `shake-128`, `shake-256`, `keccak-224`, `keccak-256`, `keccak-384`, `keccak-512` | `@multiformats/sha3`           | [multiformats/js-sha3](https://github.com/multiformats/js-sha3)                                                    |\n * | `identity`                                                                                                                      | `multiformats/hashes/identity` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes/identity.js) |\n * | `murmur3-128`, `murmur3-32`                                                                                                     | `@multiformats/murmur3`        | [multiformats/js-murmur3](https://github.com/multiformats/js-murmur3)                                              |\n * | `blake2b-*`, `blake2s-*`                                                                                                        | `@multiformats/blake2`         | [multiformats/js-blake2](https://github.com/multiformats/js-blake2)                                                |\n *\n * ### IPLD codecs (multicodec)\n *\n * | codec      | import                     | repo                                                                                                   |\n * | ---------- | -------------------------- | ------------------------------------------------------------------------------------------------------ |\n * | `raw`      | `multiformats/codecs/raw`  | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |\n * | `json`     | `multiformats/codecs/json` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |\n * | `dag-cbor` | `@ipld/dag-cbor`           | [ipld/js-dag-cbor](https://github.com/ipld/js-dag-cbor)                                                |\n * | `dag-json` | `@ipld/dag-json`           | [ipld/js-dag-json](https://github.com/ipld/js-dag-json)                                                |\n * | `dag-pb`   | `@ipld/dag-pb`             | [ipld/js-dag-pb](https://github.com/ipld/js-dag-pb)                                                    |\n * | `dag-jose` | `dag-jose`                 | [ceramicnetwork/js-dag-jose](https://github.com/ceramicnetwork/js-dag-jose)                            |\n */\n\nimport * as bytes from './bytes.js'\nimport { CID } from './cid.js'\nimport * as digest from './hashes/digest.js'\nimport * as hasher from './hashes/hasher.js'\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './interface.js'\n\nexport { CID, hasher, digest, varint, bytes }\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n","import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n","/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n","import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode }: { name: Name, code: Code, encode(input: Uint8Array): Await<Uint8Array> }): Hasher<Name, Code> {\n  return new Hasher(name, code, encode)\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  digest (input: Uint8Array): Await<Digest.Digest<Code, number>> {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n","import { bytes as binary, CID } from './index.js'\nimport type * as API from './interface.js'\n\nfunction readonly ({ enumerable = true, configurable = false } = {}): { enumerable: boolean, configurable: boolean, writable: false } {\n  return { enumerable, configurable, writable: false }\n}\n\nfunction * linksWithin (path: [string | number, string], value: any): Iterable<[string, CID]> {\n  if (value != null && typeof value === 'object') {\n    if (Array.isArray(value)) {\n      for (const [index, element] of value.entries()) {\n        const elementPath = [...path, index]\n        const cid = CID.asCID(element)\n        if (cid != null) {\n          yield [elementPath.join('/'), cid]\n        } else if (typeof element === 'object') {\n          yield * links(element, elementPath)\n        }\n      }\n    } else {\n      const cid = CID.asCID(value)\n      if (cid != null) {\n        yield [path.join('/'), cid]\n      } else {\n        yield * links(value, path)\n      }\n    }\n  }\n}\n\nfunction * links <T> (source: T, base: Array<string | number>): Iterable<[string, CID]> {\n  if (source == null || source instanceof Uint8Array) {\n    return\n  }\n  const cid = CID.asCID(source)\n  if (cid != null) {\n    yield [base.join('/'), cid]\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key] as [string | number, string]\n    yield * linksWithin(path, value)\n  }\n}\n\nfunction * treeWithin (path: [string | number, string], value: any): Iterable<string> {\n  if (Array.isArray(value)) {\n    for (const [index, element] of value.entries()) {\n      const elementPath = [...path, index]\n      yield elementPath.join('/')\n      if (typeof element === 'object' && (CID.asCID(element) == null)) {\n        yield * tree(element, elementPath)\n      }\n    }\n  } else {\n    yield * tree(value, path)\n  }\n}\n\nfunction * tree <T> (source: T, base: Array<string | number>): Iterable<string> {\n  if (source == null || typeof source !== 'object') {\n    return\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key] as [string | number, string]\n    yield path.join('/')\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && (CID.asCID(value) == null)) {\n      yield * treeWithin(path, value)\n    }\n  }\n}\n\nfunction get <T> (source: T, path: string[]): API.BlockCursorView<unknown> {\n  let node = source as Record<string, any>\n  for (const [index, key] of path.entries()) {\n    node = node[key]\n    if (node == null) {\n      throw new Error(`Object has no property at ${path.slice(0, index + 1).map(part => `[${JSON.stringify(part)}]`).join('')}`)\n    }\n    const cid = CID.asCID(node)\n    if (cid != null) {\n      return { value: cid, remaining: path.slice(index + 1).join('/') }\n    }\n  }\n  return { value: node }\n}\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template C - multicodec code corresponding to codec used to encode the block\n * @template A - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template V - CID version\n */\nexport class Block<T, C extends number, A extends number, V extends API.Version> implements API.BlockView<T, C, A, V> {\n  readonly cid: CID<T, C, A, V>\n  readonly bytes: API.ByteView<T>\n  readonly value: T\n  readonly asBlock: this\n\n  constructor ({ cid, bytes, value }: { cid: CID<T, C, A, V>, bytes: API.ByteView<T>, value: T }) {\n    if (cid == null || bytes == null || typeof value === 'undefined') { throw new Error('Missing required argument') }\n\n    this.cid = cid\n    this.bytes = bytes\n    this.value = value\n    this.asBlock = this\n\n    // Mark all the properties immutable\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    })\n  }\n\n  links (): Iterable<[string, CID<unknown, number, number, API.Version>]> {\n    return links(this.value, [])\n  }\n\n  tree (): Iterable<string> {\n    return tree(this.value, [])\n  }\n\n  get (path = '/'): API.BlockCursorView<unknown> {\n    return get(this.value, path.split('/').filter(Boolean))\n  }\n}\n\ninterface EncodeInput <T, Code extends number, Alg extends number> {\n  value: T\n  codec: API.BlockEncoder<Code, T>\n  hasher: API.MultihashHasher<Alg>\n}\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template Code - multicodec code corresponding to codec used to encode the block\n * @template Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n */\nexport async function encode <T, Code extends number, Alg extends number> ({ value, codec, hasher }: EncodeInput<T, Code, Alg>): Promise<API.BlockView<T, Code, Alg>> {\n  if (typeof value === 'undefined') throw new Error('Missing required argument \"value\"')\n  if (codec == null || hasher == null) throw new Error('Missing required argument: codec or hasher')\n\n  const bytes = codec.encode(value)\n  const hash = await hasher.digest(bytes)\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  const cid = CID.create(\n    1,\n    codec.code,\n    hash\n  ) as CID<T, Code, Alg, 1>\n\n  return new Block({ value, bytes, cid })\n}\n\ninterface DecodeInput <T, Code extends number, Alg extends number> {\n  bytes: API.ByteView<T>\n  codec: API.BlockDecoder<Code, T>\n  hasher: API.MultihashHasher<Alg>\n}\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template Code - multicodec code corresponding to codec used to encode the block\n * @template Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n */\nexport async function decode <T, Code extends number, Alg extends number> ({ bytes, codec, hasher }: DecodeInput<T, Code, Alg>): Promise<API.BlockView<T, Code, Alg>> {\n  if (bytes == null) throw new Error('Missing required argument \"bytes\"')\n  if (codec == null || hasher == null) throw new Error('Missing required argument: codec or hasher')\n\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  const cid = CID.create(1, codec.code, hash) as CID<T, Code, Alg, 1>\n\n  return new Block({ value, bytes, cid })\n}\n\ntype CreateUnsafeInput <T, Code extends number, Alg extends number, V extends API.Version> = {\n  cid: API.Link<T, Code, Alg, V>\n  value: T\n  codec?: API.BlockDecoder<Code, T>\n  bytes: API.ByteView<T>\n} | {\n  cid: API.Link<T, Code, Alg, V>\n  value?: undefined\n  codec: API.BlockDecoder<Code, T>\n  bytes: API.ByteView<T>\n}\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template Code - multicodec code corresponding to codec used to encode the block\n * @template Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template V - CID version\n */\nexport function createUnsafe <T, Code extends number, Alg extends number, V extends API.Version> ({ bytes, cid, value: maybeValue, codec }: CreateUnsafeInput<T, Code, Alg, V>): API.BlockView<T, Code, Alg, V> {\n  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n  const value = maybeValue !== undefined\n    ? maybeValue\n    : (codec?.decode(bytes))\n\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"')\n\n  return new Block({\n    cid: cid as CID<T, Code, Alg, V>,\n    bytes,\n    value\n  })\n}\n\ninterface CreateInput <T, Code extends number, Alg extends number, V extends API.Version> {\n  bytes: API.ByteView<T>\n  cid: API.Link<T, Code, Alg, V>\n  hasher: API.MultihashHasher<Alg>\n  codec: API.BlockDecoder<Code, T>\n}\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template Code - multicodec code corresponding to codec used to encode the block\n * @template Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template V - CID version\n */\nexport async function create <T, Code extends number, Alg extends number, V extends API.Version> ({ bytes, cid, hasher, codec }: CreateInput<T, Code, Alg, V>): Promise<API.BlockView<T, Code, Alg, V>> {\n  if (bytes == null) throw new Error('Missing required argument \"bytes\"')\n  if (hasher == null) throw new Error('Missing required argument \"hasher\"')\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes')\n  }\n\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  })\n}\n","import { CID, format, toJSON, fromJSON } from './cid.js'\nimport type * as API from './link/interface.js'\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nconst DAG_PB_CODE = 0x70\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12\n\n/**\n * Simplified version of `create` for CIDv0.\n */\nexport function createLegacy (digest: API.MultihashDigest<typeof SHA_256_CODE>): API.LegacyLink {\n  return CID.create(0, DAG_PB_CODE, digest)\n}\n\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @param code - Content encoding format code.\n * @param digest - Miltihash of the content.\n */\nexport function create <Data, Code extends number, Alg extends number> (code: Code, digest: API.MultihashDigest<Alg>): API.Link<Data, Code, Alg> {\n  return CID.create(1, code, digest)\n}\n\n/**\n * Type predicate returns true if value is the link.\n */\nexport function isLink <L extends API.Link<unknown, number, number, 0 | 1>> (value: unknown | L): value is L & CID {\n  if (value == null) {\n    return false\n  }\n\n  const withSlash = value as { '/'?: Uint8Array, bytes: Uint8Array }\n\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true\n  }\n\n  const withAsCID = value as { 'asCID'?: unknown }\n\n  if (withAsCID.asCID === value) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n */\nexport function parse <Prefix extends string, Data, Code extends number, Alg extends number, Ver extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>, base?: API.MultibaseDecoder<Prefix>): API.Link<Data, Code, Alg, Ver> {\n  return CID.parse(source, base)\n}\n\nexport { format, toJSON, fromJSON }\n\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n */\nexport function decode <Data, Code extends number, Alg extends number, Ver extends API.Version> (bytes: API.ByteView<API.Link<Data, Code, Alg, Ver>>): API.Link<Data, Code, Alg, Ver> {\n  return CID.decode(bytes)\n}\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst _encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\nexport const encodeOptions = {\n  ..._encodeOptions,\n  typeEncoders: {\n    ..._encodeOptions.typeEncoders\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst _decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const decodeOptions = {\n  ..._decodeOptions,\n  tags: _decodeOptions.tags.slice()\n}\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, _encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(toByteView(data), _decodeOptions)\n","// This is an unfortunate replacement for @sindresorhus/is that we need to\n// re-implement for performance purposes. In particular the is.observable()\n// check is expensive, and unnecessary for our purposes. The values returned\n// are compatible with @sindresorhus/is, however.\n\nconst typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n]\n\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n]\n\n/**\n * @param {any} value\n * @returns {string}\n */\nexport function is (value) {\n  if (value === null) {\n    return 'null'\n  }\n  if (value === undefined) {\n    return 'undefined'\n  }\n  if (value === true || value === false) {\n    return 'boolean'\n  }\n  const typeOf = typeof value\n  if (typeofs.includes(typeOf)) {\n    return typeOf\n  }\n  /* c8 ignore next 4 */\n  // not going to bother testing this, it's not going to be valid anyway\n  if (typeOf === 'function') {\n    return 'Function'\n  }\n  if (Array.isArray(value)) {\n    return 'Array'\n  }\n  if (isBuffer(value)) {\n    return 'Buffer'\n  }\n  const objectType = getObjectType(value)\n  if (objectType) {\n    return objectType\n  }\n  /* c8 ignore next */\n  return 'Object'\n}\n\n/**\n * @param {any} value\n * @returns {boolean}\n */\nfunction isBuffer (value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value)\n}\n\n/**\n * @param {any} value\n * @returns {string|undefined}\n */\nfunction getObjectType (value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1)\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName\n  }\n  /* c8 ignore next */\n  return undefined\n}\n","class Type {\n  /**\n   * @param {number} major\n   * @param {string} name\n   * @param {boolean} terminal\n   */\n  constructor (major, name, terminal) {\n    this.major = major\n    this.majorEncoded = major << 5\n    this.name = name\n    this.terminal = terminal\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Type[${this.major}].${this.name}`\n  }\n\n  /**\n   * @param {Type} typ\n   * @returns {number}\n   */\n  compare (typ) {\n    /* c8 ignore next 1 */\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0\n  }\n}\n\n// convert to static fields when better supported\nType.uint = new Type(0, 'uint', true)\nType.negint = new Type(1, 'negint', true)\nType.bytes = new Type(2, 'bytes', true)\nType.string = new Type(3, 'string', true)\nType.array = new Type(4, 'array', false)\nType.map = new Type(5, 'map', false)\nType.tag = new Type(6, 'tag', false) // terminal?\nType.float = new Type(7, 'float', true)\nType.false = new Type(7, 'false', true)\nType.true = new Type(7, 'true', true)\nType.null = new Type(7, 'null', true)\nType.undefined = new Type(7, 'undefined', true)\nType.break = new Type(7, 'break', true)\n// Type.indefiniteLength = new Type(0, 'indefiniteLength', true)\n\nclass Token {\n  /**\n   * @param {Type} type\n   * @param {any} [value]\n   * @param {number} [encodedLength]\n   */\n  constructor (type, value, encodedLength) {\n    this.type = type\n    this.value = value\n    this.encodedLength = encodedLength\n    /** @type {Uint8Array|undefined} */\n    this.encodedBytes = undefined\n    /** @type {Uint8Array|undefined} */\n    this.byteValue = undefined\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Token[${this.type}].${this.value}`\n  }\n}\n\nexport { Type, Token }\n","// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n","/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js'\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n","const decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n}\n","/* globals BigInt */\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix, assertEnoughData } from './common.js'\n\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8 (data, offset, options) {\n  assertEnoughData(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16 (data, offset, options) {\n  assertEnoughData(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32 (data, offset, options) {\n  assertEnoughData(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n","/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64 (data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n","import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { compare, fromString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length)\n  const buf = slice(data, pos + prefix, pos + prefix + length)\n  return new Token(Type.bytes, buf, prefix + length)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeBytesCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * `encodedBytes` allows for caching when we do a byte version of a string\n * for key sorting purposes\n * @param {Token} token\n * @returns {Uint8Array}\n */\nfunction tokenBytes (token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value\n  }\n  // @ts-ignore c'mon\n  return token.encodedBytes\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeBytes (buf, token) {\n  const bytes = tokenBytes(token)\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length)\n  buf.push(bytes)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeBytes.encodedSize = function encodedSize (token) {\n  const bytes = tokenBytes(token)\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeBytes.compareTokens = function compareTokens (tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2))\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compareBytes (b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2)\n}\n","import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { toString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length, options) {\n  const totLength = prefix + length\n  assertEnoughData(data, pos, totLength)\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength)\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength)\n  }\n  return tok\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeStringCompact (data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options)\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`)\n  }\n  return toToken(data, pos, 9, l, options)\n}\n\nexport const encodeString = encodeBytes\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray (buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeMapCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMapIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeMap (buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value)\n}\n\n// using a map as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeMap.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeMap.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeTagCompact (_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag8 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag16 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag32 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag64 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeTag (buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value)\n}\n\nencodeTag.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeTag.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n","// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix } from './common.js'\nimport { encodeUint } from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1)\n  }\n  return new Token(Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new Token(Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new Token(Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n","import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n","import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n","import { Block, encode, decode } from 'multiformats/block'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as cbor from '@ipld/dag-cbor'\n// eslint-disable-next-line no-unused-vars\nimport * as API from './api.js'\n\n/**\n * Advance the clock by adding an event.\n *\n * @template T\n * @param {API.BlockFetcher} blocks Block storage.\n * @param {API.EventLink<T>[]} head The head of the clock.\n * @param {API.EventLink<T>} event The event to add.\n */\nexport const advance = async (blocks, head, event) => {\n  const events = new EventFetcher(blocks)\n  const headmap = new Map(head.map(cid => [cid.toString(), cid]))\n  if (headmap.has(event.toString())) return head\n\n  // does event contain the clock?\n  let changed = false\n  for (const cid of head) {\n    if (await contains(events, event, cid)) {\n      headmap.delete(cid.toString())\n      headmap.set(event.toString(), event)\n      changed = true\n    }\n  }\n  if (changed) {\n    return [...headmap.values()]\n  }\n\n  // does clock contain the event?\n  for (const p of head) {\n    if (await contains(events, p, event)) {\n      return head\n    }\n  }\n\n  return head.concat(event)\n}\n\n/**\n * @template T\n * @extends {Block<API.EventView<T>, typeof cbor.code, typeof sha256.code, 1>}\n * @implements {API.EventBlockView<T>}\n */\nexport class EventBlock extends Block {\n  /**\n   * @param {object} config\n   * @param {API.EventLink<T>} config.cid\n   * @param {Event} config.value\n   * @param {Uint8Array} config.bytes\n   * @param {string} config.prefix\n   */\n  constructor ({ cid, value, bytes, prefix }) {\n    // @ts-expect-error\n    super({ cid, value, bytes })\n    this.prefix = prefix\n  }\n\n  /**\n   * @template T\n   * @param {T} data\n   * @param {API.EventLink<T>[]} [parents]\n   */\n  static create (data, parents) {\n    return encodeEventBlock({ data, parents: parents ?? [] })\n  }\n}\n\n/** @template T */\nexport class EventFetcher {\n  /** @param {API.BlockFetcher} blocks */\n  constructor (blocks) {\n    /** @private */\n    this._blocks = blocks\n  }\n\n  /**\n   * @param {API.EventLink<T>} link\n   * @returns {Promise<API.EventBlockView<T>>}\n   */\n  async get (link) {\n    const block = await this._blocks.get(link)\n    if (!block) throw new Error(`missing block: ${link}`)\n    return decodeEventBlock(block.bytes)\n  }\n}\n\n/**\n * @template T\n * @param {API.EventView<T>} value\n * @returns {Promise<API.EventBlockView<T>>}\n */\nexport const encodeEventBlock = async (value) => {\n  // TODO: sort parents\n  const { cid, bytes } = await encode({ value, codec: cbor, hasher: sha256 })\n  // @ts-expect-error\n  return new Block({ cid, value, bytes })\n}\n\n/**\n * @template T\n * @param {Uint8Array} bytes\n * @returns {Promise<API.EventBlockView<T>>}\n */\nexport const decodeEventBlock = async (bytes) => {\n  const { cid, value } = await decode({ bytes, codec: cbor, hasher: sha256 })\n  // @ts-expect-error\n  return new Block({ cid, value, bytes })\n}\n\n/**\n * Returns true if event \"a\" contains event \"b\". Breadth first search.\n * @template T\n * @param {EventFetcher<T>} events\n * @param {API.EventLink<T>} a\n * @param {API.EventLink<T>} b\n */\nconst contains = async (events, a, b) => {\n  if (a.toString() === b.toString()) return true\n  const [{ value: aevent }, { value: bevent }] = await Promise.all([events.get(a), events.get(b)])\n  const links = [...aevent.parents]\n  const seen = new Set()\n  while (links.length) {\n    const link = links.shift()\n    if (!link) break\n    if (link.toString() === b.toString()) return true\n    // if any of b's parents are this link, then b cannot exist in any of the\n    // tree below, since that would create a cycle.\n    if (bevent.parents.some(p => link.toString() === p.toString())) continue\n    if (seen.has(link.toString())) continue\n    seen.add(link.toString())\n    const { value: event } = await events.get(link)\n    links.push(...event.parents)\n  }\n  return false\n}\n\n/**\n * @template T\n * @param {API.BlockFetcher} blocks Block storage.\n * @param {API.EventLink<T>[]} head\n * @param {object} [options]\n * @param {(b: API.EventBlockView<T>) => string} [options.renderNodeLabel]\n */\nexport const vis = async function * (blocks, head, options = {}) {\n  const renderNodeLabel = options.renderNodeLabel ?? (b => shortLink(b.cid))\n  const events = new EventFetcher(blocks)\n  yield 'digraph clock {'\n  yield '  node [shape=point fontname=\"Courier\"]; head;'\n  const hevents = await Promise.all(head.map(link => events.get(link)))\n  /** @type {import('multiformats').Link<API.EventView<any>>[]} */\n  const links = []\n  const nodes = new Set()\n  for (const e of hevents) {\n    nodes.add(e.cid.toString())\n    yield `  node [shape=oval fontname=\"Courier\"]; ${e.cid} [label=\"${renderNodeLabel(e)}\"];`\n    yield `  head -> ${e.cid};`\n    for (const p of e.value.parents) {\n      yield `  ${e.cid} -> ${p};`\n    }\n    links.push(...e.value.parents)\n  }\n  while (links.length) {\n    const link = links.shift()\n    if (!link) break\n    if (nodes.has(link.toString())) continue\n    nodes.add(link.toString())\n    const block = await events.get(link)\n    yield `  node [shape=oval]; ${link} [label=\"${renderNodeLabel(block)}\" fontname=\"Courier\"];`\n    for (const p of block.value.parents) {\n      yield `  ${link} -> ${p};`\n    }\n    links.push(...block.value.parents)\n  }\n  yield '}'\n}\n\n/** @param {import('multiformats').UnknownLink} l */\nconst shortLink = l => `${String(l).slice(0, 4)}..${String(l).slice(-4)}`\n","import * as Link from 'multiformats/link'\nimport { Block, encode, decode } from 'multiformats/block'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as dagCBOR from '@ipld/dag-cbor'\n// eslint-disable-next-line no-unused-vars\nimport * as API from './api.js'\n\nexport const KeyCharsASCII = 'ascii'\nexport const MaxKeySize = 4096\n\n/**\n * @extends {Block<API.Shard, typeof dagCBOR.code, typeof sha256.code, 1>}\n * @implements {API.ShardBlockView}\n */\nexport class ShardBlock extends Block {\n  /**\n   * @param {object} config\n   * @param {API.ShardLink} config.cid\n   * @param {API.Shard} config.value\n   * @param {Uint8Array} config.bytes\n   */\n  constructor ({ cid, value, bytes }) {\n    // @ts-expect-error\n    super({ cid, value, bytes })\n  }\n\n  /** @param {API.ShardOptions} [options] */\n  static create (options) {\n    return encodeBlock(create(options))\n  }\n}\n\n/**\n * @param {API.ShardOptions} [options]\n * @returns {API.Shard}\n */\nexport const create = (options) => ({ entries: [], ...configure(options) })\n\n/**\n * @param {API.ShardOptions} [options]\n * @returns {API.ShardConfig}\n */\nexport const configure = (options) => ({\n  version: 1,\n  keyChars: options?.keyChars ?? KeyCharsASCII,\n  maxKeySize: options?.maxKeySize ?? MaxKeySize,\n  prefix: options?.prefix ?? ''\n})\n\n/**\n * @param {API.ShardEntry[]} entries\n * @param {API.ShardOptions} [options]\n * @returns {API.Shard}\n */\nexport const withEntries = (entries, options) => ({ ...create(options), entries })\n\n/** @type {WeakMap<Uint8Array, API.ShardBlockView>} */\nconst decodeCache = new WeakMap()\n\n/**\n * @param {API.Shard} value\n * @returns {Promise<API.ShardBlockView>}\n */\nexport const encodeBlock = async value => {\n  const { cid, bytes } = await encode({ value, codec: dagCBOR, hasher: sha256 })\n  const block = new ShardBlock({ cid, value, bytes })\n  decodeCache.set(block.bytes, block)\n  return block\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {Promise<API.ShardBlockView>}\n */\nexport const decodeBlock = async bytes => {\n  const block = decodeCache.get(bytes)\n  if (block) return block\n  const { cid, value } = await decode({ bytes, codec: dagCBOR, hasher: sha256 })\n  if (!isShard(value)) throw new Error(`invalid shard: ${cid}`)\n  return new ShardBlock({ cid, value, bytes })\n}\n\n/**\n * @param {any} value\n * @returns {value is API.Shard}\n */\nexport const isShard = value =>\n  value != null &&\n  typeof value === 'object' &&\n  Array.isArray(value.entries) &&\n  value.version === 1 &&\n  typeof value.maxKeySize === 'number' &&\n  typeof value.keyChars === 'string' &&\n  typeof value.prefix === 'string'\n\n/**\n * @param {any} value\n * @returns {value is API.ShardLink}\n */\nexport const isShardLink = (value) =>\n  Link.isLink(value) &&\n  value.code === dagCBOR.code\n\nexport class ShardFetcher {\n  /** @param {API.BlockFetcher} blocks */\n  constructor (blocks) {\n    this._blocks = blocks\n  }\n\n  /**\n   * @param {API.ShardLink} link\n   * @returns {Promise<API.ShardBlockView>}\n   */\n  async get (link) {\n    const block = await this._blocks.get(link)\n    if (!block) throw new Error(`missing block: ${link}`)\n    return decodeBlock(block.bytes)\n  }\n}\n\n/**\n * @param {API.ShardEntry[]} target Entries to insert into.\n * @param {API.ShardEntry} newEntry\n * @returns {API.ShardEntry[]}\n */\nexport const putEntry = (target, newEntry) => {\n  /** @type {API.ShardEntry[]} */\n  const entries = []\n\n  for (const [i, entry] of target.entries()) {\n    const [k, v] = entry\n    if (newEntry[0] === k) {\n      // if new value is link to shard...\n      if (Array.isArray(newEntry[1])) {\n        // and old value is link to shard\n        // and old value is _also_ link to data\n        // and new value does not have link to data\n        // then preserve old data\n        if (Array.isArray(v) && v[1] != null && newEntry[1][1] == null) {\n          entries.push([k, [newEntry[1][0], v[1]]])\n        } else {\n          entries.push(newEntry)\n        }\n      } else {\n        // shard as well as value?\n        if (Array.isArray(v)) {\n          entries.push([k, [v[0], newEntry[1]]])\n        } else {\n          entries.push(newEntry)\n        }\n      }\n      for (let j = i + 1; j < target.length; j++) {\n        entries.push(target[j])\n      }\n      return entries\n    }\n    if (i === 0 && newEntry[0] < k) {\n      entries.push(newEntry)\n      for (let j = i; j < target.length; j++) {\n        entries.push(target[j])\n      }\n      return entries\n    }\n    if (i > 0 && newEntry[0] > target[i - 1][0] && newEntry[0] < k) {\n      entries.push(newEntry)\n      for (let j = i; j < target.length; j++) {\n        entries.push(target[j])\n      }\n      return entries\n    }\n    entries.push(entry)\n  }\n\n  entries.push(newEntry)\n\n  return entries\n}\n\n/** @param {string} s */\nexport const isPrintableASCII = s => /^[\\x20-\\x7E]*$/.test(s)\n","// eslint-disable-next-line no-unused-vars\nimport * as API from './api.js'\nimport { ShardFetcher, isPrintableASCII } from './shard.js'\nimport * as Shard from './shard.js'\n\n/**\n * Put a value (a CID) for the given key. If the key exists it's value is\n * overwritten.\n *\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.ShardLink} root CID of the root node of the bucket.\n * @param {string} key The key of the value to put.\n * @param {API.UnknownLink} value The value to put.\n * @returns {Promise<{ root: API.ShardLink } & API.ShardDiff>}\n */\nexport const put = async (blocks, root, key, value) => {\n  const shards = new ShardFetcher(blocks)\n  const rshard = await shards.get(root)\n\n  if (rshard.value.keyChars !== Shard.KeyCharsASCII) {\n    throw new Error(`unsupported key character set: ${rshard.value.keyChars}`)\n  }\n  if (!isPrintableASCII(key)) {\n    throw new Error('key contains non-ASCII characters')\n  }\n  // ensure utf8 encoded key is smaller than max\n  if (new TextEncoder().encode(key).length > rshard.value.maxKeySize) {\n    throw new Error(`UTF-8 encoded key exceeds max size of ${rshard.value.maxKeySize} bytes`)\n  }\n\n  const path = await traverse(shards, rshard, key)\n  const target = path[path.length - 1]\n  const skey = key.slice(target.value.prefix.length) // key within the shard\n\n  /** @type {API.ShardEntry} */\n  let entry = [skey, value]\n  let targetEntries = [...target.value.entries]\n\n  /** @type {API.ShardBlockView[]} */\n  const additions = []\n\n  for (const [i, e] of targetEntries.entries()) {\n    const [k, v] = e\n\n    // is this just a replace?\n    if (k === skey) break\n\n    // do we need to shard this entry?\n    const shortest = k.length < skey.length ? k : skey\n    const other = shortest === k ? skey : k\n    let common = ''\n    for (const char of shortest) {\n      const next = common + char\n      if (!other.startsWith(next)) break\n      common = next\n    }\n    if (common.length) {\n      /** @type {API.ShardEntry[]} */\n      let entries = []\n\n      // if the existing entry key or new key is equal to the common prefix,\n      // then the existing value / new value needs to persist in the parent\n      // shard. Otherwise they persist in this new shard.\n      if (common !== skey) {\n        entries = Shard.putEntry(entries, [skey.slice(common.length), value])\n      }\n      if (common !== k) {\n        entries = Shard.putEntry(entries, [k.slice(common.length), v])\n      }\n\n      let child = await Shard.encodeBlock(\n        Shard.withEntries(entries, { ...target.value, prefix: target.value.prefix + common })\n      )\n      additions.push(child)\n  \n      // need to spread as access by index does not consider utf-16 surrogates\n      const commonChars = [...common]\n\n      // create parent shards for each character of the common prefix\n      for (let i = commonChars.length - 1; i > 0; i--) {\n        const parentConfig = { ...target.value, prefix: target.value.prefix + commonChars.slice(0, i).join('') }\n        /** @type {API.ShardEntryLinkValue | API.ShardEntryValueValue | API.ShardEntryLinkAndValueValue} */\n        let parentValue\n        // if the first iteration and the existing entry key is equal to the\n        // common prefix, then existing value needs to persist in this parent\n        if (i === commonChars.length - 1 && common === k) {\n          if (Array.isArray(v)) throw new Error('found a shard link when expecting a value')\n          parentValue = [child.cid, v]\n        } else if (i === commonChars.length - 1 && common === skey) {\n          parentValue = [child.cid, value]\n        } else {\n          parentValue = [child.cid]\n        }\n        const parent = await Shard.encodeBlock(Shard.withEntries([[commonChars[i], parentValue]], parentConfig))\n        additions.push(parent)\n        child = parent\n      }\n\n      // remove the sharded entry\n      targetEntries.splice(i, 1)\n\n      // create the entry that will be added to target\n      if (commonChars.length === 1 && common === k) {\n        if (Array.isArray(v)) throw new Error('found a shard link when expecting a value')\n        entry = [commonChars[0], [child.cid, v]]\n      } else if (commonChars.length === 1 && common === skey) {\n        entry = [commonChars[0], [child.cid, value]]\n      } else {\n        entry = [commonChars[0], [child.cid]]\n      }\n      break\n    }\n  }\n\n  const shard = Shard.withEntries(Shard.putEntry(targetEntries, entry), target.value)\n  let child = await Shard.encodeBlock(shard)\n\n  // if no change in the target then we're done\n  if (child.cid.toString() === target.cid.toString()) {\n    return { root, additions: [], removals: [] }\n  }\n\n  additions.push(child)\n\n  // path is root -> target, so work backwards, propagating the new shard CID\n  for (let i = path.length - 2; i >= 0; i--) {\n    const parent = path[i]\n    const key = child.value.prefix.slice(parent.value.prefix.length)\n    const value = Shard.withEntries(\n      parent.value.entries.map((entry) => {\n        const [k, v] = entry\n        if (k !== key) return entry\n        if (!Array.isArray(v)) throw new Error(`\"${key}\" is not a shard link in: ${parent.cid}`)\n        return /** @type {API.ShardEntry} */(v[1] == null ? [k, [child.cid]] : [k, [child.cid, v[1]]])\n      }),\n      parent.value\n    )\n\n    child = await Shard.encodeBlock(value)\n    additions.push(child)\n  }\n\n  return { root: additions[additions.length - 1].cid, additions, removals: path }\n}\n\n/**\n * Get the stored value for the given key from the bucket. If the key is not\n * found, `undefined` is returned.\n *\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.ShardLink} root CID of the root node of the bucket.\n * @param {string} key The key of the value to get.\n * @returns {Promise<API.UnknownLink | undefined>}\n */\nexport const get = async (blocks, root, key) => {\n  const shards = new ShardFetcher(blocks)\n  const rshard = await shards.get(root)\n  const path = await traverse(shards, rshard, key)\n  const target = path[path.length - 1]\n  const skey = key.slice(target.value.prefix.length) // key within the shard\n  const entry = target.value.entries.find(([k]) => k === skey)\n  if (!entry) return\n  return Array.isArray(entry[1]) ? entry[1][1] : entry[1]\n}\n\n/**\n * Delete the value for the given key from the bucket. If the key is not found\n * no operation occurs.\n *\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.ShardLink} root CID of the root node of the bucket.\n * @param {string} key The key of the value to delete.\n * @returns {Promise<{ root: API.ShardLink } & API.ShardDiff>}\n */\nexport const del = async (blocks, root, key) => {\n  const shards = new ShardFetcher(blocks)\n  const rshard = await shards.get(root)\n  const path = await traverse(shards, rshard, key)\n  const target = path[path.length - 1]\n  const skey = key.slice(target.value.prefix.length) // key within the shard\n\n  const entryidx = target.value.entries.findIndex(([k]) => k === skey)\n  if (entryidx === -1) return { root, additions: [], removals: [] }\n\n  const entry = target.value.entries[entryidx]\n  // cannot delete a shard (without data)\n  if (Array.isArray(entry[1]) && entry[1][1] == null) {\n    return { root, additions: [], removals: [] }\n  }\n\n  /** @type {API.ShardBlockView[]} */\n  const additions = []\n  /** @type {API.ShardBlockView[]} */\n  const removals = [...path]\n\n  let shard = Shard.withEntries([...target.value.entries], target.value)\n\n  if (Array.isArray(entry[1])) {\n    // remove the value from this link+value\n    shard.entries[entryidx] = [entry[0], [entry[1][0]]]\n  } else {\n    shard.entries.splice(entryidx, 1)\n    // if now empty, remove from parent\n    while (!shard.entries.length) {\n      const child = path[path.length - 1]\n      const parent = path[path.length - 2]\n      if (!parent) break\n      path.pop()\n      shard = Shard.withEntries(\n        parent.value.entries.filter(e => {\n          if (!Array.isArray(e[1])) return true\n          return e[1][0].toString() !== child.cid.toString()\n        }),\n        parent.value\n      )\n    }\n  }\n\n  let child = await Shard.encodeBlock(shard)\n  additions.push(child)\n\n  // path is root -> shard, so work backwards, propagating the new shard CID\n  for (let i = path.length - 2; i >= 0; i--) {\n    const parent = path[i]\n    const key = child.value.prefix.slice(parent.value.prefix.length)\n    const value = Shard.withEntries(\n      parent.value.entries.map((entry) => {\n        const [k, v] = entry\n        if (k !== key) return entry\n        if (!Array.isArray(v)) throw new Error(`\"${key}\" is not a shard link in: ${parent.cid}`)\n        return /** @type {API.ShardEntry} */(v[1] == null ? [k, [child.cid]] : [k, [child.cid, v[1]]])\n      }),\n      parent.value\n    )\n\n    child = await Shard.encodeBlock(value)\n    additions.push(child)\n  }\n\n  return { root: additions[additions.length - 1].cid, additions, removals }\n}\n\n/**\n * @param {API.EntriesOptions} [options]\n * @returns {options is API.KeyPrefixOption}\n */\nconst isKeyPrefixOption = options => {\n  const opts = options ?? {}\n  return 'prefix' in opts && Boolean(opts.prefix)\n}\n\n/**\n * @param {API.EntriesOptions} [options]\n * @returns {options is API.KeyRangeOption}\n */\nconst isKeyRangeOption = options => {\n  const opts = options ?? {}\n  return ('gt' in opts && Boolean(opts.gt)) || ('gte' in opts && Boolean(opts.gte)) || ('lt' in opts && Boolean(opts.lt)) || ('lte' in opts && Boolean(opts.lte))\n}\n\n/**\n * @param {API.KeyRangeOption} options\n * @returns {options is API.KeyLowerBoundRangeOption}\n */\nconst isKeyLowerBoundRangeOption = options => ('gt' in options && Boolean(options.gt)) || ('gte' in options && Boolean(options.gte))\n\n/**\n * @param {API.KeyLowerBoundRangeOption} options\n * @returns {options is API.KeyLowerBoundRangeInclusiveOption}\n */\nconst isKeyLowerBoundRangeInclusiveOption = options => 'gte' in options && Boolean(options.gte)\n\n/**\n * @param {API.KeyLowerBoundRangeOption} options\n * @returns {options is API.KeyLowerBoundRangeExclusiveOption}\n */\nconst isKeyLowerBoundRangeExclusiveOption = options => 'gt' in options && Boolean(options.gt)\n\n/**\n * @param {API.KeyRangeOption} options\n * @returns {options is API.KeyUpperBoundRangeOption}\n */\nconst isKeyUpperBoundRangeOption = options => ('lt' in options && Boolean(options.lt)) || ('lte' in options && Boolean(options.lte))\n\n/**\n * @param {API.KeyUpperBoundRangeOption} options\n * @returns {options is API.KeyUpperBoundRangeInclusiveOption}\n */\nconst isKeyUpperBoundRangeInclusiveOption = options => 'lte' in options && Boolean(options.lte)\n\n/**\n * @param {API.KeyUpperBoundRangeOption} options\n * @returns {options is API.KeyUpperBoundRangeExclusiveOption}\n */\nconst isKeyUpperBoundRangeExclusiveOption = options => 'lt' in options && Boolean(options.lt)\n\n/**\n * List entries in the bucket.\n *\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.ShardLink} root CID of the root node of the bucket.\n * @param {API.EntriesOptions} [options]\n * @returns {AsyncIterableIterator<API.ShardValueEntry>}\n */\nexport const entries = async function * (blocks, root, options) {\n  const hasKeyPrefix = isKeyPrefixOption(options)\n  const hasKeyRange = isKeyRangeOption(options)\n  const hasKeyLowerBoundRange = hasKeyRange && isKeyLowerBoundRangeOption(options)\n  const hasKeyLowerBoundRangeInclusive = hasKeyLowerBoundRange && isKeyLowerBoundRangeInclusiveOption(options)\n  const hasKeyLowerBoundRangeExclusive = hasKeyLowerBoundRange && isKeyLowerBoundRangeExclusiveOption(options)\n  const hasKeyUpperBoundRange = hasKeyRange && isKeyUpperBoundRangeOption(options)\n  const hasKeyUpperBoundRangeInclusive = hasKeyUpperBoundRange && isKeyUpperBoundRangeInclusiveOption(options)\n  const hasKeyUpperBoundRangeExclusive = hasKeyUpperBoundRange && isKeyUpperBoundRangeExclusiveOption(options)\n  const hasKeyUpperAndLowerBoundRange = hasKeyLowerBoundRange && hasKeyUpperBoundRange\n\n  const shards = new ShardFetcher(blocks)\n  const rshard = await shards.get(root)\n\n  yield * (\n    /** @returns {AsyncIterableIterator<API.ShardValueEntry>} */\n    async function * ents (shard) {\n      for (const entry of shard.value.entries) {\n        const key = shard.value.prefix + entry[0]\n\n        // if array, this is a link to a shard\n        if (Array.isArray(entry[1])) {\n          if (entry[1][1]) {\n            if (\n              (hasKeyPrefix && key.startsWith(options.prefix)) ||\n              (hasKeyUpperAndLowerBoundRange && (\n                ((hasKeyLowerBoundRangeExclusive && key > options.gt) || (hasKeyLowerBoundRangeInclusive && key >= options.gte)) &&\n                ((hasKeyUpperBoundRangeExclusive && key < options.lt) || (hasKeyUpperBoundRangeInclusive && key <= options.lte))\n              )) ||\n              (hasKeyLowerBoundRangeExclusive && key > options.gt) ||\n              (hasKeyLowerBoundRangeInclusive && key >= options.gte) ||\n              (hasKeyUpperBoundRangeExclusive && key < options.lt) ||\n              (hasKeyUpperBoundRangeInclusive && key <= options.lte) ||\n              (!hasKeyPrefix && !hasKeyRange)\n            ) {\n              yield [key, entry[1][1]]\n            }\n          }\n\n          if (hasKeyPrefix) {\n            if (options.prefix.length <= key.length && !key.startsWith(options.prefix)) {\n              continue\n            }\n            if (options.prefix.length > key.length && !options.prefix.startsWith(key)) {\n              continue\n            }\n          } else if (\n            (hasKeyLowerBoundRangeExclusive && (trunc(key, Math.min(key.length, options.gt.length)) < trunc(options.gt, Math.min(key.length, options.gt.length)))) ||\n            (hasKeyLowerBoundRangeInclusive && (trunc(key, Math.min(key.length, options.gte.length)) < trunc(options.gte, Math.min(key.length, options.gte.length)))) ||\n            (hasKeyUpperBoundRangeExclusive && (trunc(key, Math.min(key.length, options.lt.length)) > trunc(options.lt, Math.min(key.length, options.lt.length)))) ||\n            (hasKeyUpperBoundRangeInclusive && (trunc(key, Math.min(key.length, options.lte.length)) > trunc(options.lte, Math.min(key.length, options.lte.length))))\n          ) {\n            continue\n          }\n          yield * ents(await shards.get(entry[1][0]))\n        } else {\n          if (\n            (hasKeyPrefix && key.startsWith(options.prefix)) ||\n            (hasKeyRange && hasKeyUpperAndLowerBoundRange && (\n              ((hasKeyLowerBoundRangeExclusive && key > options.gt) || (hasKeyLowerBoundRangeInclusive && key >= options.gte)) &&\n              ((hasKeyUpperBoundRangeExclusive && key < options.lt) || (hasKeyUpperBoundRangeInclusive && key <= options.lte))\n            )) ||\n            (hasKeyRange && !hasKeyUpperAndLowerBoundRange && (\n              (hasKeyLowerBoundRangeExclusive && key > options.gt) || (hasKeyLowerBoundRangeInclusive && key >= options.gte) ||\n              (hasKeyUpperBoundRangeExclusive && key < options.lt) || (hasKeyUpperBoundRangeInclusive && key <= options.lte)\n            )) ||\n            (!hasKeyPrefix && !hasKeyRange)\n          ) {\n            yield [key, entry[1]]\n          }\n        }\n      }\n    }\n  )(rshard)\n}\n\n/**\n * @param {string} str\n * @param {number} len\n */\nconst trunc = (str, len) => str.length <= len ? str : str.slice(0, len)\n\n/**\n * Traverse from the passed shard block to the target shard block using the\n * passed key. All traversed shards are returned, starting with the passed\n * shard and ending with the target.\n *\n * @param {ShardFetcher} shards\n * @param {API.ShardBlockView} shard\n * @param {string} key\n * @returns {Promise<[API.ShardBlockView, ...Array<API.ShardBlockView>]>}\n */\nconst traverse = async (shards, shard, key) => {\n  for (const [k, v] of shard.value.entries) {\n    if (key === k) return [shard]\n    if (key.startsWith(k) && Array.isArray(v)) {\n      const path = await traverse(shards, await shards.get(v[0]), key.slice(k.length))\n      return [shard, ...path]\n    }\n  }\n  return [shard]\n}\n","// eslint-disable-next-line no-unused-vars\nimport * as API from './api.js'\nimport { parse } from 'multiformats/link'\n\n/** @implements {API.BlockFetcher} */\nexport class MemoryBlockstore {\n  /** @type {Map<string, Uint8Array>} */\n  #blocks = new Map()\n\n  /**\n   * @param {Array<import('multiformats').Block>} [blocks]\n   */\n  constructor (blocks) {\n    if (blocks) {\n      this.#blocks = new Map(blocks.map(b => [b.cid.toString(), b.bytes]))\n    }\n  }\n\n  /** @type {API.BlockFetcher['get']} */\n  async get (cid) {\n    const bytes = this.#blocks.get(cid.toString())\n    if (!bytes) return\n    return { cid, bytes }\n  }\n\n  /**\n   * @param {API.UnknownLink} cid\n   * @param {Uint8Array} bytes\n   */\n  async put (cid, bytes) {\n    this.#blocks.set(cid.toString(), bytes)\n  }\n\n  /**\n   * @param {API.UnknownLink} cid\n   * @param {Uint8Array} bytes\n   */\n  putSync (cid, bytes) {\n    this.#blocks.set(cid.toString(), bytes)\n  }\n\n  /** @param {API.UnknownLink} cid */\n  async delete (cid) {\n    this.#blocks.delete(cid.toString())\n  }\n\n  /** @param {API.UnknownLink} cid */\n  deleteSync (cid) {\n    this.#blocks.delete(cid.toString())\n  }\n\n  * entries () {\n    for (const [str, bytes] of this.#blocks) {\n      yield { cid: parse(str), bytes }\n    }\n  }\n}\n\nexport class MultiBlockFetcher {\n  /** @type {API.BlockFetcher[]} */\n  #fetchers\n\n  /** @param {API.BlockFetcher[]} fetchers */\n  constructor (...fetchers) {\n    this.#fetchers = fetchers\n  }\n\n  /** @type {API.BlockFetcher['get']} */\n  async get (link) {\n    for (const f of this.#fetchers) {\n      const v = await f.get(link)\n      if (v) return v\n    }\n  }\n}\n","// eslint-disable-next-line no-unused-vars\nimport * as API from './api.js'\nimport { configure } from '../shard.js'\n\n/**\n * @param {API.BatcherShardInit} [init]\n * @returns {API.BatcherShard}\n */\nexport const create = init => ({\n  base: init?.base,\n  entries: [...init?.entries ?? []],\n  ...configure(init)\n})\n","// eslint-disable-next-line no-unused-vars\nimport * as API from './api.js'\nimport { ShardFetcher, isPrintableASCII } from '../shard.js'\nimport * as Shard from '../shard.js'\nimport * as BatcherShard from './shard.js'\n\n/** @implements {API.Batcher} */\nclass Batcher {\n  #committed = false\n\n  /**\n   * @param {object} init\n   * @param {API.BlockFetcher} init.blocks Block storage.\n   * @param {API.BatcherShardEntry[]} init.entries The entries in this shard.\n   * @param {string} init.prefix Key prefix.\n   * @param {number} init.version Shard compatibility version.\n   * @param {string} init.keyChars Characters allowed in keys, referring to a known character set.\n   * @param {number} init.maxKeySize Max key size in bytes.\n   * @param {API.ShardBlockView} init.base Original shard this batcher is based on.\n   */\n  constructor ({ blocks, entries, prefix, version, keyChars, maxKeySize, base }) {\n    this.blocks = blocks\n    this.prefix = prefix\n    this.entries = [...entries]\n    this.base = base\n    this.version = version\n    this.keyChars = keyChars\n    this.maxKeySize = maxKeySize\n  }\n\n  /**\n   * @param {string} key The key of the value to put.\n   * @param {API.UnknownLink} value The value to put.\n   * @returns {Promise<void>}\n   */\n  async put (key, value) {\n    if (this.#committed) throw new BatchCommittedError()\n    return put(this.blocks, this, key, value)\n  }\n\n  async commit () {\n    if (this.#committed) throw new BatchCommittedError()\n    this.#committed = true\n    return commit(this)\n  }\n\n  /**\n   * @param {object} init\n   * @param {API.BlockFetcher} init.blocks Block storage.\n   * @param {API.ShardLink} init.link CID of the shard block.\n   */\n  static async create ({ blocks, link }) {\n    const shards = new ShardFetcher(blocks)\n    const base = await shards.get(link)\n    return new Batcher({ blocks, base, ...base.value })\n  }\n}\n\n/**\n * @param {API.BlockFetcher} blocks\n * @param {API.BatcherShard} shard\n * @param {string} key The key of the value to put.\n * @param {API.UnknownLink} value The value to put.\n * @returns {Promise<void>}\n */\nexport const put = async (blocks, shard, key, value) => {\n  if (shard.keyChars !== Shard.KeyCharsASCII) {\n    throw new Error(`unsupported key character set: ${shard.keyChars}`)\n  }\n  if (!isPrintableASCII(key)) {\n    throw new Error('key contains non-ASCII characters')\n  }\n  // ensure utf8 encoded key is smaller than max\n  if (new TextEncoder().encode(key).length > shard.maxKeySize) {\n    throw new Error(`UTF-8 encoded key exceeds max size of ${shard.maxKeySize} bytes`)\n  }\n\n  const shards = new ShardFetcher(blocks)\n  const dest = await traverse(shards, shard, key)\n  if (dest.shard !== shard) {\n    shard = dest.shard\n    key = dest.key\n  }\n\n  /** @type {API.BatcherShardEntry} */\n  let entry = [dest.key, value]\n  let targetEntries = [...dest.shard.entries]\n\n  for (const [i, e] of targetEntries.entries()) {\n    const [k, v] = e\n\n    // is this just a replace?\n    if (k === dest.key) break\n\n    // do we need to shard this entry?\n    const shortest = k.length < dest.key.length ? k : dest.key\n    const other = shortest === k ? dest.key : k\n    let common = ''\n    for (const char of shortest) {\n      const next = common + char\n      if (!other.startsWith(next)) break\n      common = next\n    }\n    if (common.length) {\n      /** @type {API.ShardEntry[]} */\n      let entries = []\n\n      // if the existing entry key or new key is equal to the common prefix,\n      // then the existing value / new value needs to persist in the parent\n      // shard. Otherwise they persist in this new shard.\n      if (common !== dest.key) {\n        entries = Shard.putEntry(entries, [dest.key.slice(common.length), value])\n      }\n      if (common !== k) {\n        entries = Shard.putEntry(entries, asShardEntry([k.slice(common.length), v]))\n      }\n\n      let child = BatcherShard.create({\n        ...Shard.configure(dest.shard),\n        prefix: dest.shard.prefix + common,\n        entries\n      })\n  \n      // need to spread as access by index does not consider utf-16 surrogates\n      const commonChars = [...common]\n\n      // create parent shards for each character of the common prefix\n      for (let i = commonChars.length - 1; i > 0; i--) {\n        /** @type {API.ShardEntryShardValue | API.ShardEntryShardAndValueValue} */\n        let parentValue\n        // if the first iteration and the existing entry key is equal to the\n        // common prefix, then existing value needs to persist in this parent\n        if (i === commonChars.length - 1 && common === k) {\n          if (Array.isArray(v)) throw new Error('found a shard link when expecting a value')\n          parentValue = [child, v]\n        } else if (i === commonChars.length - 1 && common === dest.key) {\n          parentValue = [child, value]\n        } else {\n          parentValue = [child]\n        }\n        const parent = BatcherShard.create({\n          ...Shard.configure(dest.shard),\n          prefix: dest.shard.prefix + commonChars.slice(0, i).join(''),\n          entries: [[commonChars[i], parentValue]]\n        })\n        child = parent\n      }\n\n      // remove the sharded entry\n      targetEntries.splice(i, 1)\n\n      // create the entry that will be added to target\n      if (commonChars.length === 1 && common === k) {\n        if (Array.isArray(v)) throw new Error('found a shard link when expecting a value')\n        entry = [commonChars[0], [child, v]]\n      } else if (commonChars.length === 1 && common === dest.key) {\n        entry = [commonChars[0], [child, value]]\n      } else {\n        entry = [commonChars[0], [child]]\n      }\n      break\n    }\n  }\n\n  shard.entries = Shard.putEntry(asShardEntries(targetEntries), asShardEntry(entry))\n}\n\n/**\n * Traverse from the passed shard through to the correct shard for the passed\n * key.\n *\n * @param {ShardFetcher} shards\n * @param {API.BatcherShard} shard\n * @param {string} key\n * @returns {Promise<{ shard: API.BatcherShard, key: string }>}\n */\nexport const traverse = async (shards, shard, key) => {\n  for (let i = 0; i < shard.entries.length; i++) {\n    const [k, v] = shard.entries[i]\n    if (key <= k) break\n    if (key.startsWith(k) && Array.isArray(v)) {\n      if (Shard.isShardLink(v[0])) {\n        const blk = await shards.get(v[0])\n        const batcher = BatcherShard.create({ base: blk, ...blk.value })\n        shard.entries[i] = [k, v[1] == null ? [batcher] : [batcher, v[1]]]\n        return traverse(shards, batcher, key.slice(k.length))\n      }\n      return traverse(shards, v[0], key.slice(k.length))\n    }\n  }\n  return { shard, key }\n}\n\n/**\n * Encode all altered shards in the batch and return the new root CID and\n * difference blocks.\n *\n * @param {API.BatcherShard} shard\n */\nexport const commit = async shard => {\n  /** @type {API.ShardBlockView[]} */\n  const additions = []\n  /** @type {API.ShardBlockView[]} */\n  const removals = []\n\n  /** @type {API.ShardEntry[]} */\n  const entries = []\n  for (const entry of shard.entries) {\n    if (Array.isArray(entry[1]) && !Shard.isShardLink(entry[1][0])) {\n      const result = await commit(entry[1][0])\n      entries.push([\n        entry[0],\n        entry[1][1] == null ? [result.root] : [result.root, entry[1][1]]\n      ])\n      additions.push(...result.additions)\n      removals.push(...result.removals)\n    } else {\n      entries.push(asShardEntry(entry))\n    }\n  }\n\n  const block = await Shard.encodeBlock(Shard.withEntries(entries, shard))\n  additions.push(block)\n\n  if (shard.base && shard.base.cid.toString() === block.cid.toString()) {\n    return { root: block.cid, additions: [], removals: [] }\n  }\n\n  if (shard.base) removals.push(shard.base)\n\n  return { root: block.cid, additions, removals }\n}\n\n/** @param {API.BatcherShardEntry[]} entries */\nconst asShardEntries = entries => /** @type {API.ShardEntry[]} */ (entries)\n\n/** @param {API.BatcherShardEntry} entry */\nconst asShardEntry = entry => /** @type {API.ShardEntry} */ (entry)\n\n/**\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.ShardLink} root CID of the root shard block.\n * @returns {Promise<API.Batcher>}\n */\nexport const create = (blocks, root) => Batcher.create({ blocks, link: root })\n\nexport class BatchCommittedError extends Error {\n  /**\n   * @param {string} [message]\n   * @param {ErrorOptions} [options]\n   */\n  constructor (message, options) {\n    super(message ?? 'batch already committed', options)\n    this.code = BatchCommittedError.code\n  }\n\n  static code = 'ERR_BATCH_COMMITTED'\n}\n","// eslint-disable-next-line no-unused-vars\nimport * as API from './api.js'\nimport * as Clock from '../clock/index.js'\nimport { EventFetcher, EventBlock } from '../clock/index.js'\nimport * as Pail from '../index.js'\nimport { ShardBlock } from '../shard.js'\nimport { MemoryBlockstore, MultiBlockFetcher } from '../block.js'\nimport * as Batch from '../batch/index.js'\n\n/**\n * Put a value (a CID) for the given key. If the key exists it's value is\n * overwritten.\n *\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.EventLink<API.Operation>[]} head Merkle clock head.\n * @param {string} key The key of the value to put.\n * @param {API.UnknownLink} value The value to put.\n * @returns {Promise<API.Result>}\n */\nexport const put = async (blocks, head, key, value) => {\n  const mblocks = new MemoryBlockstore()\n  blocks = new MultiBlockFetcher(mblocks, blocks)\n\n  if (!head.length) {\n    const shard = await ShardBlock.create()\n    mblocks.putSync(shard.cid, shard.bytes)\n    const result = await Pail.put(blocks, shard.cid, key, value)\n    /** @type {API.Operation} */\n    const data = { type: 'put', root: result.root, key, value }\n    const event = await EventBlock.create(data, head)\n    head = await Clock.advance(blocks, head, event.cid)\n    return {\n      root: result.root,\n      additions: [shard, ...result.additions],\n      removals: result.removals,\n      head,\n      event\n    }\n  }\n\n  /** @type {EventFetcher<API.Operation>} */\n  const events = new EventFetcher(blocks)\n  const ancestor = await findCommonAncestor(events, head)\n  if (!ancestor) throw new Error('failed to find common ancestor event')\n\n  const aevent = await events.get(ancestor)\n  let { root } = aevent.value.data\n\n  const sorted = await findSortedEvents(events, head, ancestor)\n  /** @type {Map<string, API.ShardBlockView>} */\n  const additions = new Map()\n  /** @type {Map<string, API.ShardBlockView>} */\n  const removals = new Map()\n\n  for (const { value: event } of sorted) {\n    let result\n    if (event.data.type === 'put') {\n      result = await Pail.put(blocks, root, event.data.key, event.data.value)\n    } else if (event.data.type === 'del') {\n      result = await Pail.del(blocks, root, event.data.key)\n    } else if (event.data.type === 'batch') {\n      const batch = await Batch.create(blocks, root)\n      for (const op of event.data.ops) {\n        if (op.type !== 'put') throw new Error(`unsupported batch operation: ${op.type}`)\n        await batch.put(op.key, op.value)\n      }\n      result = await batch.commit()\n    } else {\n      // @ts-expect-error type does not exist on never\n      throw new Error(`unknown operation: ${event.data.type}`)\n    }\n\n    root = result.root\n    for (const a of result.additions) {\n      mblocks.putSync(a.cid, a.bytes)\n      additions.set(a.cid.toString(), a)\n    }\n    for (const r of result.removals) {\n      removals.set(r.cid.toString(), r)\n    }\n  }\n\n  const result = await Pail.put(blocks, root, key, value)\n  // if we didn't change the pail we're done\n  if (result.root.toString() === root.toString()) {\n    return { root, additions: [], removals: [], head }\n  }\n\n  for (const a of result.additions) {\n    mblocks.putSync(a.cid, a.bytes)\n    additions.set(a.cid.toString(), a)\n  }\n  for (const r of result.removals) {\n    removals.set(r.cid.toString(), r)\n  }\n\n  /** @type {API.Operation} */\n  const data = { type: 'put', root: result.root, key, value }\n  const event = await EventBlock.create(data, head)\n  mblocks.putSync(event.cid, event.bytes)\n  head = await Clock.advance(blocks, head, event.cid)\n\n  // filter blocks that were added _and_ removed\n  for (const k of removals.keys()) {\n    if (additions.has(k)) {\n      additions.delete(k)\n      removals.delete(k)\n    }\n  }\n\n  return {\n    root: result.root,\n    additions: [...additions.values()],\n    removals: [...removals.values()],\n    head,\n    event\n  }\n}\n\n/**\n * Delete the value for the given key from the bucket. If the key is not found\n * no operation occurs.\n *\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.EventLink<API.Operation>[]} head Merkle clock head.\n * @param {string} key The key of the value to delete.\n * @param {object} [options]\n * @returns {Promise<API.Result>}\n */\nexport const del = async (blocks, head, key, options) => {\n  throw new Error('not implemented')\n}\n\n/**\n * Determine the effective pail root given the current merkle clock head.\n *\n * Clocks with multiple head events may return blocks that were added or\n * removed while playing forward events from their common ancestor.\n *\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.EventLink<API.Operation>[]} head Merkle clock head.\n * @returns {Promise<{ root: API.ShardLink } & API.ShardDiff>}\n */\nexport const root = async (blocks, head) => {\n  if (!head.length) throw new Error('cannot determine root of headless clock')\n\n  const mblocks = new MemoryBlockstore()\n  blocks = new MultiBlockFetcher(mblocks, blocks)\n\n  /** @type {EventFetcher<API.Operation>} */\n  const events = new EventFetcher(blocks)\n\n  if (head.length === 1) {\n    const event = await events.get(head[0])\n    const { root } = event.value.data\n    return { root, additions: [], removals: [] }\n  }\n\n  const ancestor = await findCommonAncestor(events, head)\n  if (!ancestor) throw new Error('failed to find common ancestor event')\n\n  const aevent = await events.get(ancestor)\n  let { root } = aevent.value.data\n\n  const sorted = await findSortedEvents(events, head, ancestor)\n  /** @type {Map<string, API.ShardBlockView>} */\n  const additions = new Map()\n  /** @type {Map<string, API.ShardBlockView>} */\n  const removals = new Map()\n\n  for (const { value: event } of sorted) {\n    let result\n    if (event.data.type === 'put') {\n      result = await Pail.put(blocks, root, event.data.key, event.data.value)\n    } else if (event.data.type === 'del') {\n      result = await Pail.del(blocks, root, event.data.key)\n    } else if (event.data.type === 'batch') {\n      const batch = await Batch.create(blocks, root)\n      for (const op of event.data.ops) {\n        if (op.type !== 'put') throw new Error(`unsupported batch operation: ${op.type}`)\n        await batch.put(op.key, op.value)\n      }\n      result = await batch.commit()\n    } else {\n      // @ts-expect-error type does not exist on never\n      throw new Error(`unknown operation: ${event.data.type}`)\n    }\n\n    root = result.root\n    for (const a of result.additions) {\n      mblocks.putSync(a.cid, a.bytes)\n      additions.set(a.cid.toString(), a)\n    }\n    for (const r of result.removals) {\n      removals.set(r.cid.toString(), r)\n    }\n  }\n\n  // filter blocks that were added _and_ removed\n  for (const k of removals.keys()) {\n    if (additions.has(k)) {\n      additions.delete(k)\n      removals.delete(k)\n    }\n  }\n\n  return {\n    root,\n    additions: [...additions.values()],\n    removals: [...removals.values()]\n  }\n}\n\n/**\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.EventLink<API.Operation>[]} head Merkle clock head.\n * @param {string} key The key of the value to retrieve.\n */\nexport const get = async (blocks, head, key) => {\n  if (!head.length) return\n  const result = await root(blocks, head)\n  if (result.additions.length) {\n    blocks = new MultiBlockFetcher(new MemoryBlockstore(result.additions), blocks)\n  }\n  return Pail.get(blocks, result.root, key)\n}\n\n/**\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.EventLink<API.Operation>[]} head Merkle clock head.\n * @param {API.EntriesOptions} [options]\n */\nexport const entries = async function * (blocks, head, options) {\n  if (!head.length) return\n  const result = await root(blocks, head)\n  if (result.additions.length) {\n    blocks = new MultiBlockFetcher(new MemoryBlockstore(result.additions), blocks)\n  }\n  yield * Pail.entries(blocks, result.root, options)\n}\n\n/**\n * Find the common ancestor event of the passed children. A common ancestor is\n * the first single event in the DAG that _all_ paths from children lead to.\n *\n * @param {EventFetcher<API.Operation>} events\n * @param  {API.EventLink<API.Operation>[]} children\n */\nconst findCommonAncestor = async (events, children) => {\n  if (!children.length) return\n  const candidates = children.map(c => [c])\n  while (true) {\n    let changed = false\n    for (const c of candidates) {\n      const candidate = await findAncestorCandidate(events, c[c.length - 1])\n      if (!candidate) continue\n      changed = true\n      c.push(candidate)\n      const ancestor = findCommonString(candidates)\n      if (ancestor) return ancestor\n    }\n    if (!changed) return\n  }\n}\n\n/**\n * @param {EventFetcher<API.Operation>} events\n * @param {API.EventLink<API.Operation>} root\n */\nconst findAncestorCandidate = async (events, root) => {\n  const { value: event } = await events.get(root)\n  if (!event.parents.length) return root\n  return event.parents.length === 1\n    ? event.parents[0]\n    : findCommonAncestor(events, event.parents)\n}\n\n/**\n * @template {{ toString: () => string }} T\n * @param  {Array<T[]>} arrays\n */\nconst findCommonString = (arrays) => {\n  arrays = arrays.map(a => [...a])\n  for (const arr of arrays) {\n    for (const item of arr) {\n      let matched = true\n      for (const other of arrays) {\n        if (arr === other) continue\n        matched = other.some(i => String(i) === String(item))\n        if (!matched) break\n      }\n      if (matched) return item\n    }\n  }\n}\n\n/**\n * Find and sort events between the head(s) and the tail.\n * @param {EventFetcher<API.Operation>} events\n * @param {API.EventLink<API.Operation>[]} head\n * @param {API.EventLink<API.Operation>} tail\n */\nconst findSortedEvents = async (events, head, tail) => {\n  if (head.length === 1 && head[0].toString() === tail.toString()) {\n    return []\n  }\n\n  // get weighted events - heavier events happened first\n  /** @type {Map<string, { event: API.EventBlockView<API.Operation>, weight: number }>} */\n  const weights = new Map()\n  const all = await Promise.all(head.map(h => findEvents(events, h, tail)))\n  for (const arr of all) {\n    for (const { event, depth } of arr) {\n      const info = weights.get(event.cid.toString())\n      if (info) {\n        info.weight += depth\n      } else {\n        weights.set(event.cid.toString(), { event, weight: depth })\n      }\n    }\n  }\n\n  // group events into buckets by weight\n  /** @type {Map<number, API.EventBlockView<API.Operation>[]>} */\n  const buckets = new Map()\n  for (const { event, weight } of weights.values()) {\n    const bucket = buckets.get(weight)\n    if (bucket) {\n      bucket.push(event)\n    } else {\n      buckets.set(weight, [event])\n    }\n  }\n\n  // sort by weight, and by CID within weight\n  return Array.from(buckets)\n    .sort((a, b) => b[0] - a[0])\n    .flatMap(([, es]) => es.sort((a, b) => String(a.cid) < String(b.cid) ? -1 : 1))\n}\n\n/**\n * @param {EventFetcher<API.Operation>} events\n * @param {API.EventLink<API.Operation>} start\n * @param {API.EventLink<API.Operation>} end\n * @returns {Promise<Array<{ event: API.EventBlockView<API.Operation>, depth: number }>>}\n */\nconst findEvents = async (events, start, end, depth = 0) => {\n  const event = await events.get(start)\n  const acc = [{ event, depth }]\n  const { parents } = event.value\n  if (parents.length === 1 && String(parents[0]) === String(end)) return acc\n  const rest = await Promise.all(parents.map(p => findEvents(events, p, end, depth + 1)))\n  return acc.concat(...rest)\n}\n","// eslint-disable-next-line no-unused-vars\nimport * as API from './api.js'\nimport * as Shard from '../../shard.js'\nimport { ShardFetcher, ShardBlock } from '../../shard.js'\nimport * as Batch from '../../batch/index.js'\nimport { BatchCommittedError } from '../../batch/index.js'\nimport * as CRDT from '../index.js'\nimport * as Clock from '../../clock/index.js'\nimport { EventBlock } from '../../clock/index.js'\nimport { MemoryBlockstore, MultiBlockFetcher } from '../../block.js'\n\nexport { BatchCommittedError }\n\n/** @implements {API.CRDTBatcher} */\nclass Batcher {\n  #committed = false\n\n  /**\n   * @param {object} init\n   * @param {API.BlockFetcher} init.blocks Block storage.\n   * @param {API.EventLink<API.Operation>[]} init.head Merkle clock head.\n   * @param {API.BatcherShardEntry[]} init.entries The entries in this shard.\n   * @param {string} init.prefix Key prefix.\n   * @param {number} init.version Shard compatibility version.\n   * @param {string} init.keyChars Characters allowed in keys, referring to a known character set.\n   * @param {number} init.maxKeySize Max key size in bytes.\n   * @param {API.ShardBlockView} init.base Original shard this batcher is based on.\n   * @param {API.ShardBlockView[]} init.additions Additions to include in the committed batch.\n   * @param {API.ShardBlockView[]} init.removals Removals to include in the committed batch.\n   */\n  constructor ({ blocks, head, entries, prefix, version, keyChars, maxKeySize, base, additions, removals }) {\n    this.blocks = blocks\n    this.head = head\n    this.prefix = prefix\n    this.entries = [...entries]\n    this.base = base\n    this.version = version\n    this.keyChars = keyChars\n    this.maxKeySize = maxKeySize\n    this.additions = additions\n    this.removals = removals\n    /** @type {API.BatchOperation['ops']} */\n    this.ops = []\n  }\n\n  /**\n   * @param {string} key The key of the value to put.\n   * @param {API.UnknownLink} value The value to put.\n   * @returns {Promise<void>}\n   */\n  async put (key, value) {\n    if (this.#committed) throw new BatchCommittedError()\n    await Batch.put(this.blocks, this, key, value)\n    this.ops.push({ type: 'put', key, value })\n  }\n\n  async commit () {\n    if (this.#committed) throw new BatchCommittedError()\n    this.#committed = true\n\n    const res = await Batch.commit(this)\n\n    /** @type {API.Operation} */\n    const data = { type: 'batch', ops: this.ops, root: res.root }\n    const event = await EventBlock.create(data, this.head)\n\n    const mblocks = new MemoryBlockstore()\n    const blocks = new MultiBlockFetcher(mblocks, this.blocks)\n    mblocks.putSync(event.cid, event.bytes)\n\n    const head = await Clock.advance(blocks, this.head, event.cid)\n\n    /** @type {Map<string, API.ShardBlockView>} */\n    const additions = new Map()\n    /** @type {Map<string, API.ShardBlockView>} */\n    const removals = new Map()\n\n    for (const a of this.additions) {\n      additions.set(a.cid.toString(), a)\n    }\n    for (const r of this.removals) {\n      removals.set(r.cid.toString(), r)\n    }\n\n    for (const a of res.additions) {\n      if (removals.has(a.cid.toString())) {\n        removals.delete(a.cid.toString())\n      }\n      additions.set(a.cid.toString(), a)\n    }\n    for (const r of res.removals) {\n      if (additions.has(r.cid.toString())) {\n        additions.delete(r.cid.toString())\n      } else {\n        removals.set(r.cid.toString(), r)\n      }\n    }\n\n    return {\n      head,\n      event,\n      root: res.root,\n      additions: [...additions.values()],\n      removals: [...removals.values()]\n    }\n  }\n\n  /**\n   * @param {object} init\n   * @param {API.BlockFetcher} init.blocks Block storage.\n   * @param {API.EventLink<API.Operation>[]} init.head Merkle clock head.\n   */\n  static async create ({ blocks, head }) {\n    const mblocks = new MemoryBlockstore()\n    blocks = new MultiBlockFetcher(mblocks, blocks)\n\n    if (!head.length) {\n      const base = await ShardBlock.create()\n      mblocks.putSync(base.cid, base.bytes)\n      return new Batcher({\n        blocks,\n        head,\n        entries: [],\n        base,\n        additions: [base],\n        removals: [],\n        ...Shard.configure(base.value)\n      })\n    }\n\n    const { root, additions, removals } = await CRDT.root(blocks, head)\n    for (const a of additions) {\n      mblocks.putSync(a.cid, a.bytes)\n    }\n\n    const shards = new ShardFetcher(blocks)\n    const base = await shards.get(root)\n    return new Batcher({\n      blocks,\n      head,\n      entries: base.value.entries,\n      base,\n      additions,\n      removals,\n      ...Shard.configure(base.value)\n    })\n  }\n}\n\n/**\n * @param {API.BlockFetcher} blocks Bucket block storage.\n * @param {API.EventLink<API.Operation>[]} head Merkle clock head.\n * @returns {Promise<API.CRDTBatcher>}\n */\nexport const create = (blocks, head) => Batcher.create({ blocks, head })\n","export * from \"./types.js\";\n\nexport * from \"./store-factory.js\";\nexport * from \"./gateway.js\";\nexport * from \"./fragment-gateway.js\";\n\nimport { type Connectable } from \"./connection-base.js\";\nexport { Connectable };\n\n// import { type CarClockHead, type DbMetaEventBlock } from \"./types.js\";\n// export { CarClockHead, DbMetaEventBlock };\n\nexport { EncryptedBlockstore, BaseBlockstore, CompactionFetcher, type BlockFetcher, CarTransaction } from \"./transaction.js\";\nexport { Loader } from \"./loader.js\";\nexport { parseCarFile } from \"./loader-helpers.js\";\nexport { ConnectionBase } from \"./connection-base.js\";\nexport { setCryptoKeyFromGatewayMetaPayload, addCryptoKeyToGatewayMetaPayload } from \"./store-meta.js\";\n","import type { CID, Link, Version } from \"multiformats\";\nimport type { BlockCodec } from \"../runtime/wait-pr-multiformats/codec-interface\";\nimport { DocFileMeta, Falsy, StoreType, SuperThis } from \"../types.js\";\nimport { BlockFetcher, CarTransaction } from \"./transaction.js\";\nimport { Logger, Result } from \"../utils.js\";\nimport { CommitQueue } from \"./commit-queue.js\";\nimport { KeyBagOpts } from \"../runtime/key-bag.js\";\nimport { CoerceURI, CryptoRuntime, CTCryptoKey, URI } from \"@adviser/cement\";\nimport { EventBlock } from \"@web3-storage/pail/clock\";\nimport { TaskManager } from \"./task-manager\";\n\nexport type AnyLink = Link<unknown, number, number, Version>;\nexport type CarGroup = AnyLink[];\nexport type CarLog = CarGroup[];\nexport type AnyAnyLink = Link<unknown, number, number, Version>;\n\nexport type AnyLinkFn = (cid: AnyLink) => Promise<AnyBlock | undefined>;\n\nexport interface AnyBlock {\n  readonly cid: Link<unknown, number, number, Version>;\n  readonly bytes: Uint8Array;\n}\n\nexport interface CIDBlock {\n  readonly cid: CID<unknown, number, number, Version>;\n  readonly bytes: Uint8Array;\n}\n\nexport function toCIDBlock(block: AnyBlock): CIDBlock {\n  return block as CIDBlock;\n}\nexport interface AnyAnyBlock {\n  readonly cid: AnyAnyLink;\n  readonly bytes: Uint8Array;\n}\n\n// export interface EncryptOpts {\n//   readonly key: ArrayBuffer;\n//   readonly cid: AnyLink;\n//   readonly bytes: Uint8Array;\n// }\n\nexport interface IvKeyIdData {\n  readonly iv: Uint8Array;\n  readonly keyId: Uint8Array;\n  readonly data: Uint8Array;\n}\n\nexport interface IvAndBytes {\n  readonly bytes: Uint8Array;\n  readonly iv: Uint8Array;\n}\n\nexport interface BytesWithIv {\n  readonly bytes: Uint8Array;\n  readonly iv?: Uint8Array;\n}\n\n// export interface DecryptOpts {\n//   readonly key: ArrayBuffer;\n//   readonly value: IvAndBytes;\n// }\n\nexport interface AnyDecodedBlock {\n  readonly cid: AnyLink;\n  readonly bytes: Uint8Array;\n  readonly value: Uint8Array;\n}\n\nexport interface CarMakeable {\n  entries(): Iterable<AnyBlock>;\n  get(cid: AnyLink): Promise<AnyBlock | undefined>;\n}\n\nexport interface CarHeader<T> {\n  readonly cars: CarLog;\n  readonly compact: CarLog;\n  readonly meta: T;\n}\n\n// type NestedData =\n//   | Uint8Array\n//   | string\n//   | number\n//   | boolean\n//   | undefined\n//   | null\n//   | AnyLink\n//   | NestedData[]\n//   | { [key: string]: NestedData };\n\nexport interface TransactionWrapper<M extends TransactionMeta> {\n  meta: M;\n  cars?: CarGroup;\n  t: CarTransaction;\n}\n\nexport type TransactionMeta = unknown;\n//CRDTMeta | IndexTransactionMeta | FileTransactionMeta;\n\n// export interface MakeCodecCrypto {\n//   subtle: {\n//     decrypt: (algo: { name: string; iv: Uint8Array; tagLength: number }, key: CryptoKey, data: Uint8Array) => Promise<ArrayBuffer>;\n//     encrypt: (algo: { name: string; iv: Uint8Array; tagLength: number }, key: CryptoKey, data: Uint8Array) => Promise<ArrayBuffer>;\n//   };\n// }\n\n// an implementation of this Interface contains the keymaterial\n// so that the fp-core can use the decrypt and encrypt without knowing the key\nexport interface EncryptedBlock {\n  readonly value: IvAndBytes;\n}\n\nexport interface KeyMaterial {\n  readonly key: Uint8Array;\n  readonly keyStr: string;\n}\n\nexport interface KeyWithFingerPrint {\n  readonly fingerPrint: string;\n  readonly key: CTCryptoKey;\n}\n\nexport interface KeyWithFingerExtract extends KeyWithFingerPrint {\n  extract(): Promise<KeyMaterial>;\n}\n\nexport interface CodecOpts {\n  readonly ivCalc: \"random\" | \"hash\";\n  readonly noIVVerify: boolean;\n}\nexport interface KeyedCrypto {\n  readonly ivLength: number; // in bytes only 12 and 16 are allowed\n  readonly logger: Logger;\n  readonly crypto: CryptoRuntime;\n  readonly url: URI;\n  // readonly codec: BlockCodec<number, IvAndBytes>;\n  // readonly isEncrypting: boolean;\n  fingerPrint(): Promise<string>;\n  algo(iv?: Uint8Array): { name: string; iv: Uint8Array; tagLength: number };\n  codec(iv?: Uint8Array, codecOpts?: Partial<CodecOpts>): BlockCodec<number, Uint8Array>;\n  _decrypt(data: IvAndBytes): Promise<Uint8Array>;\n  _encrypt(data: BytesWithIv): Promise<Uint8Array>;\n  // encode(data: Uint8Array): Promise<Uint8Array>;\n  // decode(bytes: Uint8Array | ArrayBuffer): Promise<Uint8Array>;\n}\n\nexport interface BlobLike {\n  /**\n   * Returns a ReadableStream which yields the Blob data.\n   */\n  stream: () => ReadableStream;\n}\n\nexport interface StoreFactory {\n  makeMetaStore?: (loader: Loadable) => Promise<MetaStore>;\n  makeDataStore?: (loader: Loadable) => Promise<DataStore>;\n  makeWALStore?: (loader: Loadable) => Promise<WALStore>;\n\n  encodeFile?: (blob: BlobLike) => Promise<{ cid: AnyLink; blocks: AnyBlock[] }>;\n  decodeFile?: (blocks: unknown, cid: AnyLink, meta: DocFileMeta) => Promise<File>;\n}\n\nexport interface StoreOpts extends StoreFactory {\n  readonly isIndex?: string; // index prefix\n  readonly stores?: {\n    // string means local storage\n    // URL means schema selects the storeType\n    readonly base?: CoerceURI;\n\n    readonly meta?: CoerceURI;\n    readonly data?: CoerceURI;\n    readonly index?: CoerceURI;\n    readonly wal?: CoerceURI;\n  };\n}\n\nexport interface StoreRuntime {\n  // the factories should produce ready-to-use stores\n  // which means they have to call start() on the store\n  // to fullfill lifecycle requirements\n  // to release resources, like one database connection\n  // for all stores a refcount on close() should be used\n  makeMetaStore(loader: Loadable): Promise<MetaStore>;\n  makeDataStore(loader: Loadable): Promise<DataStore>;\n  makeWALStore(loader: Loadable): Promise<WALStore>;\n  encodeFile(blob: BlobLike): Promise<{ cid: AnyLink; blocks: AnyBlock[] }>;\n  decodeFile(blocks: unknown, cid: AnyLink, meta: DocFileMeta): Promise<File>;\n}\n\nexport interface CommitOpts {\n  readonly noLoader?: boolean;\n  readonly compact?: boolean;\n  // readonly public?: boolean;\n}\n\nexport interface DbMeta {\n  readonly cars: CarGroup;\n  key?: string;\n}\n\n// export interface UploadMetaFnParams {\n//   readonly name: string;\n//   readonly branch: string;\n// }\n\n// export type FnParamTypes = \"data\" | \"file\";\n\n// export interface UploadDataFnParams {\n//   readonly type: FnParamTypes;\n//   readonly name: string;\n//   readonly car: string;\n//   readonly size: string;\n// }\n\n// export interface DownloadDataFnParams {\n//   readonly type: FnParamTypes;\n//   readonly name: string;\n//   readonly car: string;\n// }\n\n// export interface DownloadMetaFnParams {\n//   readonly name: string;\n//   readonly branch: string;\n// }\n\nexport type LoadHandler = (dbMetas: DbMeta[]) => Promise<void>;\n\nexport interface Connection {\n  readonly loader?: Loadable;\n  readonly loaded: Promise<void>;\n  connectMeta_X({ loader }: { loader?: Loadable }): void;\n  connectStorage_X({ loader }: { loader?: Loadable }): void;\n\n  // metaUpload(bytes: Uint8Array, params: UploadMetaFnParams): Promise<Uint8Array[] | Falsy>;\n  // dataUpload(bytes: Uint8Array, params: UploadDataFnParams, opts?: { public?: boolean }): Promise<void>;\n  // metaDownload(params: DownloadMetaFnParams): Promise<Uint8Array[] | Falsy>;\n  // dataDownload(params: DownloadDataFnParams): Promise<Uint8Array | Falsy>;\n}\n\nexport interface BaseStore {\n  readonly storeType: StoreType;\n  // readonly url: URI\n  url(): URI;\n  readonly name: string;\n  onStarted(fn: () => void): void;\n  onClosed(fn: () => void): void;\n\n  keyedCrypto(): Promise<KeyedCrypto>;\n\n  close(): Promise<Result<void>>;\n  destroy(): Promise<Result<void>>;\n  readonly ready?: () => Promise<void>;\n  start(): Promise<Result<URI>>;\n}\n\nexport interface MetaStore extends BaseStore {\n  readonly storeType: \"meta\";\n  load(branch?: string): Promise<DbMeta[] | Falsy>;\n  // branch is defaulted to \"main\"\n  save(meta: DbMeta, branch?: string): Promise<Result<void>>;\n  handleByteHeads(byteHeads: Uint8Array, branch?: string): Promise<{ eventCid: CarClockLink; dbMeta: DbMeta }[]>;\n}\n\nexport interface DataSaveOpts {\n  readonly public: boolean;\n}\n\nexport interface DataStore extends BaseStore {\n  readonly storeType: \"data\";\n  load(cid: AnyLink): Promise<AnyBlock>;\n  save(car: AnyBlock, opts?: DataSaveOpts): Promise</*AnyLink | */ void>;\n  remove(cid: AnyLink): Promise<Result<void>>;\n}\n\nexport interface WALState {\n  operations: DbMeta[];\n  noLoaderOps: DbMeta[];\n  fileOperations: {\n    readonly cid: AnyLink;\n    readonly public: boolean;\n  }[];\n}\n\nexport interface WALStore extends BaseStore {\n  readonly storeType: \"wal\";\n  ready: () => Promise<void>;\n  readonly processing?: Promise<void> | undefined;\n  readonly processQueue: CommitQueue<void>;\n\n  process(): Promise<void>;\n  enqueue(dbMeta: DbMeta, opts: CommitOpts): Promise<void>;\n  enqueueFile(fileCid: AnyLink /*, publicFile?: boolean*/): Promise<void>;\n  load(): Promise<WALState | Falsy>;\n  save(state: WALState): Promise<void>;\n}\n\nexport type CompactFetcher = BlockFetcher & {\n  readonly loggedBlocks: CarTransaction;\n};\nexport type CompactFn = (blocks: CompactFetcher) => Promise<TransactionMeta>;\n\nexport type BlockstoreOpts = Partial<{\n  readonly logger: Logger;\n  readonly applyMeta: (meta: TransactionMeta, snap?: boolean) => Promise<void>;\n  readonly compact: CompactFn;\n  readonly autoCompact: number;\n  readonly crypto: CryptoRuntime;\n  readonly store: StoreOpts;\n  readonly keyBag: KeyBagOpts;\n  readonly public: boolean;\n  readonly meta: DbMeta;\n  readonly name: string;\n  readonly threshold: number;\n}>;\n\nexport interface BlockstoreRuntime {\n  readonly logger: Logger;\n  readonly applyMeta: (meta: TransactionMeta, snap?: boolean) => Promise<void>;\n  readonly compact: CompactFn;\n  readonly autoCompact: number;\n  readonly crypto: CryptoRuntime;\n  readonly store: StoreOpts;\n  readonly storeRuntime: StoreRuntime;\n  readonly keyBag: Partial<KeyBagOpts>;\n  // readonly public: boolean;\n  readonly meta?: DbMeta;\n  readonly name?: string;\n  readonly threshold: number;\n}\n\nexport interface Loadable {\n  readonly name: string; // = \"\";\n  readonly sthis: SuperThis;\n  readonly ebOpts: BlockstoreRuntime;\n  remoteCarStore?: DataStore;\n  carStore(): Promise<DataStore>;\n  carLog: CarLog; // = new Array<CarGroup>();\n  remoteMetaStore?: MetaStore;\n  remoteFileStore?: DataStore;\n  taskManager?: TaskManager;\n  ready(): Promise<void>;\n  close(): Promise<void>;\n  fileStore(): Promise<DataStore>;\n  WALStore(): Promise<WALStore>;\n  handleDbMetasFromStore(metas: DbMeta[]): Promise<void>;\n}\n\nexport type DbMetaEventBlock = EventBlock<{ dbMeta: Uint8Array }>;\nexport type CarClockLink = Link<DbMetaEventBlock, number, number, Version>;\nexport type CarClockHead = CarClockLink[];\n","import { Logger, KeyedResolvOnce, CoerceURI, URI, Result } from \"@adviser/cement\";\n\nimport { decodeFile, encodeFile } from \"../runtime/files.js\";\nimport { DataStoreImpl, WALStoreImpl } from \"./store.js\";\nimport { MetaStoreImpl } from \"./store-meta.js\";\nimport { Loadable, StoreOpts, StoreRuntime } from \"./types.js\";\nimport { dataDir, ensureLogger, ensureSuperLog } from \"../utils.js\";\nimport { Gateway, TestGateway } from \"./gateway.js\";\nimport { getKeyBag } from \"../runtime/key-bag.js\";\nimport { SuperThis } from \"../types.js\";\n\nfunction ensureIsIndex(url: URI, isIndex?: string): URI {\n  if (isIndex) {\n    return url.build().setParam(\"index\", isIndex).URI();\n  }\n  return url.build().delParam(\"index\").URI();\n}\n\nfunction ensureName(name: string, url: URI): URI {\n  if (!url.hasParam(\"name\")) {\n    return url.build().setParam(\"name\", name).URI();\n  }\n  return url;\n}\n\nexport interface GatewayFactoryItem {\n  readonly protocol: string;\n  readonly overrideBaseURL?: string; // if this set it overrides the defaultURL\n  readonly overrideRegistration?: boolean; // if this is set, it will override the registration\n\n  readonly gateway: (sthis: SuperThis) => Promise<Gateway>;\n  readonly test: (sthis: SuperThis) => Promise<TestGateway>;\n  // which switches between file and indexdb\n  // readonly data: (logger: Logger) => Promise<Gateway>;\n  // readonly meta: (logger: Logger) => Promise<Gateway>;\n  // readonly wal: (logger: Logger) => Promise<Gateway>;\n  // readonly test: (logger: Logger) => Promise<TestStore>;\n}\n\nconst storeFactory = new Map<string, GatewayFactoryItem>();\n\nfunction buildURL(optURL: CoerceURI, loader: Loadable): URI {\n  const storeOpts = loader.ebOpts.store;\n  const obuItem = Array.from(storeFactory.values()).find((items) => items.overrideBaseURL);\n  let obuUrl: URI | undefined;\n  if (obuItem && obuItem.overrideBaseURL) {\n    obuUrl = URI.from(obuItem.overrideBaseURL);\n  }\n  const ret = ensureIsIndex(\n    URI.from(optURL || obuUrl || dataDir(loader.sthis, loader.name, storeOpts.stores?.base)),\n    storeOpts.isIndex,\n  );\n  // console.log(\"buildURL\", storeOpts.isIndex);\n  return ret;\n}\n\ninterface GatewayReady {\n  readonly gateway: Gateway;\n  readonly test: TestGateway;\n}\nconst onceGateway = new KeyedResolvOnce<GatewayReady>();\nexport async function getGatewayFromURL(url: URI, sthis: SuperThis): Promise<GatewayReady | undefined> {\n  return onceGateway.get(url.toString()).once(async () => {\n    const item = storeFactory.get(url.protocol);\n    if (item) {\n      const ret = {\n        gateway: await item.gateway(sthis),\n        test: await item.test(sthis),\n      };\n      const res = await ret.gateway.start(url);\n      if (res.isErr()) {\n        sthis.logger.Error().Result(\"start\", res).Msg(\"start failed\");\n        return undefined;\n      }\n      return ret;\n    }\n    sthis.logger.Warn().Url(url).Msg(\"unsupported protocol\");\n    return undefined;\n  });\n}\n\nexport function registerStoreProtocol(item: GatewayFactoryItem): () => void {\n  let protocol = item.protocol;\n  if (!protocol.endsWith(\":\")) {\n    protocol += \":\";\n  }\n  if (storeFactory.has(protocol)) {\n    if (!item.overrideBaseURL && storeFactory.get(protocol) !== item) {\n      throw new Error(`we need a logger here`);\n      // const logger = ensureLogger(sthis, \"registerStoreProtocol\", { protocol });\n      // logger.Warn().Msg(`protocol ${protocol} already registered`);\n      return () => {\n        /* no-op */\n      };\n    }\n  }\n  // we need to clear the overrideBaseURL if it is set\n  if (item.overrideBaseURL) {\n    Array.from(storeFactory.values()).forEach((items) => {\n      (\n        items as {\n          overrideBaseURL?: string;\n        }\n      ).overrideBaseURL = undefined;\n    });\n  }\n  storeFactory.set(protocol, item);\n  return () => {\n    storeFactory.delete(protocol);\n  };\n}\n\n// function runStoreFactory<T>(url: URI, logger: Logger, run: (item: StoreFactoryItem) => Promise<T>): Promise<T> {\n//   // const store = url.getParam(\"store\");\n//   // if (!store) {\n//   //   throw logger.Error().Url(url).Msg(\"store not found\").AsError();\n//   // }\n//   // const key = `${url.protocol}:${store}`;\n//   const item = storeFactory.get(url.protocol);\n//   if (!item) {\n//     throw logger\n//       .Error()\n//       .Url(url.asURL())\n//       .Str(\"protocol\", url.protocol)\n//       .Any(\"keys\", Array(storeFactory.keys()))\n//       .Msg(`unsupported protocol`)\n//       .AsError();\n//   }\n//   logger.Debug().Str(\"protocol\", url.protocol).Msg(\"run\");\n//   return run(item);\n// }\n\n// const onceLoadDataGateway = new KeyedResolvOnce<Gateway>();\n// function loadDataGateway(url: URI, logger: Logger) {\n//   return onceLoadDataGateway.get(url.protocol).once(async () => {\n//     return await getGatewayFromURL(url, logger).then((item) => {\n//       if (!item) {\n//         throw logger.Error().Url(url).Msg(\"unsupported protocol or store\").AsError();\n//       }\n//       return item;\n//     });\n//   })\n// }\n\nconst onceDataStoreFactory = new KeyedResolvOnce<DataStoreImpl>();\nasync function dataStoreFactory(loader: Loadable): Promise<DataStoreImpl> {\n  const url = ensureName(loader.name, buildURL(loader.ebOpts.store.stores?.data, loader)).build().setParam(\"store\", \"data\").URI();\n  const sthis = ensureSuperLog(loader.sthis, \"dataStoreFactory\", { url: url.toString() });\n  return onceDataStoreFactory.get(url.toString()).once(async () => {\n    const gateway = await getGatewayFromURL(url, sthis);\n    if (!gateway) {\n      throw sthis.logger.Error().Url(url).Msg(\"gateway not found\").AsError();\n    }\n    const store = new DataStoreImpl(sthis, loader.name, url, {\n      gateway: gateway.gateway,\n      keybag: () =>\n        getKeyBag(loader.sthis, {\n          ...loader.ebOpts.keyBag,\n        }),\n    });\n    return store;\n  });\n}\n\n// const onceLoadMetaGateway = new KeyedResolvOnce<Gateway>();\n// function loadMetaGateway(url: URI, logger: Logger) {\n//   return onceLoadMetaGateway.get(url.protocol).once(async () => {\n//     return await getGatewayFromURL(url, logger).then((item) => {\n//       if (!item) {\n//         throw logger.Error().Url(url).Msg(\"unsupported protocol or store\").AsError();\n//       }\n//       return item;\n//     });\n//   });\n// }\n\nconst onceMetaStoreFactory = new KeyedResolvOnce<MetaStoreImpl>();\nasync function metaStoreFactory(loader: Loadable): Promise<MetaStoreImpl> {\n  const url = ensureName(loader.name, buildURL(loader.ebOpts.store.stores?.meta, loader)).build().setParam(\"store\", \"meta\").URI();\n  const sthis = ensureSuperLog(loader.sthis, \"metaStoreFactory\", { url: () => url.toString() });\n  return onceMetaStoreFactory.get(url.toString()).once(async () => {\n    sthis.logger.Debug().Str(\"protocol\", url.protocol).Msg(\"pre-protocol switch\");\n    const gateway = await getGatewayFromURL(url, sthis);\n    if (!gateway) {\n      throw sthis.logger.Error().Url(url).Msg(\"gateway not found\").AsError();\n    }\n    const store = new MetaStoreImpl(loader.sthis, loader.name, url, {\n      gateway: gateway.gateway,\n      keybag: () =>\n        getKeyBag(loader.sthis, {\n          ...loader.ebOpts.keyBag,\n        }),\n    });\n    // const ret = await store.start();\n    // if (ret.isErr()) {\n    //   throw logger.Error().Result(\"start\", ret).Msg(\"start failed\").AsError();\n    // }\n    // logger.Debug().Url(ret.Ok(), \"prepared\").Msg(\"produced\");\n    return store;\n  });\n}\n\n// const onceWalGateway = new KeyedResolvOnce<Gateway>();\n// function loadWalGateway(url: URI, logger: Logger) {\n//   return onceWalGateway.get(url.protocol).once(async () => {\n//     return await getGatewayFromURL(url, logger).then((item) => {\n//       if (!item) {\n//         throw logger.Error().Url(url).Msg(\"unsupported protocol or store\").AsError();\n//       }\n//       return item;\n//     });\n//   });\n// }\n\nconst onceRemoteWalFactory = new KeyedResolvOnce<WALStoreImpl>();\nasync function remoteWalFactory(loader: Loadable): Promise<WALStoreImpl> {\n  const url = ensureName(loader.name, buildURL(loader.ebOpts.store.stores?.wal, loader)).build().setParam(\"store\", \"wal\").URI();\n  const sthis = ensureSuperLog(loader.sthis, \"remoteWalFactory\", { url: url.toString() });\n  return onceRemoteWalFactory.get(url.toString()).once(async () => {\n    const gateway = await getGatewayFromURL(url, sthis);\n    if (!gateway) {\n      throw sthis.logger.Error().Url(url).Msg(\"gateway not found\").AsError();\n    }\n    sthis.logger.Debug().Str(\"prepared\", url.toString()).Msg(\"produced\");\n    const store = new WALStoreImpl(loader, url, {\n      gateway: gateway.gateway,\n      keybag: () =>\n        getKeyBag(loader.sthis, {\n          ...loader.ebOpts.keyBag,\n        }),\n    });\n    // const ret = await store.start();\n    // if (ret.isErr()) {\n    //   throw logger.Error().Result(\"start\", ret).Msg(\"start failed\").AsError();\n    // }\n    // logger.Debug().Url(ret.Ok(), \"prepared\").Msg(\"produced\");\n    return store;\n  });\n}\n\nexport async function testStoreFactory(url: URI, sthis: SuperThis): Promise<TestGateway> {\n  sthis = ensureSuperLog(sthis, \"testStoreFactory\");\n  const gateway = await getGatewayFromURL(url, sthis);\n  if (!gateway) {\n    throw sthis.logger.Error().Url(url).Msg(\"gateway not found\").AsError();\n  }\n  return gateway.test;\n}\n\nexport async function ensureStart<T>(store: T & { start: () => Promise<Result<URI>> }, logger: Logger): Promise<T> {\n  const ret = await store.start();\n  if (ret.isErr()) {\n    throw logger.Error().Result(\"start\", ret).Msg(\"start failed\").AsError();\n  }\n  logger.Debug().Url(ret.Ok(), \"prepared\").Msg(\"produced\");\n  return store;\n}\n\nexport function toStoreRuntime(opts: StoreOpts, sthis: SuperThis): StoreRuntime {\n  const logger = ensureLogger(sthis, \"toStoreRuntime\", {});\n  return {\n    makeMetaStore: async (loader: Loadable) => {\n      logger\n        .Debug()\n        .Str(\"fromOpts\", \"\" + !!loader.ebOpts.store.makeMetaStore)\n        .Msg(\"makeMetaStore\");\n      return ensureStart(await (loader.ebOpts.store.makeMetaStore || metaStoreFactory)(loader), logger);\n    },\n    makeDataStore: async (loader: Loadable) => {\n      logger\n        .Debug()\n        .Str(\"fromOpts\", \"\" + !!loader.ebOpts.store.makeDataStore)\n        .Msg(\"makeDataStore\");\n      return ensureStart(await (loader.ebOpts.store.makeDataStore || dataStoreFactory)(loader), logger);\n    },\n    makeWALStore: async (loader: Loadable) => {\n      logger\n        .Debug()\n        .Str(\"fromOpts\", \"\" + !!loader.ebOpts.store.makeWALStore)\n        .Msg(\"makeRemoteWAL\");\n      return ensureStart(await (loader.ebOpts.store.makeWALStore || remoteWalFactory)(loader), logger);\n    },\n\n    encodeFile: opts.encodeFile || encodeFile,\n    decodeFile: opts.decodeFile || decodeFile,\n  };\n}\n\nregisterStoreProtocol({\n  protocol: \"file:\",\n  gateway: async (sthis) => {\n    const { FileGateway } = await import(\"../runtime/gateways/file/gateway.js\");\n    return new FileGateway(sthis);\n  },\n  test: async (sthis) => {\n    const { FileTestStore } = await import(\"../runtime/gateways/file/gateway.js\");\n    return new FileTestStore(sthis);\n  },\n});\n\nregisterStoreProtocol({\n  protocol: \"indexdb:\",\n  gateway: async (sthis) => {\n    const { IndexDBGateway } = await import(\"../runtime/gateways/indexdb/gateway.js\");\n    return new IndexDBGateway(sthis);\n  },\n  test: async (sthis) => {\n    const { IndexDBTestStore } = await import(\"../runtime/gateways/indexdb/gateway.js\");\n    return new IndexDBTestStore(sthis);\n  },\n});\n","import * as UnixFS from \"@ipld/unixfs\";\nimport * as raw from \"multiformats/codecs/raw\";\nimport { withMaxChunkSize } from \"@ipld/unixfs/file/chunker/fixed\";\nimport { withWidth } from \"@ipld/unixfs/file/layout/balanced\";\n\nimport type { View } from \"@ipld/unixfs\";\nimport { DocFileMeta } from \"../types.js\";\n\nimport { exporter, ReadableStorage } from \"ipfs-unixfs-exporter\";\nimport { BlobLike, AnyLink, AnyBlock } from \"../blockstore/index.js\";\n\nconst queuingStrategy = UnixFS.withCapacity();\n\nconst settings = UnixFS.configure({\n  fileChunkEncoder: raw,\n  smallFileEncoder: raw,\n  chunker: withMaxChunkSize(1024 * 1024),\n  fileLayout: withWidth(1024),\n});\n\nasync function collect<T>(collectable: ReadableStream<T>): Promise<T[]> {\n  const chunks: T[] = [];\n  await collectable.pipeTo(\n    new WritableStream({\n      write(chunk) {\n        chunks.push(chunk);\n      },\n    }),\n  );\n  return chunks;\n}\n\nexport async function encodeFile(blob: BlobLike): Promise<{ cid: AnyLink; blocks: AnyBlock[] }> {\n  const readable = createFileEncoderStream(blob);\n  const blocks = await collect(readable);\n  return { cid: blocks.at(-1).cid, blocks };\n}\n\nexport async function decodeFile(blocks: unknown, cid: AnyLink, meta: DocFileMeta): Promise<File> {\n  const entry = await exporter(cid.toString(), blocks as ReadableStorage, { length: meta.size });\n  const chunks = [];\n  for await (const chunk of entry.content()) {\n    chunks.push(chunk);\n  }\n  return new File(chunks, entry.name, { type: meta.type, lastModified: 0 });\n}\n\nfunction createFileEncoderStream(blob: BlobLike) {\n  const { readable, writable } = new TransformStream({}, queuingStrategy);\n  const unixfsWriter = UnixFS.createWriter({ writable, settings });\n  const fileBuilder = new UnixFSFileBuilder(\"\", blob);\n  void (async () => {\n    await fileBuilder.finalize(unixfsWriter);\n    await unixfsWriter.close();\n  })();\n  return readable;\n}\n\nclass UnixFSFileBuilder {\n  #file;\n  readonly name: string;\n  constructor(name: string, file: BlobLike) {\n    this.name = name;\n    this.#file = file;\n  }\n\n  async finalize(writer: View) {\n    const unixfsFileWriter = UnixFS.createFileWriter(writer);\n    await this.#file.stream().pipeTo(\n      new WritableStream({\n        async write(chunk) {\n          await unixfsFileWriter.write(chunk as Uint8Array);\n        },\n      }),\n    );\n    return await unixfsFileWriter.close();\n  }\n}\n","import * as PB from \"@ipld/dag-pb\"\nimport * as UnixFS from \"./unixfs.js\"\nimport { NodeType } from \"./unixfs.js\"\nimport { Data } from \"../gen/unixfs.js\"\n\nexport * from \"./unixfs.js\"\n\n/** @type {ReadonlyArray<any>} */\nconst EMPTY = Object.freeze([])\nconst EMPTY_BUFFER = new Uint8Array(0)\n\nconst BLANK = Object.freeze({})\nexport const DEFAULT_FILE_MODE = parseInt(\"0644\", 8)\nexport const DEFAULT_DIRECTORY_MODE = parseInt(\"0755\", 8)\n\nexport const code = PB.code\nexport const name = \"UnixFS\"\n\n/**\n * @param {UnixFS.IData} data\n * @param {ReadonlyArray<UnixFS.PBLink>} links\n */\nconst encodePB = (data, links) => {\n  Object(globalThis).debug && console.log({ data, links })\n\n  return PB.encode(\n    // We run through prepare as links need to be sorted by name which it will\n    // do.\n    PB.prepare({\n      Data: Data.encode(data).finish(),\n      // We can cast to mutable array as we know no mutation occurs there\n      Links:\n        /** @type {PB.PBLink[]} */ (links),\n    })\n  )\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.Raw}\n */\nexport const createRaw = content => ({\n  type: NodeType.Raw,\n  content,\n})\n\n/**\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createEmptyFile = metadata =>\n  createSimpleFile(EMPTY_BUFFER, metadata)\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createSimpleFile = (content, metadata) => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.FileChunk}\n */\nexport const createFileChunk = content => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.AdvancedFile}\n */\nexport const createAdvancedFile = (parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @returns {UnixFS.FileShard}\n */\nexport const createFileShard = parts => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n})\n\n/**\n * @deprecated\n * @param {Uint8Array} content\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ComplexFile}\n */\nexport const createComplexFile = (content, parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"complex\",\n  content,\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.DirectoryEntryLink[]} entries\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.FlatDirectory}\n */\nexport const createFlatDirectory = (entries, metadata) => ({\n  type: NodeType.Directory,\n  metadata: decodeMetadata(metadata),\n  entries,\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ShardedDirectory}\n */\nexport const createShardedDirectory = (\n  entries,\n  bitfield,\n  fanout,\n  hashType,\n  metadata = BLANK\n) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @returns {UnixFS.DirectoryShard}\n */\nexport const createDirectoryShard = (entries, bitfield, fanout, hashType) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n})\n\n/**\n *\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.Raw>}\n */\nexport const encodeRaw = content =>\n  encodePB(\n    {\n      Type: NodeType.Raw,\n      // TODO:\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      // @ts-ignore\n      blocksizes: EMPTY,\n    },\n    []\n  )\n\n/**\n * @param {UnixFS.File|UnixFS.FileChunk|UnixFS.FileShard} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile>}\n */\nexport const encodeFile = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  switch (node.layout) {\n    case \"simple\":\n      return encodeSimpleFile(node.content, metadata)\n    case \"advanced\":\n      return encodeAdvancedFile(node.parts, metadata)\n    case \"complex\":\n      return encodeComplexFile(node.content, node.parts, metadata)\n    default:\n      throw new TypeError(\n        `File with unknown layout \"${Object(node).layout}\" was passed`\n      )\n  }\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.FileChunk>}\n */\nexport const encodeFileChunk = content => encodeSimpleFile(content, BLANK)\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @returns {UnixFS.ByteView<UnixFS.FileShard>}\n */\nexport const encodeFileShard = parts =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.AdvancedFile>}\n */\nexport const encodeAdvancedFile = (parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n\n      ...encodeMetadata(metadata),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.DAGLink} dag\n * @returns {UnixFS.PBLink}\n */\nexport const encodeLink = dag => ({\n  Name: \"\",\n  Tsize: dag.dagByteLength,\n  // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161\n  Hash: dag.cid,\n})\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile>}\n */\n\nexport const encodeSimpleFile = (content, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      // adding empty file to both go-ipfs and js-ipfs produces block in\n      // which `Data` is omitted but filesize and blocksizes are present.\n      // For the sake of hash consistency we do the same.\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      blocksizes: [],\n      ...encodeMetadata(metadata),\n    },\n    []\n  )\n\n/**\n *\n * @param {Uint8Array} content\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.ComplexFile>}\n */\nexport const encodeComplexFile = (content, parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      Data: content,\n      filesize: content.byteLength + cumulativeContentByteLength(parts),\n      blocksizes: parts.map(contentByteLength),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.FlatDirectory} node\n * @returns {UnixFS.ByteView<UnixFS.FlatDirectory>}\n */\nexport const encodeDirectory = node =>\n  encodePB(\n    {\n      Type: node.type,\n      ...encodeDirectoryMetadata(node.metadata || BLANK),\n    },\n    node.entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {UnixFS.ShardedDirectory|UnixFS.DirectoryShard} node\n * @returns {UnixFS.ByteView<UnixFS.ShardedDirectory>}\n */\nexport const encodeHAMTShard = ({\n  bitfield,\n  fanout,\n  hashType,\n  entries,\n  metadata = BLANK,\n}) =>\n  encodePB(\n    {\n      Type: NodeType.HAMTShard,\n      Data: bitfield.byteLength > 0 ? bitfield : undefined,\n      fanout: readFanout(fanout),\n      hashType: readInt(hashType),\n\n      ...encodeDirectoryMetadata(metadata),\n    },\n    entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {number} n\n * @returns {number}\n */\nconst readFanout = n => {\n  if (Math.log2(n) % 1 === 0) {\n    return n\n  } else {\n    throw new TypeError(\n      `Expected hamt size to be a power of two instead got ${n}`\n    )\n  }\n}\n\n/**\n * @param {number} n\n * @returns {number}\n */\n\nconst readInt = n => {\n  if (Number.isInteger(n)) {\n    return n\n  } else {\n    throw new TypeError(`Expected an integer value instead got ${n}`)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n */\nconst readData = bytes => (bytes.byteLength > 0 ? bytes : undefined)\n\n/**\n * @param {Uint8Array} path\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.Symlink}\n */\nexport const createSymlink = (path, metadata = BLANK) => ({\n  type: NodeType.Symlink,\n  content: path,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.Symlink} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.Symlink>}\n */\nexport const encodeSymlink = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  // We do not include filesize on symlinks because that is what go-ipfs does\n  // when doing `ipfs add mysymlink`. js-ipfs on the other hand seems to store\n  // it, here we choose to follow go-ipfs\n  // @see https://explore.ipld.io/#/explore/QmPZ1CTc5fYErTH2XXDGrfsPsHicYXtkZeVojGycwAfm3v\n  // @see https://github.com/ipfs/js-ipfs-unixfs/issues/195\n  return encodePB(\n    {\n      Type: NodeType.Symlink,\n      Data: node.content,\n      ...encodeMetadata(metadata || BLANK),\n    },\n    []\n  )\n}\n\n/**\n * @template {UnixFS.Node} T\n * @param {T} node\n * @param {boolean} root\n */\nexport const encode = (node, root = true) => {\n  switch (node.type) {\n    case NodeType.Raw:\n      return encodeRaw(node.content)\n    case NodeType.File:\n      return encodeFile(node)\n    case NodeType.Directory:\n      return encodeDirectory(node)\n    case NodeType.HAMTShard:\n      return encodeHAMTShard(node)\n    case NodeType.Symlink:\n      return encodeSymlink(node)\n    default:\n      throw new Error(`Unknown node type ${Object(node).type}`)\n  }\n}\n\n/**\n * @param {UnixFS.ByteView<UnixFS.Node>} bytes\n * @returns {UnixFS.Node}\n */\nexport const decode = bytes => {\n  const pb = PB.decode(bytes)\n  const message = Data.decode(/** @type {Uint8Array} */ (pb.Data))\n\n  const {\n    Type: type,\n    Data: data,\n    mtime,\n    mode,\n    blocksizes,\n    ...rest\n  } = Data.toObject(message, {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false,\n  })\n  const metadata = {\n    ...(mode && { mode }),\n    ...decodeMtime(mtime),\n  }\n  /** @type {UnixFS.PBLink[]} */\n  const links = pb.Links\n\n  switch (message.Type) {\n    case NodeType.Raw:\n      return createRaw(data)\n    case NodeType.File:\n      if (links.length === 0) {\n        return new SimpleFileView(data, metadata)\n      } else if (data.byteLength === 0) {\n        return new AdvancedFileView(\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      } else {\n        return new ComplexFileView(\n          data,\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      }\n    case NodeType.Directory:\n      return createFlatDirectory(decodeDirectoryLinks(links), metadata)\n    case NodeType.HAMTShard:\n      return createShardedDirectory(\n        decodeDirectoryLinks(links),\n        data || EMPTY_BUFFER,\n        rest.fanout,\n        rest.hashType,\n        metadata\n      )\n    case NodeType.Symlink:\n      return createSymlink(data, metadata)\n    default:\n      throw new TypeError(`Unsupported node type ${message.Type}`)\n  }\n}\n\n/**\n * @param {UnixFS.UnixTime|undefined} mtime\n */\nconst decodeMtime = mtime =>\n  mtime == null\n    ? undefined\n    : {\n        mtime: { secs: mtime.Seconds, nsecs: mtime.FractionalNanoseconds || 0 },\n      }\n\n/**\n * @param {NodeType} type\n * @param {number[]|undefined} blocksizes\n */\nconst decodeBlocksizes = (type, blocksizes) => {\n  switch (type) {\n    case NodeType.File:\n      return blocksizes && blocksizes.length > 0 ? { blocksizes } : undefined\n    default:\n      return undefined\n  }\n}\n\n/**\n *\n * @param {number[]} blocksizes\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.FileLink[]}\n */\n\nconst decodeFileLinks = (blocksizes, links) => {\n  const parts = []\n  const length = blocksizes.length\n  let n = 0\n  while (n < length) {\n    parts.push(\n      /** @type {UnixFS.FileLink} */ ({\n        cid: links[n].Hash,\n        dagByteLength: links[n].Tsize || 0,\n        contentByteLength: blocksizes[n],\n      })\n    )\n  }\n  return parts\n}\n\n/**\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.DirectoryEntryLink[]}\n */\nconst decodeDirectoryLinks = links =>\n  links.map(\n    link =>\n      /** @type {UnixFS.DirectoryEntryLink} */ ({\n        cid: link.Hash,\n        name: link.Name || \"\",\n        dagByteLength: link.Tsize || 0,\n      })\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} links\n * @returns {number}\n */\nexport const cumulativeContentByteLength = links =>\n  links.reduce((size, link) => size + link.contentByteLength, 0)\n\n/**\n * @param {Uint8Array} root\n * @param {ReadonlyArray<UnixFS.DAGLink>} links\n * @returns {number}\n */\nexport const cumulativeDagByteLength = (root, links) =>\n  links.reduce((size, link) => size + link.dagByteLength, root.byteLength)\n\n/**\n *\n * @param {UnixFS.FileLink} link\n */\nconst contentByteLength = link => link.contentByteLength\n\n/**\n * @param {UnixFS.NamedDAGLink<unknown>} link\n * @returns {UnixFS.PBLink}\n */\nconst encodeNamedLink = ({ name, dagByteLength, cid }) => ({\n  Name: name,\n  Tsize: dagByteLength,\n  Hash: cid,\n})\n\n/**\n * @param {UnixFS.Metadata} metadata\n */\nexport const encodeDirectoryMetadata = metadata =>\n  encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE)\n\n/**\n * @param {UnixFS.Metadata} metadata\n * @param {UnixFS.Mode} defaultMode\n */\nexport const encodeMetadata = (\n  { mode, mtime },\n  defaultMode = DEFAULT_FILE_MODE\n) => ({\n  mode: mode != null ? encodeMode(mode, defaultMode) : undefined,\n  mtime: mtime != null ? encodeMTime(mtime) : undefined,\n})\n\n/**\n * @param {UnixFS.Metadata} [data]\n */\nexport const decodeMetadata = data =>\n  data == null\n    ? BLANK\n    : {\n        ...(data.mode == null ? undefined : { mode: decodeMode(data.mode) }),\n        ...(data.mtime == null ? undefined : { mtime: data.mtime }),\n      }\n\n/**\n * @param {UnixFS.MTime} mtime\n */\nconst encodeMTime = mtime => {\n  return mtime == null\n    ? undefined\n    : mtime.nsecs !== 0\n    ? { Seconds: mtime.secs, FractionalNanoseconds: mtime.nsecs }\n    : { Seconds: mtime.secs }\n}\n\n/**\n * @param {number} specifiedMode\n * @param {number} defaultMode\n */\nexport const encodeMode = (specifiedMode, defaultMode) => {\n  const mode = specifiedMode == null ? undefined : decodeMode(specifiedMode)\n  return mode === defaultMode || mode == null ? undefined : mode\n}\n\n/**\n * @param {UnixFS.Mode} mode\n * @returns {UnixFS.Mode}\n */\nconst decodeMode = mode => (mode & 0xfff) | (mode & 0xfffff000)\n\n/**\n * @param {{content?: Uint8Array, parts?: ReadonlyArray<UnixFS.FileLink>, metadata?: UnixFS.Metadata }} node\n * @returns {UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile}\n */\nexport const matchFile = ({\n  content = EMPTY_BUFFER,\n  parts = EMPTY,\n  metadata = BLANK,\n  ...rest\n}) => {\n  if (parts.length === 0) {\n    return new SimpleFileView(content, metadata)\n  } else if (content.byteLength === 0) {\n    return new AdvancedFileView(parts, metadata)\n  } else {\n    return new ComplexFileView(content, parts, metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.SimpleFile}\n */\nclass SimpleFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, metadata) {\n    this.content = content\n    this.metadata = metadata\n    /**\n     * @readonly\n     * @type {\"simple\"}\n     */\n    this.layout = \"simple\"\n    /**\n     * @readonly\n     * @type {NodeType.File}\n     */\n    this.type = NodeType.File\n  }\n\n  get filesize() {\n    return this.content.byteLength\n  }\n\n  encode() {\n    return encodeSimpleFile(this.content, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.AdvancedFile}\n */\nclass AdvancedFileView {\n  /**\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(parts, metadata) {\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"advanced\"} */\n  get layout() {\n    return \"advanced\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeAdvancedFile(this.parts, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.ComplexFile}\n */\nclass ComplexFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, parts, metadata) {\n    this.content = content\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"complex\"} */\n  get layout() {\n    return \"complex\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return this.content.byteLength + cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeComplexFile(this.content, this.parts, this.metadata)\n  }\n}\n\n/**\n * @param {UnixFS.File|UnixFS.Raw|UnixFS.FileChunk|UnixFS.FileShard|UnixFS.Symlink} node\n * @returns {number}\n */\nexport const filesize = node => {\n  switch (node.type) {\n    case NodeType.Raw:\n    case NodeType.Symlink:\n      return node.content.byteLength\n    case NodeType.File:\n      switch (node.layout) {\n        case \"simple\":\n          return node.content.byteLength\n        case \"advanced\":\n          return cumulativeContentByteLength(node.parts)\n        case \"complex\":\n          return (\n            node.content.byteLength + cumulativeContentByteLength(node.parts)\n          )\n      }\n    default:\n      return 0\n  }\n}\n","const textDecoder = new TextDecoder()\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[number, number]}\n */\nfunction decodeVarint (bytes, offset) {\n  let v = 0\n\n  for (let shift = 0; ; shift += 7) {\n    /* c8 ignore next 3 */\n    if (shift >= 64) {\n      throw new Error('protobuf: varint overflow')\n    }\n    /* c8 ignore next 3 */\n    if (offset >= bytes.length) {\n      throw new Error('protobuf: unexpected end of data')\n    }\n\n    const b = bytes[offset++]\n    v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)\n    if (b < 0x80) {\n      break\n    }\n  }\n  return [v, offset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[Uint8Array, number]}\n */\nfunction decodeBytes (bytes, offset) {\n  let byteLen\n  ;[byteLen, offset] = decodeVarint(bytes, offset)\n  const postOffset = offset + byteLen\n\n  /* c8 ignore next 3 */\n  if (byteLen < 0 || postOffset < 0) {\n    throw new Error('protobuf: invalid length')\n  }\n  /* c8 ignore next 3 */\n  if (postOffset > bytes.length) {\n    throw new Error('protobuf: unexpected end of data')\n  }\n\n  return [bytes.subarray(offset, postOffset), postOffset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} index\n * @returns {[number, number, number]}\n */\nfunction decodeKey (bytes, index) {\n  let wire\n  ;[wire, index] = decodeVarint(bytes, index)\n  // [wireType, fieldNum, newIndex]\n  return [wire & 0x7, wire >> 3, index]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBLink}\n */\nfunction decodeLink (bytes) {\n  /** @type {RawPBLink} */\n  const link = {}\n  const l = bytes.length\n  let index = 0\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (fieldNum === 1) {\n      if (link.Hash) {\n        throw new Error('protobuf: (PBLink) duplicate Hash section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)\n      }\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')\n      }\n\n      [link.Hash, index] = decodeBytes(bytes, index)\n    } else if (fieldNum === 2) {\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Name section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')\n      }\n\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      link.Name = textDecoder.decode(byts)\n    } else if (fieldNum === 3) {\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Tsize section')\n      }\n      if (wireType !== 0) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)\n      }\n\n      [link.Tsize, index] = decodeVarint(bytes, index)\n    } else {\n      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBLink) unexpected end of data')\n  }\n\n  return link\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBNode}\n */\nexport function decodeNode (bytes) {\n  const l = bytes.length\n  let index = 0\n  /** @type {RawPBLink[]|void} */\n  let links = undefined // eslint-disable-line no-undef-init\n  let linksBeforeData = false\n  /** @type {Uint8Array|void} */\n  let data = undefined // eslint-disable-line no-undef-init\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (wireType !== 2) {\n      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)\n    }\n\n    if (fieldNum === 1) {\n      if (data) {\n        throw new Error('protobuf: (PBNode) duplicate Data section')\n      }\n\n      [data, index] = decodeBytes(bytes, index)\n      if (links) {\n        linksBeforeData = true\n      }\n    } else if (fieldNum === 2) {\n      if (linksBeforeData) { // interleaved Links/Data/Links\n        throw new Error('protobuf: (PBNode) duplicate Links section')\n      } else if (!links) {\n        links = []\n      }\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      links.push(decodeLink(byts))\n    } else {\n      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBNode) unexpected end of data')\n  }\n\n  /** @type {RawPBNode} */\n  const node = {}\n  if (data) {\n    node.Data = data\n  }\n  node.Links = links || []\n  return node\n}\n","const textEncoder = new TextEncoder()\nconst maxInt32 = 2 ** 32\nconst maxUInt32 = 2 ** 31\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n// the encoders work backward from the end of the bytes array\n\n/**\n * encodeLink() is passed a slice of the parent byte array that ends where this\n * link needs to end, so it packs to the right-most part of the passed `bytes`\n *\n * @param {RawPBLink} link\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nfunction encodeLink (link, bytes) {\n  let i = bytes.length\n\n  if (typeof link.Tsize === 'number') {\n    if (link.Tsize < 0) {\n      throw new Error('Tsize cannot be negative')\n    }\n    if (!Number.isSafeInteger(link.Tsize)) {\n      throw new Error('Tsize too large for encoding')\n    }\n    i = encodeVarint(bytes, i, link.Tsize) - 1\n    bytes[i] = 0x18\n  }\n\n  if (typeof link.Name === 'string') {\n    const nameBytes = textEncoder.encode(link.Name)\n    i -= nameBytes.length\n    bytes.set(nameBytes, i)\n    i = encodeVarint(bytes, i, nameBytes.length) - 1\n    bytes[i] = 0x12\n  }\n\n  if (link.Hash) {\n    i -= link.Hash.length\n    bytes.set(link.Hash, i)\n    i = encodeVarint(bytes, i, link.Hash.length) - 1\n    bytes[i] = 0xa\n  }\n\n  return bytes.length - i\n}\n\n/**\n * Encodes a PBNode into a new byte array of precisely the correct size\n *\n * @param {RawPBNode} node\n * @returns {Uint8Array}\n */\nexport function encodeNode (node) {\n  const size = sizeNode(node)\n  const bytes = new Uint8Array(size)\n  let i = size\n\n  if (node.Data) {\n    i -= node.Data.length\n    bytes.set(node.Data, i)\n    i = encodeVarint(bytes, i, node.Data.length) - 1\n    bytes[i] = 0xa\n  }\n\n  if (node.Links) {\n    for (let index = node.Links.length - 1; index >= 0; index--) {\n      const size = encodeLink(node.Links[index], bytes.subarray(0, i))\n      i -= size\n      i = encodeVarint(bytes, i, size) - 1\n      bytes[i] = 0x12\n    }\n  }\n\n  return bytes\n}\n\n/**\n * work out exactly how many bytes this link takes up\n *\n * @param {RawPBLink} link\n * @returns\n */\nfunction sizeLink (link) {\n  let n = 0\n\n  if (link.Hash) {\n    const l = link.Hash.length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Name === 'string') {\n    const l = textEncoder.encode(link.Name).length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Tsize === 'number') {\n    n += 1 + sov(link.Tsize)\n  }\n\n  return n\n}\n\n/**\n * Work out exactly how many bytes this node takes up\n *\n * @param {RawPBNode} node\n * @returns {number}\n */\nfunction sizeNode (node) {\n  let n = 0\n\n  if (node.Data) {\n    const l = node.Data.length\n    n += 1 + l + sov(l)\n  }\n\n  if (node.Links) {\n    for (const link of node.Links) {\n      const l = sizeLink(link)\n      n += 1 + l + sov(l)\n    }\n  }\n\n  return n\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @param {number} v\n * @returns {number}\n */\nfunction encodeVarint (bytes, offset, v) {\n  offset -= sov(v)\n  const base = offset\n\n  while (v >= maxUInt32) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v /= 128\n  }\n\n  while (v >= 128) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v >>>= 7\n  }\n\n  bytes[offset] = v\n\n  return base\n}\n\n/**\n * size of varint\n *\n * @param {number} x\n * @returns {number}\n */\nfunction sov (x) {\n  if (x % 2 === 0) {\n    x++\n  }\n  return Math.floor((len64(x) + 6) / 7)\n}\n\n/**\n * golang math/bits, how many bits does it take to represent this integer?\n *\n * @param {number} x\n * @returns {number}\n */\nfunction len64 (x) {\n  let n = 0\n  if (x >= maxInt32) {\n    x = Math.floor(x / maxInt32)\n    n = 32\n  }\n  if (x >= (1 << 16)) {\n    x >>>= 16\n    n += 16\n  }\n  if (x >= (1 << 8)) {\n    x >>>= 8\n    n += 8\n  }\n  return n + len8tab[x]\n}\n\n// golang math/bits\nconst len8tab = [\n  0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8\n]\n","import { CID } from 'multiformats/cid'\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\nconst pbNodeProperties = ['Data', 'Links']\nconst pbLinkProperties = ['Hash', 'Name', 'Tsize']\n\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {PBLink} a\n * @param {PBLink} b\n * @returns {number}\n */\nfunction linkComparator (a, b) {\n  if (a === b) {\n    return 0\n  }\n\n  const abuf = a.Name ? textEncoder.encode(a.Name) : []\n  const bbuf = b.Name ? textEncoder.encode(b.Name) : []\n\n  let x = abuf.length\n  let y = bbuf.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (abuf[i] !== bbuf[i]) {\n      x = abuf[i]\n      y = bbuf[i]\n      break\n    }\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0\n}\n\n/**\n * @param {any} node\n * @param {string[]} properties\n * @returns {boolean}\n */\nfunction hasOnlyProperties (node, properties) {\n  return !Object.keys(node).some((p) => !properties.includes(p))\n}\n\n/**\n * Converts a CID, or a PBLink-like object to a PBLink\n *\n * @param {any} link\n * @returns {PBLink}\n */\nfunction asLink (link) {\n  if (typeof link.asCID === 'object') {\n    const Hash = CID.asCID(link)\n    if (!Hash) {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n    return { Hash }\n  }\n\n  if (typeof link !== 'object' || Array.isArray(link)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  const pbl = {}\n\n  if (link.Hash) {\n    let cid = CID.asCID(link.Hash)\n    try {\n      if (!cid) {\n        if (typeof link.Hash === 'string') {\n          cid = CID.parse(link.Hash)\n        } else if (link.Hash instanceof Uint8Array) {\n          cid = CID.decode(link.Hash)\n        }\n      }\n    } catch (/** @type {any} */ e) {\n      throw new TypeError(`Invalid DAG-PB form: ${e.message}`)\n    }\n\n    if (cid) {\n      pbl.Hash = cid\n    }\n  }\n\n  if (!pbl.Hash) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (typeof link.Name === 'string') {\n    pbl.Name = link.Name\n  }\n\n  if (typeof link.Tsize === 'number') {\n    pbl.Tsize = link.Tsize\n  }\n\n  return pbl\n}\n\n/**\n * @param {any} node\n * @returns {PBNode}\n */\nexport function prepare (node) {\n  if (node instanceof Uint8Array || typeof node === 'string') {\n    node = { Data: node }\n  }\n\n  if (typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  /** @type {PBNode} */\n  const pbn = {}\n\n  if (node.Data !== undefined) {\n    if (typeof node.Data === 'string') {\n      pbn.Data = textEncoder.encode(node.Data)\n    } else if (node.Data instanceof Uint8Array) {\n      pbn.Data = node.Data\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  }\n\n  if (node.Links !== undefined) {\n    if (Array.isArray(node.Links)) {\n      pbn.Links = node.Links.map(asLink)\n      pbn.Links.sort(linkComparator)\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  } else {\n    pbn.Links = []\n  }\n\n  return pbn\n}\n\n/**\n * @param {PBNode} node\n */\nexport function validate (node) {\n  /*\n  type PBLink struct {\n    Hash optional Link\n    Name optional String\n    Tsize optional Int\n  }\n\n  type PBNode struct {\n    Links [PBLink]\n    Data optional Bytes\n  }\n  */\n  // @ts-ignore private property for TS\n  if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || (node['/'] && node['/'] === node.bytes)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (!hasOnlyProperties(node, pbNodeProperties)) {\n    throw new TypeError('Invalid DAG-PB form (extraneous properties)')\n  }\n\n  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {\n    throw new TypeError('Invalid DAG-PB form (Data must be bytes)')\n  }\n\n  if (!Array.isArray(node.Links)) {\n    throw new TypeError('Invalid DAG-PB form (Links must be a list)')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const link = node.Links[i]\n    // @ts-ignore private property for TS\n    if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || (link['/'] && link['/'] === link.bytes)) {\n      throw new TypeError('Invalid DAG-PB form (bad link)')\n    }\n\n    if (!hasOnlyProperties(link, pbLinkProperties)) {\n      throw new TypeError('Invalid DAG-PB form (extraneous properties on link)')\n    }\n\n    if (link.Hash === undefined) {\n      throw new TypeError('Invalid DAG-PB form (link must have a Hash)')\n    }\n\n    // @ts-ignore private property for TS\n    if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {\n      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')\n    }\n\n    if (link.Name !== undefined && typeof link.Name !== 'string') {\n      throw new TypeError('Invalid DAG-PB form (link Name must be a string)')\n    }\n\n    if (link.Tsize !== undefined) {\n      if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')\n      }\n      if (link.Tsize < 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)')\n      }\n    }\n\n    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {\n      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {PBLink[]} [links=[]]\n * @returns {PBNode}\n */\nexport function createNode (data, links = []) {\n  return prepare({ Data: data, Links: links })\n}\n\n/**\n * @param {string} name\n * @param {number} size\n * @param {CID} cid\n * @returns {PBLink}\n */\nexport function createLink (name, size, cid) {\n  return asLink({ Hash: cid, Name: name, Tsize: size })\n}\n","import { CID } from 'multiformats/cid'\nimport { decodeNode } from './pb-decode.js'\nimport { encodeNode } from './pb-encode.js'\nimport { prepare, validate, createNode, createLink } from './util.js'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\nexport const name = 'dag-pb'\nexport const code = 0x70\n\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\nexport function encode (node) {\n  validate(node)\n\n  const pbn = {}\n  if (node.Links) {\n    pbn.Links = node.Links.map((l) => {\n      const link = {}\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes // cid -> bytes\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n  if (node.Data) {\n    pbn.Data = node.Data\n  }\n\n  return encodeNode(pbn)\n}\n\n/**\n * @param {ByteView<PBNode>} bytes\n * @returns {PBNode}\n */\nexport function decode (bytes) {\n  const pbn = decodeNode(bytes)\n\n  const node = {}\n\n  if (pbn.Data) {\n    node.Data = pbn.Data\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map((l) => {\n      const link = {}\n      try {\n        link.Hash = CID.decode(l.Hash)\n      } catch (e) {}\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID')\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n\n  return node\n}\n\nexport { prepare, validate, createNode, createLink }\n","/*eslint-disable*/\nimport $protobuf from \"protobufjs/minimal.js\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots.unixfs || ($protobuf.roots.unixfs = {});\n\nexport const Data = $root.Data = (() => {\n\n    /**\n     * Properties of a Data.\n     * @exports IData\n     * @interface IData\n     * @property {Data.DataType} Type Data Type\n     * @property {Uint8Array|null} [Data] Data Data\n     * @property {number|null} [filesize] Data filesize\n     * @property {Array.<number>|null} [blocksizes] Data blocksizes\n     * @property {number|null} [hashType] Data hashType\n     * @property {number|null} [fanout] Data fanout\n     * @property {number|null} [mode] Data mode\n     * @property {IUnixTime|null} [mtime] Data mtime\n     */\n\n    /**\n     * Constructs a new Data.\n     * @exports Data\n     * @classdesc Represents a Data.\n     * @implements IData\n     * @constructor\n     * @param {IData=} [p] Properties to set\n     */\n    function Data(p) {\n        this.blocksizes = [];\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Data Type.\n     * @member {Data.DataType} Type\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.Type = 0;\n\n    /**\n     * Data Data.\n     * @member {Uint8Array} Data\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.Data = $util.newBuffer([]);\n\n    /**\n     * Data filesize.\n     * @member {number} filesize\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data blocksizes.\n     * @member {Array.<number>} blocksizes\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.blocksizes = $util.emptyArray;\n\n    /**\n     * Data hashType.\n     * @member {number} hashType\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data fanout.\n     * @member {number} fanout\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data mode.\n     * @member {number} mode\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.mode = 0;\n\n    /**\n     * Data mtime.\n     * @member {IUnixTime|null|undefined} mtime\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.mtime = null;\n\n    /**\n     * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.\n     * @function encode\n     * @memberof Data\n     * @static\n     * @param {IData} m Data message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Data.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int32(m.Type);\n        if (m.Data != null && Object.hasOwnProperty.call(m, \"Data\"))\n            w.uint32(18).bytes(m.Data);\n        if (m.filesize != null && Object.hasOwnProperty.call(m, \"filesize\"))\n            w.uint32(24).uint64(m.filesize);\n        if (m.blocksizes != null && m.blocksizes.length) {\n            for (var i = 0; i < m.blocksizes.length; ++i)\n                w.uint32(32).uint64(m.blocksizes[i]);\n        }\n        if (m.hashType != null && Object.hasOwnProperty.call(m, \"hashType\"))\n            w.uint32(40).uint64(m.hashType);\n        if (m.fanout != null && Object.hasOwnProperty.call(m, \"fanout\"))\n            w.uint32(48).uint64(m.fanout);\n        if (m.mode != null && Object.hasOwnProperty.call(m, \"mode\"))\n            w.uint32(56).uint32(m.mode);\n        if (m.mtime != null && Object.hasOwnProperty.call(m, \"mtime\"))\n            $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();\n        return w;\n    };\n\n    /**\n     * Decodes a Data message from the specified reader or buffer.\n     * @function decode\n     * @memberof Data\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Data} Data\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Data.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Type = r.int32();\n                break;\n            case 2:\n                m.Data = r.bytes();\n                break;\n            case 3:\n                m.filesize = r.uint64();\n                break;\n            case 4:\n                if (!(m.blocksizes && m.blocksizes.length))\n                    m.blocksizes = [];\n                if ((t & 7) === 2) {\n                    var c2 = r.uint32() + r.pos;\n                    while (r.pos < c2)\n                        m.blocksizes.push(r.uint64());\n                } else\n                    m.blocksizes.push(r.uint64());\n                break;\n            case 5:\n                m.hashType = r.uint64();\n                break;\n            case 6:\n                m.fanout = r.uint64();\n                break;\n            case 7:\n                m.mode = r.uint32();\n                break;\n            case 8:\n                m.mtime = $root.UnixTime.decode(r, r.uint32());\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Type\"))\n            throw $util.ProtocolError(\"missing required 'Type'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates a Data message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Data\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Data} Data\n     */\n    Data.fromObject = function fromObject(d) {\n        if (d instanceof $root.Data)\n            return d;\n        var m = new $root.Data();\n        switch (d.Type) {\n        case \"Raw\":\n        case 0:\n            m.Type = 0;\n            break;\n        case \"Directory\":\n        case 1:\n            m.Type = 1;\n            break;\n        case \"File\":\n        case 2:\n            m.Type = 2;\n            break;\n        case \"Metadata\":\n        case 3:\n            m.Type = 3;\n            break;\n        case \"Symlink\":\n        case 4:\n            m.Type = 4;\n            break;\n        case \"HAMTShard\":\n        case 5:\n            m.Type = 5;\n            break;\n        }\n        if (d.Data != null) {\n            if (typeof d.Data === \"string\")\n                $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);\n            else if (d.Data.length)\n                m.Data = d.Data;\n        }\n        if (d.filesize != null) {\n            if ($util.Long)\n                (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;\n            else if (typeof d.filesize === \"string\")\n                m.filesize = parseInt(d.filesize, 10);\n            else if (typeof d.filesize === \"number\")\n                m.filesize = d.filesize;\n            else if (typeof d.filesize === \"object\")\n                m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);\n        }\n        if (d.blocksizes) {\n            if (!Array.isArray(d.blocksizes))\n                throw TypeError(\".Data.blocksizes: array expected\");\n            m.blocksizes = [];\n            for (var i = 0; i < d.blocksizes.length; ++i) {\n                if ($util.Long)\n                    (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;\n                else if (typeof d.blocksizes[i] === \"string\")\n                    m.blocksizes[i] = parseInt(d.blocksizes[i], 10);\n                else if (typeof d.blocksizes[i] === \"number\")\n                    m.blocksizes[i] = d.blocksizes[i];\n                else if (typeof d.blocksizes[i] === \"object\")\n                    m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);\n            }\n        }\n        if (d.hashType != null) {\n            if ($util.Long)\n                (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;\n            else if (typeof d.hashType === \"string\")\n                m.hashType = parseInt(d.hashType, 10);\n            else if (typeof d.hashType === \"number\")\n                m.hashType = d.hashType;\n            else if (typeof d.hashType === \"object\")\n                m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);\n        }\n        if (d.fanout != null) {\n            if ($util.Long)\n                (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;\n            else if (typeof d.fanout === \"string\")\n                m.fanout = parseInt(d.fanout, 10);\n            else if (typeof d.fanout === \"number\")\n                m.fanout = d.fanout;\n            else if (typeof d.fanout === \"object\")\n                m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);\n        }\n        if (d.mode != null) {\n            m.mode = d.mode >>> 0;\n        }\n        if (d.mtime != null) {\n            if (typeof d.mtime !== \"object\")\n                throw TypeError(\".Data.mtime: object expected\");\n            m.mtime = $root.UnixTime.fromObject(d.mtime);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a Data message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Data\n     * @static\n     * @param {Data} m Data\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Data.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.arrays || o.defaults) {\n            d.blocksizes = [];\n        }\n        if (o.defaults) {\n            d.Type = o.enums === String ? \"Raw\" : 0;\n            if (o.bytes === String)\n                d.Data = \"\";\n            else {\n                d.Data = [];\n                if (o.bytes !== Array)\n                    d.Data = $util.newBuffer(d.Data);\n            }\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.filesize = o.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.hashType = o.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.fanout = o.longs === String ? \"0\" : 0;\n            d.mode = 0;\n            d.mtime = null;\n        }\n        if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n            d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;\n        }\n        if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n        }\n        if (m.filesize != null && m.hasOwnProperty(\"filesize\")) {\n            if (typeof m.filesize === \"number\")\n                d.filesize = o.longs === String ? String(m.filesize) : m.filesize;\n            else\n                d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;\n        }\n        if (m.blocksizes && m.blocksizes.length) {\n            d.blocksizes = [];\n            for (var j = 0; j < m.blocksizes.length; ++j) {\n                if (typeof m.blocksizes[j] === \"number\")\n                    d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];\n                else\n                    d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];\n            }\n        }\n        if (m.hashType != null && m.hasOwnProperty(\"hashType\")) {\n            if (typeof m.hashType === \"number\")\n                d.hashType = o.longs === String ? String(m.hashType) : m.hashType;\n            else\n                d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;\n        }\n        if (m.fanout != null && m.hasOwnProperty(\"fanout\")) {\n            if (typeof m.fanout === \"number\")\n                d.fanout = o.longs === String ? String(m.fanout) : m.fanout;\n            else\n                d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;\n        }\n        if (m.mode != null && m.hasOwnProperty(\"mode\")) {\n            d.mode = m.mode;\n        }\n        if (m.mtime != null && m.hasOwnProperty(\"mtime\")) {\n            d.mtime = $root.UnixTime.toObject(m.mtime, o);\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Data to JSON.\n     * @function toJSON\n     * @memberof Data\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Data.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * DataType enum.\n     * @name Data.DataType\n     * @enum {number}\n     * @property {number} Raw=0 Raw value\n     * @property {number} Directory=1 Directory value\n     * @property {number} File=2 File value\n     * @property {number} Metadata=3 Metadata value\n     * @property {number} Symlink=4 Symlink value\n     * @property {number} HAMTShard=5 HAMTShard value\n     */\n    Data.DataType = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Raw\"] = 0;\n        values[valuesById[1] = \"Directory\"] = 1;\n        values[valuesById[2] = \"File\"] = 2;\n        values[valuesById[3] = \"Metadata\"] = 3;\n        values[valuesById[4] = \"Symlink\"] = 4;\n        values[valuesById[5] = \"HAMTShard\"] = 5;\n        return values;\n    })();\n\n    return Data;\n})();\n\nexport const UnixTime = $root.UnixTime = (() => {\n\n    /**\n     * Properties of an UnixTime.\n     * @exports IUnixTime\n     * @interface IUnixTime\n     * @property {number} Seconds UnixTime Seconds\n     * @property {number|null} [FractionalNanoseconds] UnixTime FractionalNanoseconds\n     */\n\n    /**\n     * Constructs a new UnixTime.\n     * @exports UnixTime\n     * @classdesc Represents an UnixTime.\n     * @implements IUnixTime\n     * @constructor\n     * @param {IUnixTime=} [p] Properties to set\n     */\n    function UnixTime(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * UnixTime Seconds.\n     * @member {number} Seconds\n     * @memberof UnixTime\n     * @instance\n     */\n    UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n    /**\n     * UnixTime FractionalNanoseconds.\n     * @member {number} FractionalNanoseconds\n     * @memberof UnixTime\n     * @instance\n     */\n    UnixTime.prototype.FractionalNanoseconds = 0;\n\n    /**\n     * Encodes the specified UnixTime message. Does not implicitly {@link UnixTime.verify|verify} messages.\n     * @function encode\n     * @memberof UnixTime\n     * @static\n     * @param {IUnixTime} m UnixTime message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    UnixTime.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int64(m.Seconds);\n        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, \"FractionalNanoseconds\"))\n            w.uint32(21).fixed32(m.FractionalNanoseconds);\n        return w;\n    };\n\n    /**\n     * Decodes an UnixTime message from the specified reader or buffer.\n     * @function decode\n     * @memberof UnixTime\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {UnixTime} UnixTime\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    UnixTime.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Seconds = r.int64();\n                break;\n            case 2:\n                m.FractionalNanoseconds = r.fixed32();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Seconds\"))\n            throw $util.ProtocolError(\"missing required 'Seconds'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates an UnixTime message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof UnixTime\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {UnixTime} UnixTime\n     */\n    UnixTime.fromObject = function fromObject(d) {\n        if (d instanceof $root.UnixTime)\n            return d;\n        var m = new $root.UnixTime();\n        if (d.Seconds != null) {\n            if ($util.Long)\n                (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;\n            else if (typeof d.Seconds === \"string\")\n                m.Seconds = parseInt(d.Seconds, 10);\n            else if (typeof d.Seconds === \"number\")\n                m.Seconds = d.Seconds;\n            else if (typeof d.Seconds === \"object\")\n                m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();\n        }\n        if (d.FractionalNanoseconds != null) {\n            m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from an UnixTime message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof UnixTime\n     * @static\n     * @param {UnixTime} m UnixTime\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    UnixTime.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, false);\n                d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.Seconds = o.longs === String ? \"0\" : 0;\n            d.FractionalNanoseconds = 0;\n        }\n        if (m.Seconds != null && m.hasOwnProperty(\"Seconds\")) {\n            if (typeof m.Seconds === \"number\")\n                d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;\n            else\n                d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;\n        }\n        if (m.FractionalNanoseconds != null && m.hasOwnProperty(\"FractionalNanoseconds\")) {\n            d.FractionalNanoseconds = m.FractionalNanoseconds;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this UnixTime to JSON.\n     * @function toJSON\n     * @memberof UnixTime\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    UnixTime.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return UnixTime;\n})();\n\nexport const Metadata = $root.Metadata = (() => {\n\n    /**\n     * Properties of a Metadata.\n     * @exports IMetadata\n     * @interface IMetadata\n     * @property {string|null} [MimeType] Metadata MimeType\n     */\n\n    /**\n     * Constructs a new Metadata.\n     * @exports Metadata\n     * @classdesc Represents a Metadata.\n     * @implements IMetadata\n     * @constructor\n     * @param {IMetadata=} [p] Properties to set\n     */\n    function Metadata(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Metadata MimeType.\n     * @member {string} MimeType\n     * @memberof Metadata\n     * @instance\n     */\n    Metadata.prototype.MimeType = \"\";\n\n    /**\n     * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.\n     * @function encode\n     * @memberof Metadata\n     * @static\n     * @param {IMetadata} m Metadata message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Metadata.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        if (m.MimeType != null && Object.hasOwnProperty.call(m, \"MimeType\"))\n            w.uint32(10).string(m.MimeType);\n        return w;\n    };\n\n    /**\n     * Decodes a Metadata message from the specified reader or buffer.\n     * @function decode\n     * @memberof Metadata\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Metadata} Metadata\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Metadata.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.MimeType = r.string();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        return m;\n    };\n\n    /**\n     * Creates a Metadata message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Metadata\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Metadata} Metadata\n     */\n    Metadata.fromObject = function fromObject(d) {\n        if (d instanceof $root.Metadata)\n            return d;\n        var m = new $root.Metadata();\n        if (d.MimeType != null) {\n            m.MimeType = String(d.MimeType);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a Metadata message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Metadata\n     * @static\n     * @param {Metadata} m Metadata\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Metadata.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            d.MimeType = \"\";\n        }\n        if (m.MimeType != null && m.hasOwnProperty(\"MimeType\")) {\n            d.MimeType = m.MimeType;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Metadata to JSON.\n     * @function toJSON\n     * @memberof Metadata\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Metadata.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Metadata;\n})();\n\nexport { $root as default };\n","// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n\nimport { Data } from \"../gen/unixfs.js\"\nexport const NodeType = Data.DataType\n","import * as Task from \"./task.js\"\nexport * from \"./task.js\"\n\n/**\n * Turns a task (that never fails or sends messages) into an effect of it's\n * result.\n *\n * @template T\n * @param {Task.Task<T, never>} task\n * @returns {Task.Effect<T>}\n */\nexport const effect = function* (task) {\n  const message = yield* task\n  yield* send(message)\n}\n\n/**\n * Gets a handle to the task that invoked it. Useful when task needs to\n * suspend execution until some outside event occurs, in which case handle\n * can be used resume execution (see `suspend` code example for more details)\n *\n * @template T, M, X\n * @returns {Task.Task<Task.Controller<T, X, M>, never>}\n */\nexport function* current() {\n  return /** @type {Task.Controller<T, X, M>} */ (yield CURRENT)\n}\n\n/**\n * Suspends the current task (task that invokes it),  which can then be\n * resumed from another task or an outside event (e.g. `setTimeout` callback)\n * by calling the `resume` with an task's handle.\n *\n * Calling this in almost all cases is preceeded by call to `current()` in\n * order to obtain a `handle` which can be passed to `resume` function\n * to resume the execution.\n *\n * Note: This task never fails, although it may never resume either. However\n * you can utilize `finally` block to do a necessary cleanup in case execution\n * is aborted.\n *\n * @example\n * ```js\n * import { current, suspend, resume } from \"actor\"\n * function * sleep(duration) {\n *    // get a reference to this task so we can resume it.\n *    const self = yield * current()\n *    // resume this task when timeout fires\n *    const id = setTimeout(() => resume(self), duration)\n *    try {\n *      // suspend this task nothing below this line will run until task is\n *      // resumed.\n *      yield * suspend()\n *    } finally {\n *      // if task is aborted finally block will still run which given you\n *      // chance to cleanup.\n *      clearTimeout(id)\n *    }\n * }\n * ```\n *\n * @returns {Task.Task<void, never>}\n */\nexport const suspend = function* () {\n  yield SUSPEND\n}\n\n/**\n * Suspends execution for the given duration in milliseconds, after which\n * execution is resumed (unless it was aborted in the meantime).\n *\n * @example\n * ```js\n * function * demo() {\n *    console.log(\"I'm going to take small nap\")\n *    yield * sleep(200)\n *    console.log(\"I am back to work\")\n * }\n * ```\n *\n * @param {number} [duration]\n * @returns {Task.Task<void, never>}\n */\nexport function* sleep(duration = 0) {\n  const task = yield* current()\n  const id = setTimeout(enqueue, duration, task)\n\n  try {\n    yield* suspend()\n  } finally {\n    clearTimeout(id)\n  }\n}\n\n/**\n * Provides equivalent of `await` in async functions. Specifically it takes\n * a value that you can `await` on (that is `Promise<T>|T`) and suspends\n * execution until promise is settled. If promise succeeds execution is resumed\n * with `T` otherwise an error of type `X` is thrown (which is by default\n * `unknown` since promises do not encode error type).\n *\n * It is useful when you need to deal with potentially async set of operations\n * without having to check if thing is a promise at every step.\n *\n * Please note: This that execution is suspended even if given value is not a\n * promise, however scheduler will still resume it in the same tick of the event\n * loop after, just processing other scheduled tasks. This avoids problematic\n * race condititions that can otherwise occur when values are sometimes promises\n * and other times are not.\n *\n * @example\n * ```js\n * function * fetchJSON (url, options) {\n *    const response = yield * wait(fetch(url, options))\n *    const json = yield * wait(response.json())\n *    return json\n * }\n * ```\n *\n * @template T, [X=unknown]\n * @param {Task.Await<T>} input\n * @returns {Task.Task<T, Error>}\n */\nexport const wait = function* (input) {\n  const task = yield* current()\n  if (isAsync(input)) {\n    let failed = false\n    /** @type {unknown} */\n    let output = undefined\n    input.then(\n      value => {\n        failed = false\n        output = value\n        enqueue(task)\n      },\n      error => {\n        failed = true\n        output = error\n        enqueue(task)\n      }\n    )\n\n    yield* suspend()\n    if (failed) {\n      throw output\n    } else {\n      return /** @type {T} */ (output)\n    }\n  } else {\n    // This may seem redundunt but it is not, by enqueuing this task we allow\n    // scheduler to perform other queued tasks first. This way many race\n    // conditions can be avoided when values are sometimes promises and other\n    // times aren't.\n    // Unlike `await` however this will resume in the same tick.\n    main(wake(task))\n    yield* suspend()\n    return input\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n * @returns {Task.Task<void, never, never>}\n */\nfunction* wake(task) {\n  enqueue(task)\n}\n\n/**\n * Checks if value value is a promise (or it's lookalike).\n *\n * @template T\n * @param {any} node\n * @returns {node is PromiseLike<T>}\n */\n\nconst isAsync = node =>\n  node != null &&\n  typeof (/** @type {{then?:unknown}} */ (node).then) === \"function\"\n\n/**\n * Task that sends given message (or rather an effect producing this message).\n * Please note, that while you could use `yield message` instead, but you'd risk\n * having to deal with potential breaking changes if library internals change\n * in the future, which in fact may happen as anticipated improvements in\n * TS generator inference could enable replace need for `yield *`.\n *\n * @see https://github.com/microsoft/TypeScript/issues/43632\n *\n * @template T\n * @param {T} message\n * @returns {Task.Effect<T>}\n */\nexport const send = function* (message) {\n  yield /** @type {Task.Message<T>} */ (message)\n}\n\n/**\n * Takes several effects and merges them into a single effect of tagged\n * variants so that their source could be identified via `type` field.\n *\n * @example\n * ```js\n * listen({\n *    read: Task.effect(dbRead),\n *    write: Task.effect(dbWrite)\n * })\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {{ [K in Tag]: Task.Effect<T> }} source\n * @returns {Task.Effect<Tagged<Tag, T>>}\n */\nexport const listen = function* (source) {\n  /** @type {Task.Fork<void, never, Tagged<Tag, T>>[]} */\n  const forks = []\n  for (const entry of Object.entries(source)) {\n    const [name, effect] = /** @type {[Tag, Task.Effect<T>]} */ (entry)\n    if (effect !== NONE) {\n      forks.push(yield* fork(tag(effect, name)))\n    }\n  }\n\n  yield* group(forks)\n}\n\n/**\n * Takes several tasks and creates an effect of them all.\n *\n * @example\n * ```js\n * Task.effects([\n *    dbRead,\n *    dbWrite\n * ])\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {Task.Task<T, never>[]} tasks\n * @returns {Task.Effect<T>}\n */\n\nexport const effects = tasks =>\n  tasks.length > 0 ? batch(tasks.map(effect)) : NONE\n\n/**\n * Takes several effects and combines them into a one.\n *\n * @template T\n * @param {Task.Effect<T>[]} effects\n * @returns {Task.Effect<T>}\n */\nexport function* batch(effects) {\n  const forks = []\n  for (const effect of effects) {\n    forks.push(yield* fork(effect))\n  }\n\n  yield* group(forks)\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @typedef {{type: Tag} & {[K in Tag]: T}} Tagged\n */\n/**\n * Tags an effect by boxing each event with an object that has `type` field\n * corresponding to given tag and same named field holding original message\n * e.g. given `nums` effect that produces numbers, `tag(nums, \"inc\")` would\n * create an effect that produces events like `{type:'inc', inc:1}`.\n *\n * @template {string} Tag\n * @template T, M, X\n * @param {Task.Task<T, X, M>} effect\n * @param {Tag} tag\n * @returns {Task.Task<T, X, Tagged<Tag, M>>}\n */\nexport const tag = (effect, tag) =>\n  // @ts-ignore\n  effect === NONE\n    ? NONE\n    : effect instanceof Tagger\n    ? new Tagger([...effect.tags, tag], effect.source)\n    : new Tagger([tag], effect)\n\n/**\n * @template {string} Tag\n * @template Success, Failure, Message\n *\n * @implements {Task.Task<Success, Failure, Tagged<Tag, Message>>}\n * @implements {Task.Controller<Success, Failure, Tagged<Tag, Message>>}\n */\nclass Tagger {\n  /**\n   * @param {Task.Task<Success, Failure, Message>} source\n   * @param {string[]} tags\n   */\n  constructor(tags, source) {\n    this.tags = tags\n    this.source = source\n    /** @type {Task.Controller<Success, Failure, Message>} */\n    this.controller\n  }\n  /* c8 ignore next 3 */\n  [Symbol.iterator]() {\n    if (!this.controller) {\n      this.controller = this.source[Symbol.iterator]()\n    }\n    return this\n  }\n  /**\n   * @param {Task.TaskState<Success, Message>} state\n   * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}\n   */\n  box(state) {\n    if (state.done) {\n      return state\n    } else {\n      switch (state.value) {\n        case SUSPEND:\n        case CURRENT:\n          return /** @type {Task.TaskState<Success, Tagged<Tag, Message>>} */ (\n            state\n          )\n        default: {\n          // Instead of boxing result at each transform step we perform in-place\n          // mutation as we know nothing else is accessing this value.\n          const tagged = /** @type {{ done: false, value: any }} */ (state)\n          let { value } = tagged\n          for (const tag of this.tags) {\n            value = withTag(tag, value)\n          }\n          tagged.value = value\n          return tagged\n        }\n      }\n    }\n  }\n  /**\n   *\n   * @param {Task.Instruction<Message>} instruction\n   */\n  next(instruction) {\n    return this.box(this.controller.next(instruction))\n  }\n  /**\n   *\n   * @param {Failure} error\n   */\n  throw(error) {\n    return this.box(this.controller.throw(error))\n  }\n  /**\n   * @param {Success} value\n   */\n  return(value) {\n    return this.box(this.controller.return(value))\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"TaggedEffect\"\n  }\n}\n\n/**\n * Returns empty `Effect`, that is produces no messages. Kind of like `[]` or\n * `\"\"` but for effects.\n *\n * @type {() => Task.Effect<never>}\n */\nexport const none = () => NONE\n\n/**\n * Takes iterable of tasks and runs them concurrently, returning array of\n * results in an order of tasks (not the order of completion). If any of the\n * tasks fail all the rest are aborted and error is throw into calling task.\n *\n * > This is basically equivalent of `Promise.all` except cancelation logic\n * because tasks unlike promises can be cancelled.\n *\n * @template T, X\n * @param {Iterable<Task.Task<T, X>>} tasks\n * @returns {Task.Task<T[], X>}\n */\nexport const all = function* (tasks) {\n  const self = yield* current()\n\n  /** @type {(id:number) => (value:T) => void} */\n  const succeed = id => value => {\n    delete forks[id]\n    results[id] = value\n    count -= 1\n    if (count === 0) {\n      enqueue(self)\n    }\n  }\n\n  /** @type {(error:X) => void} */\n  const fail = error => {\n    for (const handle of forks) {\n      if (handle) {\n        enqueue(abort(handle, error))\n      }\n    }\n\n    enqueue(abort(self, error))\n  }\n\n  /** @type {Task.Fork<void, never>[]} */\n  let forks = []\n  let count = 0\n  for (const task of tasks) {\n    forks.push(yield* fork(then(task, succeed(count++), fail)))\n  }\n  const results = new Array(count)\n\n  if (count > 0) {\n    yield* suspend()\n  }\n\n  return results\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @param {Tag} tag\n * @param {Task.Message<T>} value\n */\nconst withTag = (tag, value) =>\n  /** @type {Tagged<Tag, T>} */\n  ({ type: tag, [tag]: value })\n\n/**\n * Kind of like promise.then which is handy when you want to extract result\n * from the given task from the outside.\n *\n * @template T, U, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {(value:T) => U} resolve\n * @param {(error:X) => U} reject\n * @returns {Task.Task<U, never, M>}\n */\nexport function* then(task, resolve, reject) {\n  try {\n    return resolve(yield* task)\n  } catch (error) {\n    return reject(/** @type {X} */ (error))\n  }\n}\n\n// Special control instructions recognized by a scheduler.\nconst CURRENT = Symbol(\"current\")\nconst SUSPEND = Symbol(\"suspend\")\n/** @typedef {typeof SUSPEND|typeof CURRENT} Control */\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is M}\n */\nexport const isMessage = value => {\n  switch (value) {\n    case SUSPEND:\n    case CURRENT:\n      return false\n    default:\n      return true\n  }\n}\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is Control}\n */\nexport const isInstruction = value => !isMessage(value)\n\n/**\n * @template T, X, M\n * @implements {Task.TaskGroup<T, X, M>}\n */\nclass Group {\n  /**\n   * @template T, X, M\n   * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member\n   * @returns {Task.Group<T, X, M>}\n   */\n  static of(member) {\n    return (\n      /** @type {{group?:Task.TaskGroup<T, X, M>}} */ (member).group || MAIN\n    )\n  }\n\n  /**\n   * @template T, X, M\n   * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member\n   * @param {Task.TaskGroup<T, X, M>} group\n   */\n  static enqueue(member, group) {\n    member.group = group\n    group.stack.active.push(member)\n  }\n  /**\n   * @param {Task.Controller<T, X, M>} driver\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   * @param {Task.Stack<T, X, M>} [stack]\n   */\n  constructor(\n    driver,\n    active = [],\n    idle = new Set(),\n    stack = new Stack(active, idle)\n  ) {\n    this.driver = driver\n    this.parent = Group.of(driver)\n    this.stack = stack\n    this.id = ++ID\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Main<T, X, M>}\n */\nclass Main {\n  constructor() {\n    this.status = IDLE\n    this.stack = new Stack()\n    this.id = /** @type {0} */ (0)\n  }\n}\n\n/**\n * @template T, X, M\n */\nclass Stack {\n  /**\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   */\n  constructor(active = [], idle = new Set()) {\n    this.active = active\n    this.idle = idle\n  }\n\n  /**\n   *\n   * @param {Task.Stack<unknown, unknown, unknown>} stack\n   * @returns\n   */\n  static size({ active, idle }) {\n    return active.length + idle.size\n  }\n}\n\n/**\n * Starts a main task.\n *\n * @param {Task.Task<void, never>} task\n */\nexport const main = task => enqueue(task[Symbol.iterator]())\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nconst enqueue = task => {\n  let group = Group.of(task)\n  group.stack.active.push(task)\n  group.stack.idle.delete(task)\n\n  // then walk up the group chain and unblock their driver tasks.\n  while (group.parent) {\n    const { idle, active } = group.parent.stack\n    if (idle.has(group.driver)) {\n      idle.delete(group.driver)\n      active.push(group.driver)\n    } else {\n      // if driver was not blocked it must have been unblocked by\n      // other task so stop there.\n      break\n    }\n\n    group = group.parent\n  }\n\n  if (MAIN.status === IDLE) {\n    MAIN.status = ACTIVE\n    while (true) {\n      try {\n        for (const _message of step(MAIN)) {\n        }\n        MAIN.status = IDLE\n        break\n      } catch (_error) {\n        // Top level task may crash and throw an error, but given this is a main\n        // group we do not want to interupt other unrelated tasks, which is why\n        // we discard the error and the task that caused it.\n        MAIN.stack.active.shift()\n      }\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nexport const resume = task => enqueue(task)\n\n/**\n * @template T, X, M\n * @param {Task.Group<T, X, M>} group\n */\n\nconst step = function* (group) {\n  const { active } = group.stack\n  let task = active[0]\n  group.stack.idle.delete(task)\n  while (task) {\n    /** @type {Task.TaskState<T, M>} */\n    let state = INIT\n    // Keep processing insturctions until task is done, it send suspend request\n    // or it's has been removed from the active queue.\n    // ⚠️ Group changes require extra care so please make sure to understand\n    // the detail here. It occurs when spawned task(s) are joined into a group\n    // which will change the task driver, that is when `task === active[0]` will\n    // became false and need to to drop the task immediately otherwise race\n    // condition will occur due to task been  driven by multiple concurrent\n    // schedulers.\n    loop: while (!state.done && task === active[0]) {\n      const instruction = state.value\n      switch (instruction) {\n        // if task is suspended we add it to the idle list and break the loop\n        // to move to a next task.\n        case SUSPEND:\n          group.stack.idle.add(task)\n          break loop\n        // if task requested a context (which is usually to suspend itself)\n        // pass back a task reference and continue.\n        case CURRENT:\n          state = task.next(task)\n          break\n        default:\n          // otherwise task sent a message which we yield to the driver and\n          // continue\n          state = task.next(\n            yield /** @type {M & Task.Message<M>}*/ (instruction)\n          )\n          break\n      }\n    }\n\n    // If task is complete, or got suspended we move to a next task\n    active.shift()\n    task = active[0]\n    group.stack.idle.delete(task)\n  }\n}\n\n/**\n * Executes given task concurrently with a current task (task that spawned it).\n * Spawned task is detached from the task that spawned it and it can outlive it\n * and / or fail without affecting a task that spawned it. If you need to wait\n * on concurrent task completion consider using `fork` instead which can be\n * later `joined`. If you just want a to block on task execution you can just\n * `yield* work()` directly instead.\n *\n * @param {Task.Task<void, never, never>} task\n * @returns {Task.Task<void, never>}\n */\nexport function* spawn(task) {\n  main(task)\n}\n\n/**\n * Executes given task concurrently with current task (the task that initiated\n * fork). Froked task is detached from the task that created it and it can\n * outlive it and / or fail without affecting it. You do however get a handle\n * for the fork which could be used to `join` the task, in which case `joining`\n * task will block until fork finishes execution.\n *\n * This is also a primary interface for executing tasks from the outside of the\n * task context. Function returns `Fork` which implements `Promise` interface\n * so it could be awaited. Please note that calling `fork` does not really do\n * anything, it lazily starts execution when you either `await fork(work())`\n * from arbitray context or `yield* fork(work())` in anothe task context.\n *\n * @template T, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {Task.ForkOptions} [options]\n * @returns {Task.Fork<T, X, M>}\n */\nexport const fork = (task, options) => new Fork(task, options)\n\n/**\n * Exits task succesfully with a given return value.\n *\n * @template T, M, X\n * @param  {Task.Controller<T, M, X>} handle\n * @param {T} value\n * @returns {Task.Task<void, never>}\n */\nexport const exit = (handle, value) => conclude(handle, { ok: true, value })\n\n/**\n * Terminates task execution execution. Only takes task that produces no\n * result, if your task has non `void` return type you should use `exit` instead.\n *\n * @template M, X\n * @param {Task.Controller<void, X, M>} handle\n */\nexport const terminate = handle =>\n  conclude(handle, { ok: true, value: undefined })\n\n/**\n * Aborts given task with an error. Task error type should match provided error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {X} [error]\n */\nexport const abort = (handle, error) => conclude(handle, { ok: false, error })\n\n/**\n * Aborts given task with an given error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {Task.Result<T, X>} result\n * @returns {Task.Task<void, never> & Task.Controller<void, never>}\n */\nfunction* conclude(handle, result) {\n  try {\n    const task = handle\n    const state = result.ok\n      ? task.return(result.value)\n      : task.throw(result.error)\n\n    if (!state.done) {\n      if (state.value === SUSPEND) {\n        const { idle } = Group.of(task).stack\n        idle.add(task)\n      } else {\n        enqueue(task)\n      }\n    }\n  } catch (error) {}\n}\n\n/**\n * Groups multiple forks togather and joins joins them with current task.\n *\n * @template T, X, M\n * @param {Task.Fork<T, X, M>[]} forks\n * @returns {Task.Task<void, X, M>}\n */\nexport function* group(forks) {\n  // Abort eraly if there'se no work todo.\n  if (forks.length === 0) return\n\n  const self = yield* current()\n  /** @type {Task.TaskGroup<T, X, M>} */\n  const group = new Group(self)\n  /** @type {Task.Failure<X>|null} */\n  let failure = null\n\n  for (const fork of forks) {\n    const { result } = fork\n    if (result) {\n      if (!result.ok && !failure) {\n        failure = result\n      }\n      continue\n    }\n    move(fork, group)\n  }\n\n  // Keep work looping until there is nom more work to be done\n  try {\n    if (failure) {\n      throw failure.error\n    }\n\n    while (true) {\n      yield* step(group)\n      if (Stack.size(group.stack) > 0) {\n        yield* suspend()\n      } else {\n        break\n      }\n    }\n  } catch (error) {\n    for (const task of group.stack.active) {\n      yield* abort(task, error)\n    }\n\n    for (const task of group.stack.idle) {\n      yield* abort(task, error)\n      enqueue(task)\n    }\n\n    throw error\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @param {Task.TaskGroup<T, X, M>} group\n */\nconst move = (fork, group) => {\n  const from = Group.of(fork)\n  if (from !== group) {\n    const { active, idle } = from.stack\n    const target = group.stack\n    fork.group = group\n    // If it is idle just move from one group to the other\n    // and update the group task thinks it belongs to.\n    if (idle.has(fork)) {\n      idle.delete(fork)\n      target.idle.add(fork)\n    } else {\n      const index = active.indexOf(fork)\n      // If task is in the job queue, we move it to a target job queue. Moving\n      // top task in the queue requires extra care so it does not end up\n      // processed by two groups which would lead to race. For that reason\n      // `step` loop checks for group changes on each turn.\n      if (index >= 0) {\n        active.splice(index, 1)\n        target.active.push(fork)\n      }\n      // otherwise task is complete\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @returns {Task.Task<T, X, M>}\n */\nexport function* join(fork) {\n  // If fork is still idle activate it.\n  if (fork.status === IDLE) {\n    yield* fork\n  }\n\n  if (!fork.result) {\n    yield* group([fork])\n  }\n\n  const result = /** @type {Task.Result<T, X>} */ (fork.result)\n  if (result.ok) {\n    return result.value\n  } else {\n    throw result.error\n  }\n}\n\n/**\n * @template T, X\n * @implements {Task.Future<T, X>}\n */\nclass Future {\n  /**\n   * @param {Task.StateHandler<T, X>} handler\n   */\n  constructor(handler) {\n    this.handler = handler\n    /**\n     * @abstract\n     * @type {Task.Result<T, X>|void}\n     */\n    this.result\n  }\n  /**\n   * @type {Promise<T>}\n   */\n  get promise() {\n    const { result } = this\n    const promise =\n      result == null\n        ? new Promise((succeed, fail) => {\n            this.handler.onsuccess = succeed\n            this.handler.onfailure = fail\n          })\n        : result.ok\n        ? Promise.resolve(result.value)\n        : Promise.reject(result.error)\n    Object.defineProperty(this, \"promise\", { value: promise })\n    return promise\n  }\n\n  /**\n   * @template U, [E=never]\n   * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]\n   * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]\n   * @returns {Promise<U|E>}\n   */\n  then(onresolve, onreject) {\n    return this.activate().promise.then(onresolve, onreject)\n  }\n  /**\n   * @template [U=never]\n   * @param {(error:X) => U} onreject\n   */\n  catch(onreject) {\n    return /** @type {Task.Future<T|U, never>} */ (\n      this.activate().promise.catch(onreject)\n    )\n  }\n  /**\n   * @param {() => void} onfinally\n   * @returns {Task.Future<T, X>}\n   */\n  finally(onfinally) {\n    return /** @type {Task.Future<T, X>} */ (\n      this.activate().promise.finally(onfinally)\n    )\n  }\n  /**\n   * @abstract\n   */\n  /* c8 ignore next 3 */\n  activate() {\n    return this\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Fork<T, X, M>}\n * @implements {Task.Controller<T, X, M>}\n * @implements {Task.Task<Task.Fork<T, X, M>, never>}\n * @implements {Task.Future<T, X>}\n * @extends {Future<T, X>}\n */\nclass Fork extends Future {\n  /**\n   * @param {Task.Task<T, X, M>} task\n   * @param {Task.ForkOptions} [options]\n   * @param {Task.StateHandler<T, X>} [handler]\n   * @param {Task.TaskState<T, M>} [state]\n   */\n  constructor(task, options = BLANK, handler = {}, state = INIT) {\n    super(handler)\n    this.id = ++ID\n    this.name = options.name || \"\"\n    /** @type {Task.Task<T, X, M>} */\n    this.task = task\n    this.state = state\n    this.status = IDLE\n    /** @type {Task.Result<T, X>} */\n    this.result\n    this.handler = handler\n\n    /** @type {Task.Controller<T, X, M>} */\n    this.controller\n  }\n\n  *resume() {\n    resume(this)\n  }\n\n  /**\n   * @returns {Task.Task<T, X, M>}\n   */\n  join() {\n    return join(this)\n  }\n\n  /**\n   * @param {X} error\n   */\n  abort(error) {\n    return abort(this, error)\n  }\n  /**\n   * @param {T} value\n   */\n  exit(value) {\n    return exit(this, value)\n  }\n  get [Symbol.toStringTag]() {\n    return \"Fork\"\n  }\n\n  /**\n   * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}\n   */\n  *[Symbol.iterator]() {\n    return this.activate()\n  }\n\n  activate() {\n    this.controller = this.task[Symbol.iterator]()\n    this.status = ACTIVE\n    enqueue(this)\n    return this\n  }\n\n  /**\n   * @private\n   * @param {any} error\n   * @returns {never}\n   */\n  panic(error) {\n    this.result = { ok: false, error }\n    this.status = FINISHED\n    const { handler } = this\n    if (handler.onfailure) {\n      handler.onfailure(error)\n    }\n\n    throw error\n  }\n\n  /**\n   * @private\n   * @param {Task.TaskState<T, M>} state\n   */\n  step(state) {\n    this.state = state\n    if (state.done) {\n      this.result = { ok: true, value: state.value }\n      this.status = FINISHED\n      const { handler } = this\n      if (handler.onsuccess) {\n        handler.onsuccess(state.value)\n      }\n    }\n\n    return state\n  }\n\n  /**\n   * @param {unknown} value\n   */\n  next(value) {\n    try {\n      return this.step(this.controller.next(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {T} value\n   */\n  return(value) {\n    try {\n      return this.step(this.controller.return(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {X} error\n   */\n  throw(error) {\n    try {\n      return this.step(this.controller.throw(error))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n}\n\n/**\n * @template M\n * @param {Task.Effect<M>} init\n * @param {(message:M) => Task.Effect<M>} next\n * @returns {Task.Task<void, never, never>}\n */\nexport const loop = function* (init, next) {\n  /** @type {Task.Controller<void, never, M>} */\n  const controller = yield* current()\n  const group = new Group(controller)\n  Group.enqueue(init[Symbol.iterator](), group)\n\n  while (true) {\n    for (const message of step(group)) {\n      Group.enqueue(next(message)[Symbol.iterator](), group)\n    }\n\n    if (Stack.size(group.stack) > 0) {\n      yield* suspend()\n    } else {\n      break\n    }\n  }\n}\n\nlet ID = 0\n/** @type {Task.Status} */\nconst IDLE = \"idle\"\nconst ACTIVE = \"active\"\nconst FINISHED = \"finished\"\n/** @type {Task.TaskState<any, any>} */\nconst INIT = { done: false, value: CURRENT }\n\nconst BLANK = {}\n\n/** @type {Task.Effect<never>} */\nconst NONE = (function* none() {})()\n\n/** @type {Task.Main<any, any, any>} */\nconst MAIN = new Main()\n","function Indexed() {}\n\nObject.defineProperties(Indexed, {\n  prototype: {\n    value: new Proxy(Object.prototype, {\n      /**\n       * @param {object} target\n       * @param {PropertyKey} property\n       * @param {{get(key:PropertyKey): any}} receiver\n       */\n      get(target, property, receiver) {\n        return typeof property === \"symbol\"\n          ? Reflect.get(target, property, receiver)\n          : receiver.get(property)\n      },\n    }),\n  },\n})\n\nexport { Indexed }\n","import { Indexed } from \"./indexed.js\"\n\n/**\n * @typedef {{\n * readonly byteOffset: number\n * readonly byteLength: number\n * readonly segments: Uint8Array[]\n * }} BufferSlice\n */\n\n/** @typedef {BufferView} View */\nexport const empty = () => new BufferView()\n\n/**\n * @param {Uint8Array[]} segments\n * @param {number} byteOffset\n * @param {number} byteLength\n */\nexport const create = (\n  segments,\n  byteOffset = 0,\n  byteLength = totalByteLength(segments)\n) => new BufferView(segments, byteOffset, byteLength)\n\n/**\n *\n * @param {Uint8Array[]} segments\n * @returns\n */\nconst totalByteLength = segments => {\n  let byteLength = 0\n  for (const segment of segments) {\n    byteLength += segment.byteLength\n  }\n  return byteLength\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} [startOffset]\n * @param {number} [endOffset]\n */\nexport const slice = (\n  buffer,\n  startOffset = 0,\n  endOffset = buffer.byteLength\n) => {\n  const segments = []\n  const start = startOffset < 0 ? buffer.byteLength - startOffset : startOffset\n  const end = endOffset < 0 ? buffer.byteLength - endOffset : endOffset\n\n  // If start at 0 offset and end is past buffer range it is effectively\n  // as same buffer.\n  if (start === 0 && end >= buffer.byteLength) {\n    return buffer\n  }\n\n  // If range is not within the current buffer just create an empty slice.\n  if (start > end || start > buffer.byteLength || end <= 0) {\n    return empty()\n  }\n\n  let byteLength = 0\n  let offset = 0\n  for (const segment of buffer.segments) {\n    const nextOffset = offset + segment.byteLength\n    // Have not found a start yet\n    if (byteLength === 0) {\n      // If end offset is within the current segment we know start is also,\n      // because it preceeds the end & we had not found start yet.\n      // In such case we create a view with only single segment of bytes\n      // in the range.\n      if (end <= nextOffset) {\n        const range = segment.subarray(start - offset, end - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n        break\n      }\n      // If start offeset falls with in current range (but not the end)\n      // we save matching buffer slice and update byteLength.\n      else if (start < nextOffset) {\n        const range =\n          start === offset ? segment : segment.subarray(start - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n      }\n    }\n    // Otherwise we already started collecting matching segments and are looking\n    // for the end end of the slice. If it is with in the current range capture\n    // the segment and create a view.\n    else if (end <= nextOffset) {\n      const range =\n        end === nextOffset ? segment : segment.subarray(0, end - offset)\n      segments.push(range)\n      byteLength += range.byteLength\n      break\n    }\n    // If end is past current range we just save the segment and continue.\n    else {\n      segments.push(segment)\n      byteLength += segment.byteLength\n    }\n\n    offset = nextOffset\n  }\n\n  return new BufferView(segments, buffer.byteOffset + start, byteLength)\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {Uint8Array} part\n */\n\nexport const push = (buffer, part) => {\n  if (part.byteLength > 0) {\n    // We MUTATE here but that is ok because it is out of bound for the passed\n    // buffer view so there will be no visible side effects.\n    buffer.segments.push(part)\n    return new BufferView(\n      buffer.segments,\n      buffer.byteOffset,\n      buffer.byteLength + part.byteLength\n    )\n  } else {\n    return buffer\n  }\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} n\n */\nexport const get = (buffer, n) => {\n  if (n < buffer.byteLength) {\n    let offset = 0\n    for (const segment of buffer.segments) {\n      if (n < offset + segment.byteLength) {\n        return segment[n - offset]\n      } else {\n        offset += segment.byteLength\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n *\n * @param {BufferView} buffer\n * @param {Uint8Array} target\n * @param {number} byteOffset\n */\nexport const copyTo = (buffer, target, byteOffset) => {\n  let offset = byteOffset\n  for (const segment of buffer.segments) {\n    target.set(segment, offset)\n    offset += segment.byteLength\n  }\n\n  return target\n}\n\n/**\n *\n * @param {BufferView} buffer\n */\nexport function* iterate(buffer) {\n  for (const part of buffer.segments) {\n    yield* part\n  }\n}\n\n/**\n * @extends {Indexed<number>}\n */\nclass BufferView extends Indexed {\n  /**\n   * @param {Uint8Array[]} segments\n   * @param {number} byteOffset\n   * @param {number} byteLength\n   */\n  constructor(segments = [], byteOffset = 0, byteLength = 0) {\n    super()\n    /** @hide */\n    this.segments = segments\n    /** @readonly */\n    this.byteLength = byteLength\n    /** @readonly */\n    this.length = byteLength\n    /** @readonly */\n    this.byteOffset = byteOffset\n  }\n\n  [Symbol.iterator]() {\n    return iterate(this)\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  slice(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  subarray(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   *\n   * @param {Uint8Array} bytes\n   */\n  push(bytes) {\n    return /** @type {BufferView} */ (push(this, bytes))\n  }\n\n  /**\n   * @param {number} n\n   */\n  get(n) {\n    return get(this, n)\n  }\n\n  /**\n   *\n   * @param {Uint8Array} target\n   * @param {number} offset\n   */\n  copyTo(target, offset) {\n    return copyTo(this, target, offset)\n  }\n}\n","/**\n * @param {string} reason\n * @returns {never}\n */\nexport const panic = reason => {\n  throw new Error(reason)\n}\n\n/**\n * @param {{ raw: readonly string[] | ArrayLike<string>}} template\n * @param {never} [subject]\n * @param {unknown[]} substitutions\n * @returns {never}\n */\nexport const unreachable = (template, subject, ...substitutions) =>\n  panic(String.raw(template, JSON.stringify(subject), ...substitutions))\n\nexport const EMPTY_BUFFER = new Uint8Array(0)\n/** @type {any[]} */\nexport const EMPTY = []\n","import * as BufferQueue from \"./chunker/buffer.js\"\nimport * as Chunker from \"./chunker/api.js\"\nimport { EMPTY } from \"../writer/util.js\"\nexport * from \"./chunker/api.js\"\n\n/**\n * @typedef {{\n * chunker: Chunker.Chunker\n * }} Config\n *\n *\n * @typedef {{\n * buffer: BufferQueue.View\n * config: Config\n * }} Chunker\n *\n * @typedef {Chunker & {chunks: Chunker.Chunk[]}} ChunkerWithChunks\n */\n\n/**\n * @param {Config} config\n * @returns {Chunker}\n */\nexport const open = config => ({\n  config,\n  buffer: BufferQueue.empty(),\n})\n\n/**\n * @param {Chunker} state\n * @param {Uint8Array} bytes\n * @returns {ChunkerWithChunks}\n */\nexport const write = (state, bytes) =>\n  bytes.byteLength > 0\n    ? split(state.config, state.buffer.push(bytes), false)\n    : { ...state, chunks: EMPTY }\n\n/**\n * @param {Chunker} state\n * @returns {ChunkerWithChunks}\n */\nexport const close = state => split(state.config, state.buffer, true)\n\n/**\n * @param {Config} config\n * @param {BufferQueue.View} buffer\n * @param {boolean} end\n * @returns {ChunkerWithChunks}\n */\n\nexport const split = (config, buffer, end) => {\n  const chunker = config.chunker\n  const chunks = []\n\n  let offset = 0\n  for (const size of chunker.cut(chunker.context, buffer, end)) {\n    // We may be splitting empty buffer in which case there will be no chunks\n    // in it so we make sure that we do not emit empty buffer.\n    if (size > 0) {\n      const chunk = buffer.subarray(offset, offset + size)\n      chunks.push(chunk)\n      offset += size\n    }\n  }\n\n  return { config, chunks, buffer: buffer.subarray(offset) }\n}\n","import * as Layout from \"./api.js\"\nimport * as Queue from \"./queue/api.js\"\nexport * from \"./queue/api.js\"\n\n/**\n * @returns {Queue.Result}\n */\nexport const empty = () => ({\n  mutable: false,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: [],\n})\n\nexport const mutable = () => ({\n  mutable: true,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: EMPTY,\n})\n\n/**\n * Adds given layout node to the layout queue. If links for all of the node\n * children are available correspnoding linked node is added (removing links\n * form the queue) otherwise `nood` is added to the wait queue until all the\n * needed links are added.\n *\n *\n * @param {Layout.Branch} node\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\nexport const addNode = (node, queue) => addNodes([node], queue)\n\n/**\n *\n * @param {Layout.Branch[]} newNodes\n * @param {Queue.Queue} input\n * @returns {Queue.Result}\n */\nexport const addNodes = (newNodes, input) => {\n  let queue = patch(input, {})\n  for (const node of newNodes) {\n    const { ready, has, wants } = collect(node.children, queue.links)\n    // If node isn't waiting on any of the children it's ready to be linked\n    // so we add linked node diretly.\n    if (wants.length === 0) {\n      queue = patch(queue, {\n        links: assign(undefined, has),\n        linked: [{ id: node.id, links: ready }],\n      })\n    } else {\n      queue = patch(queue, {\n        needs: assign(node.id, wants),\n        nodes: {\n          [node.id]: {\n            children: node.children,\n            count: wants.length,\n          },\n        },\n      })\n    }\n  }\n\n  return queue\n}\n\n/**\n * Adds link to the queue. If queue contains a node that needs this link it gets\n * updated. Either it's gets linked (when it was blocked only on this link) or\n * it's want could is reduced. If no node needed this link it just gets stored\n * for the future node that will need it.\n *\n *\n * @param {Queue.NodeID} id\n * @param {Queue.Link} link\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\n\nexport const addLink = (id, link, queue) => {\n  const nodeID = queue.needs[id]\n  const node = queue.nodes[nodeID]\n  // We have node than needs this link.\n  if (node != null) {\n    // This is the only link it needed so we materialize the node and remove\n    // links and needs associated with it.\n    if (node.count === 1) {\n      const { ready, has } = collect(node.children, {\n        ...queue.links,\n        [id]: link,\n      })\n\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: assign(undefined, has),\n        nodes: { [nodeID]: undefined },\n        linked: [{ id: nodeID, links: ready }],\n      })\n    }\n    // If node needs more links we just reduce a want count and remove this\n    // need.\n    else {\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: { [id]: link },\n        nodes: {\n          [nodeID]: {\n            ...node,\n            count: node.count - 1,\n          },\n        },\n      })\n    }\n  }\n  // If we have no one waiting for this link just add it to the queue\n  else {\n    return patch(queue, {\n      links: { [id]: link },\n    })\n  }\n}\n\n/**\n *\n * @param {Queue.Queue} queue\n * @param {Queue.Delta} delta\n */\n\nconst patch = (queue, { needs, nodes, links, linked }) => {\n  const result = queue.mutable ? queue : { ...queue }\n  const original = queue.mutable ? BLANK : undefined\n\n  if (needs) {\n    result.needs = patchDict(queue.needs, needs, original)\n  }\n\n  if (nodes) {\n    result.nodes = patchDict(queue.nodes, nodes, original)\n  }\n\n  if (links) {\n    result.links = patchDict(queue.links, links, original)\n  }\n\n  result.linked = linked\n    ? append(queue.linked || EMPTY, linked, EMPTY)\n    : queue.linked || []\n\n  return /** @type {Queue.Result} */ (result)\n}\n\n/**\n * @template V\n * @template {PropertyKey} K\n * @param {V} value\n * @param {K[]} keys\n * @returns {Record<K, V>}\n */\n\nconst assign = (value, keys) => {\n  const delta = /** @type {Record<K, V>} */ ({})\n  for (const key of keys) {\n    delta[key] = value\n  }\n\n  return delta\n}\n\n/**\n * @template {PropertyKey} K\n * @template V\n * @param {Record<K, V>} target\n *\n * @param {Record<K, V|void>} delta\n * @param {Record<K, V>} original\n * @returns {Record<K, V>}\n */\n\nconst patchDict = (target, delta, original = target) => {\n  const result = target === original ? { ...target } : target\n  for (const entry of Object.entries(delta)) {\n    const [id, value] = /** @type {[K, V|void]} */ (entry)\n    if (value == null) {\n      delete result[id]\n    } else {\n      result[id] = value\n    }\n  }\n\n  return result\n}\n/**\n *\n * @param {Iterable<[Queue.NodeID, Queue.Link]>} entries\n * @param {Queue.Queue} queue\n * @returns {Queue.Queue}\n */\nexport const addLinks = (entries, queue) => {\n  for (const [id, link] of entries) {\n    queue = addLink(id, link, queue)\n  }\n  return queue\n}\n\n/**\n * @param {Queue.Queue} queue\n */\n\nexport const isEmpty = queue =>\n  Object.keys(queue.nodes).length === 0 && Object.keys(queue.links).length === 0\n\n/**\n * @template T\n * @param {T[]} target\n * @param {T[]} items\n * @param {T[]} original\n */\nconst append = (target, items, original = target) => {\n  if (target === original) {\n    return [...target, ...items]\n  } else {\n    for (const item of items) {\n      target.push(item)\n    }\n    return target\n  }\n}\n\n/**\n * @param {Queue.NodeID[]} children\n * @param {Record<Queue.NodeID, Queue.Link>} source\n * @returns {{has:Queue.NodeID[], wants:Queue.NodeID[], ready:Queue.Link[]}}\n */\nconst collect = (children, source) => {\n  const has = []\n  const wants = []\n  const ready = []\n  for (const child of children) {\n    const link = source[child]\n    if (link) {\n      has.push(child)\n      ready.push(link)\n    } else {\n      wants.push(child)\n    }\n  }\n\n  return { has, wants, ready }\n}\n\nconst EMPTY = /** @type {never[]} */ (Object.freeze([]))\n\nconst BLANK = /** @type {Record<never, never>} */ (Object.freeze({}))\n","import * as Task from \"actor\"\nimport * as API from \"./api.js\"\nimport * as Layout from \"./layout/api.js\"\nimport * as UnixFS from \"../codec.js\"\nimport * as Chunker from \"./chunker.js\"\nimport { EMPTY_BUFFER, panic, unreachable } from \"../writer/util.js\"\nimport * as Queue from \"./layout/queue.js\"\n\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'open'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * chunker: Chunker.Chunker\n * layout: Layout\n * nodeQueue: Queue.Queue\n * }} Open\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'closed'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly rootID: Layout.NodeID\n * readonly end?: Task.Fork<void, never>\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Closed\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'linked'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly link: Layout.Link\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Linked\n */\n\n/**\n * @template Layout\n * @typedef {Open<Layout>|Closed<Layout>|Linked<Layout>} State\n */\n\n/**\n * @template {object} Layout\n * @typedef {{\n * state: State<Layout>\n * effect: Task.Effect<Message>\n * }} Update\n */\n/**\n * @typedef {never\n * |{type:\"write\", bytes:Uint8Array}\n * |{type:\"link\", link:API.EncodedFile}\n * |{type:\"block\"}\n * |{type: \"close\"}\n * |{type: \"end\"}\n * } Message\n */\n\n/**\n * @template Layout\n * @param {Message} message\n * @param {State<Layout>} state\n */\nexport const update = (message, state) => {\n  switch (message.type) {\n    case \"write\":\n      return write(state, message.bytes)\n    case \"link\":\n      return link(state, message.link)\n    /* c8 ignore next 2 */\n    case \"block\":\n      return { state, effect: Task.none() }\n    case \"close\":\n      return close(state)\n    case \"end\":\n      return { state, effect: Task.none() }\n    default:\n      return unreachable`File Writer got unknown message ${message}`\n  }\n}\n\n/**\n * @template Layout\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Metadata} metadata\n * @param {API.EncoderSettings} config\n * @returns {State<Layout>}\n */\nexport const init = (writer, metadata, config) => {\n  return {\n    status: \"open\",\n    metadata,\n    config,\n    writer,\n    chunker: Chunker.open({ chunker: config.chunker }),\n    layout: config.fileLayout.open(),\n    // Note: Writing in large slices e.g. 1GiB at a time creates large queues\n    // with around `16353` items. Immutable version ends up copying it every\n    // time state of the queue changes, which introduces significant overhead.\n    // To avoid this overhead we use mutable implementation which is API\n    // compatible but makes in place updates.\n    // TODO: We should consider using Persistent bit-partitioned vector tries\n    // instead of arrays which would provide immutable interface with neglegable\n    // overhead.\n    // @see https://github.com/Gozala/vectrie\n    nodeQueue: Queue.mutable(),\n  }\n}\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {Uint8Array} bytes\n * @returns {Update<Layout>}\n */\nexport const write = (state, bytes) => {\n  if (state.status === \"open\") {\n    // Chunk up provided bytes\n    const { chunks, ...chunker } = Chunker.write(state.chunker, bytes)\n\n    // Pass chunks to layout engine to produce nodes\n    const { nodes, leaves, layout } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    // Create leaf encode tasks for all new leaves\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    return {\n      state: {\n        ...state,\n        chunker,\n        layout,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n      }),\n    }\n  } else {\n    return panic(\"Unable to perform write on closed file\")\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {API.EncodedFile} entry\n * @returns {Update<Layout>}\n */\nexport const link = (state, { id, link, block }) => {\n  let { linked, ...nodeQueue } = Queue.addLink(id, link, state.nodeQueue)\n\n  const tasks = encodeBranches(linked, state.config)\n\n  /** @type {State<Layout>} */\n  const newState =\n    state.status === \"closed\" && id === state.rootID\n      ? {\n          ...state,\n          status: \"linked\",\n          link,\n          nodeQueue,\n        }\n      : { ...state, nodeQueue }\n\n  // If we just linked a root and there is a **suspended** \"end\" task we create\n  // a task to resume it.\n  const end =\n    state.status === \"closed\" && id === state.rootID && state.end\n      ? state.end.resume()\n      : Task.none()\n\n  return {\n    state: newState,\n    effect: Task.listen({\n      link: Task.effects(tasks),\n      block: writeBlock(state.writer, block),\n      end,\n    }),\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @returns {Update<Layout>}\n */\nexport const close = state => {\n  if (state.status === \"open\") {\n    const { chunks } = Chunker.close(state.chunker)\n    const { layout, ...write } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { root, ...close } = state.config.fileLayout.close(\n      layout,\n      state.metadata\n    )\n\n    const [nodes, leaves] = isLeafNode(root)\n      ? [\n          [...write.nodes, ...close.nodes],\n          [...write.leaves, ...close.leaves, root],\n        ]\n      : [\n          [...write.nodes, ...close.nodes, root],\n          [...write.leaves, ...close.leaves],\n        ]\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    // We want to keep run loop around until root node is linked. To\n    // accomplish this we fork a task that suspends itself, which we will\n    // resume when root is linked (see link function).\n    // Below we join this forked task in our effect, this way effect is not\n    // complete until task forked task is, which will do once we link the\n    // root.\n    const fork = Task.fork(Task.suspend())\n\n    return {\n      state: {\n        ...state,\n        chunker: null,\n        layout: null,\n        rootID: root.id,\n        status: \"closed\",\n        end: fork,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n        end: Task.join(fork),\n      }),\n    }\n  } else {\n    return { state, effect: Task.none() }\n  }\n}\n\n/**\n * Creates concurrent leaf encode tasks. Each one will have an ID corresponding\n * to index in the queue.\n *\n * @param {Layout.Leaf[]} leaves\n * @param {API.EncoderSettings} config\n */\nconst encodeLeaves = (leaves, config) =>\n  leaves.map(leaf => encodeLeaf(config, leaf, config.fileChunkEncoder))\n\n/**\n * @param {API.EncoderSettings} config\n * @param {Layout.Leaf} leaf\n * @param {API.FileChunkEncoder} encoder\n * @returns {Task.Task<API.EncodedFile, never>}\n */\nconst encodeLeaf = function* ({ hasher, linker }, { id, content }, encoder) {\n  const bytes = encoder.encode(content ? asUint8Array(content) : EMPTY_BUFFER)\n  const hash = yield* Task.wait(hasher.digest(bytes))\n  const cid = linker.createLink(encoder.code, hash)\n\n  const block = { cid, bytes }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: content ? content.byteLength : 0,\n    dagByteLength: bytes.byteLength,\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {Queue.LinkedNode[]} nodes\n * @param {API.EncoderSettings} config\n */\nconst encodeBranches = (nodes, config) =>\n  nodes.map(node => encodeBranch(config, node))\n\n/**\n * @template Layout\n * @param {API.EncoderSettings<Layout>} config\n * @param {Queue.LinkedNode} node\n * @param {UnixFS.Metadata} [metadata]\n * @returns {Task.Task<API.EncodedFile>}\n */\nexport const encodeBranch = function* (config, { id, links }, metadata) {\n  const bytes = config.fileEncoder.encode({\n    type: UnixFS.NodeType.File,\n    layout: \"advanced\",\n    parts: links,\n    metadata,\n  })\n  const hash = yield* Task.wait(Promise.resolve(config.hasher.digest(bytes)))\n  const cid = config.linker.createLink(config.fileEncoder.code, hash)\n  const block = { bytes, cid }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: UnixFS.cumulativeContentByteLength(links),\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, links),\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Block} block\n * @returns {Task.Task<void, never>}\n */\n\nexport const writeBlock = function* (writer, block) {\n  if ((writer.desiredSize || 0) <= 0) {\n    yield* Task.wait(writer.ready)\n  }\n  writer.write(block)\n}\n\n/**\n *\n * @param {Uint8Array|Chunker.Chunk} buffer\n * @returns\n */\n\nconst asUint8Array = buffer =>\n  buffer instanceof Uint8Array\n    ? buffer\n    : buffer.copyTo(new Uint8Array(buffer.byteLength), 0)\n\n/**\n * @param {Layout.Node} node\n * @returns {node is Layout.Leaf}\n */\nconst isLeafNode = node => node.children == null\n","import * as API from \"./api.js\"\n\nexport const name = \"fixed\"\n/**\n * @typedef {Object} FixedSize\n * @property {number} maxChunkSize\n */\n\n/** @type {FixedSize} */\nexport const context = {\n  maxChunkSize: 262144,\n}\n\nexport const type = \"Stateless\"\n\n/**\n * @param {number} maxChunkSize\n * @returns {API.StatelessChunker<FixedSize>}\n */\nexport const withMaxChunkSize = maxChunkSize => ({\n  type: \"Stateless\",\n  context: { maxChunkSize },\n  name,\n  cut,\n})\n\n/**\n * @param {FixedSize} maxChunkSize\n * @param {API.Chunk} buffer\n * @param {boolean} end\n * @returns {number[]}\n */\nexport const cut = ({ maxChunkSize }, { byteLength }, end) => {\n  // number of fixed size chunks that would fit\n  const n = (byteLength / maxChunkSize) | 0\n  const chunks = new Array(n).fill(maxChunkSize)\n  const lastChunkSize = end ? byteLength - n * maxChunkSize : 0\n  if (lastChunkSize > 0) {\n    chunks.push(lastChunkSize)\n  }\n  return chunks\n}\n","import * as Layout from \"./api.js\"\nimport * as Chunker from \"./../chunker/api.js\"\n\n/**\n * Type representing a state of the balanced tree. First row hold leaves coming\n * into a builder, once number of leaves in the stack reaches `maxChildren` they\n * are moved into `RootNode` instance which is pushed into the next row of nodes.\n * If next row now contains `maxChildren` nodes from there are again moved into\n * a new `RootNode` and pushed into next row etc...\n *\n * For illustration let's assume we have `maxChildren: 3`, after 3 leafs were\n * added tree will have following layout\n *\n * ```\n *           (root1)\n *              |\n *    ----------------------\n *    |         |          |\n * (leaf1)   (leaf2)    (leaf3)\n * ```\n *\n * Which in our model before flushing is represented as follows:\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf1, leaf2, leaf3]\n *    nodeIndex: []\n *    nodes: []\n * }\n * ```\n *\n * After flushing 3 leaves (which is width) are moved into a `RootNode` that\n * is added to `nodes` array (and returned so that caller can create a block).\n * Additionally position of the added node is captured in the `index` at an\n * appropriate depth `0` (that is because we don't count leaves into depth).\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: []\n *    nodeIndex: [[0]]\n *    nodes: [new RootNode([leaf1, leaf2, leaf3])]\n * }\n * ```\n *\n * Increasing number of leaves to 10 would produce following tree layout\n *\n *```\n *                                                         (root7)\n *                                                           |\n *                                    ------------------------------------------\n *                                    |                                        |\n *                                 (root4)                                  (root6)\n *                                    |                                        |\n *            -------------------------------------------------                |\n *            |                       |                       |                |\n *         (root1)                 (root2)                 (root3)          (root5)\n *            |                       |                       |                |\n *    --------|--------       --------|--------       --------|--------        |\n *    |       |       |       |       |       |       |       |       |        |\n * (leaf1) (leaf2) (leaf3) (leaf4) (leaf5) (leaf6) (leaf7) (leaf8) (leaf9) (leaf10)\n * ```\n *\n * Which in our model will look as follows (note we do not have root5 - root7\n * in model because they are build once width is reached or once builder is\n * closed)\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf10]\n *    nodeIndex: [\n *      [0, 1, 2], // [r1, r2, r3]\n *      [3]        // [r4]\n *     ]\n *    nodes: [\n *      new Node([leaf1, leaf2, leaf3]), // r1\n *      new Node([leaf4, leaf5, leaf6]), // r2\n *      new Node([leaf7, leaf8, leaf9]), // r3\n *      new Node([ // r4\n *         new Node([leaf1, leaf2, leaf3]), // r1\n *         new Node([leaf4, leaf5, leaf6]), // r2\n *         new Node([leaf7, leaf8, leaf9]), // r3\n *      ])\n *    ]\n * }\n * ```\n *\n * @typedef {{\n * width: number\n * head: Chunker.Chunk | null\n * leafIndex: number[]\n * nodeIndex: number[][]\n * lastID: number\n * }} Balanced\n */\n\nclass Node {\n  /**\n   *\n   * @param {number} id\n   * @param {number[]} children\n   * @param {Layout.Metadata} [metadata]\n   */\n  constructor(id, children, metadata) {\n    this.id = id\n    this.children = children\n    this.metadata = metadata\n  }\n}\n\n/**\n * @typedef Options\n * @property {number} width - Max children per node.\n *\n * @param {number} width\n * @returns {Layout.LayoutEngine<Balanced>}\n */\nexport const withWidth = width => ({\n  open: () => open({ width }),\n  write,\n  close,\n})\n\nexport const defaults = { width: 174 }\n\n/**\n * @param {Options} options\n * @returns {Balanced}\n */\nexport const open = ({ width } = defaults) => ({\n  width,\n\n  head: null,\n  leafIndex: [],\n  nodeIndex: [],\n  lastID: 0,\n})\n\n/**\n *\n * @param {Balanced} layout\n * @param {Chunker.Chunk[]} chunks\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const write = (layout, chunks) => {\n  if (chunks.length === 0) {\n    return { layout, nodes: EMPTY, leaves: EMPTY }\n  } else {\n    let { lastID } = layout\n    // We need to hold on to the first chunk until we either get a second chunk\n    // (at which point we know our layout will have branches) or until we close\n    // (at which point our layout will be single leaf or node depneding on\n    // metadata)\n    const [head, slices] = layout.head\n      ? // If we had a head we have more then two chunks (we already checked\n        // chunks weren't empty) so we process head along with other chunks.\n        [null, (chunks.unshift(layout.head), chunks)]\n      : // If we have no head no leaves and got only one chunk we have to save it\n      // until we can decide what to do with it.\n      chunks.length === 1 && layout.leafIndex.length === 0\n      ? [chunks[0], EMPTY]\n      : // Otherwise we have no head but got enough chunks to know we'll have a\n        // node.\n        [null, chunks]\n\n    if (slices.length === 0) {\n      return { layout: { ...layout, head }, nodes: EMPTY, leaves: EMPTY }\n    } else {\n      const leafIndex = [...layout.leafIndex]\n      const leaves = []\n      for (const chunk of slices) {\n        const leaf = { id: ++lastID, content: chunk }\n        leaves.push(leaf)\n        leafIndex.push(leaf.id)\n      }\n\n      if (leafIndex.length > layout.width) {\n        return flush({ ...layout, leafIndex, head, lastID }, leaves)\n      } else {\n        return {\n          layout: { ...layout, head, leafIndex, lastID },\n          leaves,\n          nodes: EMPTY,\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {Balanced} state\n * @param {Layout.Leaf[]} leaves\n * @param {Layout.Branch[]} [nodes]\n * @param {boolean} [close]\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const flush = (state, leaves = EMPTY, nodes = [], close = false) => {\n  let { lastID } = state\n  const nodeIndex = state.nodeIndex.map(row => [...row])\n  const leafIndex = [...state.leafIndex]\n  const { width } = state\n\n  // Move leaves into nodes\n  while (leafIndex.length > width || (leafIndex.length > 0 && close)) {\n    grow(nodeIndex, 1)\n    const node = new Node(++lastID, leafIndex.splice(0, width))\n    nodeIndex[0].push(node.id)\n    nodes.push(node)\n  }\n\n  let depth = 0\n  while (depth < nodeIndex.length) {\n    const row = nodeIndex[depth]\n    depth++\n\n    while (\n      row.length > width ||\n      (row.length > 0 && close && depth < nodeIndex.length)\n    ) {\n      const node = new Node(++lastID, row.splice(0, width))\n      grow(nodeIndex, depth + 1)\n      nodeIndex[depth].push(node.id)\n      nodes.push(node)\n    }\n  }\n\n  return { layout: { ...state, lastID, leafIndex, nodeIndex }, leaves, nodes }\n}\n\n/**\n * @param {Balanced} layout\n * @param {Layout.Metadata} [metadata]\n * @returns {Layout.CloseResult}\n */\nexport const close = (layout, metadata) => {\n  const state = layout\n  if (layout.head) {\n    return {\n      root: { id: 1, content: layout.head, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else if (layout.leafIndex.length === 0) {\n    return {\n      root: { id: 1, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else {\n    // Flush with width 1 so all the items will be propagate up the tree\n    // and height of `depth-1` so we propagate nodes all but from the top\n    // most level\n    const { nodes, layout } = flush(state, EMPTY, [], true)\n\n    const { nodeIndex } = layout\n    const height = nodeIndex.length - 1\n\n    const top = nodeIndex[height]\n    if (top.length === 1) {\n      const root = nodes[nodes.length - 1]\n      nodes.length = nodes.length - 1\n      return { root, nodes, leaves: EMPTY }\n    } else {\n      const root = new Node(layout.lastID + 1, top, metadata)\n      return { root, nodes, leaves: EMPTY }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T[][]} index\n * @param {number} length\n */\nconst grow = (index, length) => {\n  while (index.length < length) {\n    index.push([])\n  }\n  return index\n}\n\n/** @type {never[]} */\nconst EMPTY = []\n","import * as API from \"./file/api.js\"\nimport * as UnixFS from \"./codec.js\"\nimport * as Writer from \"./file/writer.js\"\nimport * as Task from \"actor\"\nimport { panic } from \"./writer/util.js\"\nimport * as FixedSize from \"./file/chunker/fixed.js\"\nimport { sha256 } from \"multiformats/hashes/sha2\"\nimport { CID } from \"multiformats/cid\"\nimport * as Balanced from \"./file/layout/balanced.js\"\n\nexport * from \"./file/api.js\"\n\n/**\n * @returns {API.EncoderSettings}\n */\nexport const defaults = () => ({\n  chunker: FixedSize,\n  fileChunkEncoder: UnixFSLeaf,\n  smallFileEncoder: UnixFSLeaf,\n  fileEncoder: UnixFS,\n  fileLayout: Balanced.withWidth(174),\n  hasher: sha256,\n  linker: { createLink: CID.createV1 },\n})\n\n/**\n * @template {unknown} Layout\n * @param {Partial<API.EncoderSettings<Layout>>} config\n * @returns {API.EncoderSettings<Layout>}\n */\nexport const configure = config => ({\n  ...defaults(),\n  ...config,\n})\n\nexport const UnixFSLeaf = {\n  code: UnixFS.code,\n  name: UnixFS.name,\n  encode: UnixFS.encodeFileChunk,\n}\n\nexport const UnixFSRawLeaf = {\n  code: UnixFS.code,\n  name: UnixFS.name,\n  encode: UnixFS.encodeRaw,\n}\n\n/**\n * @template Layout\n * @param {API.Options<Layout>} options\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, metadata = {}, settings = defaults() }) =>\n  new FileWriterView(Writer.init(writer, metadata, configure(settings)))\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {Uint8Array} bytes\n * @return {Promise<API.View<T>>}\n */\n\nexport const write = async (view, bytes) => {\n  await perform(view, Task.send({ type: \"write\", bytes }))\n  return view\n}\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {API.CloseOptions} options\n */\nexport const close = async (\n  view,\n  { releaseLock = false, closeWriter = false } = {}\n) => {\n  await perform(view, Task.send({ type: \"close\" }))\n  const { state } = view\n  if (state.status === \"linked\") {\n    if (closeWriter) {\n      await view.state.writer.close()\n    } else if (releaseLock) {\n      view.state.writer.releaseLock()\n    }\n    return state.link\n    /* c8 ignore next 5 */\n  } else {\n    panic(\n      `Expected writer to be in 'linked' state after close, but it is in \"${state.status}\" instead`\n    )\n  }\n}\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {Task.Effect<Writer.Message>} effect\n */\nconst perform = (view, effect) =>\n  Task.fork(\n    Task.loop(effect, message => {\n      const { state, effect } = Writer.update(message, view.state)\n      view.state = state\n      return effect\n    })\n  )\n\n/**\n * @template Layout\n * @implements {API.View<Layout>}\n */\nclass FileWriterView {\n  /**\n   * @param {Writer.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.config\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {Promise<API.View<Layout>>}\n   */\n  write(bytes) {\n    return write(this, bytes)\n  }\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.FileLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n}\n","import * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nexport * from \"./directory/api.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(),\n    closed: false,\n  })\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n * @param {API.EntryLink} link\n * @param {API.WriteOptions} options\n */\nexport const set = (view, name, link, { overwrite = false } = {}) => {\n  const writable = asWritable(view.state)\n  if (name.includes(\"/\")) {\n    throw new Error(\n      `Directory entry name \"${name}\" contains forbidden \"/\" character`\n    )\n  }\n  if (!overwrite && writable.entries.has(name)) {\n    throw new Error(`Directory already contains entry with name \"${name}\"`)\n  } else {\n    writable.entries.set(name, link)\n    return view\n  }\n}\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n */\nexport const remove = (view, name) => {\n  const writer = asWritable(view.state)\n  writer.entries.delete(name)\n  return view\n}\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\n      `Can not change written directory, but you can .fork() and make changes to it`\n    )\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n  const entries = [...links(view)]\n  const node = UnixFS.createFlatDirectory(entries, metadata)\n  const bytes = UnixFS.encodeDirectory(node)\n  const digest = await settings.hasher.digest(bytes)\n  /** @type {UnixFS.Link<UnixFS.Directory>} */\n  const cid = settings.linker.createLink(UnixFS.code, digest)\n\n  // we make sure that writer has some capacity for this write. If it\n  // does not we await.\n  if ((writer.desiredSize || 0) <= 0) {\n    await writer.ready\n  }\n  // once writer has some capacity we write a block, however we do not\n  // await completion as we don't care when it's taken off the stream.\n  writer.write({ cid, bytes })\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @returns {IterableIterator<UnixFS.DirectoryEntryLink>}\n */\nexport const links = function* ({ state }) {\n  for (const [name, { dagByteLength, cid }] of state.entries) {\n    yield /** @type {UnixFS.DirectoryEntryLink} */ ({\n      name,\n      dagByteLength,\n      cid,\n    })\n  }\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(state.entries.entries()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass DirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  links() {\n    return links(this)\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n","import * as API from \"./api.js\"\n// @ts-expect-error - has no types\nimport murmur from \"murmurhash3js-revisited\"\n\nconst utf8 = new TextEncoder()\n\n/**\n * @typedef {(bytes:Uint8Array) => API.Uint32} Hasher\n * @type {Hasher}\n */\nexport const hash32 = murmur.x64.hash126\n\n/**\n * @param {Partial<API.Options<API.Uint32>>} options\n * @returns {API.Path<API.Uint32>}\n */\n/* c8 ignore next 45 */\nexport const configure = ({ bitWidth = 5, hash = hash32 }) => {\n  const hashSize = 4\n  if (bitWidth > hashSize * 8) {\n    throw new RangeError(\n      `Can not use bitWidth ${bitWidth} which exceeds the hashSize ${hashSize}`\n    )\n  }\n\n  if (hashSize * 8 > 32) {\n    throw new RangeError(\n      `Can not use hashSize ${hashSize} as it can not be encoded in Uint32`\n    )\n  }\n\n  // Mask for reading `bitWidth` number of bits from the end.\n  const mask = 0xffffffff >>> (32 - bitWidth)\n\n  /**\n   * Determines bit position for the path entry at the given `depth`.\n   * ```js\n   * const key = hash(\"result\") // 0b00011010010110010101111100110010\n   * // Which is following path (in reverse as we read from the right)\n   * // 10010/11001/10111/10010/00101/01101/00000 -> [ 18, 25, 23, 18, 5, 13, 0 ]\n   * at(key, 0) // 0b10010 -> 18\n   * at(key, 1) // 0b11001 -> 25\n   * at(key, 2) // 0b10111 -> 23\n   * at(key, 3) // 0b10010 -> 18\n   * at(key, 4) // 0b00101 -> 5\n   * at(key, 5) // 0b01101 -> 13\n   * at(key, 6) // 0b00000 -> 0\n   * ```\n   *\n   * @param {API.Uint32} path\n   * @param {number} depth\n   */\n  const at = (path, depth) => (path >>> (depth * bitWidth)) & mask\n\n  /**\n   * @param {string} key\n   * @returns {API.Uint32}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { at, from, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n","import { bytes } from 'multiformats'\nimport { from } from 'multiformats/hashes/hasher'\n// @ts-expect-error no types\nimport mur from 'murmurhash3js-revisited'\n\n/**\n * @param {number} number\n * @returns {Uint8Array}\n */\nfunction fromNumberTo32BitBuf (number) {\n  const bytes = new Array(4)\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 0xff\n    number = number >> 8\n  }\n  return new Uint8Array(bytes)\n}\n\nexport const murmur332 = from({\n  name: 'murmur3-32',\n  code: 0x23,\n  encode: (input) => fromNumberTo32BitBuf(mur.x86.hash32(input))\n})\n\nexport const murmur3128 = from({\n  name: 'murmur3-128',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input))\n})\n\n// A special-use 0x22 that truncates 64 bits, specifically for use in the UnixFS HAMT\nexport const murmur364 = from({\n  name: 'murmur3-x64-64',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input)).subarray(0, 8)\n})\n","import * as API from \"./api.js\"\nconst utf8 = new TextEncoder()\nimport { murmur364 } from \"@multiformats/murmur3\"\n\n/**\n * @param {Uint8Array} bytes\n */\n/* c8 ignore next 2 */\nexport const hash64 = bytes =>\n  /** @type {Uint8Array} */ (murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\n/* c8 ignore next 25 */\nexport const configure = ({ bitWidth = 8, hash = hash64 } = {}) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => {\n    const offset = depth * bitWidth\n    if (offset > hashSize) {\n      throw new RangeError(`Out of bounds`)\n    }\n\n    return toInt(path, offset, bitWidth)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Uint8Array}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { from, at, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset - bit offset\n * @param {number} count - number of bits to consume\n */\nexport const toInt = (bytes, offset, count) => {\n  let byteOffset = (offset / 8) | 0\n  let bitOffset = offset % 8\n  let desired = count\n  let bits = 0\n  while (desired > 0 && byteOffset < bytes.byteLength) {\n    const byte = bytes[byteOffset]\n    const available = 8 - bitOffset\n\n    const taking = available < desired ? available : desired\n    const bitsLeft = 8 - bitOffset - taking\n    // mask to turn of bits before bitOffset\n    const mask = 0xff >> bitOffset\n    // turn off offset bits and shift to drop remaining bit on the right\n    const value = (mask & byte) >> bitsLeft\n    bits = (bits << taking) + value\n\n    desired -= taking\n    byteOffset++\n    bitOffset = 0\n  }\n\n  return bits\n}\n","export * from \"./api.js\"\nimport * as Node from \"./node.js\"\nimport { create as createBitmapIndexedNode } from \"./node.js\"\nimport * as API from \"./api.js\"\nimport * as Uint32Path from \"./path/Uint32.js\"\nimport * as Uint8ArrayPath from \"./path/Uint8Array.js\"\nimport * as Uint32BitField from \"./bitfield/Uint32.js\"\nimport * as Uint8ArrayBitField from \"./bitfield/Uint8Array.js\"\n\nconst NOT_FOUND = new RangeError(\"Not Found\")\n\n/**\n * A `bitWidth` determines the number of bits of the hash to use for index\n * calculation at each level of the tree. In first layer will distribute\n * children by the first `bitWidth` bits of the key hash. In the next layer\n * next `bitWidth` number of bits of the key hash are used to determine\n * placement of it's children and so on. Each node in the tree will hold\n * `2 ** bitWidth` number of elements.\n *\n * For example when we insert an entry named `result` it will generate a\n * folowing hash (with murmur3 32) `442064690` which in binary would be\n *\n * ```\n * 11010010110010101111100110010\n * ```\n *\n * Which will correspond to a following key path\n *\n * ```\n * 11010/01011/00101/01111/10011/0010\n * ```\n *\n * Whis in decimals would be\n *\n * ```ts\n * 26/11/5/15/19/2'\n * ```\n *\n * If we then insert `fish` it would produce following path\n *\n * ```ts\n * 26/3/4/18/28/19/1\n * ```\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const empty = options => {\n  const config = configure(options)\n  return new PersistentHashMap(0, createBitmapIndexedNode(config, null), config)\n}\n\n/**\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} config\n * @returns {C}\n */\nconst configure = ({\n  bitWidth = 5,\n  /* c8 ignore next 4 */\n  BitField = bitWidth === 5 ? Uint32BitField : Uint8ArrayBitField,\n  Path = bitWidth === 5\n    ? Uint32Path.configure({ bitWidth })\n    : Uint8ArrayPath.configure({ bitWidth }),\n} = {}) => /** @type {C} */ ({ bitWidth, BitField, Path })\n\n/**\n * Creates HashMap from the provided entries.\n *\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const from = (entries, options) => {\n  const node = /** @type {API.HashMapBuilder<V, K, C>} */ (builder(options))\n  for (const [key, value] of entries) {\n    node.set(key, value)\n  }\n\n  return node.build()\n}\n\n/**\n * @template T\n * @template {string} K\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n */\nexport const has = (hamt, key) =>\n  Node.get(hamt.root, key, NOT_FOUND) !== NOT_FOUND\n\n/**\n * @template T\n * @template {string} K\n * @template [U=undefined]\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const get = (hamt, key, notFound = /** @type {U} */ (undefined)) =>\n  Node.get(hamt.root, key, notFound)\n\n/**\n * @template {string} K\n * @template T\n * @template {API.Config} C\n * @param {Partial<C>} [options]\n * @returns {API.HashMapBuilder<T, K, C>}\n */\nexport const builder = options => {\n  const edit = {}\n  const config = configure(options)\n  return new HashMapBuilder(\n    edit,\n    0,\n    createBitmapIndexedNode(config, edit),\n    config\n  )\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.PersistentHashMap<T, K, C>}\n */\nclass PersistentHashMap {\n  /**\n   *\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(count = 0, root, config) {\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    return this.count\n  }\n\n  clone() {\n    return new PersistentHashMap(this.count, this.root, this.config)\n  }\n\n  /**\n   * @returns {API.PersistentHashMap<T, K, C>}\n   */\n  empty() {\n    return new PersistentHashMap(\n      0,\n      createBitmapIndexedNode(this.config, null),\n      this.config\n    )\n  }\n  /**\n   * @param {K} key\n   * @returns {boolean}\n   */\n  has(key) {\n    return has(this, key)\n  }\n  /**\n   * @param {K} key\n   * @returns {T|undefined}\n   */\n  get(key) {\n    return Node.get(this.root, key, undefined)\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {PersistentHashMap<T, K|R, C>}\n   */\n  set(key, value) {\n    const addedLeaf = { value: false }\n    const root = Node.set(this.root, null, key, value, addedLeaf)\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(\n        addedLeaf.value ? this.count + 1 : this.count,\n        root,\n        this.config\n      )\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    const root = Node.delete(this.root, null, key, { value: false })\n\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(this.count - 1, root, this.config)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  get bitField() {\n    return this.config.BitField.or(this.root.datamap, this.root.nodemap)\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  entries() {\n    return this.root.entries()\n  }\n  keys() {\n    return this.root.keys()\n  }\n  values() {\n    return this.root.values()\n  }\n\n  /**\n   * @returns {API.HashMapBuilder<T, K, C>}\n   */\n\n  createBuilder() {\n    return new HashMapBuilder({}, this.count, this.root, this.config)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n */\nclass HashMapBuilder {\n  /**\n   * @param {API.Edit} edit\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(edit, count, root, config) {\n    /**\n     * @type {API.Edit|null}\n     * @private\n     */\n    this.edit = edit\n    /**\n     * @private\n     */\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    if (this.edit) {\n      return this.count\n    } else {\n      throw new Error(`.size was accessed on the finalized builder`)\n    }\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {HashMapBuilder<T, K|R, C>}\n   */\n  set(key, value) {\n    if (this.edit) {\n      const addedLeaf = { value: false }\n      const root = Node.set(this.root, this.edit, key, value, addedLeaf)\n\n      if (this.root !== root) {\n        this.root = /** @type {API.BitmapIndexedNode<T, K, C>} */ (root)\n      }\n\n      if (addedLeaf.value) {\n        this.count += 1\n      }\n\n      return this\n    } else {\n      throw new Error(`.set was called on the finalized builder`)\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    if (this.edit) {\n      if (this.count === 0) {\n        return this\n      }\n      const removedLeaf = { value: false }\n      const root = Node.delete(this.root, this.edit, key, removedLeaf)\n\n      if (root !== this.root) {\n        this.root = root\n      }\n      if (removedLeaf.value) {\n        this.count -= 1\n      }\n      return this\n    } else {\n      throw new Error(`.delete was called on the finalized builder`)\n    }\n  }\n\n  build() {\n    if (this.edit) {\n      this.edit = null\n      return new PersistentHashMap(this.count, this.root, this.config)\n    } else {\n      throw new Error(`.build was called on the finalized builder`)\n    }\n  }\n}\n","import * as API from \"./api.js\"\nimport { toInt } from \"./Uint8Array.js\"\nimport { murmur364 } from \"@multiformats/murmur3\"\nconst utf8 = new TextEncoder()\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const hash64 = bytes =>\n  /** @type {Uint8Array} */ (murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\nexport const configure = ({ bitWidth = 8, hash = hash64 }) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n  const options = { bitWidth, hash, hashSize }\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => read(path, depth, options)\n\n  /**\n   * @param {string} key\n   */\n  const from = key => utf8.encode(key)\n\n  return { at, from, size: Infinity }\n}\n\n/**\n * @param {Uint8Array} key\n * @param {number} depth\n * @param {object} options\n * @param {number} [options.bitWidth]\n * @param {number} options.hashSize\n * @param {(input:Uint8Array) => Uint8Array} options.hash\n */\nexport const read = (key, depth = 0, { bitWidth = 8, hash, hashSize }) => {\n  // key digest consists of infinite number of hash frames that are computed\n  // from key + frame n which looks like\n  // [hash(key), hash([key, 1]), hash([key, n])]\n  // You can think of the hash as concatination of all frames. Here we calculate\n  // frame bit size from hash size as we going to use that several times.\n  const frameBitSize = hashSize * 8\n\n  // We start with 0 digest and required `bitCount` corresponding to `bitWith`.\n  // In the loop we'll going to consume `bitCount` hash bits.\n  let digest = 0\n  let bitCount = bitWidth\n  // Calculate absolute bit offset within the key digest.\n  let bitOffset = bitWidth * depth\n  while (bitCount > 0) {\n    // We derive frame number based on current bit offset.\n    const frameOffset = (bitOffset / frameBitSize) >> 0\n    // Then we compute that hash frame\n    const frame =\n      frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset))\n\n    // compute bit offset within the current frame\n    const offset =\n      frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset\n    // calculate number of bits remaining in this frame\n    const maxBits = frameBitSize - offset\n    // we will consume all required bits from frame if enough are available\n    // otherwise we consume whatever's available and continue rest in the next\n    // cycle(s).\n    const count = maxBits < bitCount ? maxBits : bitCount\n    digest = (digest << count) + toInt(frame, offset, count)\n    bitCount -= count\n    bitOffset += count\n  }\n\n  return digest\n}\n\n/**\n * @param {Uint8Array} source\n * @param {number} byte\n */\nconst appendByte = (source, byte) => {\n  const bytes = new Uint8Array(source.byteLength + 1).fill(\n    byte,\n    source.byteLength\n  )\n  bytes.set(source)\n  return bytes\n}\n","import * as HAMT from \"./lib.js\"\nimport * as Node from \"./node.js\"\nimport * as Path from \"./path/InfiniteUint8Array.js\"\n\nexport * from \"./api.js\"\n\nexport { Path }\n\nexport const bitWidth = 8\nexport const config = {\n  bitWidth,\n  Path: Path.configure({ bitWidth }),\n}\n\n/**\n * @param {HAMT.PersistentHashMap} hamt\n */\nexport const tableSize = hamt => Math.pow(2, hamt.config.bitWidth)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.PersistentHashMap<T, K, C>}\n */\nexport const empty = (options = /** @type {C} */ (config)) =>\n  HAMT.empty(options)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.HashMapBuilder<T, K, C>}\n */\nexport const builder = (options = /** @type {C} */ (config)) =>\n  HAMT.builder(options)\n\n/**\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} options\n */\nexport const from = (entries, options = /** @type {C} */ (config)) =>\n  HAMT.from(entries, options)\n\n/**\n * @template T\n * @template {string} K\n * @template Bits, Bitmap\n * @param {HAMT.BitmapIndexedNode<T, K, HAMT.Config<Bits, Bitmap>>} hamt\n */\nexport const bitField = ({ datamap, nodemap, config: { BitField } }) =>\n  withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)))\n\n/**\n * @param {Uint8Array} bytes\n */\nconst withoutLeadingZeros = bytes => {\n  let offset = 0\n  while (offset < bytes.byteLength) {\n    if (bytes[offset] !== 0) {\n      return bytes.subarray(offset)\n    }\n    offset += 1\n  }\n  return bytes.subarray(offset)\n}\n\n/**\n * Maps HAMT node into IPFS UnixFS compatible format.\n *\n * @template T\n * @template {string} K\n * @template {HAMT.Config} C\n * @param {HAMT.BitmapIndexedNode<T, K, C>} root\n * @returns {IterableIterator<{prefix:string, key:K, value:T, node?:void}|{prefix:string, node:HAMT.BitmapIndexedNode<T, K, C>}>}\n */\nexport const iterate = function* (root) {\n  const { config, datamap, nodemap } = root\n  const { BitField: bitfield } = config\n  const size = bitfield.size(datamap)\n  let bitOffset = 0\n  let dataCount = 0\n  while (bitOffset < size) {\n    const prefix = bitOffset.toString(16).toUpperCase().padStart(2, \"0\")\n    if (bitfield.get(datamap, bitOffset)) {\n      const key = Node.keyAt(root, dataCount)\n      yield {\n        prefix,\n        key,\n        value: Node.valueAt(root, dataCount),\n      }\n      dataCount++\n    } else if (bitfield.get(nodemap, bitOffset)) {\n      yield {\n        prefix,\n        // UnixFS never contains hash collision nodes because it uses\n        // inifinite hashes\n        node: /** @type {HAMT.BitmapIndexedNode<T, K, C>} */ (\n          Node.resolveNode(root, bitOffset)\n        ),\n      }\n    }\n    bitOffset++\n  }\n}\n","import * as API from \"./api.js\"\nimport * as File from \"./file.js\"\nimport * as Directory from \"./directory.js\"\n\nexport * from \"./api.js\"\n\nexport { encode, decode, NodeType, code } from \"./codec.js\"\nexport {\n  create as createFileWriter,\n  close as closeFile,\n  write,\n  configure,\n  defaults,\n  UnixFSLeaf,\n  UnixFSRawLeaf,\n} from \"./file.js\"\nexport {\n  create as createDirectoryWriter,\n  close as closeDirectory,\n  fork as forkDirectory,\n  set,\n  remove,\n} from \"./directory.js\"\nexport {\n  create as createShardedDirectoryWriter,\n  close as closeShardedDirectory,\n  fork as forkShardedDirectory,\n} from \"./sharded-directory.js\"\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} options\n * @returns {API.View<Layout>}\n */\nexport const createWriter = ({ writable, settings = File.defaults() }) =>\n  new FileSystemWriter({\n    writer: writable.getWriter(),\n    settings,\n  })\n\n/**\n * @template {{writer:API.BlockWriter}} View\n * @param {View} view\n * @param {API.CloseOptions} options\n */\nexport const close = async (\n  view,\n  { releaseLock = true, closeWriter = true } = {}\n) => {\n  if (closeWriter) {\n    await view.writer.close()\n  } else if (releaseLock) {\n    view.writer.releaseLock()\n  }\n\n  return view\n}\n\n/**\n * @template [Layout=unknown]\n * @implemets {API.View<Layout>}\n */\nclass FileSystemWriter {\n  /**\n   * @param {object} options\n   * @param {API.BlockWriter} options.writer\n   * @param {Partial<API.EncoderSettings<Layout>>} options.settings\n   */\n  constructor({ writer, settings }) {\n    this.writer = writer\n    this.settings = File.configure(settings)\n  }\n\n  /**\n   * @template [L=unknown]\n   * @param {API.WriterOptions<L|Layout>} config\n   */\n  createFileWriter({ settings = this.settings, metadata } = {}) {\n    return File.create({\n      writer: this.writer,\n      settings,\n      metadata,\n    })\n  }\n\n  /**\n   * @template [L=unknown]\n   * @param {API.WriterOptions<L|Layout>} config\n   */\n  createDirectoryWriter({ settings = this.settings, metadata } = {}) {\n    return Directory.create({\n      writer: this.writer,\n      settings,\n      metadata,\n    })\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   */\n  close(options) {\n    return close(this, options)\n  }\n}\n\n// BlockSizeLimit specifies the maximum size an imported block can have.\n// @see https://github.com/ipfs/go-unixfs/blob/68c015a6f317ed5e21a4870f7c423a4b38b90a96/importer/helpers/helpers.go#L7-L8\nexport const BLOCK_SIZE_LIMIT = 1048576 // 1 MB\nexport const defaultCapacity = BLOCK_SIZE_LIMIT * 100\n\n/**\n * Creates `QueuingStrategy` that can fit blocks with total size up to given\n * byteLength.\n *\n * @param {number} byteLength\n * @returns {Required<QueuingStrategy<API.Block>>}\n */\nexport const withCapacity = (byteLength = defaultCapacity) => ({\n  highWaterMark: byteLength,\n  size: block => block.bytes.length,\n})\n","import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n","/**\n * @packageDocumentation\n *\n * Return the last value from an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import last from 'it-last'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const res = last(values)\n *\n * console.info(res) // 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import last from 'it-last'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const res = await last(values())\n *\n * console.info(res) // 4\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Returns the last item of an (async) iterable, unless empty, in which case\n * return `undefined`\n */\nfunction last <T> (source: Iterable<T>): T | undefined\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined>\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined> | T | undefined {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      let res\n\n      for await (const entry of source) {\n        res = entry\n      }\n\n      return res\n    })()\n  }\n\n  let res\n\n  for (const entry of source) {\n    res = entry\n  }\n\n  return res\n}\n\nexport default last\n","export class BadPathError extends Error {\n  static name = 'BadPathError'\n  static code = 'ERR_BAD_PATH'\n  name = BadPathError.name\n  code = BadPathError.code\n\n  constructor (message = 'Bad path') {\n    super(message)\n  }\n}\n\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n  static code = 'ERR_NOT_FOUND'\n  name = NotFoundError.name\n  code = NotFoundError.code\n\n  constructor (message = 'Not found') {\n    super(message)\n  }\n}\n\nexport class NoResolverError extends Error {\n  static name = 'NoResolverError'\n  static code = 'ERR_NO_RESOLVER'\n  name = NoResolverError.name\n  code = NoResolverError.code\n\n  constructor (message = 'No resolver') {\n    super(message)\n  }\n}\n\nexport class NotUnixFSError extends Error {\n  static name = 'NotUnixFSError'\n  static code = 'ERR_NOT_UNIXFS'\n  name = NotUnixFSError.name\n  code = NotUnixFSError.code\n\n  constructor (message = 'Not UnixFS') {\n    super(message)\n  }\n}\n\nexport class OverReadError extends Error {\n  static name = 'OverReadError'\n  static code = 'ERR_OVER_READ'\n  name = OverReadError.name\n  code = OverReadError.code\n\n  constructor (message = 'Over read') {\n    super(message)\n  }\n}\n\nexport class UnderReadError extends Error {\n  static name = 'UnderReadError'\n  static code = 'ERR_UNDER_READ'\n  name = UnderReadError.name\n  code = UnderReadError.code\n\n  constructor (message = 'Under read') {\n    super(message)\n  }\n}\n\nexport class NoPropError extends Error {\n  static name = 'NoPropError'\n  static code = 'ERR_NO_PROP'\n  name = NoPropError.name\n  code = NoPropError.code\n\n  constructor (message = 'No Property found') {\n    super(message)\n  }\n}\n\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  static code = 'ERR_INVALID_PARAMS'\n  name = InvalidParametersError.name\n  code = InvalidParametersError.code\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n  }\n}\n","import { Type } from '../token.js'\nimport { encodeCustom } from '../encode.js'\nimport { encodeErrPrefix } from '../common.js'\nimport { asU8A, fromString } from '../byte-utils.js'\n\n/**\n * @typedef {import('../../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../token').Token} Token\n * @typedef {import('../bl').Bl} Bl\n */\n\nclass JSONEncoder extends Array {\n  constructor () {\n    super()\n    /** @type {{type:Type,elements:number}[]} */\n    this.inRecursive = []\n  }\n\n  /**\n   * @param {Bl} buf\n   */\n  prefix (buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1]\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          buf.push([44]) // ','\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          if (recurs.elements % 2 === 1) { // key\n            buf.push([44]) // ','\n          } else {\n            buf.push([58]) // ':'\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.uint.major] (buf, token) {\n    this.prefix(buf)\n    const is = String(token.value)\n    const isa = []\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n    }\n    buf.push(isa)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.negint.major] (buf, token) {\n    // @ts-ignore hack\n    this[Type.uint.major](buf, token)\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.bytes.major] (_buf, _token) {\n    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.string.major] (buf, token) {\n    this.prefix(buf)\n    // buf.push(34) // '\"'\n    // encodeUtf8(token.value, byts)\n    // buf.push(34) // '\"'\n    const byts = fromString(JSON.stringify(token.value))\n    buf.push(byts.length > 32 ? asU8A(byts) : byts)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.array.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.array, elements: 0 })\n    buf.push([91]) // '['\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.map.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.map, elements: 0 })\n    buf.push([123]) // '{'\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.tag.major] (_buf, _token) {}\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.float.major] (buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop()\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]) // ']'\n        } else if (recurs.type === Type.map) {\n          buf.push([125]) // '}'\n        /* c8 ignore next 3 */\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!')\n        }\n        return\n      }\n      /* c8 ignore next 2 */\n      throw new Error('Unexpected break; this should not happen!')\n    }\n    if (token.value === undefined) {\n      throw new Error(`${encodeErrPrefix} unsupported type: undefined`)\n    }\n\n    this.prefix(buf)\n    if (token.type.name === 'true') {\n      buf.push([116, 114, 117, 101]) // 'true'\n      return\n    } else if (token.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]) // 'false'\n      return\n    } else if (token.type.name === 'null') {\n      buf.push([110, 117, 108, 108]) // 'null'\n      return\n    }\n\n    // number\n    const is = String(token.value)\n    const isa = []\n    let dp = false\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) { // '[.eE]'\n        dp = true\n      }\n    }\n    if (!dp) { // need a decimal point for floats\n      isa.push(46) // '.'\n      isa.push(48) // '0'\n    }\n    buf.push(isa)\n  }\n}\n\n// The below code is mostly taken and modified from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n// function encodeUtf8 (string, byts) {\n//   let codePoint\n//   const length = string.length\n//   let leadSurrogate = null\n\n//   for (let i = 0; i < length; ++i) {\n//     codePoint = string.charCodeAt(i)\n\n//     // is surrogate component\n//     if (codePoint > 0xd7ff && codePoint < 0xe000) {\n//       // last char was a lead\n//       if (!leadSurrogate) {\n//         // no lead yet\n//         /* c8 ignore next 9 */\n//         if (codePoint > 0xdbff) {\n//           // unexpected trail\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         } else if (i + 1 === length) {\n//           // unpaired lead\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         }\n\n//         // valid lead\n//         leadSurrogate = codePoint\n\n//         continue\n//       }\n\n//       // 2 leads in a row\n//       /* c8 ignore next 5 */\n//       if (codePoint < 0xdc00) {\n//         byts.push(0xef, 0xbf, 0xbd)\n//         leadSurrogate = codePoint\n//         continue\n//       }\n\n//       // valid surrogate pair\n//       codePoint = (leadSurrogate - 0xd800 << 10 | codePoint - 0xdc00) + 0x10000\n//     /* c8 ignore next 4 */\n//     } else if (leadSurrogate) {\n//       // valid bmp char, but last char was a lead\n//       byts.push(0xef, 0xbf, 0xbd)\n//     }\n\n//     leadSurrogate = null\n\n//     // encode utf8\n//     if (codePoint < 0x80) {\n//       // special JSON escapes\n//       switch (codePoint) {\n//         case 8: // '\\b'\n//           byts.push(92, 98) // '\\\\b'\n//           continue\n//         case 9: // '\\t'\n//           byts.push(92, 116) // '\\\\t'\n//           continue\n//         case 10: // '\\n'\n//           byts.push(92, 110) // '\\\\n'\n//           continue\n//         case 12: // '\\f'\n//           byts.push(92, 102) // '\\\\f'\n//           continue\n//         case 13: // '\\r'\n//           byts.push(92, 114) // '\\\\r'\n//           continue\n//         case 34: // '\"'\n//           byts.push(92, 34) // '\\\\\"'\n//           continue\n//         case 92: // '\\\\'\n//           byts.push(92, 92) // '\\\\\\\\'\n//           continue\n//       }\n\n//       byts.push(codePoint)\n//     } else if (codePoint < 0x800) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0x6 | 0xc0,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else if (codePoint < 0x10000) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0xc | 0xe0,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     /* c8 ignore next 9 */\n//     } else if (codePoint < 0x110000) {\n//       byts.push(\n//         codePoint >> 0x12 | 0xf0,\n//         codePoint >> 0xc & 0x3f | 0x80,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else {\n//       /* c8 ignore next 2 */\n//       throw new Error('Invalid code point')\n//     }\n//   }\n// }\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${encodeErrPrefix} complex map keys are not supported`)\n  }\n  const keyToken1 = e1[0]\n  const keyToken2 = e2[0]\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`)\n  }\n  if (keyToken1 < keyToken2) {\n    return -1\n  }\n  if (keyToken1 > keyToken2) {\n    return 1\n  }\n  /* c8 ignore next 1 */\n  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)\n}\n\nconst defaultEncodeOptions = { addBreakTokens: true, mapSorter }\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, new JSONEncoder(), options)\n}\n\nexport { encode }\n","import { decode as _decode, decodeFirst as _decodeFirst } from '../decode.js'\nimport { Token, Type } from '../token.js'\nimport { decodeCodePointsArray } from '../byte-utils.js'\nimport { decodeErrPrefix } from '../common.js'\n\n/**\n * @typedef {import('../../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../../interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n    /** @type {string[]} */\n    this.modeStack = ['value']\n    this.lastToken = ''\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  /**\n   * @returns {number}\n   */\n  ch () {\n    return this.data[this._pos]\n  }\n\n  /**\n   * @returns {string}\n   */\n  currentMode () {\n    return this.modeStack[this.modeStack.length - 1]\n  }\n\n  skipWhitespace () {\n    let c = this.ch()\n    // @ts-ignore\n    while (c === 32 /* ' ' */ || c === 9 /* '\\t' */ || c === 13 /* '\\r' */ || c === 10 /* '\\n' */) {\n      c = this.data[++this._pos]\n    }\n  }\n\n  /**\n   * @param {number[]} str\n   */\n  expect (str) {\n    if (this.data.length - this._pos < str.length) {\n      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`)\n    }\n    for (let i = 0; i < str.length; i++) {\n      if (this.data[this._pos++] !== str[i]) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`)\n      }\n    }\n  }\n\n  parseNumber () {\n    const startPos = this._pos\n    let negative = false\n    let float = false\n\n    /**\n     * @param {number[]} chars\n     */\n    const swallow = (chars) => {\n      while (!this.done()) {\n        const ch = this.ch()\n        if (chars.includes(ch)) {\n          this._pos++\n        } else {\n          break\n        }\n      }\n    }\n\n    // lead\n    if (this.ch() === 45) { // '-'\n      negative = true\n      this._pos++\n    }\n    if (this.ch() === 48) { // '0'\n      this._pos++\n      if (this.ch() === 46) { // '.'\n        this._pos++\n        float = true\n      } else {\n        return new Token(Type.uint, 0, this._pos - startPos)\n      }\n    }\n    swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    if (negative && this._pos === startPos + 1) {\n      throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n    }\n    if (!this.done() && this.ch() === 46) { // '.'\n      if (float) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n      }\n      float = true\n      this._pos++\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) { // '[eE]'\n      float = true\n      this._pos++\n      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) { // '+', '-'\n        this._pos++\n      }\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    // @ts-ignore\n    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos))\n    const num = parseFloat(numStr)\n    if (float) {\n      return new Token(Type.float, num, this._pos - startPos)\n    }\n    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {\n      return new Token(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos)\n    }\n    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseString () {\n    /* c8 ignore next 4 */\n    if (this.ch() !== 34) { // '\"'\n      // this would be a programming error\n      throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`)\n    }\n    this._pos++\n\n    // check for simple fast-path, all printable ascii, no escapes\n    // >0x10000 elements may fail fn.apply() (http://stackoverflow.com/a/22747272/680742)\n    for (let i = this._pos, l = 0; i < this.data.length && l < 0x10000; i++, l++) {\n      const ch = this.data[i]\n      if (ch === 92 || ch < 32 || ch >= 128) { // '\\', ' ', control-chars or non-trivial\n        break\n      }\n      if (ch === 34) { // '\"'\n        // @ts-ignore\n        const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i))\n        this._pos = i + 1\n        return new Token(Type.string, str, l)\n      }\n    }\n\n    const startPos = this._pos\n    const chars = []\n\n    const readu4 = () => {\n      if (this._pos + 4 >= this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`)\n      }\n      let u4 = 0\n      for (let i = 0; i < 4; i++) {\n        let ch = this.ch()\n        if (ch >= 48 && ch <= 57) { // '0' && '9'\n          ch -= 48\n        } else if (ch >= 97 && ch <= 102) { // 'a' && 'f'\n          ch = ch - 97 + 10\n        } else if (ch >= 65 && ch <= 70) { // 'A' && 'F'\n          ch = ch - 65 + 10\n        } else {\n          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`)\n        }\n        u4 = u4 * 16 + ch\n        this._pos++\n      }\n      return u4\n    }\n\n    // mostly taken from feross/buffer and adjusted to fit\n    const readUtf8Char = () => {\n      const firstByte = this.ch()\n      let codePoint = null\n      /* c8 ignore next 1 */\n      let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n      if (this._pos + bytesPerSequence > this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`)\n      }\n\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        /* c8 ignore next 6 */\n        // this case is dealt with by the caller function\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = this.data[this._pos + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          fourthByte = this.data[this._pos + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n\n      /* c8 ignore next 5 */\n      if (codePoint === null) {\n        // we did not generate a valid codePoint so insert a\n        // replacement char (U+FFFD) and advance only 1 byte\n        codePoint = 0xfffd\n        bytesPerSequence = 1\n      } else if (codePoint > 0xffff) {\n        // encode to utf16 (surrogate pair dance)\n        codePoint -= 0x10000\n        chars.push(codePoint >>> 10 & 0x3ff | 0xd800)\n        codePoint = 0xdc00 | codePoint & 0x3ff\n      }\n\n      chars.push(codePoint)\n      this._pos += bytesPerSequence\n    }\n\n    // TODO: could take the approach of a quick first scan for special chars like encoding/json/decode.go#unquoteBytes\n    // and converting all of the ascii chars from the base array in bulk\n    while (!this.done()) {\n      const ch = this.ch()\n      let ch1\n      switch (ch) {\n        case 92: // '\\'\n          this._pos++\n          if (this.done()) {\n            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`)\n          }\n          ch1 = this.ch()\n          this._pos++\n          switch (ch1) {\n            case 34: // '\"'\n            case 39: // '\\''\n            case 92: // '\\'\n            case 47: // '/'\n              chars.push(ch1)\n              break\n            case 98: // 'b'\n              chars.push(8)\n              break\n            case 116: // 't'\n              chars.push(9)\n              break\n            case 110: // 'n'\n              chars.push(10)\n              break\n            case 102: // 'f'\n              chars.push(12)\n              break\n            case 114: // 'r'\n              chars.push(13)\n              break\n            case 117: // 'u'\n              chars.push(readu4())\n              break\n            default:\n              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`)\n          }\n          break\n        case 34: // '\"'\n          this._pos++\n          return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos)\n        default:\n          if (ch < 32) { // ' '\n            throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`)\n          } else if (ch < 0x80) {\n            chars.push(ch)\n            this._pos++\n          } else {\n            readUtf8Char()\n          }\n      }\n    }\n\n    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseValue () {\n    switch (this.ch()) {\n      case 123: // '{'\n        this.modeStack.push('obj-start')\n        this._pos++\n        return new Token(Type.map, Infinity, 1)\n      case 91: // '['\n        this.modeStack.push('array-start')\n        this._pos++\n        return new Token(Type.array, Infinity, 1)\n      case 34: { // '\"'\n        return this.parseString()\n      }\n      case 110: // 'n' / null\n        this.expect([110, 117, 108, 108]) // 'null'\n        return new Token(Type.null, null, 4)\n      case 102: // 'f' / // false\n        this.expect([102, 97, 108, 115, 101]) // 'false'\n        return new Token(Type.false, false, 5)\n      case 116: // 't' / // true\n        this.expect([116, 114, 117, 101]) // 'true'\n        return new Token(Type.true, true, 4)\n      case 45: // '-'\n      case 48: // '0'\n      case 49: // '1'\n      case 50: // '2'\n      case 51: // '3'\n      case 52: // '4'\n      case 53: // '5'\n      case 54: // '6'\n      case 55: // '7'\n      case 56: // '8'\n      case 57: // '9'\n        return this.parseNumber()\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`)\n    }\n  }\n\n  /**\n   * @returns {Token}\n   */\n  next () {\n    this.skipWhitespace()\n    switch (this.currentMode()) {\n      case 'value':\n        this.modeStack.pop()\n        return this.parseValue()\n      case 'array-value': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      case 'array-start': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      // @ts-ignore\n      case 'obj-key':\n        if (this.ch() === 125) { // '}'\n          this.modeStack.pop()\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.skipWhitespace()\n      case 'obj-start': { // eslint-disable-line no-fallthrough\n        this.modeStack.pop()\n        if (this.ch() === 125) { // '}'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        const token = this.parseString()\n        this.skipWhitespace()\n        if (this.ch() !== 58) { // ':'\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('obj-value')\n        return token\n      }\n      case 'obj-value': {\n        this.modeStack.pop()\n        this.modeStack.push('obj-key')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      /* c8 ignore next 2 */\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`)\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decode(data, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decodeFirst(data, options)\n}\n\nexport { decode, decodeFirst, Tokenizer }\n","import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n","/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nfunction toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder (obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder (ab) {\n  return bytesEncoder(new Uint8Array(ab))\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  const buf = toByteView(data)\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(buf, decodeOptions) })\n  return cborgJson.decode(buf, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n","const textDecoder = new TextDecoder()\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[number, number]}\n */\nfunction decodeVarint (bytes, offset) {\n  let v = 0\n\n  for (let shift = 0; ; shift += 7) {\n    /* c8 ignore next 3 */\n    if (shift >= 64) {\n      throw new Error('protobuf: varint overflow')\n    }\n    /* c8 ignore next 3 */\n    if (offset >= bytes.length) {\n      throw new Error('protobuf: unexpected end of data')\n    }\n\n    const b = bytes[offset++]\n    v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)\n    if (b < 0x80) {\n      break\n    }\n  }\n  return [v, offset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[Uint8Array, number]}\n */\nfunction decodeBytes (bytes, offset) {\n  let byteLen\n  ;[byteLen, offset] = decodeVarint(bytes, offset)\n  const postOffset = offset + byteLen\n\n  /* c8 ignore next 3 */\n  if (byteLen < 0 || postOffset < 0) {\n    throw new Error('protobuf: invalid length')\n  }\n  /* c8 ignore next 3 */\n  if (postOffset > bytes.length) {\n    throw new Error('protobuf: unexpected end of data')\n  }\n\n  return [bytes.subarray(offset, postOffset), postOffset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} index\n * @returns {[number, number, number]}\n */\nfunction decodeKey (bytes, index) {\n  let wire\n  ;[wire, index] = decodeVarint(bytes, index)\n  // [wireType, fieldNum, newIndex]\n  return [wire & 0x7, wire >> 3, index]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBLink}\n */\nfunction decodeLink (bytes) {\n  /** @type {RawPBLink} */\n  const link = {}\n  const l = bytes.length\n  let index = 0\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (fieldNum === 1) {\n      if (link.Hash) {\n        throw new Error('protobuf: (PBLink) duplicate Hash section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)\n      }\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')\n      }\n\n      [link.Hash, index] = decodeBytes(bytes, index)\n    } else if (fieldNum === 2) {\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Name section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')\n      }\n\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      link.Name = textDecoder.decode(byts)\n    } else if (fieldNum === 3) {\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Tsize section')\n      }\n      if (wireType !== 0) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)\n      }\n\n      [link.Tsize, index] = decodeVarint(bytes, index)\n    } else {\n      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBLink) unexpected end of data')\n  }\n\n  return link\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBNode}\n */\nexport function decodeNode (bytes) {\n  const l = bytes.length\n  let index = 0\n  /** @type {RawPBLink[]|void} */\n  let links = undefined // eslint-disable-line no-undef-init\n  let linksBeforeData = false\n  /** @type {Uint8Array|void} */\n  let data = undefined // eslint-disable-line no-undef-init\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (wireType !== 2) {\n      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)\n    }\n\n    if (fieldNum === 1) {\n      if (data) {\n        throw new Error('protobuf: (PBNode) duplicate Data section')\n      }\n\n      [data, index] = decodeBytes(bytes, index)\n      if (links) {\n        linksBeforeData = true\n      }\n    } else if (fieldNum === 2) {\n      if (linksBeforeData) { // interleaved Links/Data/Links\n        throw new Error('protobuf: (PBNode) duplicate Links section')\n      } else if (!links) {\n        links = []\n      }\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      links.push(decodeLink(byts))\n    } else {\n      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBNode) unexpected end of data')\n  }\n\n  /** @type {RawPBNode} */\n  const node = {}\n  if (data) {\n    node.Data = data\n  }\n  node.Links = links || []\n  return node\n}\n","const textEncoder = new TextEncoder()\nconst maxInt32 = 2 ** 32\nconst maxUInt32 = 2 ** 31\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n// the encoders work backward from the end of the bytes array\n\n/**\n * encodeLink() is passed a slice of the parent byte array that ends where this\n * link needs to end, so it packs to the right-most part of the passed `bytes`\n *\n * @param {RawPBLink} link\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nfunction encodeLink (link, bytes) {\n  let i = bytes.length\n\n  if (typeof link.Tsize === 'number') {\n    if (link.Tsize < 0) {\n      throw new Error('Tsize cannot be negative')\n    }\n    if (!Number.isSafeInteger(link.Tsize)) {\n      throw new Error('Tsize too large for encoding')\n    }\n    i = encodeVarint(bytes, i, link.Tsize) - 1\n    bytes[i] = 0x18\n  }\n\n  if (typeof link.Name === 'string') {\n    const nameBytes = textEncoder.encode(link.Name)\n    i -= nameBytes.length\n    bytes.set(nameBytes, i)\n    i = encodeVarint(bytes, i, nameBytes.length) - 1\n    bytes[i] = 0x12\n  }\n\n  if (link.Hash) {\n    i -= link.Hash.length\n    bytes.set(link.Hash, i)\n    i = encodeVarint(bytes, i, link.Hash.length) - 1\n    bytes[i] = 0xa\n  }\n\n  return bytes.length - i\n}\n\n/**\n * Encodes a PBNode into a new byte array of precisely the correct size\n *\n * @param {RawPBNode} node\n * @returns {Uint8Array}\n */\nexport function encodeNode (node) {\n  const size = sizeNode(node)\n  const bytes = new Uint8Array(size)\n  let i = size\n\n  if (node.Data) {\n    i -= node.Data.length\n    bytes.set(node.Data, i)\n    i = encodeVarint(bytes, i, node.Data.length) - 1\n    bytes[i] = 0xa\n  }\n\n  if (node.Links) {\n    for (let index = node.Links.length - 1; index >= 0; index--) {\n      const size = encodeLink(node.Links[index], bytes.subarray(0, i))\n      i -= size\n      i = encodeVarint(bytes, i, size) - 1\n      bytes[i] = 0x12\n    }\n  }\n\n  return bytes\n}\n\n/**\n * work out exactly how many bytes this link takes up\n *\n * @param {RawPBLink} link\n * @returns\n */\nfunction sizeLink (link) {\n  let n = 0\n\n  if (link.Hash) {\n    const l = link.Hash.length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Name === 'string') {\n    const l = textEncoder.encode(link.Name).length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Tsize === 'number') {\n    n += 1 + sov(link.Tsize)\n  }\n\n  return n\n}\n\n/**\n * Work out exactly how many bytes this node takes up\n *\n * @param {RawPBNode} node\n * @returns {number}\n */\nfunction sizeNode (node) {\n  let n = 0\n\n  if (node.Data) {\n    const l = node.Data.length\n    n += 1 + l + sov(l)\n  }\n\n  if (node.Links) {\n    for (const link of node.Links) {\n      const l = sizeLink(link)\n      n += 1 + l + sov(l)\n    }\n  }\n\n  return n\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @param {number} v\n * @returns {number}\n */\nfunction encodeVarint (bytes, offset, v) {\n  offset -= sov(v)\n  const base = offset\n\n  while (v >= maxUInt32) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v /= 128\n  }\n\n  while (v >= 128) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v >>>= 7\n  }\n\n  bytes[offset] = v\n\n  return base\n}\n\n/**\n * size of varint\n *\n * @param {number} x\n * @returns {number}\n */\nfunction sov (x) {\n  if (x % 2 === 0) {\n    x++\n  }\n  return Math.floor((len64(x) + 6) / 7)\n}\n\n/**\n * golang math/bits, how many bits does it take to represent this integer?\n *\n * @param {number} x\n * @returns {number}\n */\nfunction len64 (x) {\n  let n = 0\n  if (x >= maxInt32) {\n    x = Math.floor(x / maxInt32)\n    n = 32\n  }\n  if (x >= (1 << 16)) {\n    x >>>= 16\n    n += 16\n  }\n  if (x >= (1 << 8)) {\n    x >>>= 8\n    n += 8\n  }\n  return n + len8tab[x]\n}\n\n// golang math/bits\nconst len8tab = [\n  0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8\n]\n","import { CID } from 'multiformats/cid'\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\nconst pbNodeProperties = ['Data', 'Links']\nconst pbLinkProperties = ['Hash', 'Name', 'Tsize']\n\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {PBLink} a\n * @param {PBLink} b\n * @returns {number}\n */\nfunction linkComparator (a, b) {\n  if (a === b) {\n    return 0\n  }\n\n  const abuf = a.Name ? textEncoder.encode(a.Name) : []\n  const bbuf = b.Name ? textEncoder.encode(b.Name) : []\n\n  let x = abuf.length\n  let y = bbuf.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (abuf[i] !== bbuf[i]) {\n      x = abuf[i]\n      y = bbuf[i]\n      break\n    }\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0\n}\n\n/**\n * @param {any} node\n * @param {string[]} properties\n * @returns {boolean}\n */\nfunction hasOnlyProperties (node, properties) {\n  return !Object.keys(node).some((p) => !properties.includes(p))\n}\n\n/**\n * Converts a CID, or a PBLink-like object to a PBLink\n *\n * @param {any} link\n * @returns {PBLink}\n */\nfunction asLink (link) {\n  if (typeof link.asCID === 'object') {\n    const Hash = CID.asCID(link)\n    if (!Hash) {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n    return { Hash }\n  }\n\n  if (typeof link !== 'object' || Array.isArray(link)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  const pbl = {}\n\n  if (link.Hash) {\n    let cid = CID.asCID(link.Hash)\n    try {\n      if (!cid) {\n        if (typeof link.Hash === 'string') {\n          cid = CID.parse(link.Hash)\n        } else if (link.Hash instanceof Uint8Array) {\n          cid = CID.decode(link.Hash)\n        }\n      }\n    } catch (/** @type {any} */ e) {\n      throw new TypeError(`Invalid DAG-PB form: ${e.message}`)\n    }\n\n    if (cid) {\n      pbl.Hash = cid\n    }\n  }\n\n  if (!pbl.Hash) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (typeof link.Name === 'string') {\n    pbl.Name = link.Name\n  }\n\n  if (typeof link.Tsize === 'number') {\n    pbl.Tsize = link.Tsize\n  }\n\n  return pbl\n}\n\n/**\n * @param {any} node\n * @returns {PBNode}\n */\nexport function prepare (node) {\n  if (node instanceof Uint8Array || typeof node === 'string') {\n    node = { Data: node }\n  }\n\n  if (typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  /** @type {PBNode} */\n  const pbn = {}\n\n  if (node.Data !== undefined) {\n    if (typeof node.Data === 'string') {\n      pbn.Data = textEncoder.encode(node.Data)\n    } else if (node.Data instanceof Uint8Array) {\n      pbn.Data = node.Data\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  }\n\n  if (node.Links !== undefined) {\n    if (Array.isArray(node.Links)) {\n      pbn.Links = node.Links.map(asLink)\n      pbn.Links.sort(linkComparator)\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  } else {\n    pbn.Links = []\n  }\n\n  return pbn\n}\n\n/**\n * @param {PBNode} node\n */\nexport function validate (node) {\n  /*\n  type PBLink struct {\n    Hash optional Link\n    Name optional String\n    Tsize optional Int\n  }\n\n  type PBNode struct {\n    Links [PBLink]\n    Data optional Bytes\n  }\n  */\n  // @ts-ignore private property for TS\n  if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || (node['/'] && node['/'] === node.bytes)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (!hasOnlyProperties(node, pbNodeProperties)) {\n    throw new TypeError('Invalid DAG-PB form (extraneous properties)')\n  }\n\n  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {\n    throw new TypeError('Invalid DAG-PB form (Data must be bytes)')\n  }\n\n  if (!Array.isArray(node.Links)) {\n    throw new TypeError('Invalid DAG-PB form (Links must be a list)')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const link = node.Links[i]\n    // @ts-ignore private property for TS\n    if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || (link['/'] && link['/'] === link.bytes)) {\n      throw new TypeError('Invalid DAG-PB form (bad link)')\n    }\n\n    if (!hasOnlyProperties(link, pbLinkProperties)) {\n      throw new TypeError('Invalid DAG-PB form (extraneous properties on link)')\n    }\n\n    if (link.Hash === undefined) {\n      throw new TypeError('Invalid DAG-PB form (link must have a Hash)')\n    }\n\n    // @ts-ignore private property for TS\n    if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {\n      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')\n    }\n\n    if (link.Name !== undefined && typeof link.Name !== 'string') {\n      throw new TypeError('Invalid DAG-PB form (link Name must be a string)')\n    }\n\n    if (link.Tsize !== undefined) {\n      if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')\n      }\n      if (link.Tsize < 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)')\n      }\n    }\n\n    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {\n      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {PBLink[]} [links=[]]\n * @returns {PBNode}\n */\nexport function createNode (data, links = []) {\n  return prepare({ Data: data, Links: links })\n}\n\n/**\n * @param {string} name\n * @param {number} size\n * @param {CID} cid\n * @returns {PBLink}\n */\nexport function createLink (name, size, cid) {\n  return asLink({ Hash: cid, Name: name, Tsize: size })\n}\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n","import { CID } from 'multiformats/cid'\nimport { decodeNode } from './pb-decode.js'\nimport { encodeNode } from './pb-encode.js'\nimport { prepare, validate, createNode, createLink, toByteView } from './util.js'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\nexport const name = 'dag-pb'\nexport const code = 0x70\n\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\nexport function encode (node) {\n  validate(node)\n\n  const pbn = {}\n  if (node.Links) {\n    pbn.Links = node.Links.map((l) => {\n      const link = {}\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes // cid -> bytes\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n  if (node.Data) {\n    pbn.Data = node.Data\n  }\n\n  return encodeNode(pbn)\n}\n\n/**\n * @param {ByteView<PBNode> | ArrayBufferView<PBNode>} bytes\n * @returns {PBNode}\n */\nexport function decode (bytes) {\n  const buf = toByteView(bytes)\n  const pbn = decodeNode(buf)\n\n  const node = {}\n\n  if (pbn.Data) {\n    node.Data = pbn.Data\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map((l) => {\n      const link = {}\n      try {\n        link.Hash = CID.decode(l.Hash)\n      } catch (e) {}\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID')\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n\n  return node\n}\n\nexport { prepare, validate, createNode, createLink }\n","import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array): Digest.Digest<typeof code, number> {\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n","import { CID } from 'multiformats/cid'\nimport { NoPropError } from '../errors.js'\nimport type { ResolveResult } from '../index.js'\n\nexport function resolveObjectPath (object: any, block: Uint8Array, cid: CID, name: string, path: string, toResolve: string[], depth: number): ResolveResult {\n  let subObject = object\n  let subPath = path\n\n  while (toResolve.length > 0) {\n    const prop = toResolve[0]\n\n    if (prop in subObject) {\n      // remove the bit of the path we have resolved\n      toResolve.shift()\n      subPath = `${subPath}/${prop}`\n\n      const subObjectCid = CID.asCID(subObject[prop])\n      if (subObjectCid != null) {\n        return {\n          entry: {\n            type: 'object',\n            name,\n            path,\n            cid,\n            node: block,\n            depth,\n            size: BigInt(block.length),\n            content: async function * () {\n              yield object\n            }\n          },\n          next: {\n            cid: subObjectCid,\n            name: prop,\n            path: subPath,\n            toResolve\n          }\n        }\n      }\n\n      subObject = subObject[prop]\n    } else {\n      // cannot resolve further\n      throw new NoPropError(`No property named ${prop} found in node ${cid}`)\n    }\n  }\n\n  return {\n    entry: {\n      type: 'object',\n      name,\n      path,\n      cid,\n      node: block,\n      depth,\n      size: BigInt(block.length),\n      content: async function * () {\n        yield object\n      }\n    }\n  }\n}\n","import * as dagCbor from '@ipld/dag-cbor'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagCbor.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n","import * as dagJson from '@ipld/dag-json'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagJson.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n","/**\n * Progress events are emitted during long running operations\n */\nexport interface ProgressEvent<T extends string = any, D = unknown> {\n  /**\n   * The event type\n   */\n  type: T\n\n  /**\n   * Context-specific event information\n   */\n  detail: D\n}\n\n/**\n * An implementation of the ProgressEvent interface, this is essentially\n * a typed `CustomEvent` with a `type` property that lets us disambiguate\n * events passed to `progress` callbacks.\n */\nexport class CustomProgressEvent<D = unknown, T extends string = any> extends Event implements ProgressEvent<T, D> {\n  public type: T\n  public detail: D\n\n  constructor (type: T, detail?: D) {\n    super(type)\n\n    this.type = type\n    // @ts-expect-error detail may be undefined\n    this.detail = detail\n  }\n}\n\n/**\n * Define an `onProgress` callback that can be invoked with `ProgressEvent`s\n *\n * @example\n *\n * ```typescript\n * type MyOperationProgressEvents =\n *   ProgressEvent<'operation:start'> |\n *   ProgressEvent<'operation:success', Result> |\n *   ProgressEvent<'operation:error', Error>\n *\n * export interface MyOperationOptions extends ProgressOptions<MyOperationProgressEvents> {\n *  // define options here\n * }\n * ```\n */\nexport interface ProgressOptions<Event extends ProgressEvent = any> {\n  onProgress?: (evt: Event) => void\n}\n","function extractDataFromBlock (block: Uint8Array, blockStart: bigint, requestedStart: bigint, requestedEnd: bigint): Uint8Array {\n  const blockLength = BigInt(block.length)\n  const blockEnd = BigInt(blockStart + blockLength)\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return new Uint8Array(0)\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.subarray(0, Number(requestedEnd - blockStart))\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.subarray(Number(requestedStart - blockStart))\n  }\n\n  return block\n}\n\nexport default extractDataFromBlock\n","import { InvalidParametersError } from '../errors.js'\n\nconst validateOffsetAndLength = (size: number | bigint, offset: number | bigint = 0, length: number | bigint = size): { start: bigint, end: bigint } => {\n  const fileSize = BigInt(size)\n  const start = BigInt(offset ?? 0)\n  let end = BigInt(length)\n\n  if (end !== fileSize) {\n    end = start + end\n  }\n\n  if (end > fileSize) {\n    end = fileSize\n  }\n\n  if (start < 0n) {\n    throw new InvalidParametersError('Offset must be greater than or equal to 0')\n  }\n\n  if (start > fileSize) {\n    throw new InvalidParametersError('Offset must be less than the file size')\n  }\n\n  if (end < 0n) {\n    throw new InvalidParametersError('Length must be greater than or equal to 0')\n  }\n\n  if (end > fileSize) {\n    throw new InvalidParametersError('Length must be less than the file size')\n  }\n\n  return {\n    start,\n    end\n  }\n}\n\nexport default validateOffsetAndLength\n","import * as mh from 'multiformats/hashes/digest'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotFoundError } from '../errors.js'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:identity', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw new NotFoundError(`No link named ${path} found in raw node ${cid}`)\n  }\n  const buf = mh.decode(cid.multihash.bytes)\n\n  return {\n    entry: {\n      type: 'identity',\n      name,\n      path,\n      cid,\n      content: rawContent(buf.digest),\n      depth,\n      size: BigInt(buf.digest.length),\n      node: buf.digest\n    }\n  }\n}\n\nexport default resolve\n","import * as json from 'multiformats/codecs/json'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = json.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n","import { CustomProgressEvent } from 'progress-events'\nimport { NotFoundError } from '../errors.js'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:raw', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw new NotFoundError(`No link named ${path} found in raw node ${cid}`)\n  }\n\n  const block = await blockstore.get(cid, options)\n\n  return {\n    entry: {\n      type: 'raw',\n      name,\n      path,\n      cid,\n      content: rawContent(block),\n      depth,\n      size: BigInt(block.length),\n      node: block\n    }\n  }\n}\n\nexport default resolve\n","import errcode from 'err-code'\nimport { Data as PBData } from './unixfs.js'\n\nexport interface Mtime {\n  secs: bigint\n  nsecs?: number\n}\n\nexport type MtimeLike = Mtime | { Seconds: number, FractionalNanoseconds?: number } | [number, number] | Date\n\nconst types: Record<string, string> = {\n  Raw: 'raw',\n  Directory: 'directory',\n  File: 'file',\n  Metadata: 'metadata',\n  Symlink: 'symlink',\n  HAMTShard: 'hamt-sharded-directory'\n}\n\nconst dirTypes = [\n  'directory',\n  'hamt-sharded-directory'\n]\n\nconst DEFAULT_FILE_MODE = parseInt('0644', 8)\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8)\n\nexport interface UnixFSOptions {\n  type?: string\n  data?: Uint8Array\n  blockSizes?: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mtime?: Mtime\n  mode?: number\n}\n\nclass UnixFS {\n  /**\n   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n   */\n  static unmarshal (marshaled: Uint8Array): UnixFS {\n    const message = PBData.decode(marshaled)\n\n    const data = new UnixFS({\n      type: types[message.Type != null ? message.Type.toString() : 'File'],\n      data: message.Data,\n      blockSizes: message.blocksizes,\n      mode: message.mode,\n      mtime: message.mtime != null\n        ? {\n            secs: message.mtime.Seconds ?? 0n,\n            nsecs: message.mtime.FractionalNanoseconds\n          }\n        : undefined,\n      fanout: message.fanout\n    })\n\n    // make sure we honour the original mode\n    data._originalMode = message.mode ?? 0\n\n    return data\n  }\n\n  public type: string\n  public data?: Uint8Array\n  public blockSizes: bigint[]\n  public hashType?: bigint\n  public fanout?: bigint\n  public mtime?: Mtime\n\n  private _mode?: number\n  private _originalMode: number\n\n  constructor (options: UnixFSOptions = {\n    type: 'file'\n  }) {\n    const {\n      type,\n      data,\n      blockSizes,\n      hashType,\n      fanout,\n      mtime,\n      mode\n    } = options\n\n    if (type != null && !Object.values(types).includes(type)) {\n      throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE')\n    }\n\n    this.type = type ?? 'file'\n    this.data = data\n    this.hashType = hashType\n    this.fanout = fanout\n    this.blockSizes = blockSizes ?? []\n    this._originalMode = 0\n    this.mode = mode\n    this.mtime = mtime\n  }\n\n  set mode (mode: number | undefined) {\n    if (mode == null) {\n      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE\n    } else {\n      this._mode = (mode & 0xFFF)\n    }\n  }\n\n  get mode (): number | undefined {\n    return this._mode\n  }\n\n  isDirectory (): boolean {\n    return dirTypes.includes(this.type)\n  }\n\n  addBlockSize (size: bigint): void {\n    this.blockSizes.push(size)\n  }\n\n  removeBlockSize (index: number): void {\n    this.blockSizes.splice(index, 1)\n  }\n\n  /**\n   * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else\n   */\n  fileSize (): bigint {\n    if (this.isDirectory()) {\n      // dirs don't have file size\n      return 0n\n    }\n\n    let sum = 0n\n    this.blockSizes.forEach((size) => {\n      sum += size\n    })\n\n    if (this.data != null) {\n      sum += BigInt(this.data.length)\n    }\n\n    return sum\n  }\n\n  /**\n   * encode to protobuf Uint8Array\n   */\n  marshal (): Uint8Array {\n    let type\n\n    switch (this.type) {\n      case 'raw': type = PBData.DataType.Raw; break\n      case 'directory': type = PBData.DataType.Directory; break\n      case 'file': type = PBData.DataType.File; break\n      case 'metadata': type = PBData.DataType.Metadata; break\n      case 'symlink': type = PBData.DataType.Symlink; break\n      case 'hamt-sharded-directory': type = PBData.DataType.HAMTShard; break\n      default:\n        throw errcode(new Error(`Type: ${type} is not valid`), 'ERR_INVALID_TYPE')\n    }\n\n    let data = this.data\n\n    if (this.data == null || this.data.length === 0) {\n      data = undefined\n    }\n\n    let mode\n\n    if (this.mode != null) {\n      mode = (this._originalMode & 0xFFFFF000) | (this.mode ?? 0)\n\n      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n        mode = undefined\n      }\n\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined\n      }\n    }\n\n    let mtime\n\n    if (this.mtime != null) {\n      mtime = {\n        Seconds: this.mtime.secs,\n        FractionalNanoseconds: this.mtime.nsecs\n      }\n    }\n\n    return PBData.encode({\n      Type: type,\n      Data: data,\n      filesize: this.isDirectory() ? undefined : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    })\n  }\n}\n\nexport { UnixFS }\n","const f32 = new Float32Array([-0])\nconst f8b = new Uint8Array(f32.buffer)\n\n/**\n * Writes a 32 bit float to a buffer using little endian byte order\n */\nexport function writeFloatLE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[0]\n  buf[pos + 1] = f8b[1]\n  buf[pos + 2] = f8b[2]\n  buf[pos + 3] = f8b[3]\n}\n\n/**\n * Writes a 32 bit float to a buffer using big endian byte order\n */\nexport function writeFloatBE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[3]\n  buf[pos + 1] = f8b[2]\n  buf[pos + 2] = f8b[1]\n  buf[pos + 3] = f8b[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using little endian byte order\n */\nexport function readFloatLE (buf: Uint8Array, pos: number): number {\n  f8b[0] = buf[pos]\n  f8b[1] = buf[pos + 1]\n  f8b[2] = buf[pos + 2]\n  f8b[3] = buf[pos + 3]\n  return f32[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using big endian byte order\n */\nexport function readFloatBE (buf: Uint8Array, pos: number): number {\n  f8b[3] = buf[pos]\n  f8b[2] = buf[pos + 1]\n  f8b[1] = buf[pos + 2]\n  f8b[0] = buf[pos + 3]\n  return f32[0]\n}\n\nconst f64 = new Float64Array([-0])\nconst d8b = new Uint8Array(f64.buffer)\n\n/**\n * Writes a 64 bit double to a buffer using little endian byte order\n */\nexport function writeDoubleLE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[0]\n  buf[pos + 1] = d8b[1]\n  buf[pos + 2] = d8b[2]\n  buf[pos + 3] = d8b[3]\n  buf[pos + 4] = d8b[4]\n  buf[pos + 5] = d8b[5]\n  buf[pos + 6] = d8b[6]\n  buf[pos + 7] = d8b[7]\n}\n\n/**\n * Writes a 64 bit double to a buffer using big endian byte order\n */\nexport function writeDoubleBE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[7]\n  buf[pos + 1] = d8b[6]\n  buf[pos + 2] = d8b[5]\n  buf[pos + 3] = d8b[4]\n  buf[pos + 4] = d8b[3]\n  buf[pos + 5] = d8b[2]\n  buf[pos + 6] = d8b[1]\n  buf[pos + 7] = d8b[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using little endian byte order\n */\nexport function readDoubleLE (buf: Uint8Array, pos: number): number {\n  d8b[0] = buf[pos]\n  d8b[1] = buf[pos + 1]\n  d8b[2] = buf[pos + 2]\n  d8b[3] = buf[pos + 3]\n  d8b[4] = buf[pos + 4]\n  d8b[5] = buf[pos + 5]\n  d8b[6] = buf[pos + 6]\n  d8b[7] = buf[pos + 7]\n  return f64[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using big endian byte order\n */\nexport function readDoubleBE (buf: Uint8Array, pos: number): number {\n  d8b[7] = buf[pos]\n  d8b[6] = buf[pos + 1]\n  d8b[5] = buf[pos + 2]\n  d8b[4] = buf[pos + 3]\n  d8b[3] = buf[pos + 4]\n  d8b[2] = buf[pos + 5]\n  d8b[1] = buf[pos + 6]\n  d8b[0] = buf[pos + 7]\n  return f64[0]\n}\n","// the largest BigInt we can safely downcast to a Number\nconst MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER)\nconst MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER)\n\n/**\n * Constructs new long bits.\n *\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @function Object() { [native code] }\n * @param {number} lo - Low 32 bits, unsigned\n * @param {number} hi - High 32 bits, unsigned\n */\nexport class LongBits {\n  public lo: number\n  public hi: number\n\n  constructor (lo: number, hi: number) {\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits\n     */\n    this.lo = lo | 0\n\n    /**\n     * High bits\n     */\n    this.hi = hi | 0\n  }\n\n  /**\n   * Converts this long bits to a possibly unsafe JavaScript number\n   */\n  toNumber (unsigned: boolean = false): number {\n    if (!unsigned && (this.hi >>> 31) > 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(lo + hi * 4294967296)\n    }\n    return this.lo + this.hi * 4294967296\n  }\n\n  /**\n   * Converts this long bits to a bigint\n   */\n  toBigInt (unsigned: boolean = false): bigint {\n    if (unsigned) {\n      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n    }\n\n    if ((this.hi >>> 31) !== 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(BigInt(lo) + (BigInt(hi) << 32n))\n    }\n\n    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n  }\n\n  /**\n   * Converts this long bits to a string\n   */\n  toString (unsigned: boolean = false): string {\n    return this.toBigInt(unsigned).toString()\n  }\n\n  /**\n   * Zig-zag encodes this long bits\n   */\n  zzEncode (): this {\n    const mask = this.hi >> 31\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0\n    this.lo = (this.lo << 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Zig-zag decodes this long bits\n   */\n  zzDecode (): this {\n    const mask = -(this.lo & 1)\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Calculates the length of this longbits when encoded as a varint.\n   */\n  length (): number {\n    const part0 = this.lo\n    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0\n    const part2 = this.hi >>> 24\n    return part2 === 0\n      ? part1 === 0\n        ? part0 < 16384\n          ? part0 < 128 ? 1 : 2\n          : part0 < 2097152 ? 3 : 4\n        : part1 < 16384\n          ? part1 < 128 ? 5 : 6\n          : part1 < 2097152 ? 7 : 8\n      : part2 < 128 ? 9 : 10\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromBigInt (value: bigint): LongBits {\n    if (value === 0n) {\n      return zero\n    }\n\n    if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {\n      return this.fromNumber(Number(value))\n    }\n\n    const negative = value < 0n\n\n    if (negative) {\n      value = -value\n    }\n\n    let hi = value >> 32n\n    let lo = value - (hi << 32n)\n\n    if (negative) {\n      hi = ~hi | 0n\n      lo = ~lo | 0n\n\n      if (++lo > TWO_32) {\n        lo = 0n\n        if (++hi > TWO_32) { hi = 0n }\n      }\n    }\n\n    return new LongBits(Number(lo), Number(hi))\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromNumber (value: number): LongBits {\n    if (value === 0) { return zero }\n    const sign = value < 0\n    if (sign) { value = -value }\n    let lo = value >>> 0\n    let hi = (value - lo) / 4294967296 >>> 0\n    if (sign) {\n      hi = ~hi >>> 0\n      lo = ~lo >>> 0\n      if (++lo > 4294967295) {\n        lo = 0\n        if (++hi > 4294967295) { hi = 0 }\n      }\n    }\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Constructs new long bits from a number, long or string\n   */\n  static from (value: bigint | number | string | { low: number, high: number }): LongBits {\n    if (typeof value === 'number') {\n      return LongBits.fromNumber(value)\n    }\n    if (typeof value === 'bigint') {\n      return LongBits.fromBigInt(value)\n    }\n    if (typeof value === 'string') {\n      return LongBits.fromBigInt(BigInt(value))\n    }\n    return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero\n  }\n}\n\nconst zero = new LongBits(0, 0)\nzero.toBigInt = function () { return 0n }\nzero.zzEncode = zero.zzDecode = function () { return this }\nzero.length = function () { return 1 }\n\nconst TWO_32 = 4294967296n\n","/**\n * Calculates the UTF8 byte length of a string\n */\nexport function length (string: string): number {\n  let len = 0\n  let c = 0\n  for (let i = 0; i < string.length; ++i) {\n    c = string.charCodeAt(i)\n\n    if (c < 128) {\n      len += 1\n    } else if (c < 2048) {\n      len += 2\n    } else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i\n      len += 4\n    } else {\n      len += 3\n    }\n  }\n\n  return len\n}\n\n/**\n * Reads UTF8 bytes as a string\n */\nexport function read (buffer: Uint8Array, start: number, end: number): string {\n  const len = end - start\n\n  if (len < 1) {\n    return ''\n  }\n\n  let parts: string[] | undefined\n  const chunk: number[] = []\n  let i = 0 // char offset\n  let t: number // temporary\n\n  while (start < end) {\n    t = buffer[start++]\n\n    if (t < 128) {\n      chunk[i++] = t\n    } else if (t > 191 && t < 224) {\n      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63\n    } else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000\n      chunk[i++] = 0xD800 + (t >> 10)\n      chunk[i++] = 0xDC00 + (t & 1023)\n    } else {\n      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63\n    }\n\n    if (i > 8191) {\n      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk))\n      i = 0\n    }\n  }\n\n  if (parts != null) {\n    if (i > 0) {\n      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)))\n    }\n\n    return parts.join('')\n  }\n\n  return String.fromCharCode.apply(String, chunk.slice(0, i))\n}\n\n/**\n * Writes a string as UTF8 bytes\n */\nexport function write (string: string, buffer: Uint8Array, offset: number): number {\n  const start = offset\n  let c1 // character 1\n  let c2 // character 2\n\n  for (let i = 0; i < string.length; ++i) {\n    c1 = string.charCodeAt(i)\n\n    if (c1 < 128) {\n      buffer[offset++] = c1\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192\n      buffer[offset++] = c1 & 63 | 128\n    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)\n      ++i\n      buffer[offset++] = c1 >> 18 | 240\n      buffer[offset++] = c1 >> 12 & 63 | 128\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    } else {\n      buffer[offset++] = c1 >> 12 | 224\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    }\n  }\n\n  return offset - start\n}\n","import { readFloatLE, readDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport * as utf8 from './utf8.js'\nimport type { Reader } from '../index.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/* istanbul ignore next */\nfunction indexOutOfRange (reader: Reader, writeLength?: number): RangeError {\n  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`)\n}\n\nfunction readFixed32End (buf: Uint8Array, end: number): number { // note that this uses `end`, not `pos`\n  return (buf[end - 4] |\n        buf[end - 3] << 8 |\n        buf[end - 2] << 16 |\n        buf[end - 1] << 24) >>> 0\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n */\nexport class Uint8ArrayReader implements Reader {\n  public buf: Uint8Array\n  public pos: number\n  public len: number\n\n  public _slice = Uint8Array.prototype.subarray\n\n  constructor (buffer: Uint8Array) {\n    /**\n     * Read buffer\n     */\n    this.buf = buffer\n\n    /**\n     * Read buffer position\n     */\n    this.pos = 0\n\n    /**\n     * Read buffer length\n     */\n    this.len = buffer.length\n  }\n\n  /**\n   * Reads a varint as an unsigned 32 bit value\n   */\n  uint32 (): number {\n    let value = 4294967295\n\n    value = (this.buf[this.pos] & 127) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value\n\n    if ((this.pos += 5) > this.len) {\n      this.pos = this.len\n      throw indexOutOfRange(this, 10)\n    }\n\n    return value\n  }\n\n  /**\n   * Reads a varint as a signed 32 bit value\n   */\n  int32 (): number {\n    return this.uint32() | 0\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 32 bit value\n   */\n  sint32 (): number {\n    const value = this.uint32()\n    return value >>> 1 ^ -(value & 1) | 0\n  }\n\n  /**\n   * Reads a varint as a boolean\n   */\n  bool (): boolean {\n    return this.uint32() !== 0\n  }\n\n  /**\n   * Reads fixed 32 bits as an unsigned 32 bit integer\n   */\n  fixed32 (): number {\n    if (this.pos + 4 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const res = readFixed32End(this.buf, this.pos += 4)\n\n    return res\n  }\n\n  /**\n   * Reads fixed 32 bits as a signed 32 bit integer\n   */\n  sfixed32 (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const res = readFixed32End(this.buf, this.pos += 4) | 0\n\n    return res\n  }\n\n  /**\n   * Reads a float (32 bit) as a number\n   */\n  float (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const value = readFloatLE(this.buf, this.pos)\n    this.pos += 4\n    return value\n  }\n\n  /**\n   * Reads a double (64 bit float) as a number\n   */\n  double (): number {\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const value = readDoubleLE(this.buf, this.pos)\n    this.pos += 8\n    return value\n  }\n\n  /**\n   * Reads a sequence of bytes preceded by its length as a varint\n   */\n  bytes (): Uint8Array {\n    const length = this.uint32()\n    const start = this.pos\n    const end = this.pos + length\n\n    /* istanbul ignore if */\n    if (end > this.len) {\n      throw indexOutOfRange(this, length)\n    }\n\n    this.pos += length\n\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n      ? new Uint8Array(0)\n      : this.buf.subarray(start, end)\n  }\n\n  /**\n   * Reads a string preceded by its byte length as a varint\n   */\n  string (): string {\n    const bytes = this.bytes()\n    return utf8.read(bytes, 0, bytes.length)\n  }\n\n  /**\n   * Skips the specified number of bytes if specified, otherwise skips a varint\n   */\n  skip (length?: number): this {\n    if (typeof length === 'number') {\n      /* istanbul ignore if */\n      if (this.pos + length > this.len) { throw indexOutOfRange(this, length) }\n      this.pos += length\n    } else {\n      do {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n      } while ((this.buf[this.pos++] & 128) !== 0)\n    }\n    return this\n  }\n\n  /**\n   * Skips the next element of the specified wire type\n   */\n  skipType (wireType: number): this {\n    switch (wireType) {\n      case 0:\n        this.skip()\n        break\n      case 1:\n        this.skip(8)\n        break\n      case 2:\n        this.skip(this.uint32())\n        break\n      case 3:\n        while ((wireType = this.uint32() & 7) !== 4) {\n          this.skipType(wireType)\n        }\n        break\n      case 5:\n        this.skip(4)\n        break\n\n        /* istanbul ignore next */\n      default:\n        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`)\n    }\n    return this\n  }\n\n  private readLongVarint (): LongBits {\n    // tends to deopt with local vars for octet etc.\n    const bits = new LongBits(0, 0)\n    let i = 0\n    if (this.len - this.pos > 4) { // fast route (lo)\n      for (; i < 4; ++i) {\n        // 1st..4th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 5th\n      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0\n      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0\n      if (this.buf[this.pos++] < 128) { return bits }\n      i = 0\n    } else {\n      for (; i < 3; ++i) {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) { throw indexOutOfRange(this) }\n        // 1st..3th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 4th\n      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0\n      return bits\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n      for (; i < 5; ++i) {\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    } else {\n      for (; i < 5; ++i) {\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    }\n\n    throw Error('invalid varint encoding')\n  }\n\n  private readFixed64 (): LongBits {\n    if (this.pos + 8 > this.len) {\n      throw indexOutOfRange(this, 8)\n    }\n\n    const lo = readFixed32End(this.buf, this.pos += 4)\n    const hi = readFixed32End(this.buf, this.pos += 4)\n\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64 (): bigint {\n    return this.readLongVarint().toBigInt()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  int64Number (): number {\n    return this.readLongVarint().toNumber()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a string\n   */\n  int64String (): string {\n    return this.readLongVarint().toString()\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64 (): bigint {\n    return this.readLongVarint().toBigInt(true)\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  uint64Number (): number {\n    return this.readLongVarint().toNumber(true)\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a string\n   */\n  uint64String (): string {\n    return this.readLongVarint().toString(true)\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64 (): bigint {\n    return this.readLongVarint().zzDecode().toBigInt()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * possibly unsafe JavaScript number\n   */\n  sint64Number (): number {\n    return this.readLongVarint().zzDecode().toNumber()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * string\n   */\n  sint64String (): string {\n    return this.readLongVarint().zzDecode().toString()\n  }\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number\n   */\n  fixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a string\n   */\n  fixed64String (): string {\n    return this.readFixed64().toString()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe\n   * JavaScript number\n   */\n  sfixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a string\n   */\n  sfixed64String (): string {\n    return this.readFixed64().toString()\n  }\n}\n\nexport function createReader (buf: Uint8Array | Uint8ArrayList): Reader {\n  return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray())\n}\n","import { createReader } from './utils/reader.js'\nimport type { Codec } from './codec.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport function decodeMessage <T> (buf: Uint8Array | Uint8ArrayList, codec: Codec<T>): T {\n  const reader = createReader(buf)\n\n  return codec.decode(reader)\n}\n","/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n","import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n","import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n","import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n","import { from } from './base.js'\n\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '🚀',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n","import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n","import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n","import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n","import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n","import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n","import { allocUnsafe } from 'uint8arrays/alloc'\n\n/**\n * A general purpose buffer pool\n */\nexport default function pool (size?: number): (size: number) => Uint8Array {\n  const SIZE = size ?? 8192\n  const MAX = SIZE >>> 1\n  let slab: Uint8Array\n  let offset = SIZE\n  return function poolAlloc (size: number) {\n    if (size < 1 || size > MAX) {\n      return allocUnsafe(size)\n    }\n\n    if (offset + size > SIZE) {\n      slab = allocUnsafe(SIZE)\n      offset = 0\n    }\n\n    const buf = slab.subarray(offset, offset += size)\n\n    if ((offset & 7) !== 0) {\n      // align to 32 bit\n      offset = (offset | 7) + 1\n    }\n\n    return buf\n  }\n}\n","import { allocUnsafe } from 'uint8arrays/alloc'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { writeFloatLE, writeDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport pool from './pool.js'\nimport * as utf8 from './utf8.js'\nimport type { Writer } from '../index.js'\n\ninterface WriterOperation<T> {\n  (val: T, buf: Uint8Array, pos: number): any\n}\n\n/**\n * Constructs a new writer operation instance.\n *\n * @classdesc Scheduled writer operation\n */\nclass Op<T> {\n  /**\n   * Function to call\n   */\n  public fn: WriterOperation<T>\n\n  /**\n   * Value byte length\n   */\n  public len: number\n\n  /**\n   * Next operation\n   */\n  public next?: Op<any>\n\n  /**\n   * Value to write\n   */\n  public val: T\n\n  constructor (fn: WriterOperation<T>, len: number, val: T) {\n    this.fn = fn\n    this.len = len\n    this.next = undefined\n    this.val = val // type varies\n  }\n}\n\n/* istanbul ignore next */\nfunction noop (): void {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance\n */\nclass State {\n  /**\n   * Current head\n   */\n  public head: Op<any>\n\n  /**\n   * Current tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Current buffer length\n   */\n  public len: number\n\n  /**\n   * Next state\n   */\n  public next?: State\n\n  constructor (writer: Uint8ArrayWriter) {\n    this.head = writer.head\n    this.tail = writer.tail\n    this.len = writer.len\n    this.next = writer.states\n  }\n}\n\nconst bufferPool = pool()\n\n/**\n * Allocates a buffer of the specified size\n */\nfunction alloc (size: number): Uint8Array {\n  if (globalThis.Buffer != null) {\n    return allocUnsafe(size)\n  }\n\n  return bufferPool(size)\n}\n\n/**\n * When a value is written, the writer calculates its byte length and puts it into a linked\n * list of operations to perform when finish() is called. This both allows us to allocate\n * buffers of the exact required size and reduces the amount of work we have to do compared\n * to first calculating over objects and then encoding over objects. In our case, the encoding\n * part is just a linked list walk calling operations with already prepared values.\n */\nclass Uint8ArrayWriter implements Writer {\n  /**\n   * Current length\n   */\n  public len: number\n\n  /**\n   * Operations head\n   */\n  public head: Op<any>\n\n  /**\n   * Operations tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Linked forked states\n   */\n  public states?: any\n\n  constructor () {\n    this.len = 0\n    this.head = new Op(noop, 0, 0)\n    this.tail = this.head\n    this.states = null\n  }\n\n  /**\n   * Pushes a new operation to the queue\n   */\n  _push (fn: WriterOperation<any>, len: number, val: any): this {\n    this.tail = this.tail.next = new Op(fn, len, val)\n    this.len += len\n\n    return this\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as a varint\n   */\n  uint32 (value: number): this {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n      (value = value >>> 0) <\n                128\n        ? 1\n        : value < 16384\n          ? 2\n          : value < 2097152\n            ? 3\n            : value < 268435456\n              ? 4\n              : 5,\n      value)).len\n    return this\n  }\n\n  /**\n   * Writes a signed 32 bit value as a varint`\n   */\n  int32 (value: number): this {\n    return value < 0\n      ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n      : this.uint32(value)\n  }\n\n  /**\n   * Writes a 32 bit value as a varint, zig-zag encoded\n   */\n  sint32 (value: number): this {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64Number (value: number): this {\n    const bits = LongBits.fromNumber(value)\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64String (value: string): this {\n    return this.uint64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64 (value: bigint): this {\n    return this.uint64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64Number (value: number): this {\n    return this.uint64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64String (value: string): this {\n    return this.uint64String(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64Number (value: number): this {\n    const bits = LongBits.fromNumber(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64String (value: string): this {\n    return this.sint64(BigInt(value))\n  }\n\n  /**\n   * Writes a boolish value as a varint\n   */\n  bool (value: boolean): this {\n    return this._push(writeByte, 1, value ? 1 : 0)\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as fixed 32 bits\n   */\n  fixed32 (value: number): this {\n    return this._push(writeFixed32, 4, value >>> 0)\n  }\n\n  /**\n   * Writes a signed 32 bit value as fixed 32 bits\n   */\n  sfixed32 (value: number): this {\n    return this.fixed32(value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64Number (value: number): this {\n    const bits = LongBits.fromNumber(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64String (value: string): this {\n    return this.fixed64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64 (value: bigint): this {\n    return this.fixed64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64Number (value: number): this {\n    return this.fixed64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64String (value: string): this {\n    return this.fixed64String(value)\n  }\n\n  /**\n   * Writes a float (32 bit)\n   */\n  float (value: number): this {\n    return this._push(writeFloatLE, 4, value)\n  }\n\n  /**\n   * Writes a double (64 bit float).\n   *\n   * @function\n   * @param {number} value - Value to write\n   * @returns {Writer} `this`\n   */\n  double (value: number): this {\n    return this._push(writeDoubleLE, 8, value)\n  }\n\n  /**\n   * Writes a sequence of bytes\n   */\n  bytes (value: Uint8Array): this {\n    const len = value.length >>> 0\n\n    if (len === 0) {\n      return this._push(writeByte, 1, 0)\n    }\n\n    return this.uint32(len)._push(writeBytes, len, value)\n  }\n\n  /**\n   * Writes a string\n   */\n  string (value: string): this {\n    const len = utf8.length(value)\n    return len !== 0\n      ? this.uint32(len)._push(utf8.write, len, value)\n      : this._push(writeByte, 1, 0)\n  }\n\n  /**\n   * Forks this writer's state by pushing it to a stack.\n   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n   */\n  fork (): this {\n    this.states = new State(this)\n    this.head = this.tail = new Op(noop, 0, 0)\n    this.len = 0\n    return this\n  }\n\n  /**\n   * Resets this instance to the last state\n   */\n  reset (): this {\n    if (this.states != null) {\n      this.head = this.states.head\n      this.tail = this.states.tail\n      this.len = this.states.len\n      this.states = this.states.next\n    } else {\n      this.head = this.tail = new Op(noop, 0, 0)\n      this.len = 0\n    }\n    return this\n  }\n\n  /**\n   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n   */\n  ldelim (): this {\n    const head = this.head\n    const tail = this.tail\n    const len = this.len\n    this.reset().uint32(len)\n    if (len !== 0) {\n      this.tail.next = head.next // skip noop\n      this.tail = tail\n      this.len += len\n    }\n    return this\n  }\n\n  /**\n   * Finishes the write operation\n   */\n  finish (): Uint8Array {\n    let head = this.head.next // skip noop\n    const buf = alloc(this.len)\n    let pos = 0\n    while (head != null) {\n      head.fn(head.val, buf, pos)\n      pos += head.len\n      head = head.next\n    }\n    // this.head = this.tail = null;\n    return buf\n  }\n}\n\nfunction writeByte (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n}\n\nfunction writeVarint32 (val: number, buf: Uint8Array, pos: number): void {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128\n    val >>>= 7\n  }\n  buf[pos] = val\n}\n\n/**\n * Constructs a new varint writer operation instance.\n *\n * @classdesc Scheduled varint writer operation\n */\nclass VarintOp extends Op<number> {\n  public next?: Op<any>\n\n  constructor (len: number, val: number) {\n    super(writeVarint32, len, val)\n    this.next = undefined\n  }\n}\n\nfunction writeVarint64 (val: LongBits, buf: Uint8Array, pos: number): void {\n  while (val.hi !== 0) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0\n    val.hi >>>= 7\n  }\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = val.lo >>> 7\n  }\n  buf[pos++] = val.lo\n}\n\nfunction writeFixed32 (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n  buf[pos + 1] = val >>> 8 & 255\n  buf[pos + 2] = val >>> 16 & 255\n  buf[pos + 3] = val >>> 24\n}\n\nfunction writeBytes (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos)\n}\n\nif (globalThis.Buffer != null) {\n  Uint8ArrayWriter.prototype.bytes = function (value: Uint8Array) {\n    const len = value.length >>> 0\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeBytesBuffer, len, value)\n    }\n\n    return this\n  }\n\n  Uint8ArrayWriter.prototype.string = function (value: string) {\n    const len = globalThis.Buffer.byteLength(value)\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeStringBuffer, len, value)\n    }\n\n    return this\n  }\n}\n\nfunction writeBytesBuffer (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos) // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n  // also works for plain array values\n}\n\nfunction writeStringBuffer (val: string, buf: Uint8Array, pos: number): void {\n  if (val.length < 40) {\n    // plain js is faster for short strings (probably due to redundant assertions)\n    utf8.write(val, buf, pos)\n    // @ts-expect-error buf isn't a Uint8Array?\n  } else if (buf.utf8Write != null) {\n    // @ts-expect-error buf isn't a Uint8Array?\n    buf.utf8Write(val, pos)\n  } else {\n    buf.set(uint8ArrayFromString(val), pos)\n  }\n}\n\n/**\n * Creates a new writer\n */\nexport function createWriter (): Writer {\n  return new Uint8ArrayWriter()\n}\n","import { createWriter } from './utils/writer.js'\nimport type { Codec } from './codec.js'\n\nexport function encodeMessage <T> (message: T, codec: Codec<T>): Uint8Array {\n  const w = createWriter()\n\n  codec.encode(message, w, {\n    lengthDelimited: false\n  })\n\n  return w.finish()\n}\n","import type { Writer, Reader } from './index.js'\n\n// https://developers.google.com/protocol-buffers/docs/encoding#structure\nexport enum CODEC_TYPES {\n  VARINT = 0,\n  BIT64,\n  LENGTH_DELIMITED,\n  START_GROUP,\n  END_GROUP,\n  BIT32\n}\n\nexport interface EncodeOptions {\n  lengthDelimited?: boolean\n  writeDefaults?: boolean\n}\n\nexport interface EncodeFunction<T> {\n  (value: Partial<T>, writer: Writer, opts?: EncodeOptions): void\n}\n\nexport interface DecodeFunction<T> {\n  (reader: Reader, length?: number): T\n}\n\nexport interface Codec<T> {\n  name: string\n  type: CODEC_TYPES\n  encode: EncodeFunction<T>\n  decode: DecodeFunction<T>\n}\n\nexport function createCodec <T> (name: string, type: CODEC_TYPES, encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return {\n    name,\n    type,\n    encode,\n    decode\n  }\n}\n","import { createCodec, CODEC_TYPES } from '../codec.js'\nimport type { DecodeFunction, EncodeFunction, Codec } from '../codec.js'\n\nexport function enumeration <T> (v: any): Codec<T> {\n  function findValue (val: string | number): number {\n    // Use the reverse mapping to look up the enum key for the stored value\n    // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\n    if (v[val.toString()] == null) {\n      throw new Error('Invalid enum value')\n    }\n\n    return v[val]\n  }\n\n  const encode: EncodeFunction<number | string> = function enumEncode (val, writer) {\n    const enumValue = findValue(val)\n\n    writer.int32(enumValue)\n  }\n\n  const decode: DecodeFunction<number | string> = function enumDecode (reader) {\n    const val = reader.int32()\n\n    return findValue(val)\n  }\n\n  // @ts-expect-error yeah yeah\n  return createCodec('enum', CODEC_TYPES.VARINT, encode, decode)\n}\n","import { createCodec, CODEC_TYPES, type EncodeOptions, type Codec } from '../codec.js'\nimport type { Reader, Writer } from '../index.js'\n\nexport interface Factory<A, T> {\n  new (obj: A): T\n}\n\nexport function message <T> (encode: (obj: Partial<T>, writer: Writer, opts?: EncodeOptions) => void, decode: (reader: Reader, length?: number) => T): Codec<T> {\n  return createCodec('message', CODEC_TYPES.LENGTH_DELIMITED, encode, decode)\n}\n","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Data {\n  Type?: Data.DataType\n  Data?: Uint8Array\n  filesize?: bigint\n  blocksizes: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mode?: number\n  mtime?: UnixTime\n}\n\nexport namespace Data {\n  export enum DataType {\n    Raw = 'Raw',\n    Directory = 'Directory',\n    File = 'File',\n    Metadata = 'Metadata',\n    Symlink = 'Symlink',\n    HAMTShard = 'HAMTShard'\n  }\n\n  enum __DataTypeValues {\n    Raw = 0,\n    Directory = 1,\n    File = 2,\n    Metadata = 3,\n    Symlink = 4,\n    HAMTShard = 5\n  }\n\n  export namespace DataType {\n    export const codec = (): Codec<DataType> => {\n      return enumeration<DataType>(__DataTypeValues)\n    }\n  }\n\n  let _codec: Codec<Data>\n\n  export const codec = (): Codec<Data> => {\n    if (_codec == null) {\n      _codec = message<Data>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          Data.DataType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (obj.filesize != null) {\n          w.uint32(24)\n          w.uint64(obj.filesize)\n        }\n\n        if (obj.blocksizes != null) {\n          for (const value of obj.blocksizes) {\n            w.uint32(32)\n            w.uint64(value)\n          }\n        }\n\n        if (obj.hashType != null) {\n          w.uint32(40)\n          w.uint64(obj.hashType)\n        }\n\n        if (obj.fanout != null) {\n          w.uint32(48)\n          w.uint64(obj.fanout)\n        }\n\n        if (obj.mode != null) {\n          w.uint32(56)\n          w.uint32(obj.mode)\n        }\n\n        if (obj.mtime != null) {\n          w.uint32(66)\n          UnixTime.codec().encode(obj.mtime, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          blocksizes: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = Data.DataType.codec().decode(reader)\n              break\n            case 2:\n              obj.Data = reader.bytes()\n              break\n            case 3:\n              obj.filesize = reader.uint64()\n              break\n            case 4:\n              obj.blocksizes.push(reader.uint64())\n              break\n            case 5:\n              obj.hashType = reader.uint64()\n              break\n            case 6:\n              obj.fanout = reader.uint64()\n              break\n            case 7:\n              obj.mode = reader.uint32()\n              break\n            case 8:\n              obj.mtime = UnixTime.codec().decode(reader, reader.uint32())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Data>): Uint8Array => {\n    return encodeMessage(obj, Data.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Data => {\n    return decodeMessage(buf, Data.codec())\n  }\n}\n\nexport interface UnixTime {\n  Seconds?: bigint\n  FractionalNanoseconds?: number\n}\n\nexport namespace UnixTime {\n  let _codec: Codec<UnixTime>\n\n  export const codec = (): Codec<UnixTime> => {\n    if (_codec == null) {\n      _codec = message<UnixTime>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Seconds != null) {\n          w.uint32(8)\n          w.int64(obj.Seconds)\n        }\n\n        if (obj.FractionalNanoseconds != null) {\n          w.uint32(21)\n          w.fixed32(obj.FractionalNanoseconds)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Seconds = reader.int64()\n              break\n            case 2:\n              obj.FractionalNanoseconds = reader.fixed32()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<UnixTime>): Uint8Array => {\n    return encodeMessage(obj, UnixTime.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): UnixTime => {\n    return decodeMessage(buf, UnixTime.codec())\n  }\n}\n\nexport interface Metadata {\n  MimeType?: string\n}\n\nexport namespace Metadata {\n  let _codec: Codec<Metadata>\n\n  export const codec = (): Codec<Metadata> => {\n    if (_codec == null) {\n      _codec = message<Metadata>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.MimeType != null) {\n          w.uint32(10)\n          w.string(obj.MimeType)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.MimeType = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Metadata>): Uint8Array => {\n    return encodeMessage(obj, Metadata.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Metadata => {\n    return decodeMessage(buf, Metadata.codec())\n  }\n}\n","// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { InfiniteHash } from './consumable-hash.js'\n\nexport interface BucketChild<V> {\n  key: string\n  value: V\n  hash: InfiniteHash\n}\n\ninterface SA<B> {\n  length: number\n  compactArray(): B[]\n  get(i: number): B\n  set(i: number, value: B): void\n  reduce <A> (fn: (acc: A, curr: B, index: number) => A, initial: A): B\n  find(fn: (item: B) => boolean): B | undefined\n  bitField(): number[]\n  unset(i: number): void\n}\n\nexport interface BucketPosition<T> {\n  bucket: Bucket<T>\n  pos: number\n  hash: InfiniteHash\n  existingChild?: BucketChild<T>\n}\n\nexport interface BucketOptions {\n  bits: number\n  hash(value: Uint8Array | InfiniteHash): InfiniteHash\n}\n\nexport class Bucket<T> {\n  _options: BucketOptions\n  _popCount: number\n  _parent?: Bucket<T>\n  _posAtParent: number\n  _children: SA<Bucket<T> | BucketChild<T>>\n\n  key: string | null\n\n  constructor (options: BucketOptions, parent?: Bucket<T>, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n    this._children = new SparseArray()\n    this.key = null\n  }\n\n  async put (key: string, value: T): Promise<void> {\n    const place = await this._findNewBucketAndPos(key)\n\n    place.bucket._putAt(place, key, value)\n  }\n\n  async get (key: string): Promise<T | undefined> {\n    const child = await this._findChild(key)\n\n    if (child != null) {\n      return child.value\n    }\n  }\n\n  async del (key: string): Promise<void> {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child != null && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  leafCount (): number {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount (): number {\n    return this._children.length\n  }\n\n  onlyChild (): Bucket<T> | BucketChild<T> {\n    return this._children.get(0)\n  }\n\n  * eachLeafSeries (): Iterable<BucketChild<T>> {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n  }\n\n  serialize <M> (map: (value: BucketChild<T>, index: number) => M, reduce: (reduced: Bucket<T> | BucketChild<T>) => M): M {\n    const acc: M[] = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child != null) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  async asyncTransform <R = T> (asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<R>): Promise<R> {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON (): Record<string, any> {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint (): string {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize (): number {\n    return Math.pow(2, this._options.bits)\n  }\n\n  async _findChild (key: string): Promise<BucketChild<T> | undefined> {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child != null && child.key === key) {\n      return child\n    }\n  }\n\n  async _findPlace (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  async _findNewBucketAndPos (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const place = await this._findPlace(key)\n\n    if ((place.existingChild != null) && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  _putAt (place: BucketPosition<T>, key: string, value: T): void {\n    this._putObjectAt(place.pos, {\n      key,\n      value,\n      hash: place.hash\n    })\n  }\n\n  _putObjectAt (pos: number, object: Bucket<T> | BucketChild<T>): void {\n    if (this._children.get(pos) == null) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  _delAt (pos: number): void {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos) != null) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level (): void {\n    if (this._parent != null && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if ((onlyChild != null) && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  _at (index: number): Bucket<T> | BucketChild<T> {\n    return this._children.get(index)\n  }\n}\n\nfunction exists (o: any): boolean {\n  return Boolean(o)\n}\n\nfunction mapNode (node: { key: string }, _: number): string {\n  return node.key\n}\n\nfunction reduceNodes <T> (nodes: T): any {\n  return nodes\n}\n\nasync function asyncTransformBucket <T, R = T> (bucket: Bucket<T>, asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<R>): Promise<R> {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n","/**\n * To guarantee Uint8Array semantics, convert nodejs Buffers\n * into vanilla Uint8Arrays\n */\nexport function asUint8Array (buf: Uint8Array): Uint8Array {\n  return buf\n}\n","import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n","const START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nexport class ConsumableBuffer {\n  _value: Uint8Array\n  _currentBytePos: number\n  _currentBitPos: number\n\n  constructor (value: Uint8Array) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits (): number {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits (): number {\n    return this._value.length * 8\n  }\n\n  take (bits: number): number {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits > 0 && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits (): boolean {\n    return this._currentBytePos >= 0\n  }\n}\n\nfunction byteBitsToInt (byte: number, start: number, length: number): number {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\nfunction maskFor (start: number, length: number): number {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n","import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { ConsumableBuffer } from './consumable-buffer.js'\n\nexport function wrapHash (hashFn: (value: Uint8Array) => Promise<Uint8Array>): (value: InfiniteHash | Uint8Array) => InfiniteHash {\n  function hashing (value: InfiniteHash | Uint8Array): InfiniteHash {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nexport class InfiniteHash {\n  _value: Uint8Array\n  _hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  _depth: number\n  _availableBits: number\n  _currentBufferIndex: number\n  _buffers: ConsumableBuffer[]\n\n  constructor (value: Uint8Array, hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits: number): Promise<number> {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits (): Promise<void> {\n    this._depth++\n\n    const value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n","/**\n * @packageDocumentation\n *\n * A [Hash Mapped Trie](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) implementation for JavaScript.\n *\n * This is used by [@helia/unixfs](https://www.npmjs.com/package/@helia/unixfs) for it's HAMT-sharded directory implementation.\n *\n * @example\n *\n * ```TypeScript\n * import { createHAMT } from 'hamt-sharding'\n * import crypto from 'crypto-promise'\n *\n * // decide how to hash buffers made from keys, can return a Promise\n * const hashFn = async (buf) => {\n *   return crypto\n *     .createHash('sha256')\n *     .update(buf)\n *     .digest()\n * }\n *\n * const bucket = createHAMT({\n *   hashFn: hashFn\n * })\n *\n * await bucket.put('key', 'value')\n *\n * const output = await bucket.get('key')\n * // output === 'value'\n * ```\n */\n\nimport { Bucket } from './bucket.js'\nimport { wrapHash } from './consumable-hash.js'\nimport type { BucketOptions, BucketPosition, BucketChild } from './bucket.js'\n\ninterface UserBucketOptions {\n  hashFn(value: Uint8Array): Promise<Uint8Array>\n  bits?: number\n}\n\nexport function createHAMT<T> (options: UserBucketOptions): Bucket<T> {\n  if (options == null || options.hashFn == null) {\n    throw new Error('please define an options.hashFn')\n  }\n\n  const bucketOptions = {\n    bits: options.bits ?? 8,\n    hash: wrapHash(options.hashFn)\n  }\n\n  return new Bucket<T>(bucketOptions)\n}\n\nexport { Bucket }\nexport type { BucketOptions, BucketPosition, BucketChild }\n","import { decode, type PBLink, type PBNode } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\nimport { Bucket, type BucketPosition, createHAMT } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { NotUnixFSError } from '../errors.js'\nimport type { ExporterOptions, ShardTraversalContext, ReadableStorage } from '../index.js'\nimport type { CID } from 'multiformats/cid'\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\nconst hashFn = async function (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\nconst addLinksToHamtBucket = async (links: PBLink[], bucket: Bucket<boolean>, rootBucket: Bucket<boolean>): Promise<void> => {\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  await Promise.all(\n    links.map(async link => {\n      if (link.Name == null) {\n        // TODO(@rvagg): what do? this is technically possible\n        throw new Error('Unexpected Link without a Name')\n      }\n      if (link.Name.length === padLength) {\n        const pos = parseInt(link.Name, 16)\n\n        bucket._putObjectAt(pos, new Bucket({\n          hash: rootBucket._options.hash,\n          bits: rootBucket._options.bits\n        }, bucket, pos))\n        return\n      }\n\n      await rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\nconst toPrefix = (position: number, padLength: number): string => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(padLength, '0')\n    .substring(0, padLength)\n}\n\nconst toBucketPath = (position: BucketPosition<boolean>): Array<Bucket<boolean>> => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent != null) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\nconst findShardCid = async (node: PBNode, name: string, blockstore: ReadableStorage, context?: ShardTraversalContext, options?: ExporterOptions): Promise<CID | undefined> => {\n  if (context == null) {\n    if (node.Data == null) {\n      throw new NotUnixFSError('no data in PBNode')\n    }\n\n    let dir: UnixFS\n    try {\n      dir = UnixFS.unmarshal(node.Data)\n    } catch (err: any) {\n      throw new NotUnixFSError(err.message)\n    }\n\n    if (dir.type !== 'hamt-sharded-directory') {\n      throw new NotUnixFSError('not a HAMT')\n    }\n    if (dir.fanout == null) {\n      throw new NotUnixFSError('missing fanout')\n    }\n\n    const rootBucket = createHAMT<boolean>({\n      hashFn,\n      bits: Math.log2(Number(dir.fanout))\n    })\n\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    }\n  }\n\n  const padLength = (context.lastBucket.tableSize() - 1).toString(16).length\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos, padLength)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent, padLength)\n  }\n\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false\n    }\n\n    const entryPrefix = link.Name.substring(0, padLength)\n    const entryName = link.Name.substring(padLength)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return false\n    }\n\n    if (entryName !== '' && entryName !== name) {\n      // not the entry we're looking for\n      return false\n    }\n\n    return true\n  })\n\n  if (link == null) {\n    return\n  }\n\n  if (link.Name != null && link.Name.substring(padLength) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  const block = await blockstore.get(link.Hash, options)\n  node = decode(block)\n\n  return findShardCid(node, name, blockstore, context, options)\n}\n\nexport default findShardCid\n","/**\n * @packageDocumentation\n *\n * Lets you look at the contents of an async iterator and decide what to do\n *\n * @example\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const it = peekable(value)\n *\n * const first = it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info([...it])\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const it = peekable(values())\n *\n * const first = await it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info(await all(it))\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n */\n\nexport interface Peek <T> {\n  peek(): IteratorResult<T, undefined>\n}\n\nexport interface AsyncPeek <T> {\n  peek(): Promise<IteratorResult<T, undefined>>\n}\n\nexport interface Push <T> {\n  push(value: T): void\n}\n\nexport type Peekable <T> = Iterable<T> & Peek<T> & Push<T> & Iterator<T>\n\nexport type AsyncPeekable <T> = AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>\n\nfunction peekable <T> (iterable: Iterable<T>): Peekable<T>\nfunction peekable <T> (iterable: AsyncIterable<T>): AsyncPeekable<T>\nfunction peekable <T> (iterable: Iterable<T> | AsyncIterable<T>): Peekable<T> | AsyncPeekable<T> {\n  // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  const queue: any[] = []\n\n  // @ts-expect-error can't use symbol to index peekable\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value: any) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length > 0) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nexport default peekable\n","/**\n * @packageDocumentation\n *\n * Filter values out of an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const fn = (val, index) => val > 2 // Return boolean to keep item\n *\n * const arr = all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n *\n * Async sources and filter functions must be awaited:\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const fn = async val => (val, index) > 2 // Return boolean or promise of boolean to keep item\n *\n * const arr = await all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Filters the passed (async) iterable by using the filter function\n */\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => boolean): Generator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): Generator<T, void, undefined> | AsyncGenerator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const entry of source) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      if (await res) {\n        yield value\n      }\n\n      for await (const entry of peekable) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => boolean\n\n  return (function * () {\n    if (res === true) {\n      yield value\n    }\n\n    for (const entry of peekable) {\n      if (func(entry, index++)) {\n        yield entry\n      }\n    }\n  })()\n}\n\nexport default filter\n","/**\n * @packageDocumentation\n *\n * Convert one value from an (async)iterator into another.\n *\n * @example\n *\n * ```javascript\n * import map from 'it-map'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const result = map(values, (val, index) => val++)\n *\n * console.info(result) // [1, 2, 3, 4, 5]\n * ```\n *\n * Async sources and transforms must be awaited:\n *\n * ```javascript\n * import map from 'it-map'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const result = await map(values(), async (val, index) => val++)\n *\n * console.info(result) // [1, 2, 3, 4, 5]\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Takes an (async) iterable and returns one with each item mapped by the passed\n * function\n */\nfunction map <I, O> (source: Iterable<I>, func: (val: I, index: number) => Promise<O>): AsyncGenerator<O, void, undefined>\nfunction map <I, O> (source: Iterable<I>, func: (val: I, index: number) => O): Generator<O, void, undefined>\nfunction map <I, O> (source: AsyncIterable<I> | Iterable<I>, func: (val: I, index: number) => O | Promise<O>): AsyncGenerator<O, void, undefined>\nfunction map <I, O> (source: AsyncIterable<I> | Iterable<I>, func: (val: I, index: number) => O | Promise<O>): AsyncGenerator<O, void, undefined> | Generator<O, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const val of source) {\n        yield func(val, index++)\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = func(value, index++)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      yield await res\n\n      for await (const val of peekable) {\n        yield func(val, index++)\n      }\n    })()\n  }\n\n  const fn = func as (val: I, index: number) => O\n\n  return (function * () {\n    yield res as O\n\n    for (const val of peekable) {\n      yield fn(val, index++)\n    }\n  })()\n}\n\nexport default map\n","export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n","/**\n * @packageDocumentation\n *\n * Takes an (async) iterable that emits promise-returning functions, invokes them in parallel up to the concurrency limit and emits the results as they become available, optionally in the same order as the input\n *\n * @example\n *\n * ```javascript\n * import parallel from 'it-parallel'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     console.info('start 1')\n *     await delay(500)\n *\n *     console.info('end 1')\n *     return 1\n *   },\n *   async () => {\n *     console.info('start 2')\n *     await delay(200)\n *\n *     console.info('end 2')\n *     return 2\n *   },\n *   async () => {\n *     console.info('start 3')\n *     await delay(100)\n *\n *     console.info('end 3')\n *     return 3\n *   }\n * ]\n *\n * const result = await all(parallel(input, {\n *   concurrency: 2\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [2, 3, 1]\n * ```\n *\n * If order is important, pass `ordered: true` as an option:\n *\n * ```javascript\n * const result = await all(parallel(input, {\n *   concurrency: 2,\n *   ordered: true\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nimport defer from 'p-defer'\n\ninterface Operation<T> {\n  done: boolean\n  ok: boolean\n  err: Error\n  value: T\n}\n\nconst CustomEvent = globalThis.CustomEvent ?? Event\n\nexport interface ParallelOptions {\n  /**\n   * How many jobs to execute in parallel (default: )\n   */\n  concurrency?: number\n  ordered?: boolean\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallel <T> (source: Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>, options: ParallelOptions = {}): AsyncGenerator<T, void, undefined> {\n  let concurrency = options.concurrency ?? Infinity\n\n  if (concurrency < 1) {\n    concurrency = Infinity\n  }\n\n  const ordered = options.ordered == null ? false : options.ordered\n  const emitter = new EventTarget()\n\n  const ops: Array<Operation<T>> = []\n  let slotAvailable = defer()\n  let resultAvailable = defer()\n  let sourceFinished = false\n  let sourceErr: Error | undefined\n  let opErred = false\n\n  emitter.addEventListener('task-complete', () => {\n    resultAvailable.resolve()\n  })\n\n  void Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer()\n          await slotAvailable.promise\n        }\n\n        if (opErred) {\n          break\n        }\n\n        const op: any = {\n          done: false\n        }\n        ops.push(op)\n\n        task()\n          .then(result => {\n            op.done = true\n            op.ok = true\n            op.value = result\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          }, err => {\n            op.done = true\n            op.err = err\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          })\n      }\n\n      sourceFinished = true\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    } catch (err: any) {\n      sourceErr = err\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    }\n  })\n\n  function valuesAvailable (): boolean {\n    if (ordered) {\n      return ops[0]?.done\n    }\n\n    return Boolean(ops.find(op => op.done))\n  }\n\n  function * yieldOrderedValues (): Generator<T, void, unknown> {\n    while ((ops.length > 0) && ops[0].done) {\n      const op = ops[0]\n      ops.shift()\n\n      if (op.ok) {\n        yield op.value\n      } else {\n        // allow the source to exit\n        opErred = true\n        slotAvailable.resolve()\n\n        throw op.err\n      }\n\n      slotAvailable.resolve()\n    }\n  }\n\n  function * yieldUnOrderedValues (): Generator<T, void, unknown> {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i]\n          ops.splice(i, 1)\n          i--\n\n          if (op.ok) {\n            yield op.value\n          } else {\n            opErred = true\n            slotAvailable.resolve()\n\n            throw op.err\n          }\n\n          slotAvailable.resolve()\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer()\n      await resultAvailable.promise\n    }\n\n    if (sourceErr != null) {\n      // the source threw an error, propagate it\n      throw sourceErr\n    }\n\n    if (ordered) {\n      yield * yieldOrderedValues()\n    } else {\n      yield * yieldUnOrderedValues()\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break\n    }\n  }\n}\n","export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n","// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n","/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\n\nimport { pushable } from 'it-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return (function * () {\n      for (const source of syncSources) {\n        yield * source\n      }\n    })()\n  }\n\n  return (async function * () {\n    const output = pushable<T>({\n      objectMode: true\n    })\n\n    void Promise.resolve().then(async () => {\n      try {\n        await Promise.all(\n          sources.map(async (source) => {\n            for await (const item of source) {\n              output.push(item)\n            }\n          })\n        )\n\n        output.end()\n      } catch (err: any) {\n        output.end(err)\n      }\n    })\n\n    yield * output\n  })()\n}\n\nexport default merge\n","import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type { Duplex, Transform, Sink } from 'it-stream-types'\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any>\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A>\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B>\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\n// one item, just a pass-through\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\n\nexport function pipe (first: any, ...rest: any[]): any {\n  if (first == null) {\n    throw new Error('Empty pipeline')\n  }\n\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first) || isAsyncIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nexport const rawPipe = (...fns: any): any => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isAsyncIterable = (obj: any): obj is AsyncIterable<unknown> => {\n  return obj?.[Symbol.asyncIterator] != null\n}\n\nconst isIterable = (obj: any): obj is Iterable<unknown> => {\n  return obj?.[Symbol.iterator] != null\n}\n\nconst isDuplex = (obj: any): obj is Duplex => {\n  if (obj == null) {\n    return false\n  }\n\n  return obj.sink != null && obj.source != null\n}\n\nconst duplexPipelineFn = (duplex: Duplex<any, any, any>) => {\n  return (source: any) => {\n    const p = duplex.sink(source)\n\n    if (p?.then != null) {\n      const stream = pushable<any>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      let sourceWrap: () => Iterable<any> | AsyncIterable<any>\n      const source = duplex.source\n\n      if (isAsyncIterable(source)) {\n        sourceWrap = async function * () {\n          yield * source\n          stream.end()\n        }\n      } else if (isIterable(source)) {\n        sourceWrap = function * () {\n          yield * source\n          stream.end()\n        }\n      } else {\n        throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable')\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n","import filter from 'it-filter'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport type { ExporterOptions, ExportWalk, UnixfsV1DirectoryContent, UnixfsV1Resolver } from '../../../index.js'\n\nconst directoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    const offset = options.offset ?? 0\n    const length = options.length ?? node.Links.length\n    const links = node.Links.slice(offset, length)\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:directory', {\n      cid\n    }))\n\n    yield * pipe(\n      links,\n      source => map(source, link => {\n        return async () => {\n          const linkName = link.Name ?? ''\n          const linkPath = `${path}/${linkName}`\n          const result = await resolve(link.Hash, linkName, linkPath, [], depth + 1, blockstore, options)\n          return result.entry\n        }\n      }),\n      source => parallel(source, {\n        ordered: true,\n        concurrency: options.blockReadConcurrency\n      }),\n      source => filter(source, entry => entry != null)\n    )\n  }\n\n  return yieldDirectoryContent\n}\n\nexport default directoryContent\n","import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n","export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n","// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n","import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && this.#queue[this.size - 1].priority >= options.priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n","import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverConcurrencyCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #interval;\n    #intervalEnd = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    #throwOnTimeout;\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n\n    Applies to each future operation.\n    */\n    timeout;\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        this.#throwOnTimeout = options.throwOnTimeout === true;\n        this.#isPaused = options.autoStart === false;\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this.#timeoutId === undefined) {\n                    this.#timeoutId = setTimeout(() => {\n                        this.#onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this.#intervalId) {\n                clearInterval(this.#intervalId);\n            }\n            this.#intervalId = undefined;\n            this.emit('empty');\n            if (this.#pending === 0) {\n                this.emit('idle');\n            }\n            return false;\n        }\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n        this.#processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    async #throwOnAbort(signal) {\n        return new Promise((_resolve, reject) => {\n            signal.addEventListener('abort', () => {\n                reject(signal.reason);\n            }, { once: true });\n        });\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: this.#throwOnTimeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                this.#intervalCount++;\n                try {\n                    options.signal?.throwIfAborted();\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    this.#next();\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n}\n","import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { type Pushable, pushable } from 'it-pushable'\nimport * as raw from 'multiformats/codecs/raw'\nimport PQueue from 'p-queue'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotUnixFSError, OverReadError, UnderReadError } from '../../../errors.js'\nimport extractDataFromBlock from '../../../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, UnixfsV1FileContent, UnixfsV1Resolver, ReadableStorage, ExportProgress, ExportWalk } from '../../../index.js'\n\nasync function walkDAG (blockstore: ReadableStorage, node: dagPb.PBNode | Uint8Array, queue: Pushable<Uint8Array>, streamPosition: bigint, start: bigint, end: bigint, options: ExporterOptions): Promise<void> {\n  // a `raw` node\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end)\n\n    queue.push(buf)\n\n    return\n  }\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  let file: UnixFS\n\n  try {\n    file = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw new NotUnixFSError(err.message)\n  }\n\n  // might be a unixfs `raw` node or have data on intermediate nodes\n  if (file.data != null) {\n    const data = file.data\n    const buf = extractDataFromBlock(data, streamPosition, start, end)\n\n    queue.push(buf)\n\n    streamPosition += BigInt(buf.byteLength)\n  }\n\n  const childOps: Array<{ link: dagPb.PBLink, blockStart: bigint }> = []\n\n  if (node.Links.length !== file.blockSizes.length) {\n    throw new NotUnixFSError('Inconsistent block sizes and dag links')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i]\n    const childStart = streamPosition // inclusive\n    const childEnd = childStart + file.blockSizes[i] // exclusive\n\n    if ((start >= childStart && start < childEnd) || // child has offset byte\n        (end >= childStart && end <= childEnd) || // child has end byte\n        (start < childStart && end > childEnd)) { // child is between offset and end bytes\n      childOps.push({\n        link: childLink,\n        blockStart: streamPosition\n      })\n    }\n\n    streamPosition = childEnd\n\n    if (streamPosition > end) {\n      break\n    }\n  }\n\n  await pipe(\n    childOps,\n    (source) => map(source, (op) => {\n      return async () => {\n        const block = await blockstore.get(op.link.Hash, options)\n\n        return {\n          ...op,\n          block\n        }\n      }\n    }),\n    (source) => parallel(source, {\n      ordered: true,\n      concurrency: options.blockReadConcurrency\n    }),\n    async (source) => {\n      for await (const { link, block, blockStart } of source) {\n        let child: dagPb.PBNode | Uint8Array\n        switch (link.Hash.code) {\n          case dagPb.code:\n            child = dagPb.decode(block)\n            break\n          case raw.code:\n            child = block\n            break\n          default:\n            queue.end(new NotUnixFSError(`Unsupported codec: ${link.Hash.code}`))\n            return\n        }\n\n        // create a queue for this child - we use a queue instead of recursion\n        // to avoid overflowing the stack\n        const childQueue = new PQueue({\n          concurrency: 1\n        })\n        // if any of the child jobs error, end the read queue with the error\n        childQueue.on('error', error => {\n          queue.end(error)\n        })\n\n        // if the job rejects the 'error' event will be emitted on the child queue\n        void childQueue.add(async () => {\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n            cid: link.Hash\n          }))\n\n          await walkDAG(blockstore, child, queue, blockStart, start, end, options)\n        })\n\n        // wait for this child to complete before moving on to the next\n        await childQueue.onIdle()\n      }\n    }\n  )\n\n  if (streamPosition >= end) {\n    queue.end()\n  }\n}\n\nconst fileContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldFileContent (options: ExporterOptions = {}): UnixfsV1FileContent {\n    const fileSize = unixfs.fileSize()\n\n    if (fileSize === undefined) {\n      throw new Error('File was a directory')\n    }\n\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(fileSize, options.offset, options.length)\n\n    if (end === 0n) {\n      return\n    }\n\n    let read = 0n\n    const wanted = end - start\n    const queue = pushable()\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n      cid\n    }))\n\n    void walkDAG(blockstore, node, queue, 0n, start, end, options)\n      .catch(err => {\n        queue.end(err)\n      })\n\n    for await (const buf of queue) {\n      if (buf == null) {\n        continue\n      }\n\n      read += BigInt(buf.byteLength)\n\n      if (read > wanted) {\n        queue.end()\n        throw new OverReadError('Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect')\n      }\n\n      if (read === wanted) {\n        queue.end()\n      }\n\n      options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:unixfs:file', {\n        bytesRead: read,\n        totalBytes: wanted,\n        fileSize\n      }))\n\n      yield buf\n    }\n\n    if (read < wanted) {\n      throw new UnderReadError('Traversed entire DAG but did not read enough bytes')\n    }\n  }\n\n  return yieldFileContent\n}\n\nexport default fileContent\n","import { decode, type PBNode } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotUnixFSError } from '../../../errors.js'\nimport type { ExporterOptions, Resolve, UnixfsV1DirectoryContent, UnixfsV1Resolver, ReadableStorage, ExportWalk } from '../../../index.js'\n\nconst hamtShardedDirectoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldHamtDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n      cid\n    }))\n\n    return listDirectory(node, path, resolve, depth, blockstore, options)\n  }\n\n  return yieldHamtDirectoryContent\n}\n\nasync function * listDirectory (node: PBNode, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): UnixfsV1DirectoryContent {\n  const links = node.Links\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  let dir: UnixFS\n  try {\n    dir = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw new NotUnixFSError(err.message)\n  }\n\n  if (dir.fanout == null) {\n    throw new NotUnixFSError('missing fanout')\n  }\n\n  const padLength = (dir.fanout - 1n).toString(16).length\n\n  const results = pipe(\n    links,\n    source => map(source, link => {\n      return async () => {\n        const name = link.Name != null ? link.Name.substring(padLength) : null\n\n        if (name != null && name !== '') {\n          const result = await resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, blockstore, options)\n\n          return { entries: result.entry == null ? [] : [result.entry] }\n        } else {\n          // descend into subshard\n          const block = await blockstore.get(link.Hash, options)\n          node = decode(block)\n\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n            cid: link.Hash\n          }))\n\n          return { entries: listDirectory(node, path, resolve, depth, blockstore, options) }\n        }\n      }\n    }),\n    source => parallel(source, {\n      ordered: true,\n      concurrency: options.blockReadConcurrency\n    })\n  )\n\n  for await (const { entries } of results) {\n    yield * entries\n  }\n}\n\nexport default hamtShardedDirectoryContent\n","import { decode, type PBNode } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { NotFoundError, NotUnixFSError } from '../../errors.js'\nimport findShardCid from '../../utils/find-cid-in-shard.js'\nimport contentDirectory from './content/directory.js'\nimport contentFile from './content/file.js'\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js'\nimport type { Resolver, UnixfsV1Resolver } from '../../index.js'\nimport type { CID } from 'multiformats/cid'\n\nconst findLinkCid = (node: PBNode, name: string): CID | undefined => {\n  const link = node.Links.find(link => link.Name === name)\n\n  return link?.Hash\n}\n\nconst contentExporters: Record<string, UnixfsV1Resolver> = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  }\n}\n\n// @ts-expect-error types are wrong\nconst unixFsResolver: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const node = decode(block)\n  let unixfs\n  let next\n\n  if (name == null) {\n    name = cid.toString()\n  }\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw new NotUnixFSError(err.message)\n  }\n\n  if (path == null) {\n    path = name\n  }\n\n  if (toResolve.length > 0) {\n    let linkCid\n\n    if (unixfs?.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], blockstore)\n    } else {\n      linkCid = findLinkCid(node, toResolve[0])\n    }\n\n    if (linkCid == null) {\n      throw new NotFoundError('file does not exist')\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift()\n    const nextPath = `${path}/${nextName}`\n\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName ?? '',\n      path: nextPath\n    }\n  }\n\n  const content = contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore)\n\n  if (content == null) {\n    throw new NotFoundError('could not find content exporter')\n  }\n\n  if (unixfs.isDirectory()) {\n    return {\n      entry: {\n        type: 'directory',\n        name,\n        path,\n        cid,\n        content,\n        unixfs,\n        depth,\n        node,\n        size: unixfs.fileSize()\n      },\n      next\n    }\n  }\n\n  return {\n    entry: {\n      type: 'file',\n      name,\n      path,\n      cid,\n      content,\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  }\n}\n\nexport default unixFsResolver\n","import * as dagCbor from '@ipld/dag-cbor'\nimport * as dagJson from '@ipld/dag-json'\nimport * as dagPb from '@ipld/dag-pb'\nimport * as json from 'multiformats/codecs/json'\nimport * as raw from 'multiformats/codecs/raw'\nimport { identity } from 'multiformats/hashes/identity'\nimport { NoResolverError } from '../errors.js'\nimport dagCborResolver from './dag-cbor.js'\nimport dagJsonResolver from './dag-json.js'\nimport identifyResolver from './identity.js'\nimport jsonResolver from './json.js'\nimport rawResolver from './raw.js'\nimport dagPbResolver from './unixfs-v1/index.js'\nimport type { Resolve, Resolver } from '../index.js'\n\nconst resolvers: Record<number, Resolver> = {\n  [dagPb.code]: dagPbResolver,\n  [raw.code]: rawResolver,\n  [dagCbor.code]: dagCborResolver,\n  [dagJson.code]: dagJsonResolver,\n  [identity.code]: identifyResolver,\n  [json.code]: jsonResolver\n}\n\nconst resolve: Resolve = async (cid, name, path, toResolve, depth, blockstore, options) => {\n  const resolver = resolvers[cid.code]\n\n  if (resolver == null) {\n    throw new NoResolverError(`No resolver for code ${cid.code}`)\n  }\n\n  return resolver(cid, name, path, toResolve, resolve, depth, blockstore, options)\n}\n\nexport default resolve\n","/**\n * @packageDocumentation\n *\n * The UnixFS Exporter provides a means to read DAGs from a blockstore given a CID.\n *\n * @example\n *\n * ```js\n * // import a file and export it again\n * import { importer } from 'ipfs-unixfs-importer'\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n *\n * // Should contain the blocks we are trying to export\n * const blockstore = new MemoryBlockstore()\n * const files = []\n *\n * for await (const file of importer([{\n *   path: '/foo/bar.txt',\n *   content: new Uint8Array([0, 1, 2, 3])\n * }], blockstore)) {\n *   files.push(file)\n * }\n *\n * console.info(files[0].cid) // Qmbaz\n *\n * const entry = await exporter(files[0].cid, blockstore)\n *\n * console.info(entry.cid) // Qmqux\n * console.info(entry.path) // Qmbaz/foo/bar.txt\n * console.info(entry.name) // bar.txt\n * console.info(entry.unixfs.fileSize()) // 4\n *\n * // stream content from unixfs node\n * const size = entry.unixfs.fileSize()\n * const bytes = new Uint8Array(size)\n * let offset = 0\n *\n * for await (const buf of entry.content()) {\n *   bytes.set(buf, offset)\n *   offset += chunk.length\n * }\n *\n * console.info(bytes) // 0, 1, 2, 3\n * ```\n */\n\nimport last from 'it-last'\nimport { CID } from 'multiformats/cid'\nimport { BadPathError, NotFoundError } from './errors.js'\nimport resolve from './resolvers/index.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { Bucket } from 'hamt-sharding'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { UnixFS } from 'ipfs-unixfs'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport * from './errors.js'\n\nexport interface ExportProgress {\n  /**\n   * How many bytes of the file have been read\n   */\n  bytesRead: bigint\n\n  /**\n   * How many bytes of the file will be read - n.b. this may be\n   * smaller than `fileSize` if `offset`/`length` have been\n   * specified\n   */\n  totalBytes: bigint\n\n  /**\n   * The size of the file being read - n.b. this may be\n   * larger than `total` if `offset`/`length` has been\n   * specified\n   */\n  fileSize: bigint\n}\n\nexport interface ExportWalk {\n  cid: CID\n}\n\n/**\n * Progress events emitted by the exporter\n */\nexport type ExporterProgressEvents =\n  ProgressEvent<'unixfs:exporter:progress:unixfs:file', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:unixfs:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:identity', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:walk:file', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:hamt-sharded-directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:raw', ExportWalk>\n\nexport interface ExporterOptions extends ProgressOptions<ExporterProgressEvents> {\n  /**\n   * An optional offset to start reading at.\n   *\n   * If the CID resolves to a file this will be a byte offset within that file,\n   * otherwise if it's a directory it will be a directory entry offset within\n   * the directory listing. (default: undefined)\n   */\n  offset?: number\n\n  /**\n   * An optional length to read.\n   *\n   * If the CID resolves to a file this will be the number of bytes read from\n   * the file, otherwise if it's a directory it will be the number of directory\n   * entries read from the directory listing. (default: undefined)\n   */\n  length?: number\n\n  /**\n   * This signal can be used to abort any long-lived operations such as fetching\n   * blocks from the network. (default: undefined)\n   */\n  signal?: AbortSignal\n\n  /**\n   * When a DAG layer is encountered, all child nodes are loaded in parallel but\n   * processed as they arrive. This allows us to load sibling nodes in advance\n   * of yielding their bytes. Pass a value here to control the number of blocks\n   * loaded in parallel. If a strict depth-first traversal is required, this\n   * value should be set to `1`, otherwise the traversal order will tend to\n   * resemble a breadth-first fan-out and yield a have stable ordering.\n   * (default: undefined)\n   */\n  blockReadConcurrency?: number\n}\n\nexport interface Exportable<T> {\n  /**\n   * A disambiguator to allow TypeScript to work out the type of the entry.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * if (entry.type === 'file') {\n   *   // access UnixFSFile properties safely\n   * }\n   *\n   * if (entry.type === 'directory') {\n   *   // access UnixFSDirectory properties safely\n   * }\n   * ```\n   */\n  type: 'file' | 'directory' | 'object' | 'raw' | 'identity'\n\n  /**\n   * The name of the entry\n   */\n  name: string\n\n  /**\n   * The path of the entry within the DAG in which it was encountered\n   */\n  path: string\n\n  /**\n   * The CID of the entry\n   */\n  cid: CID\n\n  /**\n   * How far down the DAG the entry is\n   */\n  depth: number\n\n  /**\n   * The size of the entry\n   */\n  size: bigint\n\n  /**\n   * @example File content\n   *\n   * When `entry` is a file or a `raw` node, `offset` and/or `length` arguments can be passed to `entry.content()` to return slices of data:\n   *\n   * ```javascript\n   * const length = 5\n   * const data = new Uint8Array(length)\n   * let offset = 0\n   *\n   * for await (const chunk of entry.content({\n   *   offset: 0,\n   *   length\n   * })) {\n   *   data.set(chunk, offset)\n   *   offset += chunk.length\n   * }\n   *\n   * // `data` contains the first 5 bytes of the file\n   * return data\n   * ```\n   *\n   * @example Directory content\n   *\n   * If `entry` is a directory, passing `offset` and/or `length` to `entry.content()` will limit the number of files returned from the directory.\n   *\n   * ```javascript\n   * const entries = []\n   *\n   * for await (const entry of dir.content({\n   *   offset: 0,\n   *   length: 5\n   * })) {\n   *   entries.push(entry)\n   * }\n   *\n   * // `entries` contains the first 5 files/directories in the directory\n   * ```\n   */\n  content(options?: ExporterOptions): AsyncGenerator<T, void, unknown>\n}\n\n/**\n * If the entry is a file, `entry.content()` returns an async iterator that yields one or more Uint8Arrays containing the file content:\n *\n * ```javascript\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Buffer\n *   }\n * }\n * ```\n */\nexport interface UnixFSFile extends Exportable<Uint8Array> {\n  type: 'file'\n  unixfs: UnixFS\n  node: PBNode\n}\n\n/**\n * If the entry is a directory, `entry.content()` returns further `entry` objects:\n *\n * ```javascript\n * if (entry.type === 'directory') {\n *   for await (const entry of dir.content()) {\n *     console.info(entry.name)\n *   }\n * }\n * ```\n */\nexport interface UnixFSDirectory extends Exportable<UnixFSEntry> {\n  type: 'directory'\n  unixfs: UnixFS\n  node: PBNode\n}\n\n/**\n * Entries with a `dag-cbor` or `dag-json` codec {@link CID} return JavaScript object entries\n */\nexport interface ObjectNode extends Exportable<any> {\n  type: 'object'\n  node: Uint8Array\n}\n\n/**\n * Entries with a `raw` codec {@link CID} return raw entries.\n *\n * `entry.content()` returns an async iterator that yields a buffer containing the node content:\n *\n * ```javascript\n * for await (const chunk of entry.content()) {\n *   // chunk is a Buffer\n * }\n * ```\n *\n * Unless you an options object containing `offset` and `length` keys as an argument to `entry.content()`, `chunk` will be equal to `entry.node`.\n */\nexport interface RawNode extends Exportable<Uint8Array> {\n  type: 'raw'\n  node: Uint8Array\n}\n\n/**\n * Entries with a `identity` codec {@link CID} return identity entries.\n *\n * These are entries where the data payload is stored in the CID itself,\n * otherwise they are identical to {@link RawNode}s.\n */\nexport interface IdentityNode extends Exportable<Uint8Array> {\n  type: 'identity'\n  node: Uint8Array\n}\n\n/**\n * A UnixFSEntry is a representation of the types of node that can be\n * encountered in a DAG.\n */\nexport type UnixFSEntry = UnixFSFile | UnixFSDirectory | ObjectNode | RawNode | IdentityNode\n\nexport interface NextResult {\n  cid: CID\n  name: string\n  path: string\n  toResolve: string[]\n}\n\nexport interface ResolveResult {\n  entry: UnixFSEntry\n  next?: NextResult\n}\n\nexport interface Resolve { (cid: CID, name: string, path: string, toResolve: string[], depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\nexport interface Resolver { (cid: CID, name: string, path: string, toResolve: string[], resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\n\nexport type UnixfsV1FileContent = AsyncIterable<Uint8Array> | Iterable<Uint8Array>\nexport type UnixfsV1DirectoryContent = AsyncIterable<UnixFSEntry> | Iterable<UnixFSEntry>\nexport type UnixfsV1Content = UnixfsV1FileContent | UnixfsV1DirectoryContent\nexport interface UnixfsV1Resolver { (cid: CID, node: PBNode, unixfs: UnixFS, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage): (options: ExporterOptions) => UnixfsV1Content }\n\nexport interface ShardTraversalContext {\n  hamtDepth: number\n  rootBucket: Bucket<boolean>\n  lastBucket: Bucket<boolean>\n}\n\n/**\n * A subset of the {@link Blockstore} interface that just contains the get\n * method.\n */\nexport type ReadableStorage = Pick<Blockstore, 'get'>\n\nconst toPathComponents = (path: string = ''): string[] => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) ?? [])\n    .filter(Boolean)\n}\n\nconst cidAndRest = (path: string | Uint8Array | CID): { cid: CID, toResolve: string[] } => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    }\n  }\n\n  const cid = CID.asCID(path)\n  if (cid != null) {\n    return {\n      cid,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw new BadPathError(`Unknown path type ${path}`)\n}\n\n/**\n * Returns an async iterator that yields entries for all segments in a path\n *\n * @example\n *\n * ```javascript\n * import { walkPath } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const entry of walkPath('Qmfoo/foo/bar/baz.txt', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains 4x `entry` objects\n * ```\n */\nexport async function * walkPath (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options)\n\n    if (result.entry == null && result.next == null) {\n      throw new NotFoundError(`Could not resolve ${path}`)\n    }\n\n    if (result.entry != null) {\n      yield result.entry\n    }\n\n    if (result.next == null) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\n/**\n * Uses the given blockstore instance to fetch an IPFS node by a CID or path.\n *\n * Returns a {@link Promise} which resolves to a {@link UnixFSEntry}.\n *\n * @example\n *\n * ```typescript\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { CID } from 'multiformats/cid'\n *\n * const cid = CID.parse('QmFoo')\n *\n * const entry = await exporter(cid, blockstore, {\n *   signal: AbortSignal.timeout(50000)\n * })\n *\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Uint8Array\n *   }\n * }\n * ```\n */\nexport async function exporter (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): Promise<UnixFSEntry> {\n  const result = await last(walkPath(path, blockstore, options))\n\n  if (result == null) {\n    throw new NotFoundError(`Could not resolve ${path}`)\n  }\n\n  return result\n}\n\n/**\n * Returns an async iterator that yields all entries beneath a given CID or IPFS\n * path, as well as the containing directory.\n *\n * @example\n *\n * ```typescript\n * import { recursive } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const child of recursive('Qmfoo/foo/bar', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains all children of the `Qmfoo/foo/bar` directory and it's children\n * ```\n */\nexport async function * recursive (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  const node = await exporter(path, blockstore, options)\n\n  if (node == null) {\n    return\n  }\n\n  yield node\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child\n    }\n  }\n\n  async function * recurse (node: UnixFSDirectory, options: ExporterOptions): AsyncGenerator<UnixFSEntry, void, any> {\n    for await (const file of node.content(options)) {\n      yield file\n\n      if (file instanceof Uint8Array) {\n        continue\n      }\n\n      if (file.type === 'directory') {\n        yield * recurse(file, options)\n      }\n    }\n  }\n}\n","/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\t\treturn current.value;\n\t}\n\n\tpeek() {\n\t\tif (!this.#head) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.#head.value;\n\n\t\t// TODO: Node.js 18.\n\t\t// return this.#head?.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n","import Queue from 'yocto-queue';\n\nexport default function pLimit(concurrency) {\n\tvalidateConcurrency(concurrency);\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst resumeNext = () => {\n\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t\t// Since `pendingCount` has been decreased by one, increase `activeCount` by one.\n\t\t\tactiveCount++;\n\t\t}\n\t};\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tresumeNext();\n\t};\n\n\tconst run = async (function_, resolve, arguments_) => {\n\t\tconst result = (async () => function_(...arguments_))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (function_, resolve, arguments_) => {\n\t\t// Queue `internalResolve` instead of the `run` function\n\t\t// to preserve asynchronous context.\n\t\tnew Promise(internalResolve => {\n\t\t\tqueue.enqueue(internalResolve);\n\t\t}).then(\n\t\t\trun.bind(undefined, function_, resolve, arguments_),\n\t\t);\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// after the `internalResolve` function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency) {\n\t\t\t\tresumeNext();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (function_, ...arguments_) => new Promise(resolve => {\n\t\tenqueue(function_, resolve, arguments_);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue() {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t\tconcurrency: {\n\t\t\tget: () => concurrency,\n\n\t\t\tset(newConcurrency) {\n\t\t\t\tvalidateConcurrency(newConcurrency);\n\t\t\t\tconcurrency = newConcurrency;\n\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t// eslint-disable-next-line no-unmodified-loop-condition\n\t\t\t\t\twhile (activeCount < concurrency && queue.size > 0) {\n\t\t\t\t\t\tresumeNext();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n\nfunction validateConcurrency(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n}\n","import pLimit from \"p-limit\";\nimport { format, parse, ToString } from \"@ipld/dag-json\";\nimport { exception2Result, Logger, ResolveOnce, Result, URI } from \"@adviser/cement\";\nimport type {\n  AnyBlock,\n  AnyLink,\n  CommitOpts,\n  DataSaveOpts,\n  DataStore,\n  DbMeta,\n  WALStore as WALStore,\n  WALState,\n  KeyedCrypto,\n  Loadable,\n} from \"./types.js\";\nimport { Falsy, StoreType, SuperThis, throwFalsy } from \"../types.js\";\nimport { Gateway } from \"./gateway.js\";\nimport { ensureLogger, isNotFoundError } from \"../utils.js\";\nimport { carLogIncludesGroup } from \"./loader.js\";\nimport { CommitQueue } from \"./commit-queue.js\";\nimport { keyedCryptoFactory } from \"../runtime/keyed-crypto.js\";\nimport { KeyBag } from \"../runtime/key-bag.js\";\nimport { FragmentGateway } from \"./fragment-gateway.js\";\nimport { json } from \"node:stream/consumers\";\n\nfunction guardVersion(url: URI): Result<URI> {\n  if (!url.hasParam(\"version\")) {\n    return Result.Err(`missing version: ${url.toString()}`);\n  }\n  return Result.Ok(url);\n}\n\nexport interface StoreOpts {\n  readonly gateway: Gateway;\n  readonly keybag: () => Promise<KeyBag>;\n  readonly loader?: Loadable;\n}\n\nexport abstract class BaseStoreImpl {\n  // should be injectable\n\n  abstract readonly storeType: StoreType;\n  readonly name: string;\n\n  private _url: URI;\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n  readonly gateway: FragmentGateway;\n  readonly keybag: () => Promise<KeyBag>;\n  readonly loader?: Loadable;\n  constructor(name: string, url: URI, opts: StoreOpts, sthis: SuperThis, logger: Logger) {\n    this.name = name;\n    this._url = url;\n    this.keybag = opts.keybag;\n    this.sthis = sthis;\n    this.logger = logger\n      .With()\n      .Ref(\"url\", () => this._url.toString())\n      .Str(\"name\", name)\n      .Logger();\n    this.gateway = new FragmentGateway(this.sthis, opts.gateway);\n    this.loader = opts.loader;\n  }\n\n  url(): URI {\n    return this._url;\n  }\n\n  readonly _onStarted: (() => void)[] = [];\n  onStarted(fn: () => void) {\n    this._onStarted.push(fn);\n  }\n  readonly _onClosed: (() => void)[] = [];\n  onClosed(fn: () => void) {\n    this._onClosed.push(fn);\n  }\n  abstract close(): Promise<Result<void>>;\n\n  readonly ready?: () => Promise<void>;\n\n  async keyedCrypto(): Promise<KeyedCrypto> {\n    return keyedCryptoFactory(this._url, await this.keybag(), this.sthis);\n  }\n\n  async start(): Promise<Result<URI>> {\n    this.logger.Debug().Str(\"storeType\", this.storeType).Msg(\"starting-gateway-pre\");\n    this._url = this._url.build().setParam(\"store\", this.storeType).URI();\n    const res = await this.gateway.start(this._url);\n    if (res.isErr()) {\n      this.logger.Error().Result(\"gw-start\", res).Msg(\"started-gateway\");\n      return res as Result<URI>;\n    }\n    this._url = res.Ok();\n    // add storekey to url\n    const kb = await this.keybag();\n    const skRes = await kb.ensureKeyFromUrl(this._url, () => {\n      const idx = this._url.getParam(\"index\");\n      const storeKeyName = [this.name];\n      if (idx) {\n        storeKeyName.push(idx);\n      }\n      storeKeyName.push(this.storeType);\n      return storeKeyName.join(\":\");\n    });\n    if (skRes.isErr()) {\n      return skRes as Result<URI>;\n    }\n    this._url = skRes.Ok();\n    const version = guardVersion(this._url);\n    if (version.isErr()) {\n      this.logger.Error().Result(\"version\", version).Msg(\"guardVersion\");\n      await this.close();\n      return version;\n    }\n    if (this.ready) {\n      const fn = this.ready.bind(this);\n      const ready = await exception2Result(fn);\n      if (ready.isErr()) {\n        await this.close();\n        return ready as Result<URI>;\n      }\n    }\n    this._onStarted.forEach((fn) => fn());\n    this.logger.Debug().Msg(\"started\");\n    return version;\n  }\n}\n\nexport class DataStoreImpl extends BaseStoreImpl implements DataStore {\n  readonly storeType = \"data\";\n  // readonly tag: string = \"car-base\";\n\n  constructor(sthis: SuperThis, name: string, url: URI, opts: StoreOpts) {\n    super(\n      name,\n      url,\n      {\n        ...opts,\n      },\n      sthis,\n      ensureLogger(sthis, \"DataStoreImpl\"),\n    );\n  }\n\n  async load(cid: AnyLink): Promise<AnyBlock> {\n    this.logger.Debug().Any(\"cid\", cid).Msg(\"loading\");\n    const url = await this.gateway.buildUrl(this.url(), cid.toString());\n    if (url.isErr()) {\n      throw this.logger.Error().Err(url.Err()).Str(\"cid\", cid.toString()).Msg(\"got error from gateway.buildUrl\").AsError();\n    }\n    const res = await this.gateway.get(url.Ok());\n    if (res.isErr()) {\n      throw res.Err();\n    }\n    return { cid, bytes: res.Ok() };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async save(car: AnyBlock, opts?: DataSaveOpts): Promise</*AnyLink | */ void> {\n    this.logger.Debug().Any(\"cid\", car.cid.toString()).Msg(\"saving\");\n    const url = await this.gateway.buildUrl(this.url(), car.cid.toString());\n    if (url.isErr()) {\n      throw this.logger.Error().Err(url.Err()).Ref(\"cid\", car.cid).Msg(\"got error from gateway.buildUrl\").AsError();\n    }\n    const res = await this.gateway.put(url.Ok(), car.bytes);\n    if (res.isErr()) {\n      throw this.logger.Error().Err(res.Err()).Msg(\"got error from gateway.put\").AsError();\n    }\n    return res.Ok();\n  }\n  async remove(cid: AnyLink): Promise<Result<void>> {\n    const url = await this.gateway.buildUrl(this.url(), cid.toString());\n    if (url.isErr()) {\n      return url;\n    }\n    return this.gateway.delete(url.Ok());\n  }\n  async close(): Promise<Result<void>> {\n    await this.gateway.close(this.url());\n    this._onClosed.forEach((fn) => fn());\n    return Result.Ok(undefined);\n  }\n  destroy(): Promise<Result<void>> {\n    return this.gateway.destroy(this.url());\n  }\n}\n\nexport class WALStoreImpl extends BaseStoreImpl implements WALStore {\n  readonly storeType = \"wal\";\n  // readonly tag: string = \"rwal-base\";\n\n  readonly loader: Loadable;\n\n  readonly _ready = new ResolveOnce<void>();\n\n  walState: WALState = { operations: [], noLoaderOps: [], fileOperations: [] };\n  readonly processing: Promise<void> | undefined = undefined;\n  readonly processQueue: CommitQueue<void> = new CommitQueue<void>();\n\n  constructor(loader: Loadable, url: URI, opts: StoreOpts) {\n    // const my = new URL(url.toString());\n    // my.searchParams.set(\"storekey\", 'insecure');\n    super(\n      loader.name,\n      url,\n      {\n        ...opts,\n      },\n      loader.sthis,\n      ensureLogger(loader.sthis, \"WALStoreImpl\"),\n    );\n    this.loader = loader;\n  }\n\n  ready = async () => {\n    return this._ready.once(async () => {\n      const walState = await this.load().catch((e) => {\n        this.logger.Error().Any(\"error\", e).Msg(\"error loading wal\");\n        return undefined;\n      });\n      if (!walState) {\n        this.walState.operations = [];\n        this.walState.fileOperations = [];\n      } else {\n        this.walState.operations = walState.operations || [];\n        this.walState.fileOperations = walState.fileOperations || [];\n      }\n    });\n  };\n\n  async enqueue(dbMeta: DbMeta, opts: CommitOpts) {\n    await this.ready();\n    if (opts.noLoader) {\n      console.log(\"enqueue noLoader\", dbMeta.cars.map((c) => c.toString()));\n      this.walState.noLoaderOps.push(dbMeta);\n    } else {\n      this.walState.operations.push(dbMeta);\n    }\n    await this.save(this.walState);\n    if (!opts.noLoader) {\n      void this.process();\n    }\n  }\n\n  async enqueueFile(fileCid: AnyLink, publicFile = false) {\n    await this.ready();\n    this.walState.fileOperations.push({ cid: fileCid, public: publicFile });\n    // await this.save(this.walState)\n  }\n\n  async process() {\n    await this.ready();\n    if (!this.loader.remoteCarStore) return;\n    await this.processQueue.enqueue(async () => {\n      try {\n        await this._doProcess();\n      } catch (e) {\n        this.logger.Error().Any(\"error\", e).Msg(\"error processing wal\");\n      }\n      if (this.walState.operations.length || this.walState.fileOperations.length || this.walState.noLoaderOps.length) {\n        setTimeout(() => void this.process(), 0);\n      }\n    });\n  }\n\n  async _doProcess() {\n    if (!this.loader.remoteCarStore) return;\n    const rmlp = (async () => {\n      const operations = [...this.walState.operations];\n      const fileOperations = [...this.walState.fileOperations];\n      const uploads: Promise<void>[] = [];\n      const noLoaderOps = [...this.walState.noLoaderOps];\n      const limit = pLimit(5);\n\n      if (operations.length + fileOperations.length + noLoaderOps.length === 0) return;\n\n      for (const dbMeta of noLoaderOps) {\n        const uploadP = limit(async () => {\n          for (const cid of dbMeta.cars) {\n            const car = await (await this.loader.carStore()).load(cid);\n            if (!car) {\n              if (carLogIncludesGroup(this.loader.carLog, dbMeta.cars))\n                throw this.logger.Error().Ref(\"cid\", cid).Msg(\"missing local car\").AsError();\n            } else {\n              await throwFalsy(this.loader.remoteCarStore).save(car);\n            }\n            this.walState.noLoaderOps = this.walState.noLoaderOps.filter((op) => op !== dbMeta);\n          }\n        });\n        uploads.push(uploadP);\n      }\n\n      for (const dbMeta of operations) {\n        const uploadP = limit(async () => {\n          for (const cid of dbMeta.cars) {\n            const car = await (await this.loader.carStore()).load(cid).catch(() => null);\n            if (!car) {\n              if (carLogIncludesGroup(this.loader.carLog, dbMeta.cars))\n                throw this.logger.Error().Ref(\"cid\", cid).Msg(`missing local car`).AsError();\n            } else {\n              await throwFalsy(this.loader.remoteCarStore).save(car);\n            }\n          }\n          this.walState.operations = this.walState.operations.filter((op) => op !== dbMeta);\n        });\n        uploads.push(uploadP);\n      }\n\n      if (fileOperations.length) {\n        const dbLoader = this.loader;\n        for (const { cid: fileCid, public: publicFile } of fileOperations) {\n          const uploadP = limit(async () => {\n            const fileBlock = await (await dbLoader.fileStore()).load(fileCid); // .catch(() => false)\n            await dbLoader.remoteFileStore?.save(fileBlock, { public: publicFile });\n            this.walState.fileOperations = this.walState.fileOperations.filter((op) => op.cid !== fileCid);\n          });\n          uploads.push(uploadP);\n        }\n      }\n\n      try {\n        const res = await Promise.allSettled(uploads);\n        const errors = res.filter((r) => r.status === \"rejected\") as PromiseRejectedResult[];\n        if (errors.length) {\n          throw this.logger.Error().Any(\"errors\", errors).Msg(\"error uploading\").AsError();\n        }\n        if (operations.length) {\n          const lastOp = operations[operations.length - 1];\n          // console.log(\"saving remote meta\", JSON.stringify(lastOp));\n          await this.loader.remoteMetaStore?.save(lastOp).catch((e: Error) => {\n            this.walState.operations.push(lastOp);\n            throw this.logger.Error().Any(\"error\", e).Msg(\"error saving remote meta\").AsError();\n          });\n        }\n      } finally {\n        await this.save(this.walState);\n      }\n    })();\n    // this.loader.remoteMetaLoading = rmlp;\n    await rmlp;\n  }\n\n  async load(): Promise<WALState | Falsy> {\n    this.logger.Debug().Msg(\"loading\");\n    const filepath = await this.gateway.buildUrl(this.url(), \"main\");\n    if (filepath.isErr()) {\n      throw this.logger.Error().Err(filepath.Err()).Url(this.url()).Msg(\"error building url\").AsError();\n    }\n    const bytes = await this.gateway.get(filepath.Ok());\n    if (bytes.isErr()) {\n      if (isNotFoundError(bytes)) {\n        return undefined;\n      }\n      throw this.logger.Error().Err(bytes.Err()).Msg(\"error get\").AsError();\n    }\n    try {\n      return bytes && parse<WALState>(this.sthis.txt.decode(bytes.Ok()));\n    } catch (e) {\n      throw this.logger.Error().Err(e).Msg(\"error parse\").AsError();\n    }\n  }\n\n  async save(state: WALState) {\n    const filepath = await this.gateway.buildUrl(this.url(), \"main\");\n    if (filepath.isErr()) {\n      throw this.logger.Error().Err(filepath.Err()).Url(this.url()).Msg(\"error building url\").AsError();\n    }\n    let encoded: ToString<WALState>;\n    try {\n      encoded = format(state);\n    } catch (e) {\n      throw this.logger.Error().Err(e).Any(\"state\", state).Msg(\"error format\").AsError();\n    }\n    const res = await this.gateway.put(filepath.Ok(), this.sthis.txt.encode(encoded));\n    if (res.isErr()) {\n      throw this.logger.Error().Err(res.Err()).Str(\"filePath\", filepath.Ok().toString()).Msg(\"error saving\").AsError();\n    }\n  }\n\n  async close() {\n    await this.gateway.close(this.url());\n    this._onClosed.forEach((fn) => fn());\n    return Result.Ok(undefined);\n  }\n\n  destroy() {\n    return this.gateway.destroy(this.url());\n  }\n}\n","import type { EventLink } from \"@web3-storage/pail/clock/api\";\nimport type { Operation } from \"@web3-storage/pail/crdt/api\";\n\nimport type { DbMeta, StoreOpts, AnyLink } from \"./blockstore/index.js\";\nimport { EnvFactoryOpts, Env, Logger, CryptoRuntime } from \"@adviser/cement\";\n\nimport type { MakeDirectoryOptions, PathLike, Stats } from \"fs\";\n\nexport type Falsy = false | null | undefined;\n\nexport function isFalsy(value: unknown): value is Falsy {\n  return value === false && value === null && value === undefined;\n}\n\nexport function throwFalsy<T>(value: T | Falsy): T {\n  if (isFalsy(value)) {\n    throw new Error(\"value is Falsy\");\n  }\n  return value;\n}\n\nexport function falsyToUndef<T>(value: T | Falsy): T | undefined {\n  if (isFalsy(value)) {\n    return undefined;\n  }\n  return value;\n}\n\nexport type StoreType = \"data\" | \"wal\" | \"meta\";\n\nexport interface SysFileSystem {\n  start(): Promise<SysFileSystem>;\n  mkdir(path: PathLike, options?: { recursive: boolean }): Promise<string | undefined>;\n  readdir(path: PathLike, options?: unknown): Promise<string[]>;\n  rm(path: PathLike, options?: MakeDirectoryOptions & { recursive: boolean }): Promise<void>;\n  copyFile(source: PathLike, destination: PathLike): Promise<void>;\n  readfile(path: PathLike, options?: { encoding: BufferEncoding; flag?: string }): Promise<Uint8Array>;\n  stat(path: PathLike): Promise<Stats>;\n  unlink(path: PathLike): Promise<void>;\n  writefile(path: PathLike, data: Uint8Array | string): Promise<void>;\n}\n\nexport interface PathOps {\n  join(...args: string[]): string;\n  dirname(path: string): string;\n  // homedir(): string;\n}\n\n// export interface Sys {\n//   // fs: SysFileSystem;\n//   fsHelper: PathOps;\n// }\nexport interface TextEndeCoder {\n  encode(input: string): Uint8Array;\n  decode(input: Uint8Array): string;\n}\nexport interface SuperThisOpts {\n  // readonly crypto?: CryptoRuntime;\n  readonly logger: Logger;\n  readonly pathOps: PathOps;\n  readonly crypto: CryptoRuntime;\n  readonly env: EnvFactoryOpts;\n  readonly txt: TextEndeCoder;\n  readonly ctx: Record<string, unknown>;\n}\n\nexport interface SuperThis {\n  readonly logger: Logger;\n  readonly env: Env;\n  readonly pathOps: PathOps;\n  readonly ctx: Record<string, unknown>;\n  readonly txt: TextEndeCoder;\n  nextId(bytes?: number): { str: string; bin: Uint8Array };\n  start(): Promise<void>;\n  clone(override: Partial<SuperThisOpts>): SuperThis;\n}\n\nexport interface ConfigOpts extends Partial<SuperThisOpts> {\n  readonly public?: boolean;\n  readonly meta?: DbMeta;\n  readonly persistIndexes?: boolean;\n  readonly autoCompact?: number;\n  readonly store?: StoreOpts;\n  readonly threshold?: number;\n}\n\nexport type ClockLink = EventLink<Operation>;\n\nexport type ClockHead = ClockLink[];\n\nexport type DocFragment = Uint8Array | string | number | boolean | null | AnyLink | DocFragment[] | object;\n// | { [key: string]: DocFragment };\n\nexport type DocLiteral = string | number | boolean | Uint8Array | unknown;\n\nexport type DocObject = NonNullable<unknown>;\nexport type DocTypes = DocObject;\n\nexport type DocRecord<T extends DocObject> = T;\n\nexport type UnknownDoc = DocRecord<never>;\n\nexport type DocFiles = Record<string, DocFileMeta | File>;\n\nexport interface DocBase {\n  readonly _id: string;\n  readonly _files?: DocFiles;\n  readonly _publicFiles?: DocFiles;\n  readonly _deleted?: boolean;\n}\n\nexport type DocWithId<T extends DocTypes> = DocBase & T;\n\nexport type DocSet<T extends DocTypes> = Partial<DocBase> & T;\n\nexport interface DocFileMeta {\n  readonly type: string;\n  readonly size: number;\n  readonly cid: AnyLink;\n  readonly car?: AnyLink;\n  url?: string;\n  file?: () => Promise<File>;\n}\n\nexport interface DocUpdate<T extends DocTypes> {\n  readonly id: string;\n  readonly value?: DocSet<T>;\n  readonly del?: boolean;\n  readonly clock?: ClockLink; // would be useful to give ClockLinks a type\n}\n\n// todo merge into above\nexport interface DocValue<T extends DocTypes> {\n  readonly doc: DocWithId<T>;\n  readonly del: boolean;\n  readonly cid: AnyLink;\n}\n\nexport type KeyLiteral = string | number | boolean;\nexport type IndexKeyType = KeyLiteral | KeyLiteral[];\nexport type IndexKey<K extends IndexKeyType> = [K, string];\n\nexport interface IndexUpdate<K extends IndexKeyType> {\n  readonly key: IndexKey<K>;\n  readonly value?: DocFragment;\n  readonly del?: boolean;\n}\n\nexport interface IndexUpdateString {\n  readonly key: string;\n  readonly value?: DocFragment;\n  readonly del?: boolean;\n}\n\n// export interface IndexRowObject<K extends IndexKeyType, T extends DocObject> {\n//   readonly id: string;\n//   readonly key: K;\n//   readonly value: T\n//   // readonly row: T // DocFragment;\n//   // readonly doc?: DocWithId<T>;\n//   // value?: T;\n//   // readonly del?: boolean;\n// }\n\n// export interface IndexRowLiteral<K extends IndexKeyType, T extends DocLiteral> {\n//   readonly id: string;\n//   readonly key: IndexKey<K>;\n//   readonly value: T\n// }\n\n// export type IndexRow<K extends IndexKeyType, T extends DocTypes> =\n//   T extends DocLiteral ? IndexRowLiteral<K, T> : IndexRowObject<K, T>\n\nexport interface IndexRow<K extends IndexKeyType, T extends DocObject, R extends DocFragment> {\n  readonly id: string;\n  readonly key: K; // IndexKey<K>;\n  readonly value: R;\n  readonly doc?: DocWithId<T>;\n}\n\nexport interface IndexRows<K extends IndexKeyType, T extends DocObject, R extends DocFragment = T> {\n  readonly rows: IndexRow<K, T, R>[];\n}\nexport interface CRDTMeta {\n  readonly head: ClockHead;\n}\n\nexport interface IndexTransactionMeta {\n  readonly indexes: Record<string, IdxMeta>;\n}\n\nexport interface FileTransactionMeta {\n  readonly files?: AnyLink[];\n}\n\nexport type MetaType = CRDTMeta | IndexTransactionMeta | FileTransactionMeta;\n\nexport interface IdxMeta {\n  readonly byId: AnyLink;\n  readonly byKey: AnyLink;\n  readonly map: string;\n  readonly name: string;\n  readonly head: ClockHead;\n}\n\nexport interface IdxMetaMap {\n  readonly indexes?: Map<string, IdxMeta>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface QueryOpts<K extends IndexKeyType> {\n  readonly descending?: boolean;\n  readonly limit?: number;\n  includeDocs?: boolean;\n  readonly range?: [IndexKeyType, IndexKeyType];\n  readonly key?: DocFragment;\n  readonly keys?: DocFragment[];\n  prefix?: IndexKeyType;\n}\n\nexport interface AllDocsQueryOpts extends QueryOpts<string> {\n  readonly key?: string;\n  readonly keys?: string[];\n  prefix?: string;\n}\n\nexport interface AllDocsResponse<T extends DocTypes> {\n  readonly rows: {\n    readonly key: string;\n    readonly value: DocWithId<T>;\n  }[];\n  readonly clock: ClockHead;\n  readonly name?: string;\n}\n\ntype EmitFn = (k: IndexKeyType, v?: DocFragment) => void;\nexport type MapFn<T extends DocTypes> = (doc: DocWithId<T>, emit: EmitFn) => DocFragment | unknown;\n\nexport interface ChangesOptions {\n  readonly dirty?: boolean;\n  readonly limit?: number;\n}\n\nexport interface ChangesResponseRow<T extends DocTypes> {\n  readonly key: string;\n  readonly value: DocWithId<T>;\n  readonly clock?: ClockLink;\n}\n\nexport interface ChangesResponse<T extends DocTypes> {\n  readonly clock: ClockHead;\n  readonly rows: ChangesResponseRow<T>[];\n  readonly name?: string;\n}\n\nexport interface DocResponse {\n  readonly id: string;\n  readonly clock: ClockHead;\n  readonly name?: string;\n}\n\nexport type UpdateListenerFn<T extends DocTypes> = (docs: DocWithId<T>[]) => Promise<void> | void;\nexport type NoUpdateListenerFn = () => Promise<void> | void;\nexport type ListenerFn<T extends DocTypes> = UpdateListenerFn<T> | NoUpdateListenerFn;\n\nexport interface CRDTEntry {\n  data: string;\n  parents: string[];\n  cid: string;\n}\n","import varint from 'varint'\n\nexport const CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n}\n\nexport const V2_HEADER_LENGTH = /* characteristics */ 16 /* v1 offset */ + 8 /* v1 size */ + 8 /* index offset */ + 8\n\n/**\n * Decodes varint and seeks the buffer\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @param {import('./coding').Seekable} seeker\n * @returns {number}\n */\nexport function decodeVarint (bytes, seeker) {\n  if (!bytes.length) {\n    throw new Error('Unexpected end of data')\n  }\n  const i = varint.decode(bytes)\n  seeker.seek(/** @type {number} */(varint.decode.bytes))\n  return i\n}\n\n/**\n * Decode v2 header\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.exactly(V2_HEADER_LENGTH, true) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @returns {import('./coding').CarV2FixedHeader}\n */\nexport function decodeV2Header (bytes) {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  let offset = 0\n  const header = {\n    version: 2,\n    /** @type {[bigint, bigint]} */\n    characteristics: [\n      dv.getBigUint64(offset, true),\n      dv.getBigUint64(offset += 8, true)\n    ],\n    dataOffset: Number(dv.getBigUint64(offset += 8, true)),\n    dataSize: Number(dv.getBigUint64(offset += 8, true)),\n    indexOffset: Number(dv.getBigUint64(offset += 8, true))\n  }\n  return header\n}\n\n/**\n * Checks the length of the multihash to be read afterwards\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n */\nexport function getMultihashLength (bytes) {\n  // | code | length | .... |\n  // where both code and length are varints, so we have to decode\n  // them first before we can know total length\n\n  varint.decode(bytes) // code\n  const codeLength = /** @type {number} */(varint.decode.bytes)\n  const length = varint.decode(bytes.subarray(varint.decode.bytes))\n  const lengthLength = /** @type {number} */(varint.decode.bytes)\n  const mhLength = codeLength + lengthLength + length\n\n  return mhLength\n}\n","/** Auto-generated with @ipld/schema@v4.2.0 at Thu Sep 14 2023 from IPLD Schema:\n *\n * # CarV1HeaderOrV2Pragma is a more relaxed form, and can parse {version:x} where\n * # roots are optional. This is typically useful for the {verison:2} CARv2\n * # pragma.\n *\n * type CarV1HeaderOrV2Pragma struct {\n * \troots optional [&Any]\n * \t# roots is _not_ optional for CarV1 but we defer that check within code to\n * \t# gracefully handle the V2 case where it's just {version:X}\n * \tversion Int\n * }\n *\n * # CarV1Header is the strict form of the header, and requires roots to be\n * # present. This is compatible with the CARv1 specification.\n *\n * # type CarV1Header struct {\n * # \troots [&Any]\n * # \tversion Int\n * # }\n *\n */\n\nconst Kinds = {\n  Null: /** @returns {undefined|null} */ (/** @type {any} */ obj) => obj === null ? obj : undefined,\n  Int: /** @returns {undefined|number} */ (/** @type {any} */ obj) => Number.isInteger(obj) ? obj : undefined,\n  Float: /** @returns {undefined|number} */ (/** @type {any} */ obj) => typeof obj === 'number' && Number.isFinite(obj) ? obj : undefined,\n  String: /** @returns {undefined|string} */ (/** @type {any} */ obj) => typeof obj === 'string' ? obj : undefined,\n  Bool: /** @returns {undefined|boolean} */ (/** @type {any} */ obj) => typeof obj === 'boolean' ? obj : undefined,\n  Bytes: /** @returns {undefined|Uint8Array} */ (/** @type {any} */ obj) => obj instanceof Uint8Array ? obj : undefined,\n  Link: /** @returns {undefined|object} */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID === obj ? obj : undefined,\n  List: /** @returns {undefined|Array<any>} */ (/** @type {any} */ obj) => Array.isArray(obj) ? obj : undefined,\n  Map: /** @returns {undefined|object} */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : undefined\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Types = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Types['CarV1HeaderOrV2Pragma > roots (anon)'](obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Types.Int(obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Reprs = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Reprs['CarV1HeaderOrV2Pragma > roots (anon)'](value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Reprs.Int(value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n\nexport const CarV1HeaderOrV2Pragma = {\n  toTyped: Types.CarV1HeaderOrV2Pragma,\n  toRepresentation: Reprs.CarV1HeaderOrV2Pragma\n}\n","import { makeCborEncoders, objectToTokens } from './encode.js'\nimport { quickEncodeToken } from './jump.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\nconst cborEncoders = makeCborEncoders()\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  quickEncodeToken\n}\n\n/**\n * Calculate the byte length of the given data when encoded as CBOR with the\n * options provided.\n * This calculation will be accurate if the same options are used as when\n * performing a normal encode. Some encode options can change the encoding\n * output length.\n *\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {number}\n */\nexport function encodedLength (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  options.mapSorter = undefined // won't change the length\n  const tokens = objectToTokens(data, options)\n  return tokensToLength(tokens, cborEncoders, options)\n}\n\n/**\n * Calculate the byte length of the data as represented by the given tokens when\n * encoded as CBOR with the options provided.\n * This function is for advanced users and would not normally be called\n * directly. See `encodedLength()` for appropriate use.\n *\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} [encoders]\n * @param {EncodeOptions} [options]\n */\nexport function tokensToLength (tokens, encoders = cborEncoders, options = defaultEncodeOptions) {\n  if (Array.isArray(tokens)) {\n    let len = 0\n    for (const token of tokens) {\n      len += tokensToLength(token, encoders, options)\n    }\n    return len\n  } else {\n    const encoder = encoders[tokens.type.major]\n    /* c8 ignore next 3 */\n    if (encoder.encodedSize === undefined || typeof encoder.encodedSize !== 'function') {\n      throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`)\n    }\n    return encoder.encodedSize(tokens, options)\n  }\n}\n","import * as CBOR from '@ipld/dag-cbor'\nimport { Token, Type } from 'cborg'\nimport { tokensToLength } from 'cborg/length'\nimport varint from 'varint'\n\n/**\n * @typedef {import('./api').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').CarBufferWriter} Writer\n * @typedef {import('./api').CarBufferWriterOptions} Options\n * @typedef {import('./coding').CarEncoder} CarEncoder\n */\n\n/**\n * A simple CAR writer that writes to a pre-allocated buffer.\n *\n * @class\n * @name CarBufferWriter\n * @implements {Writer}\n */\nclass CarBufferWriter {\n  /**\n   * @param {Uint8Array} bytes\n   * @param {number} headerSize\n   */\n  constructor (bytes, headerSize) {\n    /** @readonly */\n    this.bytes = bytes\n    this.byteOffset = headerSize\n\n    /**\n     * @readonly\n     * @type {CID[]}\n     */\n    this.roots = []\n    this.headerSize = headerSize\n  }\n\n  /**\n   * Add a root to this writer, to be used to create a header when the CAR is\n   * finalized with {@link CarBufferWriter.close `close()`}\n   *\n   * @param {CID} root\n   * @param {{resize?:boolean}} [options]\n   * @returns {CarBufferWriter}\n   */\n  addRoot (root, options) {\n    addRoot(this, root, options)\n    return this\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   * Throws if there is not enough capacity.\n   *\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {CarBufferWriter}\n   */\n  write (block) {\n    addBlock(this, block)\n    return this\n  }\n\n  /**\n   * Finalize the CAR and return it as a `Uint8Array`.\n   *\n   * @param {object} [options]\n   * @param {boolean} [options.resize]\n   * @returns {Uint8Array}\n   */\n  close (options) {\n    return close(this, options)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {CID} root\n * @param {{resize?:boolean}} [options]\n */\nexport const addRoot = (writer, root, options = {}) => {\n  const { resize = false } = options\n  const { bytes, headerSize, byteOffset, roots } = writer\n  writer.roots.push(root)\n  const size = headerLength(writer)\n  // If there is not enough space for the new root\n  if (size > headerSize) {\n    // Check if we root would fit if we were to resize the head.\n    if (size - headerSize + byteOffset < bytes.byteLength) {\n      // If resize is enabled resize head\n      if (resize) {\n        resizeHeader(writer, size)\n      // otherwise remove head and throw an error suggesting to resize\n      } else {\n        roots.pop()\n        throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.\n  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`)\n      }\n    // If head would not fit even with resize pop new root and throw error\n    } else {\n      roots.pop()\n      throw new RangeError(`Buffer has no capacity for a new root ${root}`)\n    }\n  }\n}\n\n/**\n * Calculates number of bytes required for storing given block in CAR. Useful in\n * estimating size of an `ArrayBuffer` for the `CarBufferWriter`.\n *\n * @name CarBufferWriter.blockLength(Block)\n * @param {Block} block\n * @returns {number}\n */\nexport const blockLength = ({ cid, bytes }) => {\n  const size = cid.bytes.byteLength + bytes.byteLength\n  return varint.encodingLength(size) + size\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {Block} block\n */\nexport const addBlock = (writer, { cid, bytes }) => {\n  const byteLength = cid.bytes.byteLength + bytes.byteLength\n  const size = varint.encode(byteLength)\n  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {\n    throw new RangeError('Buffer has no capacity for this block')\n  } else {\n    writeBytes(writer, size)\n    writeBytes(writer, cid.bytes)\n    writeBytes(writer, bytes)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {object} [options]\n * @param {boolean} [options.resize]\n */\nexport const close = (writer, options = {}) => {\n  const { resize = false } = options\n  const { roots, bytes, byteOffset, headerSize } = writer\n\n  const headerBytes = CBOR.encode({ version: 1, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n\n  const size = varintBytes.length + headerBytes.byteLength\n  const offset = headerSize - size\n\n  // If header size estimate was accurate we just write header and return\n  // view into buffer.\n  if (offset === 0) {\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, byteOffset)\n    // If header was overestimated and `{resize: true}` is passed resize header\n  } else if (resize) {\n    resizeHeader(writer, size)\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, writer.byteOffset)\n  } else {\n    throw new RangeError(`Header size was overestimated.\nYou can use close({ resize: true }) to resize header`)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number} byteLength\n */\nexport const resizeHeader = (writer, byteLength) => {\n  const { bytes, headerSize } = writer\n  // Move data section to a new offset\n  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength)\n  // Update header size & byteOffset\n  writer.byteOffset += byteLength - headerSize\n  writer.headerSize = byteLength\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number[]|Uint8Array} bytes\n */\n\nconst writeBytes = (writer, bytes) => {\n  writer.bytes.set(bytes, writer.byteOffset)\n  writer.byteOffset += bytes.length\n}\n/**\n * @param {{bytes:Uint8Array}} writer\n * @param {number[]} varint\n * @param {Uint8Array} header\n */\nconst writeHeader = ({ bytes }, varint, header) => {\n  bytes.set(varint)\n  bytes.set(header, varint.length)\n}\n\nconst headerPreludeTokens = [\n  new Token(Type.map, 2),\n  new Token(Type.string, 'version'),\n  new Token(Type.uint, 1),\n  new Token(Type.string, 'roots')\n]\n\nconst CID_TAG = new Token(Type.tag, 42)\n\n/**\n * Calculates header size given the array of byteLength for roots.\n *\n * @name CarBufferWriter.calculateHeaderLength(rootLengths)\n * @param {number[]} rootLengths\n * @returns {number}\n */\nexport const calculateHeaderLength = (rootLengths) => {\n  const tokens = [...headerPreludeTokens]\n  tokens.push(new Token(Type.array, rootLengths.length))\n  for (const rootLength of rootLengths) {\n    tokens.push(CID_TAG)\n    tokens.push(new Token(Type.bytes, { length: rootLength + 1 }))\n  }\n  const length = tokensToLength(tokens) // no options needed here because we have simple tokens\n  return varint.encodingLength(length) + length\n}\n\n/**\n * Calculates header size given the array of roots.\n *\n * @name CarBufferWriter.headerLength({ roots })\n * @param {object} options\n * @param {CID[]} options.roots\n * @returns {number}\n */\nexport const headerLength = ({ roots }) =>\n  calculateHeaderLength(roots.map(cid => cid.bytes.byteLength))\n\n/**\n * Estimates header size given a count of the roots and the expected byte length\n * of the root CIDs. The default length works for a standard CIDv1 with a\n * single-byte multihash code, such as SHA2-256 (i.e. the most common CIDv1).\n *\n * @name CarBufferWriter.estimateHeaderLength(rootCount[, rootByteLength])\n * @param {number} rootCount\n * @param {number} [rootByteLength]\n * @returns {number}\n */\nexport const estimateHeaderLength = (rootCount, rootByteLength = 36) =>\n  calculateHeaderLength(new Array(rootCount).fill(rootByteLength))\n\n/**\n * Creates synchronous CAR writer that can be used to encode blocks into a given\n * buffer. Optionally you could pass `byteOffset` and `byteLength` to specify a\n * range inside buffer to write into. If car file is going to have `roots` you\n * need to either pass them under `options.roots` (from which header size will\n * be calculated) or provide `options.headerSize` to allocate required space\n * in the buffer. You may also provide known `roots` and `headerSize` to\n * allocate space for the roots that may not be known ahead of time.\n *\n * Note: Incorrect `headerSize` may lead to copying bytes inside a buffer\n * which will have a negative impact on performance.\n *\n * @name CarBufferWriter.createWriter(buffer[, options])\n * @param {ArrayBuffer} buffer\n * @param {object} [options]\n * @param {CID[]} [options.roots]\n * @param {number} [options.byteOffset]\n * @param {number} [options.byteLength]\n * @param {number} [options.headerSize]\n * @returns {CarBufferWriter}\n */\nexport const createWriter = (buffer, options = {}) => {\n  const {\n    roots = [],\n    byteOffset = 0,\n    byteLength = buffer.byteLength,\n    headerSize = headerLength({ roots })\n  } = options\n  const bytes = new Uint8Array(buffer, byteOffset, byteLength)\n\n  const writer = new CarBufferWriter(bytes, headerSize)\n  for (const root of roots) {\n    writer.addRoot(root)\n  }\n\n  return writer\n}\n","import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockHeader} BlockHeader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesReader} BytesReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n * @typedef {import('./coding').CarV2FixedHeader} CarV2FixedHeader\n * @typedef {import('./coding').CarDecoder} CarDecoder\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name async decoder.readHeader(reader)\n * @param {BytesReader} reader\n * @param {number} [strictVersion]\n * @returns {Promise<CarHeader|CarV2Header>}\n */\nexport async function readHeader (reader, strictVersion) {\n  const length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = await reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format')\n    }\n    return block\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = await readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<CID>}\n */\nasync function readCid (reader) {\n  const first = await reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = await reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(await reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(await reader.upTo(8), reader)\n  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesReader} reader\n * @returns {Promise<BlockHeader>}\n */\nexport async function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = await readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<Block>}\n */\nasync function readBlock (reader) {\n  const { cid, blockLength } = await readBlockHead(reader)\n  const bytes = await reader.exactly(blockLength, true)\n  return { bytes, cid }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<BlockIndex>}\n */\nasync function readBlockIndex (reader) {\n  const offset = reader.pos\n  const { cid, length, blockLength } = await readBlockHead(reader)\n  const index = { cid, length, blockLength, offset, blockOffset: reader.pos }\n  reader.seek(index.blockLength)\n  return index\n}\n\n/**\n * Creates a `CarDecoder` from a `BytesReader`. The `CarDecoder` is as async\n * interface that will consume the bytes from the `BytesReader` to yield a\n * `header()` and either `blocks()` or `blocksIndex()` data.\n *\n * @name decoder.createDecoder(reader)\n * @param {BytesReader} reader\n * @returns {CarDecoder}\n */\nexport function createDecoder (reader) {\n  const headerPromise = (async () => {\n    const header = await readHeader(reader)\n    if (header.version === 2) {\n      const v1length = reader.pos - header.dataOffset\n      reader = limitReader(reader, header.dataSize - v1length)\n    }\n    return header\n  })()\n\n  return {\n    header: () => headerPromise,\n\n    async * blocks () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader)\n      }\n    },\n\n    async * blocksIndex () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader)\n      }\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n      return out\n    },\n\n    async exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * @ignore\n * reusable reader for streams and files, we just need a way to read an\n * additional chunk (of some undetermined size) and a way to close the\n * reader when finished\n * @param {() => Promise<Uint8Array|null>} readChunk\n * @returns {BytesReader}\n */\nexport function chunkReader (readChunk /*, closer */) {\n  let pos = 0\n  let have = 0\n  let offset = 0\n  let currentChunk = new Uint8Array(0)\n\n  const read = async (/** @type {number} */ length) => {\n    have = currentChunk.length - offset\n    const bufa = [currentChunk.subarray(offset)]\n    while (have < length) {\n      const chunk = await readChunk()\n      if (chunk == null) {\n        break\n      }\n      /* c8 ignore next 8 */\n      // undo this ignore ^ when we have a fd implementation that can seek()\n      if (have < 0) { // because of a seek()\n        /* c8 ignore next 4 */\n        // toohard to test the else\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have))\n        } // else discard\n      } else {\n        bufa.push(chunk)\n      }\n      have += chunk.length\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0))\n    let off = 0\n    for (const b of bufa) {\n      currentChunk.set(b, off)\n      off += b.length\n    }\n    offset = 0\n  }\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length))\n    },\n\n    async exactly (length, seek = false) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = currentChunk.subarray(offset, offset + length)\n      if (seek) {\n        pos += length\n        offset += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n      offset += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from an `AsyncIterable<Uint8Array>`, which allows for\n * consumption of CAR data from a streaming source.\n *\n * @name decoder.asyncIterableReader(asyncIterable)\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {BytesReader}\n */\nexport function asyncIterableReader (asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]()\n\n  async function readChunk () {\n    const next = await iterator.next()\n    if (next.done) {\n      return null\n    }\n    return next.value\n  }\n\n  return chunkReader(readChunk)\n}\n\n/**\n * Wraps a `BytesReader` in a limiting `BytesReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesReader} reader\n * @param {number} byteLimit\n * @returns {BytesReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      let bytes = await reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    async exactly (length, seek = false) {\n      const bytes = await reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n","import { asyncIterableReader, bytesReader, createDecoder } from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').CarReader} CarReaderIface\n * @typedef {import('./coding').BytesReader} BytesReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n */\n\n/**\n * Provides blockstore-like access to a CAR.\n *\n * Implements the `RootsReader` interface:\n * {@link CarReader.getRoots `getRoots()`}. And the `BlockReader` interface:\n * {@link CarReader.get `get()`}, {@link CarReader.has `has()`},\n * {@link CarReader.blocks `blocks()`} (defined as a `BlockIterator`) and\n * {@link CarReader.cids `cids()`} (defined as a `CIDIterator`).\n *\n * Load this class with either `import { CarReader } from '@ipld/car/reader'`\n * (`const { CarReader } = require('@ipld/car/reader')`). Or\n * `import { CarReader } from '@ipld/car'` (`const { CarReader } = require('@ipld/car')`).\n * The former will likely result in smaller bundle sizes where this is\n * important.\n *\n * @name CarReader\n * @class\n * @implements {CarReaderIface}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1` or `2`).\n */\nexport class CarReader {\n  /**\n   * @constructs CarReader\n   * @param {CarHeader|CarV2Header} header\n   * @param {Block[]} blocks\n   */\n  constructor (header, blocks) {\n    this._header = header\n    this._blocks = blocks\n    this._keys = blocks.map((b) => b.cid.toString())\n  }\n\n  /**\n   * @property\n   * @memberof CarReader\n   * @instance\n   */\n  get version () {\n    return this._header.version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this reader. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._header.roots\n  }\n\n  /**\n   * Check whether a given `CID` exists within the CAR referenced by this\n   * reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<boolean>}\n   */\n  async has (key) {\n    return this._keys.indexOf(key.toString()) > -1\n  }\n\n  /**\n   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR\n   * referenced by this reader matching the provided `CID`. In the case where\n   * the provided `CID` doesn't exist within the CAR, `undefined` will be\n   * returned.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<Block | undefined>}\n   */\n  async get (key) {\n    const index = this._keys.indexOf(key.toString())\n    return index > -1 ? this._blocks[index] : undefined\n  }\n\n  /**\n   * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all\n   * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within\n   * the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<Block>}\n   */\n  async * blocks () {\n    for (const block of this._blocks) {\n      yield block\n    }\n  }\n\n  /**\n   * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of\n   * the `CID`s contained within the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<CID>}\n   */\n  async * cids () {\n    for (const block of this._blocks) {\n      yield block.cid\n    }\n  }\n\n  /**\n   * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a\n   * decode fully in memory and maintains the decoded state in memory for full\n   * access to the data via the `CarReader` API.\n   *\n   * @async\n   * @static\n   * @memberof CarReader\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarReader>}\n   */\n  static async fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n    return decodeReaderComplete(bytesReader(bytes))\n  }\n\n  /**\n   * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as\n   * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * This performs a decode fully in memory and maintains the decoded state in\n   * memory for full access to the data via the `CarReader` API.\n   *\n   * Care should be taken for large archives; this API may not be appropriate\n   * where memory is a concern or the archive is potentially larger than the\n   * amount of memory that the runtime can handle.\n   *\n   * @async\n   * @static\n   * @memberof CarReader\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarReader>}\n   */\n  static async fromIterable (asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable')\n    }\n    return decodeReaderComplete(asyncIterableReader(asyncIterable))\n  }\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<CarReader>}\n */\nexport async function decodeReaderComplete (reader) {\n  const decoder = createDecoder(reader)\n  const header = await decoder.header()\n  const blocks = []\n  for await (const block of decoder.blocks()) {\n    blocks.push(block)\n  }\n\n  return new CarReader(header, blocks)\n}\n\nexport const __browser = true\n","import { encode as dagCborEncode } from '@ipld/dag-cbor'\nimport varint from 'varint'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer\n */\n\nconst CAR_V1_VERSION = 1\n\n/**\n * Create a header from an array of roots.\n *\n * @param {CID[]} roots\n * @returns {Uint8Array}\n */\nexport function createHeader (roots) {\n  const headerBytes = dagCborEncode({ version: CAR_V1_VERSION, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n  const header = new Uint8Array(varintBytes.length + headerBytes.length)\n  header.set(varintBytes, 0)\n  header.set(headerBytes, varintBytes.length)\n  return header\n}\n\n/**\n * @param {IteratorChannel_Writer} writer\n * @returns {CarEncoder}\n */\nfunction createEncoder (writer) {\n  // none of this is wrapped in a mutex, that needs to happen above this to\n  // avoid overwrites\n\n  return {\n    /**\n     * @param {CID[]} roots\n     * @returns {Promise<void>}\n     */\n    async setRoots (roots) {\n      const bytes = createHeader(roots)\n      await writer.write(bytes)\n    },\n\n    /**\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async writeBlock (block) {\n      const { cid, bytes } = block\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)))\n      await writer.write(cid.bytes)\n      if (bytes.length) {\n        // zero-length blocks are valid, but it'd be safer if we didn't write them\n        await writer.write(bytes)\n      }\n    },\n\n    /**\n     * @returns {Promise<void>}\n     */\n    async close () {\n      await writer.end()\n    },\n\n    /**\n     * @returns {number}\n     */\n    version () {\n      return CAR_V1_VERSION\n    }\n  }\n}\n\nexport { createEncoder }\n","import pLimit from \"p-limit\";\nimport { CarReader } from \"@ipld/car\";\nimport { Logger, ResolveOnce } from \"@adviser/cement\";\n// import { uuidv4 } from \"uuidv7\";\n\nimport {\n  type AnyBlock,\n  type AnyLink,\n  type CarHeader,\n  type CommitOpts,\n  type DbMeta,\n  type TransactionMeta,\n  type CarGroup,\n  type CarLog,\n  DataStore,\n  WALStore,\n  // RemoteMetaStore,\n  MetaStore,\n  BaseStore,\n  type Loadable,\n  BlockstoreRuntime,\n  BlockstoreOpts,\n} from \"./types.js\";\n\nimport { parseCarFile } from \"./loader-helpers.js\";\n\nimport { CarTransaction, defaultedBlockstoreRuntime } from \"./transaction.js\";\nimport { CommitQueue } from \"./commit-queue.js\";\nimport type { Falsy, SuperThis } from \"../types.js\";\nimport { getKeyBag, KeyBag } from \"../runtime/key-bag.js\";\nimport { commit, commitFiles, CommitParams } from \"./commitor.js\";\nimport { decode } from \"../runtime/wait-pr-multiformats/block.js\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport { TaskManager } from \"./task-manager.js\";\n\nexport function carLogIncludesGroup(list: CarLog, cids: CarGroup) {\n  return list.some((arr: CarGroup) => {\n    return arr.toString() === cids.toString();\n  });\n}\n\n// this works for car groups because toString looks like bafy,bafy\nfunction uniqueCids(list: CarLog, remove = new Set<string>()): CarLog {\n  const byString = new Map<string, CarGroup>();\n  for (const cid of list) {\n    if (remove.has(cid.toString())) continue;\n    byString.set(cid.toString(), cid);\n  }\n  return [...byString.values()];\n}\n\n// export interface DecoderAndCarReader extends CarReader {\n//   readonly decoder: BlockDecoder<number, Uint8Array>;\n// }\n\nexport class Loader implements Loadable {\n  readonly name: string;\n  readonly ebOpts: BlockstoreRuntime;\n  readonly commitQueue: CommitQueue<CarGroup> = new CommitQueue<CarGroup>();\n  readonly isCompacting = false;\n  readonly carReaders: Map<string, Promise<CarReader>> = new Map<string, Promise<CarReader>>();\n  readonly seenCompacted: Set<string> = new Set<string>();\n  readonly processedCars: Set<string> = new Set<string>();\n  readonly sthis: SuperThis;\n  readonly taskManager?: TaskManager;\n\n  carLog: CarLog = [];\n  // key?: string;\n  // keyId?: string;\n  remoteMetaStore?: MetaStore;\n  remoteCarStore?: DataStore;\n  remoteFileStore?: DataStore;\n\n  private getBlockCache = new Map<string, AnyBlock>();\n  private seenMeta = new Set<string>();\n  private writeLimit = pLimit(1);\n\n  // readonly id = uuidv4();\n\n  async keyBag(): Promise<KeyBag> {\n    return getKeyBag(this.sthis, this.ebOpts.keyBag);\n  }\n\n  async carStore(): Promise<DataStore> {\n    return this.ebOpts.storeRuntime.makeDataStore(this);\n  }\n\n  async fileStore(): Promise<DataStore> {\n    return this.ebOpts.storeRuntime.makeDataStore(this);\n  }\n  async WALStore(): Promise<WALStore> {\n    return this.ebOpts.storeRuntime.makeWALStore(this);\n  }\n\n  async metaStore(): Promise<MetaStore> {\n    return this.ebOpts.storeRuntime.makeMetaStore(this);\n  }\n\n  readonly onceReady: ResolveOnce<void> = new ResolveOnce<void>();\n  async ready(): Promise<void> {\n    return this.onceReady.once(async () => {\n      const metas = await (await this.metaStore()).load();\n      if (this.ebOpts.meta) {\n        await this.handleDbMetasFromStore([this.ebOpts.meta]);\n      } else if (metas) {\n        await this.handleDbMetasFromStore(metas);\n      }\n    });\n  }\n\n  async close() {\n    const toClose = await Promise.all([this.carStore(), this.metaStore(), this.fileStore(), this.WALStore()]);\n    await Promise.all(toClose.map((store) => store.close()));\n  }\n\n  async destroy() {\n    const toDestroy = await Promise.all([this.carStore(), this.metaStore(), this.fileStore(), this.WALStore()]);\n    await Promise.all(toDestroy.map((store) => store.destroy()));\n  }\n\n  readonly logger: Logger;\n  constructor(name: string, ebOpts: BlockstoreOpts, sthis: SuperThis) {\n    this.name = name;\n    // console.log(\"Loader\", name, ebOpts)\n    this.sthis = sthis;\n    this.ebOpts = defaultedBlockstoreRuntime(\n      sthis,\n      {\n        ...ebOpts,\n        name,\n      },\n      \"Loader\",\n    );\n    this.logger = this.ebOpts.logger;\n    this.taskManager = new TaskManager(sthis, async (dbMeta: DbMeta) => {\n      await this.handleDbMetasFromStore([dbMeta]);\n    });\n  }\n\n  // async snapToCar(carCid: AnyLink | string) {\n  //   await this.ready\n  //   if (typeof carCid === 'string') {\n  //     carCid = CID.parse(carCid)\n  //   }\n  //   const carHeader = await this.loadCarHeaderFromMeta({ car: carCid, key: this.key || null })\n  //   this.carLog = [carCid, ...carHeader.cars]\n  //   await this.getMoreReaders(carHeader.cars)\n  //   await this._applyCarHeader(carHeader, true)\n  // }\n\n  async handleDbMetasFromStore(metas: DbMeta[]): Promise<void> {\n    this.logger.Debug().Any(\"metas\", metas).Msg(\"handleDbMetasFromStore\");\n    for (const meta of metas) {\n      await this.writeLimit(async () => {\n        await this.mergeDbMetaIntoClock(meta);\n      });\n    }\n  }\n\n  async mergeDbMetaIntoClock(meta: DbMeta): Promise<void> {\n    if (this.isCompacting) {\n      throw this.logger.Error().Msg(\"cannot merge while compacting\").AsError();\n    }\n\n    if (this.seenMeta.has(meta.cars.toString())) return;\n    this.seenMeta.add(meta.cars.toString());\n\n    // if (meta.key) {\n    //   await this.setKey(meta.key);\n    // }\n    if (carLogIncludesGroup(this.carLog, meta.cars)) {\n      return;\n    }\n    const carHeader = await this.loadCarHeaderFromMeta<TransactionMeta>(meta);\n    // fetch other cars down the compact log?\n    // todo we should use a CID set for the compacted cids (how to expire?)\n    // console.log('merge carHeader', carHeader.head.length, carHeader.head.toString(), meta.car.toString())\n    carHeader.compact.map((c) => c.toString()).forEach(this.seenCompacted.add, this.seenCompacted);\n    await this.getMoreReaders(carHeader.cars.flat());\n    this.carLog = [...uniqueCids([meta.cars, ...this.carLog, ...carHeader.cars], this.seenCompacted)];\n    await this.ebOpts.applyMeta?.(carHeader.meta);\n  }\n\n  // protected async ingestKeyFromMeta(meta: DbMeta): Promise<void> {\n  //   const { key } = meta;\n  //   if (key) {\n  //     await this.setKey(key);\n  //   }\n  // }\n\n  async loadCarHeaderFromMeta<T>({ cars: cids }: DbMeta): Promise<CarHeader<T>> {\n    //Call loadCar for every cid\n    const reader = await this.loadCar(cids[0]);\n    return await parseCarFile(reader, this.logger);\n  }\n\n  // async _getKey(): Promise<string | undefined> {\n  //   if (this.key) return this.key;\n  //   // generate a random key\n  //   if (!this.ebOpts.public) {\n  //     await this.setKey(toHexString(this.ebOpts.crypto.randomBytes(32)));\n  //   }\n  //   return this.key || undefined;\n  // }\n\n  async commitFiles(\n    t: CarTransaction,\n    done: TransactionMeta,\n    // opts: CommitOpts = { noLoader: false, compact: false },\n  ): Promise<CarGroup> {\n    await this.ready();\n    const fstore = await this.fileStore();\n    const wstore = await this.WALStore();\n    return this.commitQueue.enqueue(() => commitFiles(fstore, wstore, t, done));\n  }\n\n  async loadFileCar(cid: AnyLink /*, isPublic = false*/): Promise<CarReader> {\n    return await this.storesLoadCar(cid, await this.fileStore(), this.remoteFileStore);\n  }\n\n  async commit<T = TransactionMeta>(\n    t: CarTransaction,\n    done: T,\n    opts: CommitOpts = { noLoader: false, compact: false },\n  ): Promise<CarGroup> {\n    await this.ready();\n    const fstore = await this.fileStore();\n    const params: CommitParams = {\n      encoder: (await fstore.keyedCrypto()).codec(),\n      carLog: this.carLog,\n      carStore: fstore,\n      WALStore: await this.WALStore(),\n      metaStore: await this.metaStore(),\n    };\n    return this.commitQueue.enqueue(async () => {\n      await this.cacheTransaction(t);\n      const ret = await commit(params, t, done, opts);\n      await this.updateCarLog(ret.cgrp, ret.header, !!opts.compact);\n      return ret.cgrp;\n    });\n  }\n\n  async updateCarLog<T>(cids: CarGroup, fp: CarHeader<T>, compact: boolean): Promise<void> {\n    if (compact) {\n      const previousCompactCid = fp.compact[fp.compact.length - 1];\n      fp.compact.map((c) => c.toString()).forEach(this.seenCompacted.add, this.seenCompacted);\n      this.carLog = [...uniqueCids([...this.carLog, ...fp.cars, cids], this.seenCompacted)];\n      await this.removeCidsForCompact(previousCompactCid[0]).catch((e) => e);\n    } else {\n      this.carLog.unshift(cids);\n    }\n  }\n\n  async cacheTransaction(t: CarTransaction) {\n    for await (const block of t.entries()) {\n      const sBlock = block.cid.toString();\n      if (!this.getBlockCache.has(sBlock)) {\n        this.getBlockCache.set(sBlock, block);\n      }\n    }\n  }\n\n  async cacheCarReader(carCidStr: string, reader: CarReader) {\n    if (this.processedCars.has(carCidStr)) return;\n    this.processedCars.add(carCidStr);\n    for await (const block of reader.blocks()) {\n      const sBlock = block.cid.toString();\n      if (!this.getBlockCache.has(sBlock)) {\n        this.getBlockCache.set(sBlock, block);\n      }\n    }\n  }\n\n  async removeCidsForCompact(cid: AnyLink) {\n    const carHeader = await this.loadCarHeaderFromMeta({\n      cars: [cid],\n    } as unknown as DbMeta);\n    for (const cids of carHeader.compact) {\n      for (const cid of cids) {\n        await (await this.carStore()).remove(cid);\n      }\n    }\n  }\n\n  // async flushCars() {\n  //   await this.ready\n  //   // for each cid in car log, make a dbMeta\n  //   for (const cid of this.carLog) {\n  //     const dbMeta = { car: cid, key: this.key || null } as DbMeta\n  //     await this.remoteWAL!.enqueue(dbMeta, { public: false })\n  //   }\n  // }\n\n  async *entries(cache = true): AsyncIterableIterator<AnyBlock> {\n    await this.ready();\n    if (cache) {\n      for (const [, block] of this.getBlockCache) {\n        yield block;\n      }\n    } else {\n      for (const [, block] of this.getBlockCache) {\n        yield block;\n      }\n      for (const cids of this.carLog) {\n        for (const cid of cids) {\n          const reader = await this.loadCar(cid);\n          if (!reader) throw this.logger.Error().Ref(\"cid\", cid).Msg(\"missing car reader\").AsError();\n          for await (const block of reader.blocks()) {\n            const sCid = block.cid.toString();\n            if (!this.getBlockCache.has(sCid)) {\n              yield block;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  async getBlock(cid: AnyLink): Promise<AnyBlock | Falsy> {\n    await this.ready();\n    const sCid = cid.toString();\n    if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);\n\n    const getCarCid = async (carCid: AnyLink) => {\n      if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);\n      const reader = await this.loadCar(carCid);\n      if (!reader) {\n        throw this.logger.Error().Ref(\"cid\", carCid).Msg(\"missing car reader\").AsError();\n      }\n      await this.cacheCarReader(carCid.toString(), reader).catch(() => {\n        return;\n      });\n      if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);\n      throw this.logger.Error().Str(\"cid\", sCid).Msg(\"block not in reader\").AsError();\n    };\n\n    const getCompactCarCids = async (carCid: AnyLink) => {\n      // console.log(\"getCompactCarCids\", carCid.toString())\n\n      const reader = await this.loadCar(carCid);\n      if (!reader) {\n        throw this.logger.Error().Str(\"cid\", carCid.toString()).Msg(\"missing car reader\").AsError();\n      }\n\n      const header = await parseCarFile(reader, this.logger);\n\n      const compacts = header.compact;\n\n      let got: AnyBlock | undefined;\n      const batchSize = 5;\n      for (let i = 0; i < compacts.length; i += batchSize) {\n        const promises: Promise<AnyBlock | undefined>[] = [];\n        for (let j = i; j < Math.min(i + batchSize, compacts.length); j++) {\n          for (const cid of compacts[j]) {\n            promises.push(getCarCid(cid));\n          }\n        }\n        try {\n          got = await Promise.any(promises);\n        } catch {\n          // Ignore the error and continue with the next iteration\n        }\n        if (got) break;\n      }\n\n      if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);\n      throw this.logger.Error().Str(\"cid\", sCid).Msg(\"block not in compact reader\").AsError();\n    };\n\n    let got;\n    const batchSize = 5;\n    for (let i = 0; i < this.carLog.length; i += batchSize) {\n      const batch = this.carLog.slice(i, i + batchSize);\n      const promises: Promise<AnyBlock | undefined>[] = batch.flatMap((slice) => slice.map(getCarCid));\n      try {\n        got = await Promise.any(promises);\n      } catch {\n        // Ignore the error and continue with the next iteration\n      }\n      if (got) break;\n    }\n\n    if (!got) {\n      try {\n        got = await getCompactCarCids(this.carLog[this.carLog.length - 1][0]);\n      } catch {\n        // Ignore the error and continue with the next iteration\n      }\n    }\n\n    return got;\n  }\n\n  async loadCar(cid: AnyLink): Promise<CarReader> {\n    if (!this.carStore) {\n      throw this.logger.Error().Msg(\"car store not initialized\").AsError();\n    }\n    const loaded = await this.storesLoadCar(cid, await this.carStore(), this.remoteCarStore);\n    return loaded;\n  }\n\n  async makeDecoderAndCarReader(cid: AnyLink, local: DataStore, remote?: DataStore): Promise<CarReader> {\n    const cidsString = cid.toString();\n    let loadedCar: AnyBlock | undefined = undefined;\n    let activeStore: BaseStore = local;\n    try {\n      //loadedCar now is an array of AnyBlocks\n      this.logger.Debug().Str(\"cid\", cidsString).Msg(\"loading car\");\n      loadedCar = await local.load(cid);\n      this.logger.Debug().Bool(\"loadedCar\", loadedCar).Msg(\"loaded\");\n    } catch (e) {\n      if (remote) {\n        const remoteCar = await remote.load(cid);\n        if (remoteCar) {\n          // todo test for this\n          this.logger.Debug().Ref(\"cid\", remoteCar.cid).Msg(\"saving remote car locally\");\n          await local.save(remoteCar);\n          loadedCar = remoteCar;\n          activeStore = remote;\n        }\n      } else {\n        this.logger.Error().Str(\"cid\", cidsString).Err(e).Msg(\"loading car\");\n      }\n    }\n    if (!loadedCar) {\n      throw this.logger.Error().Url(local.url()).Str(\"cid\", cidsString).Msg(\"missing car files\").AsError();\n    }\n    //This needs a fix as well as the fromBytes function expects a Uint8Array\n    //Either we can merge the bytes or return an array of rawReaders\n    const bytes = await decode({ bytes: loadedCar.bytes, hasher, codec: (await activeStore.keyedCrypto()).codec() }); // as Uint8Array,\n    const rawReader = await CarReader.fromBytes(bytes.value);\n    const readerP = Promise.resolve(rawReader);\n    // const kc = await activeStore.keyedCrypto()\n    // const readerP = !kc.isEncrypting ? Promise.resolve(rawReader) : this.ensureDecryptedReader(activeStore, rawReader);\n\n    const cachedReaderP = readerP.then(async (reader) => {\n      await this.cacheCarReader(cidsString, reader).catch((e) => {\n        this.logger.Error().Err(e).Str(\"cid\", cidsString).Msg(\"error caching car reader\");\n        return;\n      });\n      return reader;\n    });\n    this.carReaders.set(cidsString, cachedReaderP);\n    return readerP;\n  }\n\n  //What if instead it returns an Array of CarHeader\n  protected async storesLoadCar(cid: AnyLink, local: DataStore, remote?: DataStore): Promise<CarReader> {\n    const cidsString = cid.toString();\n    let dacr = this.carReaders.get(cidsString);\n    if (!dacr) {\n      dacr = this.makeDecoderAndCarReader(cid, local, remote);\n      this.carReaders.set(cidsString, dacr);\n    }\n    return dacr;\n  }\n\n  protected async getMoreReaders(cids: AnyLink[]) {\n    const limit = pLimit(5);\n    const missing = cids.filter((cid) => !this.carReaders.has(cid.toString()));\n    await Promise.all(missing.map((cid) => limit(() => this.loadCar(cid))));\n  }\n}\n","import { decode } from \"../runtime/wait-pr-multiformats/block.js\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport * as dagCodec from \"@ipld/dag-cbor\";\nimport type { Logger } from \"@adviser/cement\";\n\nimport { CarHeader } from \"./types.js\";\n// import { decodeRunLength } from \"../runtime/keyed-crypto.js\";\n// import { base58btc } from \"multiformats/bases/base58\";\nimport { CarReader } from \"@ipld/car\";\n\n// export async function encodeCarHeader<T>(fp: CarHeader<T>) {\n//   return (await encode({\n//     value: { fp },\n//     hasher,\n//     codec: dagCodec,\n//   })) as AnyBlock;\n// }\n\n// function wrapDagDecoder<T>(dec: BlockDecoder<number, Uint8Array>): BlockDecoder<number, CarDecoded<T>> {\n//   return {\n//     code: dec.code,\n//     decode: async (block: Uint8Array) => dagCodec.decode(await dec.decode(block))\n//   }\n// }\n\ninterface CarDecoded<T> {\n  readonly fp: CarHeader<T>;\n}\n\nexport async function parseCarFile<T>(reader: CarReader, logger: Logger): Promise<CarHeader<T>> {\n  const roots = await reader.getRoots();\n  const header = await reader.get(roots[0]);\n  if (!header) throw logger.Error().Msg(\"missing header block\").AsError();\n  const dec = await decode({ bytes: header.bytes, hasher, codec: dagCodec });\n  // console.log(\"parseCarFile-done\", roots[0].toString(), header)\n  // const { value } = await decode({\n  //   bytes: header.bytes,\n  //   hasher,\n  //   codec: await wrapDagDecoder<T>({\n  //     code: dagCodec.code,\n  //     decode: (block) => {\n  //       const ui = new Uint8Array(block);\n  //       const iv = decodeRunLength(ui, 0, logger);\n  //       const key = decodeRunLength(ui, iv.next, logger);\n  //       // const fp = decodeRunLength(ui, key.next, logger);\n  //       console.log(\"parseCarFile\", { iv: iv.data.length, key: base58btc.encode(key.data) }, (new Error()).stack);\n  //       return ui\n  //     }\n  //   })\n  // });\n  const fpvalue = dec.value as CarDecoded<T>;\n  // @jchris where is the fp attribute coming from?\n  if (fpvalue && !fpvalue.fp) {\n    throw logger.Error().Msg(\"missing fp\").AsError();\n  }\n  return fpvalue.fp;\n}\n","import { MemoryBlockstore } from \"@web3-storage/pail/block\";\nimport { BlockFetcher as BlockFetcherApi } from \"@web3-storage/pail/api\";\n\nimport {\n  AnyAnyLink,\n  AnyBlock,\n  AnyLink,\n  CarMakeable,\n  TransactionMeta,\n  TransactionWrapper,\n  BlockstoreOpts,\n  BlockstoreRuntime,\n} from \"./types.js\";\n\nimport { Loader } from \"./loader.js\";\nimport type { CID, Block, Version } from \"multiformats\";\nimport { falsyToUndef, SuperThis } from \"../types.js\";\nimport { toStoreRuntime } from \"./store-factory.js\";\nimport { Logger, toCryptoRuntime } from \"@adviser/cement\";\nimport { ensureLogger, ensureSuperThis } from \"../utils.js\";\n\nexport type BlockFetcher = BlockFetcherApi;\n\nexport interface CarTransactionOpts {\n  readonly add: boolean;\n  readonly noLoader: boolean;\n}\n\nexport class CarTransaction extends MemoryBlockstore implements CarMakeable {\n  readonly parent: BaseBlockstore;\n  constructor(parent: BaseBlockstore, opts: CarTransactionOpts = { add: true, noLoader: false }) {\n    super();\n    if (opts.add) {\n      parent.transactions.add(this);\n    }\n    this.parent = parent;\n  }\n\n  async get<T, C extends number, A extends number, V extends Version>(cid: AnyLink): Promise<Block<T, C, A, V> | undefined> {\n    return ((await this.superGet(cid)) || falsyToUndef(await this.parent.get(cid))) as Block<T, C, A, V>;\n  }\n\n  async superGet(cid: AnyLink): Promise<AnyBlock | undefined> {\n    return super.get(cid);\n  }\n}\n\nexport function defaultedBlockstoreRuntime(\n  sthis: SuperThis,\n  opts: BlockstoreOpts,\n  component: string,\n  ctx?: Record<string, unknown>,\n): BlockstoreRuntime {\n  const logger = ensureLogger(sthis, component, ctx);\n  const store = opts.store || {};\n  return {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    applyMeta: (meta: TransactionMeta, snap?: boolean): Promise<void> => {\n      return Promise.resolve();\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    compact: async (blocks: BlockFetcher) => {\n      return {} as unknown as TransactionMeta;\n    },\n    autoCompact: 100,\n    public: false,\n    name: undefined,\n    threshold: 1000 * 1000,\n    ...opts,\n    logger,\n    keyBag: opts.keyBag || {},\n    crypto: toCryptoRuntime(opts.crypto),\n    store,\n    storeRuntime: toStoreRuntime(store, sthis),\n  };\n}\n\nexport function blockstoreFactory(sthis: SuperThis, opts: BlockstoreOpts): BaseBlockstore | EncryptedBlockstore {\n  if (opts.name) {\n    return new EncryptedBlockstore(sthis, opts);\n  } else {\n    return new BaseBlockstore(opts);\n  }\n}\n\nexport class BaseBlockstore implements BlockFetcher {\n  readonly transactions: Set<CarTransaction> = new Set<CarTransaction>();\n  readonly ebOpts: BlockstoreRuntime;\n  readonly sthis: SuperThis;\n\n  readonly loader?: Loader;\n  readonly name?: string;\n\n  // ready: Promise<void>;\n  ready(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  async close(): Promise<void> {\n    // no-op\n  }\n\n  async destroy(): Promise<void> {\n    // no-op\n  }\n\n  readonly logger: Logger;\n  constructor(ebOpts: BlockstoreOpts = {}) {\n    // console.log(\"BaseBlockstore\", ebOpts)\n    this.sthis = ensureSuperThis(ebOpts);\n    this.ebOpts = defaultedBlockstoreRuntime(this.sthis, ebOpts, \"BaseBlockstore\");\n    this.logger = this.ebOpts.logger;\n  }\n\n  async get<T, C extends number, A extends number, V extends Version>(cid: AnyAnyLink): Promise<Block<T, C, A, V> | undefined> {\n    if (!cid) throw this.logger.Error().Msg(\"required cid\").AsError();\n    for (const f of this.transactions) {\n      // if (Math.random() < 0.001) console.log('get', cid.toString(), this.transactions.size)\n      const v = await f.superGet(cid);\n      if (v) return v as Block<T, C, A, V>;\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async put(cid: AnyAnyLink, block: Uint8Array): Promise<void> {\n    throw this.logger.Error().Msg(\"use a transaction to put\").AsError();\n  }\n\n  lastTxMeta?: unknown; // TransactionMeta\n\n  async transaction<M extends TransactionMeta>(\n    fn: (t: CarTransaction) => Promise<M>,\n    _opts?: CarTransactionOpts,\n  ): Promise<TransactionWrapper<M>> {\n    const t = new CarTransaction(this, _opts);\n    const done: M = await fn(t);\n    this.lastTxMeta = done;\n    return { t, meta: done };\n  }\n\n  async *entries(): AsyncIterableIterator<AnyBlock> {\n    const seen = new Set<string>();\n    for (const t of this.transactions) {\n      for await (const blk of t.entries()) {\n        if (seen.has(blk.cid.toString())) continue;\n        seen.add(blk.cid.toString());\n        yield blk;\n      }\n    }\n  }\n}\n\nexport class EncryptedBlockstore extends BaseBlockstore {\n  readonly name: string;\n  readonly loader: Loader;\n\n  ready(): Promise<void> {\n    return this.loader.ready();\n  }\n\n  close(): Promise<void> {\n    return this.loader.close();\n  }\n\n  destroy(): Promise<void> {\n    return this.loader.destroy();\n  }\n\n  compacting = false;\n  readonly logger: Logger;\n\n  constructor(sthis: SuperThis, ebOpts: BlockstoreOpts) {\n    super(ebOpts);\n    this.logger = ensureLogger(this.sthis, \"EncryptedBlockstore\");\n    const { name } = ebOpts;\n    if (!name) {\n      throw this.logger.Error().Msg(\"name required\").AsError();\n    }\n    this.name = name;\n    this.loader = new Loader(this.name, ebOpts, sthis);\n  }\n\n  async get<T, C extends number, A extends number, V extends Version>(cid: AnyAnyLink): Promise<Block<T, C, A, V> | undefined> {\n    const got = await super.get(cid);\n    if (got) return got as Block<T, C, A, V>;\n    if (!this.loader) {\n      return;\n    }\n    return falsyToUndef(await this.loader.getBlock(cid)) as Block<T, C, A, V>;\n  }\n\n  async transaction<M extends TransactionMeta>(\n    fn: (t: CarTransaction) => Promise<M>,\n    opts = { noLoader: false },\n  ): Promise<TransactionWrapper<M>> {\n    const { t, meta: done } = await super.transaction<M>(fn);\n    const cars = await this.loader.commit<M>(t, done, opts);\n    if (this.ebOpts.autoCompact && this.loader.carLog.length > this.ebOpts.autoCompact) {\n      setTimeout(() => void this.compact(), 10);\n    }\n    if (cars) {\n      this.transactions.delete(t);\n      return { meta: done, cars, t };\n    }\n    throw this.logger.Error().Msg(\"failed to commit car files\").AsError();\n  }\n\n  async getFile(car: AnyLink, cid: AnyLink /*, isPublic = false*/): Promise<Uint8Array> {\n    await this.ready();\n    if (!this.loader) throw this.logger.Error().Msg(\"loader required to get file, database must be named\").AsError();\n    const reader = await this.loader.loadFileCar(car /*, isPublic */);\n    const block = await reader.get(cid as CID);\n    if (!block) throw this.logger.Error().Str(\"cid\", cid.toString()).Msg(`Missing block`).AsError();\n    return block.bytes;\n  }\n\n  async compact() {\n    await this.ready();\n    if (!this.loader) throw this.logger.Error().Msg(\"loader required to compact\").AsError();\n    if (this.loader.carLog.length < 2) return;\n    const compactFn = this.ebOpts.compact || ((blocks: CompactionFetcher) => this.defaultCompact(blocks, this.logger));\n    if (!compactFn || this.compacting) return;\n    const blockLog = new CompactionFetcher(this);\n    this.compacting = true;\n    const meta = await compactFn(blockLog);\n    await this.loader?.commit(blockLog.loggedBlocks, meta, {\n      compact: true,\n      noLoader: true,\n    });\n    this.compacting = false;\n  }\n\n  async defaultCompact(blocks: CompactionFetcher, logger: Logger): Promise<TransactionMeta> {\n    // console.log('eb compact')\n    if (!this.loader) {\n      throw logger.Error().Msg(\"no loader\").AsError();\n    }\n    if (!this.lastTxMeta) {\n      throw logger.Error().Msg(\"no lastTxMeta\").AsError();\n    }\n    for await (const blk of this.loader.entries(false)) {\n      blocks.loggedBlocks.putSync(blk.cid, blk.bytes);\n    }\n    for (const t of this.transactions) {\n      for await (const blk of t.entries()) {\n        blocks.loggedBlocks.putSync(blk.cid, blk.bytes);\n      }\n    }\n    return this.lastTxMeta as TransactionMeta;\n  }\n\n  async *entries(): AsyncIterableIterator<AnyBlock> {\n    // const seen = new Set<string>();\n    for await (const blk of this.loader.entries()) {\n      // if (seen.has(blk.cid.toString())) continue\n      // seen.add(blk.cid.toString())\n      yield blk;\n    }\n  }\n}\n\nexport class CompactionFetcher implements BlockFetcher {\n  readonly blockstore: EncryptedBlockstore;\n  // loader: Loader | null = null\n  readonly loggedBlocks: CarTransaction;\n\n  constructor(blocks: EncryptedBlockstore) {\n    this.blockstore = blocks;\n    // this.loader = blocks.loader\n    this.loggedBlocks = new CarTransaction(blocks);\n  }\n\n  async get<T, C extends number, A extends number, V extends Version>(cid: AnyLink): Promise<Block<T, C, A, V> | undefined> {\n    const block = await this.blockstore.get(cid);\n    if (block) this.loggedBlocks.putSync(cid, block.bytes);\n    return falsyToUndef(block) as Block<T, C, A, V>;\n  }\n}\n","import { Future } from \"@adviser/cement\";\n\ntype QueueFunction<T = void> = () => Promise<T>;\n\nexport class CommitQueue<T = void> {\n  readonly queue: QueueFunction<void>[] = [];\n  processing = false;\n\n  readonly _waitIdleItems: Set<Future<void>> = new Set<Future<void>>();\n  waitIdle(): Promise<void> {\n    if (this.queue.length === 0 && !this.processing) {\n      return Promise.resolve();\n    }\n    const fn = new Future<void>();\n    this._waitIdleItems.add(fn);\n    return fn.asPromise();\n  }\n\n  async enqueue(fn: QueueFunction<T>): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const queueFn = async () => {\n        try {\n          resolve(await fn());\n        } catch (e) {\n          reject(e);\n        } finally {\n          this.processing = false;\n          this.processNext();\n        }\n      };\n      this.queue.push(queueFn);\n      if (!this.processing) {\n        this.processNext();\n      }\n    });\n  }\n\n  processNext() {\n    if (this.queue.length > 0 && !this.processing) {\n      this.processing = true;\n      const queueFn = this.queue.shift();\n      if (queueFn) {\n        queueFn().finally(() => {\n          /**/\n        });\n      }\n    }\n    if (this.queue.length === 0 && !this.processing) {\n      const toResolve = Array.from(this._waitIdleItems);\n      this._waitIdleItems.clear();\n      toResolve.map((fn) => fn.resolve());\n    }\n  }\n}\n","import {\n  CoerceURI,\n  CryptoRuntime,\n  KeyedResolvOnce,\n  Logger,\n  ResolveOnce,\n  ResolveSeq,\n  Result,\n  runtimeFn,\n  toCryptoRuntime,\n  URI,\n} from \"@adviser/cement\";\nimport { KeyWithFingerExtract, KeyWithFingerPrint } from \"../blockstore/types.js\";\nimport { ensureLogger } from \"../utils.js\";\nimport { base58btc } from \"multiformats/bases/base58\";\nimport { SuperThis } from \"../types.js\";\n\nexport type { KeyBagProviderFile } from \"./key-bag-file.js\";\nexport type { KeyBagProviderIndexDB } from \"./key-bag-indexdb.js\";\n\nexport class KeyBag {\n  readonly logger: Logger;\n  constructor(readonly rt: KeyBagRuntime) {\n    this.logger = ensureLogger(rt.sthis, \"KeyBag\");\n    this.logger.Debug().Msg(\"KeyBag created\");\n  }\n\n  readonly _warnOnce: ResolveOnce<void> = new ResolveOnce<void>();\n  async subtleKey(key: string): Promise<CryptoKey> {\n    const extractable = this.rt.url.getParam(\"extractKey\") === \"_deprecated_internal_api\";\n    if (extractable) {\n      this._warnOnce.once(() =>\n        this.logger.Warn().Msg(\"extractKey is enabled via _deprecated_internal_api --- handle keys safely!!!\"),\n      );\n    }\n    return await this.rt.crypto.importKey(\n      \"raw\", // raw or jwk\n      base58btc.decode(key),\n      // hexStringToUint8Array(key), // raw data\n      \"AES-GCM\",\n      extractable,\n      [\"encrypt\", \"decrypt\"],\n    );\n  }\n\n  async ensureKeyFromUrl(url: URI, keyFactory: () => string): Promise<Result<URI>> {\n    // add storekey to url\n    const storeKey = url.getParam(\"storekey\");\n    if (storeKey === \"insecure\") {\n      return Result.Ok(url);\n    }\n    if (!storeKey) {\n      const keyName = `@${keyFactory()}@`;\n      const ret = await this.getNamedKey(keyName);\n      if (ret.isErr()) {\n        return ret as unknown as Result<URI>;\n      }\n      const urb = url.build().setParam(\"storekey\", keyName);\n      return Result.Ok(urb.URI());\n    }\n    if (storeKey.startsWith(\"@\") && storeKey.endsWith(\"@\")) {\n      const ret = await this.getNamedKey(storeKey);\n      if (ret.isErr()) {\n        return ret as unknown as Result<URI>;\n      }\n    }\n    return Result.Ok(url);\n  }\n\n  async toKeyWithFingerPrint(keyStr: string): Promise<Result<KeyWithFingerPrint>> {\n    const material = base58btc.decode(keyStr); //\n    const key = await this.subtleKey(keyStr);\n    const fpr = await this.rt.crypto.digestSHA256(material);\n    return Result.Ok({\n      key,\n      fingerPrint: base58btc.encode(new Uint8Array(fpr)),\n    });\n  }\n\n  readonly _seq: ResolveSeq<Result<KeyWithFingerPrint>> = new ResolveSeq<Result<KeyWithFingerPrint>>();\n  async setNamedKey(name: string, key: string): Promise<Result<KeyWithFingerPrint>> {\n    return this._seq.add(() => this._setNamedKey(name, key));\n  }\n\n  // avoid deadlock\n  async _setNamedKey(name: string, key: string): Promise<Result<KeyWithFingerPrint>> {\n    const item = {\n      name,\n      key: key,\n    };\n    const bag = await this.rt.getBag();\n    this.logger.Debug().Str(\"name\", name).Msg(\"setNamedKey\");\n    // there should be a version that throws if key exists\n    await bag.set(name, item);\n    return await this.toKeyWithFingerPrint(item.key);\n  }\n\n  async getNamedExtractableKey(name: string, failIfNotFound = false): Promise<Result<KeyWithFingerExtract>> {\n    const ret = await this.getNamedKey(name, failIfNotFound);\n    if (ret.isErr()) {\n      return ret as unknown as Result<KeyWithFingerExtract>;\n    }\n    const named = ret.Ok();\n    return Result.Ok({\n      ...named,\n      extract: async () => {\n        const ext = new Uint8Array((await this.rt.crypto.exportKey(\"raw\", named.key)) as ArrayBuffer);\n        return {\n          key: ext,\n          keyStr: base58btc.encode(ext),\n        };\n      },\n    });\n  }\n\n  async getNamedKey(name: string, failIfNotFound = false): Promise<Result<KeyWithFingerPrint>> {\n    const id = this.rt.sthis.nextId(4).str;\n    return this._seq.add(async () => {\n      const bag = await this.rt.getBag();\n      const named = await bag.get(name);\n      if (named) {\n        const fpr = await this.toKeyWithFingerPrint(named.key);\n        this.logger.Debug().Str(\"id\", id).Str(\"name\", name).Result(\"fpr\", fpr).Msg(\"fingerPrint getNamedKey\");\n        return fpr;\n      }\n      if (failIfNotFound) {\n        this.logger.Debug().Str(\"id\", id).Str(\"name\", name).Msg(\"failIfNotFound getNamedKey\");\n        return Result.Err(new Error(`Key not found: ${name}`));\n      }\n      // this.logger.Debug().Str(\"id\", id).Str(\"name\", name).Msg(\"createKey getNamedKey-pre\");\n      const ret = await this._setNamedKey(name, base58btc.encode(this.rt.crypto.randomBytes(this.rt.keyLength)));\n      this.logger.Debug().Str(\"id\", id).Str(\"name\", name).Result(\"fpr\", ret).Msg(\"createKey getNamedKey-post\");\n      return ret;\n    });\n  }\n}\n\nexport interface KeyItem {\n  readonly name: string;\n  readonly key: string;\n}\nexport type KeyBagFile = Record<string, KeyItem>;\n\nexport interface KeyBagOpts {\n  // in future you can encrypt the keybag with ?masterkey=xxxxx\n  readonly url: CoerceURI;\n  // readonly key: string; // key to encrypt the keybag\n  readonly crypto: CryptoRuntime;\n  readonly keyLength: number; // default: 16\n  // readonly logger: Logger;\n  readonly keyRuntime: KeyBagRuntime;\n}\n\nexport interface KeyBagProvider {\n  get(id: string): Promise<KeyItem | undefined>;\n  set(id: string, item: KeyItem): Promise<void>;\n}\nexport interface KeyBagRuntime {\n  readonly url: URI;\n  readonly crypto: CryptoRuntime;\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n  readonly keyLength: number;\n  // readonly key?: FPCryptoKey;\n  getBag(): Promise<KeyBagProvider>;\n  id(): string;\n}\n\nexport type KeyBackProviderFactory = (url: URI, sthis: SuperThis) => Promise<KeyBagProvider>;\n\nexport interface KeyBagProviderFactoryItem {\n  readonly protocol: string;\n  // if this is set the default protocol selection is overridden\n  readonly override?: boolean;\n  readonly factory: KeyBackProviderFactory;\n}\n\nconst keyBagProviderFactories = new Map<string, KeyBagProviderFactoryItem>(\n  [\n    {\n      protocol: \"file:\",\n      factory: async (url: URI, sthis: SuperThis) => {\n        const { KeyBagProviderFile } = await import(\"./key-bag-file.js\");\n        return new KeyBagProviderFile(url, sthis);\n      },\n    },\n    {\n      protocol: \"indexdb:\",\n      factory: async (url: URI, sthis: SuperThis) => {\n        const { KeyBagProviderIndexDB } = await import(\"./key-bag-indexdb.js\");\n        return new KeyBagProviderIndexDB(url, sthis);\n      },\n    },\n  ].map((i) => [i.protocol, i]),\n);\n\nexport function registerKeyBagProviderFactory(item: KeyBagProviderFactoryItem) {\n  const protocol = item.protocol.endsWith(\":\") ? item.protocol : item.protocol + \":\";\n  keyBagProviderFactories.set(protocol, {\n    ...item,\n    protocol,\n  });\n}\n\nfunction defaultKeyBagOpts(sthis: SuperThis, kbo: Partial<KeyBagOpts>): KeyBagRuntime {\n  if (kbo.keyRuntime) {\n    return kbo.keyRuntime;\n  }\n  const logger = ensureLogger(sthis, \"KeyBag\");\n  let url: URI;\n  if (kbo.url) {\n    url = URI.from(kbo.url);\n    logger.Debug().Url(url).Msg(\"from opts\");\n  } else {\n    let bagFnameOrUrl = sthis.env.get(\"FP_KEYBAG_URL\");\n    if (runtimeFn().isBrowser) {\n      url = URI.from(bagFnameOrUrl || \"indexdb://fp-keybag\");\n    } else {\n      if (!bagFnameOrUrl) {\n        const home = sthis.env.get(\"HOME\");\n        bagFnameOrUrl = `${home}/.fireproof/keybag`;\n        url = URI.from(`file://${bagFnameOrUrl}`);\n      } else {\n        url = URI.from(bagFnameOrUrl);\n      }\n    }\n    logger.Debug().Url(url).Msg(\"from env\");\n  }\n  const kitem = keyBagProviderFactories.get(url.protocol);\n  if (!kitem) {\n    throw logger.Error().Url(url).Msg(\"unsupported protocol\").AsError();\n  }\n  const getBag = async () => kitem.factory(url, sthis);\n\n  if (url.hasParam(\"masterkey\")) {\n    throw logger.Error().Url(url).Msg(\"masterkey is not supported\").AsError();\n  }\n  return {\n    url,\n    crypto: kbo.crypto || toCryptoRuntime({}),\n    sthis,\n    logger,\n    keyLength: kbo.keyLength || 16,\n    getBag,\n    id: () => {\n      return url.toString();\n    },\n  };\n}\n\nconst _keyBags = new KeyedResolvOnce<KeyBag>();\nexport async function getKeyBag(sthis: SuperThis, kbo: Partial<KeyBagOpts> = {}): Promise<KeyBag> {\n  await sthis.start();\n  const rt = defaultKeyBagOpts(sthis, kbo);\n  return _keyBags.get(rt.id()).once(async () => new KeyBag(rt));\n}\n","import { FileTransactionMeta } from \"../types\";\nimport { CarTransaction } from \"./transaction\";\nimport {\n  AnyBlock,\n  AnyLink,\n  CarGroup,\n  CarHeader,\n  CarLog,\n  CarMakeable,\n  CommitOpts,\n  DataStore,\n  DbMeta,\n  MetaStore,\n  toCIDBlock,\n  TransactionMeta,\n  WALStore,\n} from \"./types\";\nimport * as CBW from \"@ipld/car/buffer-writer\";\nimport { CID } from \"multiformats\";\nimport { encode } from \"../runtime/wait-pr-multiformats/block.js\";\nimport { BlockEncoder } from \"../runtime/wait-pr-multiformats/codec-interface.js\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport * as dagCodec from \"@ipld/dag-cbor\";\n\nasync function encodeCarFile(roots: AnyLink[], t: CarMakeable, codec: BlockEncoder<number, Uint8Array>): Promise<AnyBlock> {\n  let size = 0;\n  const headerSize = CBW.headerLength({ roots } as { roots: CID<unknown, number, number, 1>[] });\n  size += headerSize;\n  for (const { cid, bytes } of t.entries()) {\n    size += CBW.blockLength({ cid, bytes } as CBW.Block);\n  }\n  const buffer = new Uint8Array(size);\n  const writer = CBW.createWriter(buffer, { headerSize });\n\n  for (const r of roots) {\n    writer.addRoot(r as CID<unknown, number, number, 1>);\n  }\n\n  for (const { cid, bytes } of t.entries()) {\n    writer.write({ cid, bytes } as CBW.Block);\n  }\n  writer.close();\n  return await encode({ value: writer.bytes, hasher, codec });\n}\n\nexport async function createCarFile(\n  encoder: BlockEncoder<number, Uint8Array>,\n  cid: AnyLink,\n  t: CarTransaction,\n): Promise<{ cid: AnyLink; bytes: Uint8Array }> {\n  // try {\n  return encodeCarFile([cid], t, encoder);\n  //   const keycr = await store.keyedCrypto()\n  //   return keycr.isEncrypting\n  //     ? await encryptedEncodeCarFile(this.logger, keycr, cid, t)\n  //     : await encodeCarFile([cid], t);\n  // } catch (e) {\n  // throw store.logger.Error().Err(e).Msg(\"error creating car file\").AsError();\n  // }\n}\n\nexport async function commitFiles(\n  fileStore: DataStore,\n  walStore: WALStore,\n  t: CarTransaction,\n  done: TransactionMeta,\n  // opts: CommitOpts = { noLoader: false, compact: false },\n): Promise<CarGroup> {\n  const { files: roots } = makeFileCarHeader(done as FileTransactionMeta) as {\n    files: AnyLink[];\n  };\n  const cids: AnyLink[] = [];\n  // const fileStore = await this.fileStore();\n  const codec = (await fileStore.keyedCrypto()).codec();\n  const cars = await prepareCarFilesFiles(codec, roots, t);\n  for (const car of cars) {\n    const { cid, bytes } = car;\n    // real deal\n    await fileStore.save({ cid, bytes });\n    await walStore.enqueueFile(cid /*, !!opts.public*/);\n    cids.push(cid);\n  }\n  return cids;\n}\n\nfunction makeFileCarHeader(result: FileTransactionMeta): TransactionMeta {\n  const files: AnyLink[] = [];\n  for (const [, meta] of Object.entries(result.files || {})) {\n    if (meta && typeof meta === \"object\" && \"cid\" in meta && meta !== null) {\n      files.push(meta.cid as AnyLink);\n    }\n  }\n  return { ...result, files };\n}\n\nasync function prepareCarFilesFiles(\n  encoder: BlockEncoder<number, Uint8Array>,\n  roots: AnyLink[],\n  t: CarTransaction,\n  // isPublic: boolean,\n): Promise<{ cid: AnyLink; bytes: Uint8Array }[]> {\n  // const theKey = isPublic ? null : await this._getKey();\n  // const kc = await store.keyedCrypto()\n  // const car = kc.isEncrypting\n  //   ? await encryptedEncodeCarFile(this.logger, kc, roots[0], t)\n  //   : await encodeCarFile(roots, t);\n  return [await encodeCarFile(roots, t, encoder)];\n}\n\n// PUR Commit\n\nfunction makeCarHeader<T>(meta: T, cars: CarLog, compact = false): CarHeader<T> {\n  const coreHeader = compact ? { cars: [], compact: cars } : { cars, compact: [] };\n  return { ...coreHeader, meta };\n}\n\nasync function encodeCarHeader<T>(fp: CarHeader<T>) {\n  return (await encode({\n    value: { fp },\n    hasher,\n    codec: dagCodec,\n  })) as AnyBlock;\n}\n\nexport interface CommitParams {\n  readonly encoder: BlockEncoder<number, Uint8Array>;\n  readonly carLog: CarLog;\n  readonly carStore: DataStore;\n  readonly WALStore: WALStore;\n  readonly metaStore: MetaStore;\n  readonly threshold?: number;\n}\n\nexport async function commit<T>(\n  params: CommitParams,\n  t: CarTransaction,\n  done: T,\n  opts: CommitOpts = { noLoader: false, compact: false },\n): Promise<{ cgrp: CarGroup; header: CarHeader<T> }> {\n  const fp = makeCarHeader<T>(done, params.carLog, !!opts.compact);\n  const rootBlock = await encodeCarHeader(fp);\n\n  const cars = await prepareCarFiles(params.encoder, params.threshold, rootBlock, t);\n  const cids: AnyLink[] = [];\n  for (const car of cars) {\n    const { cid, bytes } = car;\n    await params.carStore.save({ cid, bytes });\n    cids.push(cid);\n  }\n\n  // await this.cacheTransaction(t);\n  const newDbMeta = { cars: cids } as DbMeta;\n  await params.WALStore.enqueue(newDbMeta, opts);\n  await params.metaStore.save(newDbMeta);\n  return { cgrp: cids, header: fp };\n}\n\nasync function prepareCarFiles(\n  encoder: BlockEncoder<number, Uint8Array>,\n  threshold: number | undefined,\n  rootBlock: AnyBlock,\n  t: CarTransaction,\n): Promise<{ cid: AnyLink; bytes: Uint8Array }[]> {\n  // const theKey = isPublic ? undefined : await this._getKey();\n  const carFiles: { cid: AnyLink; bytes: Uint8Array }[] = [];\n  threshold = threshold || 1000 * 1000;\n  let clonedt = new CarTransaction(t.parent, { add: false, noLoader: false });\n  clonedt.putSync(rootBlock.cid, rootBlock.bytes);\n  let newsize = CBW.blockLength(toCIDBlock(rootBlock));\n  let cidRootBlock = rootBlock;\n  for (const { cid, bytes } of t.entries()) {\n    newsize += CBW.blockLength(toCIDBlock({ cid: cid, bytes }));\n    if (newsize >= threshold) {\n      carFiles.push(await createCarFile(encoder, cidRootBlock.cid, clonedt));\n      clonedt = new CarTransaction(t.parent, { add: false, noLoader: false });\n      clonedt.putSync(cid, bytes);\n      cidRootBlock = { cid, bytes };\n      newsize = CBW.blockLength(toCIDBlock({ cid, bytes })); //+ CBW.blockLength(rootBlock)\n    } else {\n      clonedt.putSync(cid, bytes);\n    }\n  }\n  // HEREMENO\n  carFiles.push(await createCarFile(encoder, cidRootBlock.cid, clonedt));\n  // console.log(\"split to \", carFiles.length, \"files\")\n  return carFiles;\n}\n","import { Logger } from \"@adviser/cement\";\nimport type { CarClockLink, DbMeta } from \"./types.js\";\nimport { ensureLogger } from \"../utils.js\";\nimport { SuperThis } from \"../types.js\";\n\ninterface TaskItem {\n  readonly cid: string;\n  readonly dbMeta: DbMeta;\n  retries: number;\n}\n\nexport class TaskManager {\n  private readonly eventsWeHandled = new Set<string>();\n\n  private queue: TaskItem[] = [];\n  private isProcessing = false;\n\n  readonly logger: Logger;\n  readonly callback: (dbMeta: DbMeta) => Promise<void>;\n  constructor(sthis: SuperThis, callback: (dbMeta: DbMeta) => Promise<void>) {\n    this.logger = ensureLogger(sthis, \"TaskManager\");\n    this.callback = callback;\n  }\n\n  async handleEvent(cid: CarClockLink, parents: string[], dbMeta: DbMeta) {\n    for (const parent of parents) {\n      this.eventsWeHandled.add(parent.toString());\n    }\n    this.queue.push({ cid: cid.toString(), dbMeta, retries: 0 });\n    this.queue = this.queue.filter(({ cid }) => !this.eventsWeHandled.has(cid));\n    void this.processQueue();\n  }\n\n  private async processQueue() {\n    if (this.isProcessing) return;\n    this.isProcessing = true;\n    const filteredQueue = this.queue.filter(({ cid }) => !this.eventsWeHandled.has(cid));\n    const first = filteredQueue[0];\n    if (!first) {\n      return;\n    }\n    try {\n      await this.callback(first.dbMeta);\n      this.eventsWeHandled.add(first.cid);\n      this.queue = this.queue.filter(({ cid }) => !this.eventsWeHandled.has(cid));\n    } catch (err) {\n      if (first.retries++ > 3) {\n        this.logger.Error().Str(\"cid\", first.cid).Msg(\"failed to process event block after 3 retries\");\n        this.queue = this.queue.filter(({ cid }) => cid !== first.cid);\n      }\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      throw this.logger.Error().Err(err).Msg(\"failed to process event block\").AsError();\n    } finally {\n      this.isProcessing = false;\n      if (this.queue.length > 0) {\n        void this.processQueue();\n      }\n    }\n  }\n}\n","import { CryptoRuntime, Logger, URI } from \"@adviser/cement\";\nimport { BytesWithIv, CodecOpts, IvAndBytes, IvKeyIdData, KeyedCrypto, KeyWithFingerPrint } from \"../blockstore\";\nimport { ensureLogger, UInt8ArrayEqual } from \"../utils.js\";\nimport { KeyBag } from \"./key-bag\";\nimport type { BlockCodec } from \"./wait-pr-multiformats/codec-interface\";\nimport { base58btc } from \"multiformats/bases/base58\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport * as CBOR from \"cborg\";\nimport { SuperThis } from \"../types.js\";\n\ninterface GenerateIVFn {\n  calc(ko: KeyedCrypto, crypto: CryptoRuntime, data: Uint8Array): Promise<Uint8Array>;\n  verify(ko: KeyedCrypto, crypto: CryptoRuntime, iv: Uint8Array, data: Uint8Array): Promise<boolean>;\n}\n\nconst generateIV: Record<string, GenerateIVFn> = {\n  random: {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    calc: async (ko: KeyedCrypto, crypto: CryptoRuntime, data: Uint8Array): Promise<Uint8Array> => {\n      return crypto.randomBytes(ko.ivLength);\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    verify: async (ko: KeyedCrypto, crypto: CryptoRuntime, iv: Uint8Array, data: Uint8Array): Promise<boolean> => {\n      return true;\n    },\n  },\n  hash: {\n    calc: async (ko: KeyedCrypto, crypto: CryptoRuntime, data: Uint8Array): Promise<Uint8Array> => {\n      const hash = await hasher.digest(data);\n      const hashBytes = new Uint8Array(hash.bytes);\n      const hashArray = new Uint8Array(ko.ivLength);\n      for (let i = 0; i < hashBytes.length; i++) {\n        hashArray[i % ko.ivLength] ^= hashBytes[i];\n      }\n      return hashArray;\n    },\n    verify: async function (ko: KeyedCrypto, crypto: CryptoRuntime, iv: Uint8Array, data: Uint8Array): Promise<boolean> {\n      return ko.url.getParam(\"ivverify\") !== \"disable\" && UInt8ArrayEqual(iv, await this.calc(ko, crypto, data));\n    },\n  },\n};\n\nfunction getGenerateIVFn(url: URI, opts: Partial<CodecOpts>): GenerateIVFn {\n  const ivhash = opts.ivCalc || url.getParam(\"ivhash\") || \"hash\";\n  return generateIV[ivhash] || generateIV[\"hash\"];\n}\n\nexport class BlockIvKeyIdCodec implements BlockCodec<0x300539, Uint8Array> {\n  readonly code = 0x300539;\n  readonly name = \"Fireproof@encrypted-block:aes-gcm\";\n\n  readonly ko: KeyedCrypto;\n  readonly iv?: Uint8Array;\n  readonly opts: Partial<CodecOpts>;\n  constructor(ko: KeyedCrypto, iv?: Uint8Array, opts?: CodecOpts) {\n    this.ko = ko;\n    this.iv = iv;\n    this.opts = opts || {};\n  }\n\n  async encode(data: Uint8Array): Promise<Uint8Array> {\n    const calcIv = this.iv || (await getGenerateIVFn(this.ko.url, this.opts).calc(this.ko, this.ko.crypto, data));\n    const { iv } = this.ko.algo(calcIv);\n    const fprt = await this.ko.fingerPrint();\n    const keyId = base58btc.decode(fprt);\n    this.ko.logger.Debug().Str(\"fp\", fprt).Msg(\"encode\");\n    return CBOR.encode({\n      iv: iv,\n      keyId: keyId,\n      data: await this.ko._encrypt({ iv, bytes: data }),\n    } as IvKeyIdData);\n  }\n\n  async decode(abytes: Uint8Array | ArrayBuffer): Promise<Uint8Array> {\n    let bytes: Uint8Array;\n    if (abytes instanceof Uint8Array) {\n      bytes = abytes;\n    } else {\n      bytes = new Uint8Array(abytes);\n    }\n    const { iv, keyId, data } = CBOR.decode(bytes) as IvKeyIdData;\n    const fprt = await this.ko.fingerPrint();\n    this.ko.logger.Debug().Str(\"fp\", base58btc.encode(keyId)).Msg(\"decode\");\n    if (base58btc.encode(keyId) !== fprt) {\n      throw this.ko.logger.Error().Str(\"fp\", fprt).Str(\"keyId\", base58btc.encode(keyId)).Msg(\"keyId mismatch\").AsError();\n    }\n    const result = await this.ko._decrypt({ iv: iv, bytes: data });\n    if (!this.opts?.noIVVerify && !(await getGenerateIVFn(this.ko.url, this.opts).verify(this.ko, this.ko.crypto, iv, result))) {\n      throw this.ko.logger.Error().Msg(\"iv missmatch\").AsError();\n    }\n    return result;\n  }\n}\n\nclass keyedCrypto implements KeyedCrypto {\n  readonly ivLength = 12;\n  readonly logger: Logger;\n  readonly crypto: CryptoRuntime;\n  readonly key: KeyWithFingerPrint;\n  readonly isEncrypting = true;\n  readonly url: URI;\n  constructor(url: URI, key: KeyWithFingerPrint, cyopt: CryptoRuntime, sthis: SuperThis) {\n    this.logger = ensureLogger(sthis, \"keyedCrypto\");\n    this.crypto = cyopt;\n    this.key = key;\n    this.url = url;\n  }\n  fingerPrint(): Promise<string> {\n    return Promise.resolve(this.key.fingerPrint);\n  }\n  codec(iv?: Uint8Array, opts?: CodecOpts): BlockCodec<number, Uint8Array> {\n    return new BlockIvKeyIdCodec(this, iv, opts);\n  }\n  algo(iv?: Uint8Array) {\n    return {\n      name: \"AES-GCM\",\n      iv: iv || this.crypto.randomBytes(this.ivLength),\n      tagLength: 128,\n    };\n  }\n  async _decrypt(data: IvAndBytes): Promise<Uint8Array> {\n    this.logger.Debug().Len(data.bytes, \"bytes\").Len(data.iv, \"iv\").Str(\"fp\", this.key.fingerPrint).Msg(\"decrypting\");\n    return new Uint8Array(await this.crypto.decrypt(this.algo(data.iv), this.key.key, data.bytes));\n  }\n  async _encrypt(data: BytesWithIv): Promise<Uint8Array> {\n    this.logger.Debug().Len(data.bytes).Str(\"fp\", this.key.fingerPrint).Msg(\"encrypting\");\n    const a = this.algo(data.iv);\n    return new Uint8Array(await this.crypto.encrypt(a, this.key.key, data.bytes));\n  }\n}\n\nclass nullCodec implements BlockCodec<0x0, Uint8Array> {\n  readonly code = 0x0;\n  readonly name = \"Fireproof@unencrypted-block\";\n\n  encode(data: Uint8Array): Uint8Array {\n    return data;\n  }\n  decode(data: Uint8Array): Uint8Array {\n    return data;\n  }\n}\n\nclass noCrypto implements KeyedCrypto {\n  readonly ivLength = 0;\n  readonly code = 0x0;\n  readonly name = \"Fireproof@unencrypted-block\";\n  readonly logger: Logger;\n  readonly crypto: CryptoRuntime;\n  readonly isEncrypting = false;\n  readonly _fingerPrint = \"noCrypto:\" + Math.random();\n  readonly url: URI;\n  constructor(url: URI, cyrt: CryptoRuntime, sthis: SuperThis) {\n    this.logger = ensureLogger(sthis, \"noCrypto\");\n    this.crypto = cyrt;\n    this.url = url;\n  }\n\n  fingerPrint(): Promise<string> {\n    return Promise.resolve(this._fingerPrint);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  codec(iv?: Uint8Array): BlockCodec<number, Uint8Array> {\n    return new nullCodec();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  algo(iv?: Uint8Array): { name: string; iv: Uint8Array; tagLength: number } {\n    return {\n      name: \"noCrypto\",\n      iv: new Uint8Array(),\n      tagLength: 0,\n    };\n  }\n  _decrypt(): Promise<Uint8Array> {\n    throw this.logger.Error().Msg(\"noCrypto.decrypt not implemented\").AsError();\n  }\n  _encrypt(): Promise<Uint8Array> {\n    throw this.logger.Error().Msg(\"noCrypto.decrypt not implemented\").AsError();\n  }\n}\n\nexport async function keyedCryptoFactory(url: URI, kb: KeyBag, sthis: SuperThis): Promise<KeyedCrypto> {\n  const storekey = url.getParam(\"storekey\");\n  if (storekey && storekey !== \"insecure\") {\n    let rkey = await kb.getNamedKey(storekey, true);\n    if (rkey.isErr()) {\n      try {\n        rkey = await kb.toKeyWithFingerPrint(storekey);\n      } catch (e) {\n        throw (\n          sthis.logger\n            .Error()\n            .Err(e)\n            .Str(\"keybag\", kb.rt.id())\n            // .Result(\"key\", rkey)\n            .Str(\"name\", storekey)\n            .Msg(\"getNamedKey failed\")\n            .AsError()\n        );\n      }\n    }\n    return new keyedCrypto(url, rkey.Ok(), kb.rt.crypto, sthis);\n  }\n  return new noCrypto(url, kb.rt.crypto, sthis);\n}\n","import { Logger, Result, URI } from \"@adviser/cement\";\n\nimport { base58btc } from \"multiformats/bases/base58\";\nimport { encode, decode } from \"cborg\";\nimport { Gateway, GetResult, VoidResult } from \"./gateway.js\";\nimport { SuperThis } from \"../types.js\";\nimport { ensureSuperLog } from \"../utils.js\";\n\nfunction getFragSize(url: URI): number {\n  const fragSize = url.getParam(\"fragSize\");\n  let ret = 0;\n  if (fragSize) {\n    ret = parseInt(fragSize);\n  }\n  if (isNaN(ret) || ret <= 0) {\n    ret = 0;\n  }\n  return ret;\n}\n\nasync function getFrags(url: URI, innerGW: Gateway, headerSize: number, logger: Logger): Promise<Result<Fragment>[]> {\n  const fragSize = getFragSize(url);\n  if (!fragSize) {\n    const res = await innerGW.get(url);\n    if (res.isErr()) {\n      return [res as unknown as Result<Fragment>];\n    }\n    const data = res.unwrap();\n    return [\n      Result.Ok({\n        fid: new Uint8Array(0),\n        ofs: 0,\n        len: data.length,\n        data,\n      }),\n    ];\n  }\n  const firstRaw = await innerGW.get(url.build().setParam(\"ofs\", \"0\").URI());\n  if (firstRaw.isErr()) {\n    return [firstRaw as unknown as Result<Fragment>];\n  }\n  const firstFragment = decode(firstRaw.unwrap()) as Fragment;\n  const blockSize = firstFragment.data.length;\n  const ops: Promise<Result<Fragment>>[] = [Promise.resolve(Result.Ok(firstFragment))];\n  const fidStr = base58btc.encode(firstFragment.fid);\n  const fragUrl = url\n    .build()\n    .setParam(\"fid\", fidStr)\n    .setParam(\"len\", firstFragment.len.toString())\n    .setParam(\"headerSize\", headerSize.toString());\n\n  for (let ofs = blockSize; ofs < firstFragment.len; ofs += blockSize) {\n    ops.push(\n      (async (furl, ofs): Promise<Result<Fragment>> => {\n        const raw = await innerGW.get(furl);\n        if (raw.isErr()) {\n          return raw as unknown as Result<Fragment>;\n        }\n        const fragment = decode(raw.unwrap());\n        if (base58btc.encode(fragment.fid) !== fidStr) {\n          return Result.Err(logger.Error().Msg(\"Fragment fid mismatch\").AsError());\n        }\n        if (fragment.ofs !== ofs) {\n          return Result.Err(logger.Error().Uint64(\"ofs\", ofs).Msg(\"Fragment ofs mismatch\").AsError());\n        }\n        return Result.Ok(fragment);\n      })(fragUrl.setParam(\"ofs\", ofs.toString()).URI(), ofs),\n    );\n  }\n  return Promise.all(ops);\n}\n\ninterface Fragment {\n  readonly fid: Uint8Array;\n  readonly ofs: number;\n  readonly len: number;\n  readonly data: Uint8Array;\n}\n\nexport class FragmentGateway implements Gateway {\n  readonly sthis: SuperThis;\n  readonly logger: Logger;\n  readonly fidLength = 4;\n\n  readonly innerGW: Gateway;\n  headerSize = 32;\n\n  constructor(sthis: SuperThis, innerGW: Gateway) {\n    this.sthis = ensureSuperLog(sthis, \"FragmentGateway\");\n    this.logger = this.sthis.logger;\n    this.innerGW = innerGW;\n  }\n\n  slicer(url: URI, body: Uint8Array): Promise<VoidResult>[] {\n    const fragSize = getFragSize(url);\n    if (!fragSize) {\n      return [this.innerGW.put(url, body)];\n    }\n    const blocksize = fragSize - this.headerSize;\n    if (blocksize <= 0) {\n      throw this.logger\n        .Error()\n        .Uint64(\"fragSize\", fragSize)\n        .Uint64(\"headerSize\", this.headerSize)\n        .Msg(\"Fragment size is too small\")\n        .AsError();\n    }\n    const ops: Promise<VoidResult>[] = [];\n    const fid = this.sthis.nextId(this.fidLength);\n    const fragUrl = url\n      .build()\n      .setParam(\"fid\", fid.str)\n      .setParam(\"len\", body.length.toString())\n      .setParam(\"headerSize\", this.headerSize.toString());\n    for (let ofs = 0; ofs < body.length; ofs += blocksize) {\n      const block = encode({\n        fid: fid.bin,\n        ofs,\n        len: body.length,\n        data: body.slice(ofs, ofs + blocksize),\n      } as Fragment);\n      if (block.length > fragSize) {\n        throw this.logger.Error().Uint64(\"block\", block.length).Uint64(\"fragSize\", fragSize).Msg(\"Block size to big\").AsError();\n      }\n      ops.push(this.innerGW.put(fragUrl.setParam(\"ofs\", ofs.toString()).URI(), block));\n    }\n    return ops;\n  }\n\n  buildUrl(baseUrl: URI, key: string): Promise<Result<URI>> {\n    return this.innerGW.buildUrl(baseUrl, key);\n  }\n\n  async destroy(iurl: URI): Promise<Result<void>> {\n    return this.innerGW.destroy(iurl);\n  }\n\n  async start(url: URI): Promise<Result<URI>> {\n    this.headerSize =\n      encode({\n        fid: this.sthis.nextId(this.fidLength).bin,\n        ofs: 1024 * 1024, // 32bit\n        len: 16 * 1024 * 1024, // 32bit\n        data: new Uint8Array(1024),\n      }).length - 1024;\n    return this.innerGW.start(url);\n  }\n\n  async close(url: URI): Promise<VoidResult> {\n    return this.innerGW.close(url);\n  }\n\n  async put(url: URI, body: Uint8Array): Promise<VoidResult> {\n    await Promise.all(this.slicer(url, body));\n    return Result.Ok(undefined);\n  }\n\n  async get(url: URI): Promise<GetResult> {\n    const rfrags = await getFrags(url, this.innerGW, this.headerSize, this.logger);\n    let buffer: Uint8Array | undefined = undefined;\n    for (const rfrag of rfrags) {\n      if (rfrag.isErr()) {\n        return Result.Err(rfrag.Err());\n      }\n      const frag = rfrag.Ok();\n      buffer = buffer || new Uint8Array(frag.len);\n      buffer.set(frag.data, frag.ofs);\n    }\n    return Result.Ok(buffer || new Uint8Array(0));\n  }\n\n  async subscribe(url: URI, callback: (msg: Uint8Array) => void): Promise<VoidResult> {\n    if (this.innerGW.subscribe) {\n      return this.innerGW.subscribe(url, callback);\n    } else {\n      return Result.Err(this.logger.Error().Msg(\"subscribe not supported\").AsError());\n      // let lastData: Uint8Array | undefined = undefined;\n      // let interval = 100;\n      // const fetchData = async () => {\n      //   const result = await this.innerGW.get(url); // this should be store.load()\n      //   if (result.isOk()) {\n      //     const data = result.Ok();\n      //     if (!lastData || !data.every((value, index) => lastData && value === lastData[index])) {\n      //       lastData = data;\n      //       callback(data);\n      //       interval = 100; // Reset interval when data changes\n      //     } else {\n      //       interval *= 2; // Double the interval when data is unchanged\n      //     }\n      //   }\n      //   timeoutId = setTimeout(fetchData, interval);\n      // };\n      // let timeoutId = setTimeout(fetchData, interval);\n\n      // return Result.Ok(() => {\n      //   clearTimeout(timeoutId);\n      // });\n    }\n  }\n\n  async delete(url: URI): Promise<VoidResult> {\n    const rfrags = await getFrags(url, this.innerGW, this.headerSize, this.logger);\n    for (const rfrag of rfrags) {\n      if (rfrag.isErr()) {\n        return Result.Err(rfrag.Err());\n      }\n      const frag = rfrag.Ok();\n      const fidStr = base58btc.encode(frag.fid);\n      const fragUrl = url\n        .build()\n        .setParam(\"fid\", fidStr)\n        .setParam(\"len\", frag.len.toString())\n        .setParam(\"headerSize\", this.headerSize.toString())\n        .URI();\n      await this.innerGW.delete(fragUrl);\n    }\n    return Result.Ok(undefined);\n  }\n}\n","import { format, parse } from \"@ipld/dag-json\";\nimport { EventBlock, decodeEventBlock } from \"@web3-storage/pail/clock\";\nimport { EventView } from \"@web3-storage/pail/clock/api\";\nimport { BaseStoreImpl, StoreOpts } from \"./store.js\";\nimport type { DbMeta, MetaStore, CarClockHead, DbMetaEventBlock, CarClockLink, LoadHandler } from \"./types.js\";\nimport { SuperThis, CRDTEntry, Falsy } from \"../types.js\";\nimport { CID, Link } from \"multiformats\";\nimport { Result, URI } from \"@adviser/cement\";\nimport { ensureLogger, isNotFoundError } from \"../utils.js\";\nimport * as rt from \"../runtime/index.js\";\n\nasync function decodeGatewayMetaBytesToDbMeta(sthis: SuperThis, byteHeads: Uint8Array) {\n  const crdtEntries = JSON.parse(sthis.txt.decode(byteHeads)) as CRDTEntry[];\n  if (!crdtEntries.length) {\n    sthis.logger.Debug().Str(\"byteHeads\", new TextDecoder().decode(byteHeads)).Msg(\"No CRDT entries found\");\n    return [];\n  }\n  if (!crdtEntries.map) {\n    sthis.logger.Debug().Str(\"crdtEntries\", JSON.stringify(crdtEntries)).Msg(\"No data in CRDT entries\");\n    return [];\n  }\n  return Promise.all(\n    crdtEntries.map(async (crdtEntry) => {\n      const eventBlock = await decodeEventBlock<{ dbMeta: Uint8Array }>(decodeFromBase64(crdtEntry.data));\n      const dbMeta = parse<DbMeta>(sthis.txt.decode(eventBlock.value.data.dbMeta));\n      return {\n        eventCid: eventBlock.cid as CarClockLink,\n        parents: crdtEntry.parents,\n        dbMeta: dbMeta,\n      };\n    }),\n  );\n}\n\nexport async function setCryptoKeyFromGatewayMetaPayload(\n  uri: URI,\n  sthis: SuperThis,\n  data: Uint8Array,\n): Promise<Result<DbMeta | undefined>> {\n  try {\n    sthis.logger.Debug().Str(\"uri\", uri.toString()).Msg(\"Setting crypto key from gateway meta payload\");\n    const keyInfo = await decodeGatewayMetaBytesToDbMeta(sthis, data);\n    if (keyInfo.length) {\n      const dbMeta = keyInfo[0].dbMeta;\n      if (dbMeta.key) {\n        const kb = await rt.kb.getKeyBag(sthis);\n        const keyName = getStoreKeyName(uri);\n        const res = await kb.setNamedKey(keyName, dbMeta.key);\n        if (res.isErr()) {\n          sthis.logger.Debug().Str(\"keyName\", keyName).Str(\"dbMeta.key\", dbMeta.key).Msg(\"Failed to set named key\");\n          throw res.Err();\n        }\n      }\n      sthis.logger.Debug().Str(\"dbMeta.key\", dbMeta.key).Str(\"uri\", uri.toString()).Msg(\"Set crypto key from gateway meta payload\");\n      return Result.Ok(dbMeta);\n    }\n    sthis.logger.Debug().Str(\"data\", new TextDecoder().decode(data)).Msg(\"No crypto in gateway meta payload\");\n    return Result.Ok(undefined);\n  } catch (error) {\n    sthis.logger.Debug().Err(error).Msg(\"Failed to set crypto key from gateway meta payload\");\n    return Result.Err(error as Error);\n  }\n}\n\nexport async function addCryptoKeyToGatewayMetaPayload(uri: URI, sthis: SuperThis, body: Uint8Array): Promise<Result<Uint8Array>> {\n  try {\n    sthis.logger.Debug().Str(\"uri\", uri.toString()).Msg(\"Adding crypto key to gateway meta payload\");\n    const keyName = getStoreKeyName(uri);\n    const kb = await rt.kb.getKeyBag(sthis);\n    const res = await kb.getNamedExtractableKey(keyName, true);\n    if (res.isErr()) {\n      sthis.logger.Error().Str(\"keyName\", keyName).Msg(\"Failed to get named extractable key\");\n      throw res.Err();\n    }\n    const keyData = await res.Ok().extract();\n    const dbMetas = await decodeGatewayMetaBytesToDbMeta(sthis, body);\n    const { dbMeta, parents } = dbMetas[0]; // as { dbMeta: DbMeta };\n    const parentLinks = parents.map((p) => CID.parse(p) as CarClockLink);\n    dbMeta.key = keyData.keyStr;\n    const events = await Promise.all([dbMeta].map((dbMeta) => createDbMetaEventBlock(sthis, dbMeta, parentLinks)));\n    const encoded = await encodeEventsWithParents(sthis, events, parentLinks);\n    sthis.logger.Debug().Str(\"uri\", uri.toString()).Msg(\"Added crypto key to gateway meta payload\");\n    return Result.Ok(encoded);\n  } catch (error) {\n    sthis.logger.Error().Err(error).Msg(\"Failed to add crypto key to gateway meta payload\");\n    return Result.Err(error as Error);\n  }\n}\n\nfunction getStoreKeyName(url: URI): string {\n  const storeKeyName = [url.getParam(\"localName\") || url.getParam(\"name\")];\n  const idx = url.getParam(\"index\");\n  if (idx) {\n    storeKeyName.push(idx);\n  }\n  storeKeyName.push(\"data\");\n  return `@${storeKeyName.join(\":\")}@`;\n}\n\nasync function createDbMetaEventBlock(sthis: SuperThis, dbMeta: DbMeta, parents: CarClockHead): Promise<DbMetaEventBlock> {\n  const event = await EventBlock.create(\n    {\n      dbMeta: sthis.txt.encode(format(dbMeta)),\n    },\n    parents as unknown as Link<EventView<{ dbMeta: Uint8Array }>, number, number, 1>[],\n  );\n  return event as EventBlock<{ dbMeta: Uint8Array }>;\n}\n\nasync function encodeEventsWithParents(\n  sthis: SuperThis,\n  events: EventBlock<{ dbMeta: Uint8Array }>[],\n  parents: CarClockHead,\n): Promise<Uint8Array> {\n  const crdtEntries = events.map((event) => {\n    const base64String = encodeToBase64(event.bytes);\n    return {\n      cid: event.cid.toString(),\n      data: base64String,\n      parents: parents.map((p) => p.toString()),\n    };\n  });\n  return sthis.txt.encode(JSON.stringify(crdtEntries));\n}\n\nexport class MetaStoreImpl extends BaseStoreImpl implements MetaStore {\n  readonly storeType = \"meta\";\n  readonly subscribers = new Map<string, LoadHandler[]>();\n  parents: CarClockHead = [];\n\n  constructor(sthis: SuperThis, name: string, url: URI, opts: StoreOpts, remote?: boolean) {\n    // const my = new URL(url.toString());\n    // my.searchParams.set(\"storekey\", 'insecure');\n    super(\n      name,\n      url,\n      {\n        ...opts,\n      },\n      sthis,\n      ensureLogger(sthis, \"MetaStoreImpl\"),\n    );\n    if (remote && opts.gateway.subscribe) {\n      this.onStarted(async () => {\n        this.logger.Debug().Str(\"url\", this.url().toString()).Msg(\"Subscribing to the gateway\");\n        opts.gateway.subscribe?.(this.url(), async (message: Uint8Array) => {\n          this.logger.Debug().Msg(\"Received message from gateway\");\n          const dbMetas = await decodeGatewayMetaBytesToDbMeta(this.sthis, message);\n          await Promise.all(\n            dbMetas.map((dbMeta) => this.loader?.taskManager?.handleEvent(dbMeta.eventCid, dbMeta.parents, dbMeta.dbMeta)),\n          );\n          this.updateParentsFromDbMetas(dbMetas);\n        });\n      });\n    }\n  }\n\n  private updateParentsFromDbMetas(dbMetas: { eventCid: CarClockLink }[]) {\n    const cids = dbMetas.map((m) => m.eventCid);\n    const uniqueParentsMap = new Map([...this.parents, ...cids].map((p) => [p.toString(), p]));\n    this.parents = Array.from(uniqueParentsMap.values());\n  }\n\n  async handleByteHeads(byteHeads: Uint8Array) {\n    return await decodeGatewayMetaBytesToDbMeta(this.sthis, byteHeads);\n  }\n\n  async load(): Promise<DbMeta[] | Falsy> {\n    const branch = \"main\";\n    const url = await this.gateway.buildUrl(this.url(), branch);\n    if (url.isErr()) {\n      throw this.logger.Error().Result(\"buildUrl\", url).Str(\"branch\", branch).Msg(\"got error from gateway.buildUrl\").AsError();\n    }\n    const bytes = await this.gateway.get(url.Ok());\n    if (bytes.isErr()) {\n      if (isNotFoundError(bytes)) {\n        return undefined;\n      }\n      throw this.logger.Error().Url(url.Ok()).Result(\"bytes:\", bytes).Msg(\"gateway get\").AsError();\n    }\n    const dbMetas = await this.handleByteHeads(bytes.Ok());\n    await this.loader?.handleDbMetasFromStore(dbMetas.map((m) => m.dbMeta)); // the old one didn't await\n    this.updateParentsFromDbMetas(dbMetas);\n    return dbMetas.map((m) => m.dbMeta);\n  }\n\n  async save(meta: DbMeta, branch?: string): Promise<Result<void>> {\n    branch = branch || \"main\";\n    this.logger.Debug().Str(\"branch\", branch).Any(\"meta\", meta).Msg(\"saving meta\");\n    const event = await createDbMetaEventBlock(this.sthis, meta, this.parents);\n    const bytes = await encodeEventsWithParents(this.sthis, [event], this.parents);\n    const url = await this.gateway.buildUrl(this.url(), branch);\n    if (url.isErr()) {\n      throw this.logger.Error().Err(url.Err()).Str(\"branch\", branch).Msg(\"got error from gateway.buildUrl\").AsError();\n    }\n    const res = await this.gateway.put(url.Ok(), bytes);\n    if (res.isErr()) {\n      throw this.logger.Error().Err(res.Err()).Msg(\"got error from gateway.put\").AsError();\n    }\n    await this.loader?.handleDbMetasFromStore([meta]);\n    this.parents = [event.cid];\n    return res;\n  }\n\n  async close(): Promise<Result<void>> {\n    await this.gateway.close(this.url());\n    this._onClosed.forEach((fn) => fn());\n    return Result.Ok(undefined);\n  }\n  async destroy(): Promise<Result<void>> {\n    return this.gateway.destroy(this.url());\n  }\n}\n\nfunction encodeToBase64(bytes: Uint8Array): string {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  let base64 = \"\";\n  let i;\n  for (i = 0; i < bytes.length - 2; i += 3) {\n    base64 += chars[bytes[i] >> 2];\n    base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n    base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n    base64 += chars[bytes[i + 2] & 63];\n  }\n  if (i < bytes.length) {\n    base64 += chars[bytes[i] >> 2];\n    if (i === bytes.length - 1) {\n      base64 += chars[(bytes[i] & 3) << 4];\n      base64 += \"==\";\n    } else {\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[(bytes[i + 1] & 15) << 2];\n      base64 += \"=\";\n    }\n  }\n  return base64;\n}\n\nfunction decodeFromBase64(base64: string): Uint8Array {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  const bytes = new Uint8Array((base64.length * 3) / 4);\n  let i;\n  let j = 0;\n  for (i = 0; i < base64.length; i += 4) {\n    const a = chars.indexOf(base64[i]);\n    const b = chars.indexOf(base64[i + 1]);\n    const c = chars.indexOf(base64[i + 2]);\n    const d = chars.indexOf(base64[i + 3]);\n    bytes[j++] = (a << 2) | (b >> 4);\n    if (base64[i + 2] !== \"=\") {\n      bytes[j++] = ((b & 15) << 4) | (c >> 2);\n    }\n    if (base64[i + 3] !== \"=\") {\n      bytes[j++] = ((c & 3) << 6) | d;\n    }\n  }\n  return bytes.slice(0, j);\n}\n","// export * from \"./sys-container.js\";\nexport * from \"./gateways/file/utils.js\";\n\n// export * as sql from \"./store-sql/index.js\";\nexport * as files from \"./files.js\";\n\nexport * as kb from \"./key-bag.js\";\nexport * as kc from \"./keyed-crypto.js\";\n\nexport * as mf from \"./wait-pr-multiformats/index.js\";\n\nexport { runtimeFn } from \"@adviser/cement\";\n\nexport { FILESTORE_VERSION } from \"./gateways/file/version.js\";\nexport { INDEXDB_VERSION } from \"./gateways/indexdb/version.js\";\n// export { V0_19SQL_VERSION } from \"./store-sql/v0.19/version.js\";\n","export * as block from \"./block.js\";\nexport * as codec from \"./codec-interface.js\";\n","import type { ArrayBufferView, ByteView } from \"multiformats\";\n\n/**\n * IPLD encoder part of the codec.\n */\nexport interface BlockEncoder<Code extends number, T> {\n  name: string;\n  code: Code;\n  encode(data: T): ByteView<T> | PromiseLike<ByteView<T>>;\n}\n\n/**\n * IPLD decoder part of the codec.\n */\nexport interface BlockDecoder<Code extends number, T> {\n  code: Code;\n  decode(bytes: ByteView<T> | ArrayBufferView<T>): T | PromiseLike<T>;\n}\n\n/**\n * An IPLD codec is a combination of both encoder and decoder.\n */\nexport interface BlockCodec<Code extends number, T> extends BlockEncoder<Code, T>, BlockDecoder<Code, T> {}\n\nexport type { ArrayBufferView, ByteView };\n","export const FILESTORE_VERSION = \"v0.19-file\";\n","import { URI } from \"@adviser/cement\";\nimport { DataStoreImpl, StoreOpts } from \"./store.js\";\nimport { MetaStoreImpl } from \"./store-meta.js\";\nimport { SuperThis } from \"../types.js\";\n\n// export type LoadHandler = (dbMetas: DbMeta[]) => Promise<void>;\n// export function validateDataParams(params: DownloadDataFnParams | UploadDataFnParams, logger: Logger) {\n//   const { type, name, car } = params;\n//   if (!name) throw logger.Error().Msg(\"name is required\").AsError();\n//   if (!car) {\n//     throw logger.Error().Msg(\"car is required\").AsError();\n//   }\n//   if (type !== \"file\" && type !== \"data\") {\n//     throw logger.Error().Msg(\"type must be file or data\").AsError();\n//   }\n// }\n\n// export function validateMetaParams(params: DownloadMetaFnParams | UploadMetaFnParams, logger: Logger) {\n//   const { name, branch } = params;\n//   if (!name) throw logger.Error().Msg(\"name is required\").AsError();\n//   if (!branch) {\n//     throw logger.Error().Msg(\"branch is required\").AsError();\n//   }\n// }\n\n// export class RemoteDataStore extends DataStoreImpl {\n//   // just for explaining the concept\n// }\n\n// export class RemoteMetaStore extends MetaStoreImpl {\n//   // just for explaining the concept\n// }\n\nexport async function RemoteDataStore(sthis: SuperThis, name: string, url: URI, opts: StoreOpts) {\n  const ds = new DataStoreImpl(sthis, name, url, opts);\n  await ds.start();\n  return ds;\n}\nexport async function RemoteMetaStore(sthis: SuperThis, name: string, url: URI, opts: StoreOpts) {\n  const ms = new MetaStoreImpl(sthis, name, url, opts, true);\n  await ms.start();\n  return ms;\n}\n\n// export class RemoteWALStore extends WALStoreImpl {\n//   // basicly do nothing write the WAL into memory\n//   constructor(loader: Loadable) {\n\n//     //import { FileWALGateway } from \"../runtime/gateways/file/gateway.js\";\n//     // super(loader, new URL(\"file:///dummy?fs=mem\"), loader.logger, new FileWALGateway(loader.logger));\n//   }\n\n// }\n","import { Logger, URI } from \"@adviser/cement\";\n\nimport { type SuperThis, throwFalsy } from \"../types.js\";\nimport { TaskManager } from \"./task-manager.js\";\nimport type { BlockstoreRuntime, Connection, Loadable } from \"./types.js\";\nimport { type Loader } from \"./loader.js\";\nimport { RemoteDataStore, RemoteMetaStore } from \"./store-remote.js\";\nimport { getGatewayFromURL } from \"./store-factory.js\";\nimport { getKeyBag } from \"../runtime/key-bag.js\";\n\nexport interface Connectable {\n  readonly blockstore: {\n    readonly loader?: Loader;\n    readonly ebOpts: BlockstoreRuntime;\n  };\n  readonly name?: string;\n  readonly sthis: SuperThis;\n}\n\nexport abstract class ConnectionBase implements Connection {\n  // readonly ready: Promise<unknown>;\n  // todo move to LRU blockstore https://github.com/web3-storage/w3clock/blob/main/src/worker/block.js\n  // readonly eventBlocks = new MemoryBlockstore();\n  loader?: Loadable;\n  taskManager?: TaskManager;\n  loaded: Promise<void> = Promise.resolve();\n\n  readonly url: URI;\n\n  // abstract metaUpload(bytes: Uint8Array, params: UploadMetaFnParams): Promise<Uint8Array[] | Falsy>;\n  // abstract dataUpload(bytes: Uint8Array, params: UploadDataFnParams, opts?: { public?: boolean }): Promise<void>;\n  // abstract metaDownload(params: DownloadMetaFnParams): Promise<Uint8Array[] | Falsy>;\n  // abstract dataDownload(params: DownloadDataFnParams): Promise<Uint8Array | Falsy>;\n\n  readonly logger: Logger;\n  constructor(url: URI, logger: Logger) {\n    this.logger = logger;\n    this.url = url;\n  }\n\n  async refresh() {\n    await throwFalsy(throwFalsy(this.loader).remoteMetaStore).load();\n    await (await throwFalsy(this.loader).WALStore()).process();\n  }\n\n  async connect_X({ loader }: { readonly loader?: Loadable }) {\n    if (!loader) throw this.logger.Error().Msg(\"loader is required\").AsError();\n    await this.connectMeta_X({ loader });\n    await this.connectStorage_X({ loader });\n  }\n\n  async connectMeta_X({ loader }: { loader?: Loadable }) {\n    if (!loader) throw this.logger.Error().Msg(\"connectMeta_X: loader is required\").AsError();\n    this.loader = loader;\n    await this.onConnect();\n    const metaUrl = this.url.build().defParam(\"store\", \"meta\").URI();\n    const gateway = await getGatewayFromURL(metaUrl, this.loader.sthis);\n    if (!gateway) throw this.logger.Error().Url(metaUrl).Msg(\"connectMeta_X: gateway is required\").AsError();\n    const dbName = metaUrl.getParam(\"name\");\n    if (!dbName) throw this.logger.Error().Url(metaUrl).Msg(\"connectMeta_X: name is required\").AsError();\n    const remote = await RemoteMetaStore(loader.sthis, dbName, metaUrl, {\n      gateway: gateway.gateway,\n      keybag: () => getKeyBag(loader.sthis, loader.ebOpts.keyBag),\n      loader,\n    });\n    this.loader.remoteMetaStore = remote;\n    this.loaded = this.loader.ready().then(async () => {\n      remote.load().then(async () => {\n        (await throwFalsy(this.loader).WALStore()).process();\n      });\n    });\n  }\n\n  abstract onConnect(): Promise<void>;\n\n  async connectStorage_X({ loader }: { loader?: Loadable }) {\n    if (!loader) throw this.logger.Error().Msg(\"connectStorage_X: loader is required\").AsError();\n    this.loader = loader;\n    const dataUrl = this.url.build().defParam(\"store\", \"data\").URI();\n    const gateway = await getGatewayFromURL(dataUrl, this.loader.sthis);\n    if (!gateway) throw this.logger.Error().Url(dataUrl).Msg(\"connectStorage_X: gateway is required\").AsError();\n    const name = dataUrl.getParam(\"name\");\n    if (!name) throw this.logger.Error().Url(dataUrl).Msg(\"connectStorage_X: name is required\").AsError;\n    loader.remoteCarStore = await RemoteDataStore(loader.sthis, name, this.url, {\n      gateway: gateway.gateway,\n      keybag: () => getKeyBag(loader.sthis, this.loader?.ebOpts.keyBag),\n    });\n    // @jchris why we have a differention between remoteCarStore and remoteFileStore? -- file store is for on-demand attachment loading\n    loader.remoteFileStore = loader.remoteCarStore;\n  }\n\n  // move this stuff to connect\n  // async getDashboardURL(compact = true) {\n  //   const baseUrl = 'https://dashboard.fireproof.storage/'\n  //   if (!this.loader?.remoteCarStore) return new URL('/howto', baseUrl)\n  //   // if (compact) {\n  //   //   await this.compact()\n  //   // }\n  //   const currents = await this.loader?.metaStore?.load()\n  //   if (!currents) throw new Error(\"Can't sync empty database: save data first\")\n  //   if (currents.length > 1)\n  //     throw new Error(\"Can't sync database with split heads: make an update first\")\n  //   const current = currents[0]\n  //   const params = {\n  //     car: current.car.toString()\n  //   }\n  //   if (current.key) {\n  //     // @ts-ignore\n  //     params.key = current.key.toString()\n  //   }\n  //   // @ts-ignore\n  //   if (this.name) {\n  //     // @ts-ignore\n  //     params.name = this.name\n  //   }\n  //   const url = new URL('/import#' + new URLSearchParams(params).toString(), baseUrl)\n  //   console.log('Import to dashboard: ' + url.toString())\n  //   return url\n  // }\n\n  // openDashboard() {\n  //   void this.getDashboardURL().then(url => {\n  //     if (url) window.open(url.toString(), '_blank')\n  //   })\n  // }\n}\n","import { encode, decode, Block } from \"./runtime/wait-pr-multiformats/block.js\";\nimport { parse } from \"multiformats/link\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport * as codec from \"@ipld/dag-cbor\";\nimport { put, get, entries, root } from \"@web3-storage/pail/crdt\";\nimport { EventBlockView, EventLink, Operation, PutOperation } from \"@web3-storage/pail/crdt/api\";\nimport { EventFetcher, vis } from \"@web3-storage/pail/clock\";\nimport * as Batch from \"@web3-storage/pail/crdt/batch\";\nimport {\n  type EncryptedBlockstore,\n  CarTransaction,\n  BlockFetcher,\n  TransactionMeta,\n  AnyLink,\n  StoreRuntime,\n  BaseBlockstore,\n  CompactFetcher,\n} from \"./blockstore/index.js\";\nimport {\n  type IndexKeyType,\n  type DocUpdate,\n  type ClockHead,\n  type DocValue,\n  type CRDTMeta,\n  type ChangesOptions,\n  type DocFileMeta,\n  type DocFiles,\n  type DocSet,\n  type DocWithId,\n  type DocTypes,\n  throwFalsy,\n} from \"./types.js\";\nimport { Result } from \"@web3-storage/pail/crdt/api\";\nimport { Logger } from \"@adviser/cement\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction time(tag: string) {\n  // console.time(tag)\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction timeEnd(tag: string) {\n  // console.timeEnd(tag)\n}\n\nfunction toString<K extends IndexKeyType>(key: K, logger: Logger): string {\n  switch (typeof key) {\n    case \"string\":\n    case \"number\":\n      return key.toString();\n    default:\n      throw logger.Error().Msg(\"Invalid key type\").AsError();\n  }\n}\n\nexport async function applyBulkUpdateToCrdt<T extends DocTypes>(\n  store: StoreRuntime,\n  tblocks: CarTransaction,\n  head: ClockHead,\n  updates: DocUpdate<T>[],\n  logger: Logger,\n): Promise<CRDTMeta> {\n  let result: Result | null = null;\n  if (updates.length > 1) {\n    const batch = await Batch.create(tblocks, head);\n    for (const update of updates) {\n      const link = await writeDocContent(store, tblocks, update, logger);\n      await batch.put(toString(update.id, logger), link);\n    }\n    result = await batch.commit();\n  } else if (updates.length === 1) {\n    const link = await writeDocContent(store, tblocks, updates[0], logger);\n    result = await put(tblocks, head, toString(updates[0].id, logger), link);\n  }\n  if (!result) throw logger.Error().Uint64(\"updates.len\", updates.length).Msg(\"Missing result\").AsError();\n\n  if (result.event) {\n    for (const { cid, bytes } of [\n      ...result.additions,\n      // ...result.removals,\n      result.event,\n    ]) {\n      tblocks.putSync(cid, bytes);\n    }\n  }\n  return { head: result.head } as CRDTMeta;\n}\n\n// this whole thing can get pulled outside of the write queue\nasync function writeDocContent<T extends DocTypes>(\n  store: StoreRuntime,\n  blocks: CarTransaction,\n  update: DocUpdate<T>,\n  logger: Logger,\n): Promise<AnyLink> {\n  let value: Partial<DocValue<T>>;\n  if (update.del) {\n    value = { del: true };\n  } else {\n    if (!update.value) throw logger.Error().Msg(\"Missing value\").AsError();\n    await processFiles(store, blocks, update.value, logger);\n    value = { doc: update.value as DocWithId<T> };\n  }\n  const block = await encode({ value, hasher, codec });\n  blocks.putSync(block.cid, block.bytes);\n  return block.cid;\n}\n\nasync function processFiles<T extends DocTypes>(store: StoreRuntime, blocks: CarTransaction, doc: DocSet<T>, logger: Logger) {\n  if (doc._files) {\n    await processFileset(logger, store, blocks, doc._files);\n  }\n  if (doc._publicFiles) {\n    await processFileset(logger, store, blocks, doc._publicFiles /*, true*/);\n  }\n}\n\nasync function processFileset(\n  logger: Logger,\n  store: StoreRuntime,\n  blocks: CarTransaction,\n  files: DocFiles /*, publicFiles = false */,\n) {\n  const dbBlockstore = blocks.parent as EncryptedBlockstore;\n  if (!dbBlockstore.loader) throw logger.Error().Msg(\"Missing loader, database name is required\").AsError();\n  const t = new CarTransaction(dbBlockstore); // maybe this should move to encrypted-blockstore\n  const didPut = [];\n  // let totalSize = 0\n  for (const filename in files) {\n    if (File === files[filename].constructor) {\n      const file = files[filename] as File;\n\n      // totalSize += file.size\n      const { cid, blocks: fileBlocks } = await store.encodeFile(file);\n      didPut.push(filename);\n      for (const block of fileBlocks) {\n        t.putSync(block.cid, block.bytes);\n      }\n      files[filename] = { cid, type: file.type, size: file.size } as DocFileMeta;\n    } else {\n      const { cid, type, size, car } = files[filename] as DocFileMeta;\n      if (cid && type && size && car) {\n        files[filename] = { cid, type, size, car };\n      }\n    }\n  }\n\n  if (didPut.length) {\n    const car = await dbBlockstore.loader.commitFiles(\n      t,\n      { files } as unknown as TransactionMeta /* {\n      public: publicFiles,\n    } */,\n    );\n    if (car) {\n      for (const name of didPut) {\n        files[name] = { car, ...files[name] } as DocFileMeta;\n      }\n    }\n  }\n}\n\nexport async function getValueFromCrdt<T extends DocTypes>(\n  blocks: BaseBlockstore,\n  head: ClockHead,\n  key: string,\n  logger: Logger,\n): Promise<DocValue<T>> {\n  if (!head.length) throw logger.Debug().Msg(\"Getting from an empty database\").AsError();\n  const link = await get(blocks, head, key);\n  if (!link) throw logger.Error().Str(\"key\", key).Msg(`Missing key`).AsError();\n  return await getValueFromLink(blocks, link, logger);\n}\n\nexport function readFiles<T extends DocTypes>(blocks: BaseBlockstore, { doc }: Partial<DocValue<T>>) {\n  if (!doc) return;\n  if (doc._files) {\n    readFileset(blocks as EncryptedBlockstore, doc._files);\n  }\n  if (doc._publicFiles) {\n    readFileset(blocks as EncryptedBlockstore, doc._publicFiles, true);\n  }\n}\n\nfunction readFileset(blocks: EncryptedBlockstore, files: DocFiles, isPublic = false) {\n  for (const filename in files) {\n    const fileMeta = files[filename] as DocFileMeta;\n    if (fileMeta.cid) {\n      if (isPublic) {\n        fileMeta.url = `https://${fileMeta.cid.toString()}.ipfs.w3s.link/`;\n      }\n      if (fileMeta.car) {\n        fileMeta.file = async () =>\n          await blocks.ebOpts.storeRuntime.decodeFile(\n            {\n              get: async (cid: AnyLink) => {\n                return await blocks.getFile(throwFalsy(fileMeta.car), cid);\n              },\n            },\n            fileMeta.cid,\n            fileMeta,\n          );\n      }\n    }\n    files[filename] = fileMeta;\n  }\n}\n\nasync function getValueFromLink<T extends DocTypes>(blocks: BlockFetcher, link: AnyLink, logger: Logger): Promise<DocValue<T>> {\n  const block = await blocks.get(link);\n  if (!block) throw logger.Error().Str(\"link\", link.toString()).Msg(`Missing linked block`).AsError();\n  const { value } = (await decode({ bytes: block.bytes, hasher, codec })) as { value: DocValue<T> };\n  const cvalue = {\n    ...value,\n    cid: link,\n  };\n  readFiles(blocks as EncryptedBlockstore, cvalue);\n  return cvalue;\n}\n\nclass DirtyEventFetcher<T> extends EventFetcher<T> {\n  readonly logger: Logger;\n  constructor(logger: Logger, blocks: BlockFetcher) {\n    super(blocks);\n    this.logger = logger;\n  }\n  async get(link: EventLink<T>): Promise<EventBlockView<T>> {\n    try {\n      return super.get(link);\n    } catch (e) {\n      this.logger.Error().Ref(\"link\", link.toString()).Err(e).Msg(\"Missing event\");\n      return { value: undefined } as unknown as EventBlockView<T>;\n    }\n  }\n}\n\nexport async function clockChangesSince<T extends DocTypes>(\n  blocks: BlockFetcher,\n  head: ClockHead,\n  since: ClockHead,\n  opts: ChangesOptions,\n  logger: Logger,\n): Promise<{ result: DocUpdate<T>[]; head: ClockHead }> {\n  const eventsFetcher = (\n    opts.dirty ? new DirtyEventFetcher<Operation>(logger, blocks) : new EventFetcher<Operation>(blocks)\n  ) as EventFetcher<Operation>;\n  const keys = new Set<string>();\n  const updates = await gatherUpdates<T>(\n    blocks,\n    eventsFetcher,\n    head,\n    since,\n    [],\n    keys,\n    new Set<string>(),\n    opts.limit || Infinity,\n    logger,\n  );\n  return { result: updates.reverse(), head };\n}\n\nasync function gatherUpdates<T extends DocTypes>(\n  blocks: BlockFetcher,\n  eventsFetcher: EventFetcher<Operation>,\n  head: ClockHead,\n  since: ClockHead,\n  updates: DocUpdate<T>[] = [],\n  keys: Set<string>,\n  didLinks: Set<string>,\n  limit: number,\n  logger: Logger,\n): Promise<DocUpdate<T>[]> {\n  if (limit <= 0) return updates;\n  // if (Math.random() < 0.001) console.log('gatherUpdates', head.length, since.length, updates.length)\n  const sHead = head.map((l) => l.toString());\n  for (const link of since) {\n    if (sHead.includes(link.toString())) {\n      return updates;\n    }\n  }\n  for (const link of head) {\n    if (didLinks.has(link.toString())) continue;\n    didLinks.add(link.toString());\n    const { value: event } = await eventsFetcher.get(link);\n    if (!event) continue;\n    const { type } = event.data;\n    let ops = [] as PutOperation[];\n    if (type === \"batch\") {\n      ops = event.data.ops as PutOperation[];\n    } else if (type === \"put\") {\n      ops = [event.data] as PutOperation[];\n    }\n    for (let i = ops.length - 1; i >= 0; i--) {\n      const { key, value } = ops[i];\n      if (!keys.has(key)) {\n        // todo option to see all updates\n        const docValue = await getValueFromLink<T>(blocks, value, logger);\n        updates.push({ id: key, value: docValue.doc, del: docValue.del, clock: link });\n        limit--;\n        keys.add(key);\n      }\n    }\n    if (event.parents) {\n      updates = await gatherUpdates(blocks, eventsFetcher, event.parents, since, updates, keys, didLinks, limit, logger);\n    }\n  }\n  return updates;\n}\n\nexport async function* getAllEntries<T extends DocTypes>(blocks: BlockFetcher, head: ClockHead, logger: Logger) {\n  // return entries(blocks, head)\n  for await (const [key, link] of entries(blocks, head)) {\n    const docValue = await getValueFromLink(blocks, link, logger);\n    yield { id: key, value: docValue.doc, del: docValue.del } as DocUpdate<T>;\n  }\n}\n\nexport async function* clockVis(blocks: BlockFetcher, head: ClockHead) {\n  for await (const line of vis(blocks, head)) {\n    yield line;\n  }\n}\n\nlet isCompacting = false;\nexport async function doCompact(blockLog: CompactFetcher, head: ClockHead, logger: Logger) {\n  if (isCompacting) {\n    // console.log('already compacting')\n    return;\n  }\n  isCompacting = true;\n\n  time(\"compact head\");\n  for (const cid of head) {\n    const bl = await blockLog.get(cid);\n    if (!bl) throw logger.Error().Ref(\"cid\", cid).Msg(\"Missing head block\").AsError();\n  }\n  timeEnd(\"compact head\");\n\n  // for await (const blk of  blocks.entries()) {\n  //   const bl = await blockLog.get(blk.cid)\n  //   if (!bl) throw new Error('Missing tblock: ' + blk.cid.toString())\n  // }\n\n  // todo maybe remove\n  // for await (const blk of blocks.loader!.entries()) {\n  //   const bl = await blockLog.get(blk.cid)\n  //   if (!bl) throw new Error('Missing db block: ' + blk.cid.toString())\n  // }\n\n  time(\"compact all entries\");\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _entry of getAllEntries(blockLog, head, logger)) {\n    // result.push(entry)\n    // void 1;\n    continue;\n  }\n  timeEnd(\"compact all entries\");\n\n  // time(\"compact crdt entries\")\n  // for await (const [, link] of entries(blockLog, head)) {\n  //   const bl = await blockLog.get(link)\n  //   if (!bl) throw new Error('Missing entry block: ' + link.toString())\n  // }\n  // timeEnd(\"compact crdt entries\")\n\n  time(\"compact clock vis\");\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _line of vis(blockLog, head)) {\n    void 1;\n  }\n  timeEnd(\"compact clock vis\");\n\n  time(\"compact root\");\n  const result = await root(blockLog, head);\n  timeEnd(\"compact root\");\n\n  time(\"compact root blocks\");\n  for (const { cid, bytes } of [...result.additions, ...result.removals]) {\n    blockLog.loggedBlocks.putSync(cid, bytes);\n  }\n  timeEnd(\"compact root blocks\");\n\n  time(\"compact changes\");\n  await clockChangesSince(blockLog, head, [], {}, logger);\n  timeEnd(\"compact changes\");\n\n  isCompacting = false;\n}\n\nexport async function getBlock(blocks: BlockFetcher, cidString: string) {\n  const block = await blocks.get(parse(cidString));\n  if (!block) throw new Error(`Missing block ${cidString}`);\n  const { cid, value } = await decode({ bytes: block.bytes, codec, hasher });\n  return new Block({ cid, value, bytes: block.bytes });\n}\n","import type { Block, Link } from \"multiformats\";\nimport { create } from \"./runtime/wait-pr-multiformats/block.js\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport * as codec from \"@ipld/dag-cbor\";\n\n// @ts-expect-error \"charwise\" has no types\nimport charwise from \"charwise\";\n// @ts-expect-error \"prolly-trees\" has no types\nimport * as DbIndex from \"prolly-trees/db-index\";\n// @ts-expect-error \"prolly-trees\" has no types\nimport { bf, simpleCompare } from \"prolly-trees/utils\";\n// @ts-expect-error \"prolly-trees\" has no types\nimport { nocache as cache } from \"prolly-trees/cache\";\n// @ts-expect-error \"prolly-trees\" has no types\nimport { ProllyNode as BaseNode } from \"prolly-trees/db-index\";\n\nimport {\n  DocUpdate,\n  MapFn,\n  DocFragment,\n  IndexUpdate,\n  QueryOpts,\n  IndexRow,\n  DocWithId,\n  IndexKeyType,\n  IndexKey,\n  DocTypes,\n  DocObject,\n  IndexUpdateString,\n} from \"./types.js\";\nimport { CarTransaction, BlockFetcher, AnyLink, AnyBlock } from \"./blockstore/index.js\";\nimport { CRDT } from \"./crdt.js\";\n\nexport class IndexTree<K extends IndexKeyType, R extends DocFragment> {\n  cid?: AnyLink;\n  root?: ProllyNode<K, R>;\n}\n\ntype CompareRef = string | number;\nexport type CompareKey = [string | number, CompareRef];\n\nfunction refCompare(aRef: CompareRef, bRef: CompareRef) {\n  if (Number.isNaN(aRef)) return -1;\n  if (Number.isNaN(bRef)) throw new Error(\"ref may not be Infinity or NaN\");\n  if (aRef === Infinity) return 1;\n  // if (!Number.isFinite(bRef)) throw new Error('ref may not be Infinity or NaN')\n\n  return simpleCompare(aRef, bRef) as number;\n}\n\nfunction compare(a: CompareKey, b: CompareKey) {\n  const [aKey, aRef] = a;\n  const [bKey, bRef] = b;\n\n  const comp: number = simpleCompare(aKey, bKey);\n  if (comp !== 0) return comp;\n  return refCompare(aRef, bRef);\n}\n\nexport const byKeyOpts: StaticProllyOptions<CompareKey> = { cache, chunker: bf(30), codec, hasher, compare };\n\nexport const byIdOpts: StaticProllyOptions<unknown> = { cache, chunker: bf(30), codec, hasher, compare: simpleCompare };\n\nexport interface IndexDoc<K extends IndexKeyType> {\n  readonly key: IndexKey<K>;\n  readonly value: DocFragment;\n}\n\nexport interface IndexDocString {\n  readonly key: string;\n  readonly value: DocFragment;\n}\n\nexport function indexEntriesForChanges<T extends DocTypes, K extends IndexKeyType>(\n  changes: DocUpdate<T>[],\n  mapFn: MapFn<T>,\n): IndexDoc<K>[] {\n  const indexEntries: IndexDoc<K>[] = [];\n  changes.forEach(({ id: key, value, del }) => {\n    if (del || !value) return;\n    let mapCalled = false;\n    const mapReturn = mapFn({ ...(value as DocWithId<T>), _id: key }, (k: IndexKeyType, v?: DocFragment) => {\n      mapCalled = true;\n      if (typeof k === \"undefined\") return;\n      indexEntries.push({\n        key: [charwise.encode(k) as K, key],\n        value: v || null,\n      });\n    });\n    if (!mapCalled && mapReturn) {\n      indexEntries.push({\n        key: [charwise.encode(mapReturn) as K, key],\n        value: null,\n      });\n    }\n  });\n  return indexEntries;\n}\n\nfunction makeProllyGetBlock(blocks: BlockFetcher): (address: AnyLink) => Promise<AnyBlock> {\n  return async (address: AnyLink) => {\n    const block = await blocks.get(address);\n    if (!block) throw new Error(`Missing block ${address.toString()}`);\n    const { cid, bytes } = block;\n    return create({ cid, bytes, hasher, codec }) as Promise<AnyBlock>;\n  };\n}\n\nexport async function bulkIndex<K extends IndexKeyType, T extends DocFragment, CT>(\n  tblocks: CarTransaction,\n  inIndex: IndexTree<K, T>,\n  indexEntries: (IndexUpdate<K> | IndexUpdateString)[],\n  opts: StaticProllyOptions<CT>,\n): Promise<IndexTree<K, T>> {\n  if (!indexEntries.length) return inIndex;\n  if (!inIndex.root) {\n    if (!inIndex.cid) {\n      let returnRootBlock: Block | undefined = undefined;\n      let returnNode: ProllyNode<K, T> | undefined = undefined;\n\n      for await (const node of (await DbIndex.create({\n        get: makeProllyGetBlock(tblocks),\n        list: indexEntries,\n        ...opts,\n      })) as ProllyNode<K, T>[]) {\n        const block = await node.block;\n        await tblocks.put(block.cid, block.bytes);\n        returnRootBlock = block;\n        returnNode = node;\n      }\n      if (!returnNode || !returnRootBlock) throw new Error(\"failed to create index\");\n      return { root: returnNode, cid: returnRootBlock.cid };\n    } else {\n      inIndex.root = (await DbIndex.load({ cid: inIndex.cid, get: makeProllyGetBlock(tblocks), ...opts })) as ProllyNode<K, T>;\n    }\n  }\n  const { root, blocks: newBlocks } = await inIndex.root.bulk(indexEntries);\n  if (root) {\n    for await (const block of newBlocks) {\n      await tblocks.put(block.cid, block.bytes);\n    }\n    return { root, cid: (await root.block).cid };\n  } else {\n    return { root: undefined, cid: undefined };\n  }\n}\n\nexport async function loadIndex<K extends IndexKeyType, T extends DocFragment, CT>(\n  tblocks: BlockFetcher,\n  cid: AnyLink,\n  opts: StaticProllyOptions<CT>,\n): Promise<ProllyNode<K, T>> {\n  return (await DbIndex.load({ cid, get: makeProllyGetBlock(tblocks), ...opts })) as ProllyNode<K, T>;\n}\n\nexport async function applyQuery<K extends IndexKeyType, T extends DocObject, R extends DocFragment>(\n  crdt: CRDT<T>,\n  resp: { result: ProllyIndexRow<K, R>[] },\n  query: QueryOpts<K>,\n): Promise<{\n  rows: IndexRow<K, T, R>[];\n}> {\n  if (query.descending) {\n    resp.result = resp.result.reverse();\n  }\n  if (query.limit) {\n    resp.result = resp.result.slice(0, query.limit);\n  }\n  if (query.includeDocs) {\n    resp.result = await Promise.all(\n      resp.result.map(async (row) => {\n        const val = await crdt.get(row.id);\n        const doc = val ? ({ ...val.doc, _id: row.id } as DocWithId<T>) : undefined;\n        return { ...row, doc };\n      }),\n    );\n  }\n  return {\n    rows: resp.result.map(({ key, ...row }) => {\n      return {\n        key: charwise.decode(key),\n        ...row,\n      };\n    }),\n  };\n}\n\nexport function encodeRange(range: [IndexKeyType, IndexKeyType]): [string, string] {\n  return [charwise.encode(range[0]), charwise.encode(range[1])];\n}\n\nexport function encodeKey(key: DocFragment): string {\n  return charwise.encode(key) as string;\n}\n\nexport interface ProllyIndexRow<K extends IndexKeyType, T extends DocFragment> {\n  readonly id: string;\n  readonly key: IndexKey<K>;\n  readonly value: T;\n}\n\n// ProllyNode type based on the ProllyNode from 'prolly-trees/base'\ninterface ProllyNode<K extends IndexKeyType, T extends DocFragment> extends BaseNode {\n  getAllEntries(): PromiseLike<{ [x: string]: unknown; result: ProllyIndexRow<K, T>[] }>;\n  getMany<KI extends IndexKeyType>(removeIds: KI[]): Promise<{ /* [x: K]: unknown; */ result: IndexKey<K>[] }>;\n  range(a: string, b: string): Promise<{ result: ProllyIndexRow<K, T>[] }>;\n  get(key: string): Promise<{ result: ProllyIndexRow<K, T>[] }>;\n  bulk(bulk: (IndexUpdate<K> | IndexUpdateString)[]): PromiseLike<{\n    readonly root?: ProllyNode<K, T>;\n    readonly blocks: Block[];\n  }>;\n  readonly address: Promise<Link>;\n  readonly distance: number;\n  compare: (a: unknown, b: unknown) => number;\n  readonly cache: unknown;\n  readonly block: Promise<Block>;\n}\n\ninterface StaticProllyOptions<T> {\n  readonly cache: unknown;\n  chunker: (entry: T, distance: number) => boolean;\n  readonly codec: unknown;\n  readonly hasher: unknown;\n  compare: (a: T, b: T) => number;\n}\n","const readUInt32LE = buffer => {\n  const offset = buffer.byteLength - 4;\n  return (buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16) + buffer[offset + 3] * 16777216;\n};\nconst MAX_UINT32 = 4294967295;\nconst bf = factor => {\n  const threshold = Math.floor(MAX_UINT32 / factor);\n  return async entry => {\n    const identity = await entry.identity();\n    if (typeof identity !== 'number') {\n      throw new Error('Identity must be a number');\n    }\n    if (identity <= threshold) {\n      return true;\n    }\n    return false;\n  };\n};\nconst enc32 = value => {\n  value = +value;\n  const buff = new Uint8Array(4);\n  buff[3] = value >>> 24;\n  buff[2] = value >>> 16;\n  buff[1] = value >>> 8;\n  buff[0] = value & 255;\n  return buff;\n};\nconst simpleCompare = (a, b) => {\n  if (a === b)\n    return 0;\n  if (a > b)\n    return 1;\n  return -1;\n};\nconst binaryCompare = (b1, b2) => {\n  for (let i = 0; i < b1.byteLength; i++) {\n    if (b2.byteLength === i)\n      return 1;\n    const c1 = b1[i];\n    const c2 = b2[i];\n    if (c1 === c2)\n      continue;\n    if (c1 > c2)\n      return 1;\n    else\n      return -1;\n  }\n  if (b2.byteLength > b1.byteLength)\n    return -1;\n  return 0;\n};\nclass CIDCounter {\n  constructor() {\n    this._cids = new Set();\n  }\n  add(node) {\n    if (!node.address) {\n      throw new Error('Cannot add node without address');\n    }\n    if (node.address.then) {\n      const p = node.address.then(cid => this._cids.add(cid.toString()));\n      this._cids.add(p);\n      p.then(() => this._cids.delete(p));\n    } else {\n      this._cids.add(node.address.toString());\n    }\n  }\n  async all() {\n    await Promise.all([...this._cids]);\n    return this._cids;\n  }\n}\nexport {\n  readUInt32LE,\n  enc32,\n  bf,\n  binaryCompare,\n  simpleCompare,\n  CIDCounter\n};","import { encode as multiformatEncode } from 'multiformats/block';\nimport { CIDCounter } from './utils.js';\nclass Entry {\n  constructor({key, address}, opts = {}) {\n    this.key = key;\n    this.address = address;\n    this.codec = opts.codec;\n    this.hasher = opts.hasher;\n  }\n  get isEntry() {\n    return true;\n  }\n}\nclass EntryList {\n  constructor({entries, closed}) {\n    if (typeof closed !== 'boolean')\n      throw new Error('Missing required argument \"closed\"');\n    this.entries = entries;\n    this.closed = closed;\n    this.startKey = entries[0].key;\n  }\n  find(key, compare) {\n    const {entries} = this;\n    for (let i = entries.length - 1; i > -1; i--) {\n      const entry = entries[i];\n      const comp = compare(key, entry.key);\n      if (comp > -1) {\n        return [\n          i,\n          entry\n        ];\n      }\n    }\n    return null;\n  }\n  findMany(keys, compare, sorted = false, strict = false) {\n    const {entries} = this;\n    const results = new Map();\n    if (!sorted) {\n      keys = keys.sort(compare);\n    } else {\n      keys = [...keys];\n    }\n    for (let i = entries.length - 1; i > -1; i--) {\n      if (!keys.length)\n        break;\n      const entry = entries[i];\n      const found = [];\n      while (keys.length) {\n        let key = keys[keys.length - 1];\n        key = key.key ? key.key : key;\n        const comp = compare(key, entry.key);\n        if (!strict) {\n          if (comp > -1) {\n            found.push(keys.pop());\n          } else {\n            break;\n          }\n        } else {\n          if (comp === 0) {\n            found.push(keys.pop());\n          } else if (comp > 0) {\n            keys.pop();\n          } else {\n            break;\n          }\n        }\n      }\n      if (found.length) {\n        results.set(i, [\n          entry,\n          found\n        ]);\n      }\n    }\n    return results;\n  }\n  findRange(start, end, compare) {\n    const {entries} = this;\n    let last;\n    let first = 0;\n    for (let i = entries.length - 1; i > -1; i--) {\n      const entry = entries[i];\n      const comp = compare(end, entry.key);\n      if (comp > 0) {\n        last = i;\n        break;\n      }\n    }\n    for (let i = 0; i < entries.length; i++) {\n      const entry = entries[i];\n      const comp = compare(start, entry.key);\n      if (comp === 0) {\n        first = i;\n        break;\n      } else if (comp < 0) {\n        break;\n      }\n      first = i;\n    }\n    return {\n      first,\n      last,\n      entries: entries.slice(first, last + 1)\n    };\n  }\n}\nconst stringKey = key => typeof key === 'string' ? key : JSON.stringify(key);\nfunction sortBulk(bulk, opts) {\n  return bulk.sort(({key: a}, {key: b}) => opts.compare(a, b));\n}\nasync function filterLeftmostInserts(first, bulk, compare) {\n  const inserts = [];\n  for (const b of bulk) {\n    const {key, del} = b;\n    if (compare(key, first) < 0) {\n      if (!del)\n        inserts.push(b);\n    } else {\n      break;\n    }\n  }\n  return inserts;\n}\nasync function generateNewLeaves(inserts, opts, {chunker, compare}) {\n  return await Node.from({\n    entries: inserts.map(insert => new opts.LeafEntryClass(insert, opts)).sort((a, b) => compare(a.key, b.key)),\n    chunker,\n    NodeClass: opts.LeafClass,\n    distance: 0,\n    opts\n  });\n}\nasync function generateBranchEntries(that, newLeaves, results, opts) {\n  return await Promise.all(newLeaves.map(async node => {\n    const block = await node.encode();\n    results.blocks.push({\n      block,\n      node\n    });\n    that.cache.set(node);\n    const newBranchEntry = new opts.BranchEntryClass({\n      key: node.key,\n      address: await node.address\n    }, opts);\n    return newBranchEntry;\n  }));\n}\nasync function processRoot(that, results, bulk, nodeOptions) {\n  const root = results.root;\n  results.blocks.push({\n    block: await root.encode(),\n    node: root\n  });\n  that.cache.set(root);\n  const opts = nodeOptions.opts;\n  const distance = root.distance;\n  const first = root.entryList.startKey;\n  const inserts = await filterLeftmostInserts(first, bulk, that.compare);\n  if (inserts.length) {\n    const newLeaves = await generateNewLeaves(inserts, opts, that);\n    const branchEntries = await generateBranchEntries(that, newLeaves, results, opts);\n    const firstRootEntry = new opts.BranchEntryClass({\n      key: root.entryList.startKey,\n      address: await root.address\n    }, opts);\n    const newBranchEntries = [\n      firstRootEntry,\n      ...branchEntries\n    ].sort(({key: a}, {key: b}) => opts.compare(a, b));\n    let newBranches = await Node.from({\n      ...nodeOptions,\n      entries: newBranchEntries,\n      chunker: that.chunker,\n      NodeClass: opts.BranchClass,\n      distance: distance + 1\n    });\n    let allBranches = [...newBranches];\n    while (newBranches.length > 1) {\n      const newBranchEntries = await Promise.all(newBranches.map(async l => new opts.BranchEntryClass({\n        key: l.key,\n        address: await l.address\n      }, opts)));\n      newBranches = await Node.from({\n        ...nodeOptions,\n        entries: newBranchEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),\n        chunker: that.chunker,\n        NodeClass: opts.BranchClass,\n        distance: distance + 1\n      });\n      allBranches = [\n        ...allBranches,\n        ...newBranches\n      ];\n    }\n    await Promise.all(allBranches.map(async m => {\n      const block = await m.encode();\n      that.cache.set(m);\n      results.blocks.push({\n        block,\n        node: m\n      });\n    }));\n    results.root = newBranches[0];\n    results.nodes = [\n      ...results.nodes,\n      ...allBranches\n    ];\n  }\n}\nclass Node {\n  constructor({entryList, chunker, distance, getNode, compare, cache}) {\n    this.entryList = entryList;\n    this.chunker = chunker;\n    this.distance = distance;\n    this.getNode = getNode;\n    this.compare = compare;\n    this.cache = cache;\n  }\n  get closed() {\n    return this.entryList.closed;\n  }\n  get key() {\n    return this.entryList.startKey;\n  }\n  async getEntry(key, cids = new CIDCounter()) {\n    const result = await this._getEntry(key, cids);\n    return {\n      result,\n      cids\n    };\n  }\n  async _getEntry(key, cids) {\n    cids.add(this);\n    let node = this;\n    while (!node.isLeaf) {\n      const result = node.entryList.find(key, this.compare);\n      if (result === null)\n        throw new Error('Not found');\n      const [, entry] = result;\n      node = await this.getNode(await entry.address);\n      cids.add(node);\n    }\n    const result = node.entryList.find(key, this.compare);\n    if (result === null || result[1].key.toString() !== key.toString())\n      throw new Error('Not found');\n    const [, entry] = result;\n    return entry;\n  }\n  async getAllEntries(cids = new CIDCounter()) {\n    const result = await this._getAllEntries(cids);\n    return {\n      result,\n      cids\n    };\n  }\n  _getAllEntries(cids) {\n    cids.add(this);\n    if (this.isLeaf) {\n      return this.entryList.entries;\n    } else {\n      const {entries} = this.entryList;\n      const mapper = async entry => this.getNode(await entry.address).then(node => node._getAllEntries(cids)).catch(async err => {\n        throw err;\n      });\n      return Promise.all(entries.map(mapper)).then(results => results.flat());\n    }\n  }\n  async *vis(cids = new Set()) {\n    const renderNodeLabel = async node => {\n      if (node.isLeaf) {\n        const entries = node.entryList.entries.map(e => `[${ e.key },${ JSON.stringify(e.value).replace(/\"/g, '\\'') }]`).join(', ');\n        return `Leaf [${ entries }]`;\n      } else {\n        const entries = node.entryList.entries.map(e => `[${ e.key }]`).join(', ');\n        return `Branch [${ entries }]`;\n      }\n    };\n    const shortCid = cid => cid.toString().slice(0, 4) + cid.toString().slice(-4);\n    const visit = async function* (node, parentId, cids) {\n      const nodeId = await node.address;\n      if (!cids.has(nodeId)) {\n        cids.add(nodeId);\n        const nodeLabel = await renderNodeLabel(node);\n        yield `  node [shape=ellipse fontname=\"Courier\"]; ${ shortCid(nodeId) } [label=\"${ nodeLabel }\"];`;\n        yield `  ${ shortCid(parentId) } -> ${ shortCid(nodeId) };`;\n        for (const entry of node.entryList.entries) {\n          if (entry.address) {\n            const entryId = await entry.address;\n            try {\n              const childNode = await node.getNode(entryId);\n              yield* await visit(childNode, nodeId, cids);\n            } catch (err) {\n              yield `  ${ shortCid(nodeId) } -> ${ shortCid(entryId) };`;\n              yield `  node [shape=ellipse fontname=\"Courier\"]; ${ shortCid(entryId) } [label=\"Error: ${ err.message }\"];`;\n            }\n          }\n        }\n      }\n    };\n    yield 'digraph tree {';\n    yield '  node [shape=ellipse fontname=\"Courier\"]; rootnode;';\n    for await (const line of visit(this, 'rootnode', cids)) {\n      yield line;\n    }\n    yield '}';\n  }\n  async getEntries(keys, sorted = false, cids = new CIDCounter()) {\n    const result = await this._getEntries(keys, sorted, cids);\n    return {\n      result,\n      cids\n    };\n  }\n  async _getEntries(keys, sorted, cids) {\n    cids.add(this);\n    if (!sorted)\n      keys = keys.sort(this.compare);\n    const results = this.entryList.findMany(keys, this.compare, true, this.isLeaf);\n    if (this.isLeaf) {\n      return [...results.values()].map(([entry]) => entry);\n    }\n    let entries = [];\n    for (const [entry, keys] of [...results.values()].reverse()) {\n      const p = this.getNode(await entry.address);\n      entries.push(p.then(node => node._getEntries(keys.reverse(), true, cids)));\n    }\n    entries = await Promise.all(entries);\n    return entries.flat();\n  }\n  async getRangeEntries(start, end, cids = new CIDCounter()) {\n    const result = await this._getRangeEntries(start, end, cids);\n    return {\n      result,\n      cids\n    };\n  }\n  _getRangeEntries(start, end, cids) {\n    cids.add(this);\n    const {entries} = this.entryList.findRange(start, end, this.compare);\n    if (this.isLeaf) {\n      return entries.filter(entry => {\n        const s = this.compare(start, entry.key);\n        const e = this.compare(end, entry.key);\n        if (s <= 0 && e >= 0)\n          return true;\n        return false;\n      });\n    }\n    if (!entries.length)\n      return [];\n    const thenRange = async entry => this.getNode(await entry.address).then(node => node._getRangeEntries(start, end, cids));\n    const results = [thenRange(entries.shift())];\n    if (!entries.length)\n      return results[0];\n    const last = thenRange(entries.pop());\n    while (entries.length) {\n      const thenAll = async entry => this.getNode(await entry.address).then(async node => node._getAllEntries(cids));\n      results.push(thenAll(entries.shift()));\n    }\n    results.push(last);\n    return Promise.all(results).then(results => results.flat());\n  }\n  async transaction(bulk, opts = {}) {\n    opts = {\n      codec: this.codec,\n      hasher: this.hasher,\n      getNode: this.getNode,\n      compare: this.compare,\n      cache: this.cache,\n      ...opts\n    };\n    const nodeOptions = {\n      chunker: this.chunker,\n      opts\n    };\n    const results = this.entryList.findMany(bulk, opts.compare, true, this.isLeaf);\n    if (this.isLeaf) {\n      return await this.transactionLeaf(bulk, opts, nodeOptions, results);\n    } else {\n      return await this.transactionBranch(bulk, opts, nodeOptions, results);\n    }\n  }\n  async transactionLeaf(bulk, opts, nodeOptions, results) {\n    const {LeafClass, LeafEntryClass} = opts;\n    const {entries, previous} = this.processLeafEntries(bulk, results, LeafEntryClass, opts);\n    const _opts = {\n      ...nodeOptions,\n      entries,\n      NodeClass: LeafClass,\n      distance: 0\n    };\n    const nodes = await Node.from(_opts);\n    return {\n      nodes,\n      previous,\n      blocks: await Promise.all(nodes.map(async n => {\n        const block = await n.encode();\n        this.cache.set(n);\n        return {\n          block,\n          node: n\n        };\n      })),\n      distance: 0\n    };\n  }\n  processLeafEntries(bulk, results, LeafEntryClass, opts) {\n    const previous = [];\n    let entries = [];\n    const changes = {};\n    const deletes = new Map();\n    for (const {key, del, value} of bulk) {\n      const skey = stringKey(key);\n      if (del) {\n        if (typeof changes[skey] === 'undefined')\n          deletes.set(skey, null);\n      } else {\n        changes[skey] = {\n          key,\n          value\n        };\n        deletes.delete(skey);\n      }\n    }\n    entries = [...this.entryList.entries];\n    for (const [i, [entry]] of results) {\n      previous.push(entry);\n      const skey = stringKey(entry.key);\n      if (deletes.has(skey)) {\n        deletes.set(skey, i);\n      } else {\n        entries[i] = new LeafEntryClass(changes[skey], opts);\n        delete changes[skey];\n      }\n    }\n    let count = 0;\n    for (const [, i] of deletes) {\n      if (i !== null)\n        entries.splice(i - count++, 1);\n    }\n    const appends = Object.values(changes).map(obj => new LeafEntryClass(obj, opts));\n    entries = entries.concat(appends).sort(({key: a}, {key: b}) => opts.compare(a, b));\n    return {\n      entries,\n      previous\n    };\n  }\n  async transactionBranch(bulk, opts, nodeOptions, results) {\n    const {BranchClass, BranchEntryClass} = opts;\n    let distance = 0;\n    for (const [i, [entry, keys]] of results) {\n      const p = this.getNode(await entry.address).then(node => node.transaction(keys.reverse(), {\n        ...opts,\n        sorted: true\n      })).then(r => ({\n        entry,\n        keys,\n        distance,\n        ...r\n      }));\n      results.set(i, p);\n    }\n    let entries = [...this.entryList.entries];\n    const final = {\n      previous: [],\n      blocks: [],\n      nodes: []\n    };\n    for (const [i, p] of results) {\n      const {\n        nodes,\n        previous,\n        blocks,\n        distance: _distance\n      } = await p;\n      distance = _distance;\n      entries[i] = nodes;\n      if (previous.length)\n        final.previous = final.previous.concat(previous);\n      if (blocks.length)\n        final.blocks = final.blocks.concat(blocks);\n      if (nodes.length)\n        final.nodes = final.nodes.concat(nodes);\n    }\n    entries = entries.flat();\n    const newEntries = await this.handlePrepend(entries, opts, nodeOptions, final, distance);\n    distance++;\n    const toEntry = async branch => {\n      if (branch.isEntry)\n        return branch;\n      const block = await branch.encode();\n      final.blocks.push({\n        block,\n        node: branch\n      });\n      this.cache.set(branch);\n      return new BranchEntryClass(branch, opts);\n    };\n    entries = await Promise.all(newEntries.map(toEntry));\n    const _opts = {\n      ...nodeOptions,\n      entries,\n      NodeClass: BranchClass,\n      distance\n    };\n    const newNodes = await Node.from(_opts);\n    await Promise.all(newNodes.map(async n => {\n      const block = await n.encode();\n      final.blocks.push({\n        block,\n        node: n\n      });\n      this.cache.set(n);\n    }));\n    final.nodes = newNodes;\n    return {\n      ...final,\n      distance\n    };\n  }\n  async handlePrepend(entries, opts, nodeOptions, final, distance) {\n    const {BranchClass, LeafClass} = opts;\n    let newEntries = [];\n    let prepend = null;\n    for (const entry of entries) {\n      if (prepend) {\n        const mergeEntries = await this.mergeFirstLeftEntries(entry, prepend, nodeOptions, final, distance);\n        prepend = null;\n        const NodeClass = !mergeEntries[0].address ? LeafClass : BranchClass;\n        const _opts = {\n          ...nodeOptions,\n          entries: mergeEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),\n          NodeClass,\n          distance: distance\n        };\n        const nodes = await Node.from(_opts);\n        if (!nodes[nodes.length - 1].closed) {\n          prepend = nodes.pop();\n        }\n        if (nodes.length) {\n          newEntries = newEntries.concat(nodes);\n        }\n      } else {\n        if (!entry.isEntry && !entry.closed) {\n          prepend = entry;\n        } else {\n          newEntries.push(entry);\n        }\n      }\n    }\n    if (prepend) {\n      newEntries.push(prepend);\n    }\n    return newEntries;\n  }\n  async getNodeFirstFromBlocks(blocks, addr) {\n    for (const {block, node} of blocks) {\n      if (await block.cid === addr)\n        return node;\n    }\n    return await this.getNode(addr);\n  }\n  async mergeFirstLeftEntries(entry, prepend, nodeOptions, final, distance) {\n    const opts = nodeOptions.opts;\n    const {LeafClass, BranchClass, BranchEntryClass} = opts;\n    if (entry.isEntry) {\n      const addr = await entry.address;\n      entry = await this.getNodeFirstFromBlocks(final.blocks, addr);\n    }\n    const es = entry.entryList.entries;\n    if (!es.length)\n      throw new Error('unreachable no entries');\n    const basicMerge = (entries1, entries2) => {\n      return entries1.concat(entries2);\n    };\n    const processNodesAndCreateEntries = async (nodes, final, opts) => {\n      return await Promise.all(nodes.map(async l => {\n        final.blocks.push({\n          block: await l.encode(),\n          node: l\n        });\n        this.cache.set(l);\n        return new BranchEntryClass({\n          key: l.key,\n          address: await l.address\n        }, opts);\n      }));\n    };\n    if (es[0].constructor.name === prepend.entryList.entries[0].constructor.name) {\n      return await basicMerge(prepend.entryList.entries, es);\n    } else {\n      const leftEntry = es.shift();\n      if (!leftEntry)\n        throw new Error('unreachable no left entry');\n      if (!leftEntry.address)\n        throw new Error('unreachable existing leaf, no leftEntry.address');\n      const mergeLeftEntries = await this.mergeFirstLeftEntries(leftEntry, prepend, nodeOptions, final, distance - 1);\n      const esf = es.shift();\n      if (!esf) {\n        return mergeLeftEntries;\n      }\n      if (!esf.address)\n        throw new Error('unreachable existing leaf, no esf.address');\n      const oldFront = await this.getNodeFirstFromBlocks(final.blocks, await esf.address);\n      if (!oldFront.entryList.entries[0].address) {\n        const leftLeafEntries = await basicMerge(mergeLeftEntries, oldFront.entryList.entries);\n        const leftLeafNodes = await Node.from({\n          ...nodeOptions,\n          entries: leftLeafEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),\n          NodeClass: LeafClass,\n          distance\n        });\n        const leftBranches = await processNodesAndCreateEntries(leftLeafNodes, final, opts);\n        return await basicMerge(leftBranches, es);\n      } else {\n        if (mergeLeftEntries[0].address) {\n          return mergeLeftEntries.concat(oldFront.entryList.entries);\n        } else {\n          const mergeLeftNodes = await Node.from({\n            ...nodeOptions,\n            entries: mergeLeftEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),\n            NodeClass: LeafClass,\n            distance\n          });\n          const mergeLeftBranchEntries = await processNodesAndCreateEntries(mergeLeftNodes, final, opts);\n          const newFirstNodes = await Node.from({\n            ...nodeOptions,\n            entries: [\n              ...oldFront.entryList.entries,\n              ...mergeLeftBranchEntries,\n              ...es\n            ].sort(({key: a}, {key: b}) => opts.compare(a, b)),\n            NodeClass: BranchClass,\n            distance\n          });\n          const newBranchEntries = await processNodesAndCreateEntries(newFirstNodes, final, opts);\n          return newBranchEntries;\n        }\n      }\n    }\n  }\n  async bulk(bulk, opts = {}, isRoot = true) {\n    const {BranchClass} = opts;\n    opts = {\n      codec: this.codec,\n      hasher: this.hasher,\n      getNode: this.getNode,\n      compare: this.compare,\n      cache: this.cache,\n      ...opts\n    };\n    if (!opts.sorted) {\n      bulk = sortBulk(bulk, opts);\n      opts.sorted = true;\n    }\n    const nodeOptions = {\n      chunker: this.chunker,\n      opts\n    };\n    const results = await this.transaction(bulk, opts);\n    while (results.nodes.length > 1) {\n      const newDistance = results.nodes[0].distance + 1;\n      const branchEntries = await Promise.all(results.nodes.map(async node => {\n        const block = await node.encode();\n        results.blocks.push({\n          block,\n          node\n        });\n        this.cache.set(node);\n        return new opts.BranchEntryClass(node, opts);\n      }));\n      const newNodes = await Node.from({\n        ...nodeOptions,\n        entries: branchEntries,\n        NodeClass: BranchClass,\n        distance: newDistance\n      });\n      await Promise.all(newNodes.map(async node => {\n        const block = await node.encode();\n        this.cache.set(node);\n        results.blocks.push({\n          block,\n          node\n        });\n      }));\n      results.nodes = newNodes;\n    }\n    results.root = results.nodes[0];\n    if (isRoot && results.root) {\n      await processRoot(this, results, bulk, nodeOptions);\n    }\n    results.blocks = results.blocks.map(({block}) => block);\n    return results;\n  }\n  static async from({entries, chunker, NodeClass, distance, opts}) {\n    if (!entries.every(entry => entry.constructor.name === entries[0].constructor.name))\n      throw new Error('all entries must be of the same type');\n    const parts = [];\n    let chunk = [];\n    for (const entry of entries) {\n      chunk.push(entry);\n      if (await chunker(entry, distance)) {\n        parts.push(new EntryList({\n          entries: chunk,\n          closed: true\n        }));\n        chunk = [];\n      }\n    }\n    if (chunk.length) {\n      parts.push(new EntryList({\n        entries: chunk,\n        closed: false\n      }));\n    }\n    return parts.map(entryList => new NodeClass({\n      entryList,\n      chunker,\n      distance,\n      ...opts\n    }));\n  }\n}\nclass IPLDNode extends Node {\n  constructor({codec, hasher, block, ...opts}) {\n    super(opts);\n    this.codec = codec;\n    this.hasher = hasher;\n    if (!block) {\n      this.block = this.encode();\n      this.address = this.block.then(block => block.cid);\n    } else {\n      this.block = block;\n      this.address = block.cid;\n    }\n  }\n  async get(key) {\n    const {\n      result: entry,\n      cids\n    } = await this.getEntry(key);\n    return {\n      result: entry.key,\n      cids\n    };\n  }\n  async encode() {\n    if (this.block)\n      return this.block;\n    const value = await this.encodeNode();\n    const opts = {\n      codec: this.codec,\n      hasher: this.hasher,\n      value\n    };\n    this.block = await multiformatEncode(opts);\n    return this.block;\n  }\n}\nclass IPLDBranch extends IPLDNode {\n  async encodeNode() {\n    const {entries} = this.entryList;\n    const mapper = async entry => {\n      if (!entry.address)\n        throw new Error('entry.address required');\n      return [\n        entry.key,\n        await entry.address\n      ];\n    };\n    const list = await Promise.all(entries.map(mapper));\n    return {\n      branch: [\n        this.distance,\n        list\n      ],\n      closed: this.closed\n    };\n  }\n  get isBranch() {\n    return true;\n  }\n}\nclass IPLDLeaf extends IPLDNode {\n  async encodeNode() {\n    const list = await Promise.all(this.entryList.entries.map(async entry => await entry.encodeNode()));\n    return {\n      leaf: list,\n      closed: this.closed\n    };\n  }\n  get isLeaf() {\n    return true;\n  }\n}\nconst create = async function* (obj) {\n  let {LeafClass, LeafEntryClass, BranchClass, BranchEntryClass, list, chunker, compare, ...opts} = obj;\n  list = list.map(value => new LeafEntryClass(value, opts));\n  opts.compare = compare;\n  let nodes = await Node.from({\n    entries: list,\n    chunker,\n    NodeClass: LeafClass,\n    distance: 0,\n    opts\n  });\n  yield* nodes;\n  let distance = 1;\n  while (nodes.length > 1) {\n    const mapper = async node => new BranchEntryClass({\n      key: node.key,\n      address: await node.address\n    }, opts);\n    const entries = await Promise.all(nodes.map(mapper));\n    nodes = await Node.from({\n      entries,\n      chunker,\n      NodeClass: BranchClass,\n      distance,\n      opts\n    });\n    yield* nodes;\n    distance++;\n  }\n};\nexport {\n  Node,\n  Entry,\n  EntryList,\n  IPLDNode,\n  IPLDLeaf,\n  IPLDBranch,\n  create\n};","import {\n  Entry,\n  EntryList,\n  IPLDLeaf,\n  IPLDBranch,\n  create as baseCreate\n} from './base.js';\nimport { readUInt32LE } from './utils.js';\nclass MapEntry extends Entry {\n  async identity() {\n    const encoded = await this.codec.encode(await this.encodeNode());\n    const hash = await this.hasher.encode(encoded);\n    return readUInt32LE(hash);\n  }\n}\nclass MapLeafEntry extends MapEntry {\n  constructor(node, opts) {\n    super(node, opts);\n    this.value = node.value;\n  }\n  encodeNode() {\n    return [\n      this.key,\n      this.value\n    ];\n  }\n}\nclass MapBranchEntry extends MapEntry {\n  constructor(node, opts) {\n    if (!node.address)\n      throw new Error('Cannot create MapBranchEntry without address');\n    super(node, opts);\n  }\n  async encodeNode() {\n    return [\n      this.key,\n      await this.address\n    ];\n  }\n}\nconst getValue = async (node, key) => {\n  const {\n    result: entry,\n    cids\n  } = await node.getEntry(key);\n  return {\n    result: entry.value,\n    cids\n  };\n};\nconst getManyValues = async (node, keys) => {\n  const {\n    result: entries,\n    cids\n  } = await node.getEntries(keys);\n  return {\n    result: entries.map(entry => entry.value),\n    cids\n  };\n};\nclass MapLeaf extends IPLDLeaf {\n  get(key) {\n    return getValue(this, key);\n  }\n  getMany(keys) {\n    return getManyValues(this, keys);\n  }\n  bulk(bulk, opts = {}, isRoot = true) {\n    return super.bulk(bulk, {\n      ...classes,\n      ...opts\n    }, isRoot);\n  }\n}\nclass MapBranch extends IPLDBranch {\n  get(key) {\n    return getValue(this, key);\n  }\n  getMany(keys) {\n    return getManyValues(this, keys);\n  }\n  bulk(bulk, opts = {}, isRoot = true) {\n    return super.bulk(bulk, {\n      ...classes,\n      ...opts\n    }, isRoot);\n  }\n}\nconst classes = {\n  LeafClass: MapLeaf,\n  LeafEntryClass: MapLeafEntry,\n  BranchClass: MapBranch,\n  BranchEntryClass: MapBranchEntry\n};\nconst createGetNode = (get, cache, chunker, codec, hasher, compare, opts) => {\n  const LeafClass = opts.LeafClass || MapLeaf;\n  const LeafEntryClass = opts.LeafEntryClass || MapLeafEntry;\n  const BranchClass = opts.BranchClass || MapBranch;\n  const BranchEntryClass = opts.BranchEntryClass || MapBranchEntry;\n  const getNode = async cid => {\n    if (cache.has(cid))\n      return cache.get(cid);\n    return get(cid).then(block => decoder(block));\n  };\n  const decoder = makeDecoder({\n    chunker,\n    cache,\n    getNode,\n    codec,\n    hasher,\n    compare,\n    LeafEntryClass,\n    LeafClass,\n    BranchEntryClass,\n    BranchClass\n  });\n  return getNode;\n};\nconst create = ({get, cache, chunker, list, codec, hasher, sorted, compare, ...opts}) => {\n  if (!sorted)\n    list = list.sort(({key: a}, {key: b}) => compare(a, b));\n  const getNode = createGetNode(get, cache, chunker, codec, hasher, compare, opts);\n  const _opts = {\n    list,\n    codec,\n    hasher,\n    chunker,\n    getNode,\n    sorted,\n    compare,\n    cache,\n    LeafClass: opts.LeafClass || MapLeaf,\n    LeafEntryClass: opts.LeafEntryClass || MapLeafEntry,\n    BranchClass: opts.BranchClass || MapBranch,\n    BranchEntryClass: opts.BranchEntryClass || MapBranchEntry\n  };\n  return baseCreate(_opts);\n};\nconst load = ({cid, get, cache, chunker, codec, hasher, compare, ...opts}) => {\n  const getNode = createGetNode(get, cache, chunker, codec, hasher, compare, opts);\n  return getNode(cid);\n};\nfunction makeDecoder({chunker, cache, getNode, codec, hasher, compare, LeafEntryClass, LeafClass, BranchEntryClass, BranchClass}) {\n  const entryOpts = {\n    codec,\n    hasher\n  };\n  return block => {\n    const {value} = block;\n    const opts = {\n      chunker,\n      cache,\n      block,\n      getNode,\n      codec,\n      hasher,\n      compare\n    };\n    let entries;\n    let CLS;\n    if (value.leaf) {\n      entries = value.leaf.map(([key, value]) => new LeafEntryClass({\n        key,\n        value\n      }, entryOpts));\n      CLS = LeafClass;\n    } else if (value.branch) {\n      const [distance, _entries] = value.branch;\n      opts.distance = distance;\n      entries = _entries.map(([key, address]) => new BranchEntryClass({\n        key,\n        address\n      }, entryOpts));\n      CLS = BranchClass;\n    } else {\n      throw new Error('Unknown block data, does not match schema');\n    }\n    const entryList = new EntryList({\n      entries,\n      closed: value.closed\n    });\n    const node = new CLS({\n      entryList,\n      ...opts\n    });\n    cache.set(node);\n    return node;\n  };\n}\nexport {\n  create,\n  load,\n  MapLeaf,\n  MapBranch,\n  MapLeafEntry,\n  MapBranchEntry\n};","import {\n  create as mapCreate,\n  load as mapLoad,\n  MapLeaf,\n  MapBranch,\n  MapLeafEntry,\n  MapBranchEntry\n} from './map.js';\nimport { simpleCompare } from './utils.js';\nconst compare = (a, b) => {\n  const [aKey, aRef] = a;\n  const [bKey, bRef] = b;\n  const comp = simpleCompare(aKey, bKey);\n  if (comp !== 0)\n    return comp;\n  return refCompare(aRef, bRef);\n};\nconst refCompare = (aRef, bRef) => {\n  if (Number.isNaN(aRef))\n    return -1;\n  if (Number.isNaN(bRef))\n    throw new Error('ref may not be Infinity or NaN');\n  if (!Number.isFinite(aRef))\n    return 1;\n  return simpleCompare(aRef, bRef);\n};\nconst getIndex = async (node, key) => {\n  const start = [\n    key,\n    NaN\n  ];\n  const end = [\n    key,\n    Infinity\n  ];\n  const {\n    result: entries,\n    cids\n  } = await node.getRangeEntries(start, end);\n  return {\n    result: entries.map(entry => {\n      const [key, id] = entry.key;\n      return {\n        id,\n        key,\n        row: entry.value\n      };\n    }),\n    cids\n  };\n};\nconst getRange = async (node, start, end) => {\n  start = [\n    start,\n    NaN\n  ];\n  end = [\n    end,\n    Infinity\n  ];\n  const {\n    result: entries,\n    cids\n  } = await node.getRangeEntries(start, end);\n  const result = entries.map(entry => {\n    const [key, id] = entry.key;\n    return {\n      id,\n      key,\n      row: entry.value\n    };\n  });\n  return {\n    result,\n    cids\n  };\n};\nclass DBIndexLeaf extends MapLeaf {\n  get(key) {\n    return getIndex(this, key);\n  }\n  range(start, end) {\n    return getRange(this, start, end);\n  }\n  bulk(bulk, opts = {}, isRoot = true) {\n    return super.bulk(bulk, {\n      ...classes,\n      ...opts\n    }, isRoot);\n  }\n}\nclass DBIndexBranch extends MapBranch {\n  get(key) {\n    return getIndex(this, key);\n  }\n  range(start, end) {\n    return getRange(this, start, end);\n  }\n  bulk(bulk, opts = {}, isRoot = true) {\n    return super.bulk(bulk, {\n      ...classes,\n      ...opts\n    }, isRoot);\n  }\n}\nconst LeafClass = DBIndexLeaf;\nconst BranchClass = DBIndexBranch;\nconst classes = {\n  LeafClass,\n  BranchClass,\n  LeafEntryClass: MapLeafEntry,\n  BranchEntryClass: MapBranchEntry\n};\nconst defaults = {\n  ...classes,\n  compare\n};\nconst create = opts => {\n  opts = {\n    ...defaults,\n    ...opts\n  };\n  return mapCreate(opts);\n};\nconst load = opts => {\n  opts = {\n    ...defaults,\n    ...opts\n  };\n  return mapLoad(opts);\n};\nexport {\n  create,\n  load,\n  DBIndexBranch,\n  DBIndexLeaf\n};","const nocache = {\n  has: () => false,\n  get: () => {\n    throw new Error('Cannot ask for entries from nocache');\n  },\n  set: () => {\n  }\n};\nconst toKey = key => key.asCID === key ? key.toString() : JSON.stringify(key);\nconst global = {\n  blocks: {},\n  has: key => !!global.blocks[toKey(key)],\n  set: async node => {\n    let key = node.address;\n    if (key.then)\n      key = await key;\n    key = toKey(key);\n    if (!global.blocks[key])\n      global.blocks[key] = node;\n  },\n  get: key => {\n    key = toKey(key);\n    if (typeof global.blocks[key] === 'undefined')\n      throw new Error('Not found');\n    return global.blocks[key];\n  }\n};\nexport {\n  nocache,\n  global\n};","import {\n  type ClockHead,\n  type DocUpdate,\n  type MapFn,\n  type IndexUpdate,\n  type QueryOpts,\n  type IdxMeta,\n  type DocFragment,\n  type IdxMetaMap,\n  type IndexKeyType,\n  type IndexRows,\n  type DocTypes,\n  type IndexUpdateString,\n  throwFalsy,\n  IndexTransactionMeta,\n  SuperThis,\n} from \"./types.js\";\nimport { BaseBlockstore } from \"./blockstore/index.js\";\n\nimport {\n  bulkIndex,\n  indexEntriesForChanges,\n  byIdOpts,\n  byKeyOpts,\n  IndexTree,\n  applyQuery,\n  encodeRange,\n  encodeKey,\n  loadIndex,\n  IndexDocString,\n  CompareKey,\n} from \"./indexer-helpers.js\";\nimport { CRDT } from \"./crdt.js\";\nimport { ensureLogger } from \"./utils.js\";\nimport { Logger } from \"@adviser/cement\";\n\nexport function index<K extends IndexKeyType = string, T extends DocTypes = NonNullable<unknown>, R extends DocFragment = T>(\n  sthis: SuperThis,\n  { _crdt }: { _crdt: CRDT<T> | CRDT<NonNullable<unknown>> },\n  name: string,\n  mapFn?: MapFn<T>,\n  meta?: IdxMeta,\n): Index<K, T, R> {\n  if (mapFn && meta) throw _crdt.logger.Error().Msg(\"cannot provide both mapFn and meta\").AsError();\n  if (mapFn && mapFn.constructor.name !== \"Function\") throw _crdt.logger.Error().Msg(\"mapFn must be a function\").AsError();\n  if (_crdt.indexers.has(name)) {\n    const idx = _crdt.indexers.get(name) as unknown as Index<K, T>;\n    idx.applyMapFn(name, mapFn, meta);\n  } else {\n    const idx = new Index<K, T>(sthis, _crdt, name, mapFn, meta);\n    _crdt.indexers.set(name, idx as unknown as Index<K, NonNullable<unknown>, NonNullable<unknown>>);\n  }\n  return _crdt.indexers.get(name) as unknown as Index<K, T, R>;\n}\n\n// interface ByIdIndexIten<K extends IndexKeyType> {\n//   readonly key: K;\n//   readonly value: [K, K];\n// }\n\nexport class Index<K extends IndexKeyType, T extends DocTypes, R extends DocFragment = T> {\n  readonly blockstore: BaseBlockstore;\n  readonly crdt: CRDT<T>;\n  name: string;\n  mapFn?: MapFn<T>;\n  mapFnString = \"\";\n  byKey: IndexTree<K, R> = new IndexTree<K, R>();\n  byId: IndexTree<K, R> = new IndexTree<K, R>();\n  indexHead?: ClockHead;\n  includeDocsDefault = false;\n  initError?: Error;\n\n  ready(): Promise<void> {\n    return Promise.all([this.blockstore.ready(), this.crdt.ready()]).then(() => {\n      /* noop */\n    });\n  }\n\n  close(): Promise<void> {\n    return Promise.all([this.blockstore.close(), this.crdt.close()]).then(() => {\n      /* noop */\n    });\n  }\n  destroy(): Promise<void> {\n    return Promise.all([this.blockstore.destroy(), this.crdt.destroy()]).then(() => {\n      /* noop */\n    });\n  }\n\n  readonly logger: Logger;\n\n  constructor(sthis: SuperThis, crdt: CRDT<T> | CRDT<NonNullable<unknown>>, name: string, mapFn?: MapFn<T>, meta?: IdxMeta) {\n    this.logger = ensureLogger(sthis, \"Index\");\n    this.blockstore = crdt.indexBlockstore;\n    this.crdt = crdt as CRDT<T>;\n    this.applyMapFn(name, mapFn, meta);\n    this.name = name;\n    if (!(this.mapFnString || this.initError)) throw this.logger.Error().Msg(\"missing mapFnString\").AsError();\n    // this.ready = this.blockstore.ready.then(() => {\n    //   return;\n    // });\n    // .then((header: IdxCarHeader) => {\n    //     // @ts-ignore\n    //     if (header.head) throw new Error('cannot have head in idx header')\n    //     if (header.indexes === undefined) throw new Error('missing indexes in idx header')\n    //     // for (const [name, idx] of Object.entries(header.indexes)) {\n    //     //   index({ _crdt: crdt }, name, undefined, idx as IdxMeta)\n    //     // }\n    //   })\n  }\n\n  applyMapFn(name: string, mapFn?: MapFn<T>, meta?: IdxMeta) {\n    if (mapFn && meta) throw this.logger.Error().Msg(\"cannot provide both mapFn and meta\").AsError();\n    if (this.name && this.name !== name) throw this.logger.Error().Msg(\"cannot change name\").AsError();\n    this.name = name;\n    try {\n      if (meta) {\n        // hydrating from header\n        if (this.indexHead && this.indexHead.map((c) => c.toString()).join() !== meta.head.map((c) => c.toString()).join()) {\n          throw this.logger.Error().Msg(\"cannot apply different head meta\").AsError();\n        }\n\n        if (this.mapFnString) {\n          // we already initialized from application code\n          if (this.mapFnString !== meta.map) {\n            this.logger\n              .Warn()\n              .Msg(`cannot apply different mapFn meta: old mapFnString ${this.mapFnString} new mapFnString ${meta.map}`);\n            // throw new Error('cannot apply different mapFn meta')\n          } else {\n            this.byId.cid = meta.byId;\n            this.byKey.cid = meta.byKey;\n            this.indexHead = meta.head;\n          }\n        } else {\n          // we are first\n          this.mapFnString = meta.map;\n          this.byId.cid = meta.byId;\n          this.byKey.cid = meta.byKey;\n          this.indexHead = meta.head;\n        }\n      } else {\n        if (this.mapFn) {\n          // we already initialized from application code\n          if (mapFn) {\n            if (this.mapFn.toString() !== mapFn.toString()) {\n              throw this.logger.Error().Msg(\"cannot apply different mapFn app2\").AsError();\n            }\n          }\n        } else {\n          // application code is creating an index\n          if (!mapFn) {\n            mapFn = ((doc) => (doc as unknown as Record<string, unknown>)[name] ?? undefined) as MapFn<T>;\n          }\n          if (this.mapFnString) {\n            // we already loaded from a header\n            if (this.mapFnString !== mapFn.toString()) {\n              throw this.logger\n                .Error()\n                .Str(\"mapFnString\", this.mapFnString)\n                .Str(\"mapFn\", mapFn.toString())\n                .Msg(\"cannot apply different mapFn app\")\n                .AsError();\n            }\n          } else {\n            // we are first\n            this.mapFnString = mapFn.toString();\n          }\n          this.mapFn = mapFn;\n        }\n      }\n      const matches = /=>\\s*(.*)/.test(this.mapFnString);\n      this.includeDocsDefault = matches;\n    } catch (e) {\n      this.initError = e as Error;\n    }\n  }\n\n  async query(opts: QueryOpts<K> = {}): Promise<IndexRows<K, T, R>> {\n    await this.ready();\n    // this._resetIndex();\n    await this._updateIndex();\n    await this._hydrateIndex();\n    if (!this.byKey.root) {\n      return await applyQuery<K, T, R>(this.crdt, { result: [] }, opts);\n    }\n    if (this.includeDocsDefault && opts.includeDocs === undefined) opts.includeDocs = true;\n    if (opts.range) {\n      const eRange = encodeRange(opts.range);\n      return await applyQuery<K, T, R>(this.crdt, await throwFalsy(this.byKey.root).range(eRange[0], eRange[1]), opts);\n    }\n    if (opts.key) {\n      const encodedKey = encodeKey(opts.key);\n      return await applyQuery<K, T, R>(this.crdt, await throwFalsy(this.byKey.root).get(encodedKey), opts);\n    }\n    if (Array.isArray(opts.keys)) {\n      const results = await Promise.all(\n        opts.keys.map(async (key: DocFragment) => {\n          const encodedKey = encodeKey(key);\n          return (await applyQuery<K, T, R>(this.crdt, await throwFalsy(this.byKey.root).get(encodedKey), opts)).rows;\n        }),\n      );\n      return { rows: results.flat() };\n    }\n    if (opts.prefix) {\n      if (!Array.isArray(opts.prefix)) opts.prefix = [opts.prefix];\n      // prefix should be always an array\n      const start = [...opts.prefix, NaN];\n      const end = [...opts.prefix, Infinity];\n      const encodedR = encodeRange([start, end]);\n      return await applyQuery<K, T, R>(this.crdt, await this.byKey.root.range(...encodedR), opts);\n    }\n    const all = await this.byKey.root.getAllEntries(); // funky return type\n    return await applyQuery<K, T, R>(\n      this.crdt,\n      {\n        // @ts-expect-error getAllEntries returns a different type than range\n        result: all.result.map(({ key: [k, id], value }) => ({\n          key: k,\n          id,\n          value,\n        })),\n      },\n      opts,\n    );\n  }\n\n  _resetIndex() {\n    this.byId = new IndexTree();\n    this.byKey = new IndexTree();\n    this.indexHead = undefined;\n  }\n\n  async _hydrateIndex() {\n    if (this.byId.root && this.byKey.root) return;\n    if (!this.byId.cid || !this.byKey.cid) return;\n    this.byId.root = await loadIndex<K, R, K>(this.blockstore, this.byId.cid, byIdOpts);\n    this.byKey.root = await loadIndex<K, R, CompareKey>(this.blockstore, this.byKey.cid, byKeyOpts);\n  }\n\n  async _updateIndex(): Promise<IndexTransactionMeta> {\n    await this.ready();\n    if (this.initError) throw this.initError;\n    if (!this.mapFn) throw this.logger.Error().Msg(\"No map function defined\").AsError();\n    let result: DocUpdate<T>[], head: ClockHead;\n    if (!this.indexHead || this.indexHead.length === 0) {\n      ({ result, head } = await this.crdt.allDocs());\n    } else {\n      ({ result, head } = await this.crdt.changes(this.indexHead));\n    }\n    if (result.length === 0) {\n      this.indexHead = head;\n      // return { byId: this.byId, byKey: this.byKey } as IndexTransactionMeta;\n    }\n    let staleKeyIndexEntries: IndexUpdate<K>[] = [];\n    let removeIdIndexEntries: IndexUpdateString[] = [];\n    if (this.byId.root) {\n      const removeIds = result.map(({ id: key }) => key);\n      const { result: oldChangeEntries } = await this.byId.root.getMany(removeIds);\n      staleKeyIndexEntries = oldChangeEntries.map((key) => ({ key, del: true }));\n      removeIdIndexEntries = oldChangeEntries.map((key) => ({ key: key[1], del: true }));\n    }\n    const indexEntries = indexEntriesForChanges<T, K>(result, this.mapFn); // use a getter to translate from string\n    const byIdIndexEntries: IndexDocString[] = indexEntries.map(({ key }) => ({\n      key: key[1],\n      value: key,\n    }));\n    const indexerMeta: IdxMetaMap = { indexes: new Map() };\n\n    for (const [name, indexer] of this.crdt.indexers) {\n      if (indexer.indexHead) {\n        indexerMeta.indexes?.set(name, {\n          byId: indexer.byId.cid,\n          byKey: indexer.byKey.cid,\n          head: indexer.indexHead,\n          map: indexer.mapFnString,\n          name: indexer.name,\n        } as IdxMeta);\n      }\n    }\n    if (result.length === 0) {\n      return indexerMeta as unknown as IndexTransactionMeta;\n    }\n    const { meta } = await this.blockstore.transaction<IndexTransactionMeta>(async (tblocks): Promise<IndexTransactionMeta> => {\n      this.byId = await bulkIndex<K, R, K>(tblocks, this.byId, removeIdIndexEntries.concat(byIdIndexEntries), byIdOpts);\n      this.byKey = await bulkIndex<K, R, CompareKey>(tblocks, this.byKey, staleKeyIndexEntries.concat(indexEntries), byKeyOpts);\n      this.indexHead = head;\n      if (this.byId.cid && this.byKey.cid) {\n        const idxMeta = {\n          byId: this.byId.cid,\n          byKey: this.byKey.cid,\n          head,\n          map: this.mapFnString,\n          name: this.name,\n        } as IdxMeta;\n        indexerMeta.indexes?.set(this.name, idxMeta);\n      }\n      return indexerMeta as unknown as IndexTransactionMeta;\n    });\n    return meta;\n  }\n}\n","import { advance } from \"@web3-storage/pail/clock\";\nimport { root } from \"@web3-storage/pail/crdt\";\nimport { Logger, ResolveOnce } from \"@adviser/cement\";\n\nimport { clockChangesSince } from \"./crdt-helpers.js\";\nimport type { BaseBlockstore, CarTransaction } from \"./blockstore/index.js\";\nimport { type DocUpdate, type ClockHead, type DocTypes, throwFalsy, CRDTMeta } from \"./types.js\";\nimport { applyHeadQueue, ApplyHeadQueue } from \"./apply-head-queue.js\";\nimport { ensureLogger } from \"./utils.js\";\n\nexport class CRDTClock<T extends DocTypes> {\n  // todo: track local and remote clocks independently, merge on read\n  // that way we can drop the whole remote if we need to\n  // should go with making sure the local clock only references locally available blockstore on write\n  head: ClockHead = [];\n\n  readonly zoomers: Set<() => void> = new Set<() => void>();\n  readonly watchers: Set<(updates: DocUpdate<T>[]) => void> = new Set<(updates: DocUpdate<T>[]) => void>();\n  readonly emptyWatchers: Set<() => void> = new Set<() => void>();\n\n  readonly blockstore: BaseBlockstore;\n\n  readonly applyHeadQueue: ApplyHeadQueue<T>;\n\n  readonly _ready: ResolveOnce<void> = new ResolveOnce<void>();\n  async ready(): Promise<void> {\n    return this._ready.once(async () => {\n      await this.blockstore.ready();\n    });\n  }\n\n  async close() {\n    await this.blockstore.close();\n  }\n\n  readonly logger: Logger;\n  constructor(blockstore: BaseBlockstore) {\n    this.blockstore = blockstore;\n    this.logger = ensureLogger(blockstore.sthis, \"CRDTClock\");\n    this.applyHeadQueue = applyHeadQueue(this.int_applyHead.bind(this), this.logger);\n  }\n\n  setHead(head: ClockHead) {\n    this.head = head;\n  }\n\n  async applyHead(newHead: ClockHead, prevHead: ClockHead, updates?: DocUpdate<T>[]): Promise<void> {\n    for await (const { updates: updatesAcc, all } of this.applyHeadQueue.push({\n      newHead,\n      prevHead,\n      updates,\n    })) {\n      return this.processUpdates(updatesAcc, all, prevHead);\n    }\n  }\n\n  async processUpdates(updatesAcc: DocUpdate<T>[], all: boolean, prevHead: ClockHead) {\n    let internalUpdates = updatesAcc;\n    if (this.watchers.size && !all) {\n      const changes = await clockChangesSince<T>(throwFalsy(this.blockstore), this.head, prevHead, {}, this.logger);\n      internalUpdates = changes.result;\n    }\n    this.zoomers.forEach((fn) => fn());\n    this.notifyWatchers(internalUpdates || []);\n  }\n\n  notifyWatchers(updates: DocUpdate<T>[]) {\n    this.emptyWatchers.forEach((fn) => fn());\n    this.watchers.forEach((fn) => fn(updates || []));\n  }\n\n  onTick(fn: (updates: DocUpdate<T>[]) => void) {\n    this.watchers.add(fn);\n  }\n\n  onTock(fn: () => void) {\n    this.emptyWatchers.add(fn);\n  }\n\n  onZoom(fn: () => void) {\n    this.zoomers.add(fn);\n  }\n\n  async int_applyHead(newHead: ClockHead, prevHead: ClockHead, localUpdates: boolean) {\n    // if (!(this.head && prevHead && newHead)) {\n    //   throw new Error(\"missing head\");\n    // }\n    const noLoader = !localUpdates;\n    console.log(\"int_applyHead noLoader\", noLoader);\n\n    // console.log(\"int_applyHead\", this.applyHeadQueue.size(), this.head, newHead, prevHead, localUpdates);\n    const ogHead = sortClockHead(this.head);\n    newHead = sortClockHead(newHead);\n    if (compareClockHeads(ogHead, newHead)) {\n      return;\n    }\n    const ogPrev = sortClockHead(prevHead);\n    if (compareClockHeads(ogHead, ogPrev)) {\n      this.setHead(newHead);\n      return;\n    }\n\n    // const noLoader = this.head.length === 1 && !updates?.length\n    if (!this.blockstore) {\n      throw this.logger.Error().Msg(\"missing blockstore\").AsError();\n    }\n    await validateBlocks(this.logger, newHead, this.blockstore);\n    const { meta } = await this.blockstore.transaction<CRDTMeta>(\n      async (tblocks: CarTransaction) => {\n        const advancedHead = await advanceBlocks(this.logger, newHead, tblocks, this.head);\n        const result = await root(tblocks, advancedHead);\n        for (const { cid, bytes } of [\n          ...result.additions,\n          // ...result.removals\n        ]) {\n          tblocks.putSync(cid, bytes);\n        }\n        return { head: advancedHead };\n      },\n      { noLoader, add: false },\n    );\n    this.setHead(meta.head);\n  }\n}\n\n// Helper functions\nfunction sortClockHead(clockHead: ClockHead) {\n  return clockHead.sort((a, b) => a.toString().localeCompare(b.toString()));\n}\n\nasync function validateBlocks(logger: Logger, newHead: ClockHead, blockstore?: BaseBlockstore) {\n  if (!blockstore) throw logger.Error().Msg(\"missing blockstore\");\n  newHead.map(async (cid) => {\n    const got = await blockstore.get(cid);\n    if (!got) {\n      throw logger.Error().Str(\"cid\", cid.toString()).Msg(\"int_applyHead missing block\").AsError();\n    }\n  });\n}\n\nfunction compareClockHeads(head1: ClockHead, head2: ClockHead) {\n  return head1.toString() === head2.toString();\n}\n\nasync function advanceBlocks(logger: Logger, newHead: ClockHead, tblocks: CarTransaction, head: ClockHead) {\n  for (const cid of newHead) {\n    try {\n      head = await advance(tblocks, head, cid);\n    } catch (e) {\n      logger.Debug().Err(e).Msg(\"failed to advance head\");\n      // console.log('failed to advance head:', cid.toString(), e)\n      continue;\n    }\n  }\n  return head;\n}\n","import { Logger } from \"@adviser/cement\";\nimport { ClockHead, DocTypes, DocUpdate } from \"./types.js\";\n\ntype ApplyHeadWorkerFunction = (newHead: ClockHead, prevHead: ClockHead, localUpdates: boolean) => Promise<void>;\n\ninterface ApplyHeadTask<T extends DocTypes> {\n  readonly newHead: ClockHead;\n  readonly prevHead: ClockHead;\n  readonly updates?: DocUpdate<T>[];\n}\n\nexport interface ApplyHeadQueue<T extends DocTypes> {\n  push(task: ApplyHeadTask<T>): AsyncGenerator<\n    {\n      readonly updates: DocUpdate<T>[];\n      readonly all: boolean;\n    },\n    void,\n    unknown\n  >;\n  size(): number;\n}\n\nexport function applyHeadQueue<T extends DocTypes>(worker: ApplyHeadWorkerFunction, logger: Logger): ApplyHeadQueue<T> {\n  const queue: ApplyHeadTask<T>[] = [];\n  let isProcessing = false;\n\n  async function* process() {\n    if (isProcessing || queue.length === 0) return;\n    isProcessing = true;\n    const allUpdates: DocUpdate<T>[] = [];\n    try {\n      while (queue.length > 0) {\n        queue.sort((a, b) => (b.updates ? 1 : -1));\n        const task = queue.shift();\n        if (!task) continue;\n\n        console.log(\"int_applyHead worker\", task.updates);\n        await worker(task.newHead, task.prevHead, task.updates !== undefined).catch((e) => {\n          throw logger.Error().Err(e).Msg(\"int_applyHead worker error\").AsError();\n        });\n        // console.timeEnd('int_applyHead worker')\n\n        if (task.updates) {\n          allUpdates.push(...task.updates);\n        }\n        // Yield the updates if there are no tasks with updates left in the queue or the current task has updates\n        if (!queue.some((t) => t.updates) || task.updates) {\n          const allTasksHaveUpdates = queue.every((task) => task.updates !== null);\n          yield { updates: allUpdates, all: allTasksHaveUpdates };\n          allUpdates.length = 0;\n        }\n      }\n    } finally {\n      isProcessing = false;\n      const generator = process();\n      let result = await generator.next();\n      while (!result.done) {\n        result = await generator.next();\n      }\n    }\n  }\n\n  return {\n    push(task: ApplyHeadTask<T>): AsyncGenerator<{ updates: DocUpdate<T>[]; all: boolean }, void, unknown> {\n      queue.push(task);\n      return process();\n    },\n    size() {\n      return queue.length;\n    },\n  };\n}\n","export const PACKAGE_VERSION = Object.keys({\n  \"0.0.0-smoke\": \"xxxx\",\n})[0] as string;\n"],"mappings":"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IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;A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","names":["last","resolve","decoder","read","__export","decode","resolve","decoder","base","map","presetEnv","filter","from","code","name","tag","root","name","res","type","res","src","map","schema","node","schema","type","split","i","end","code","type","tag","isBlock","name","tag","map","stringKey","value","schema","stringify","comment","str","schema","map","del","Type","map","schema","schema","del","seq","seq","schema","format","tag","intIdentify","schema","init_schema","src","buffer","type","buf","seq","schema","pairs","map","schema","pairs","omap","seq","init_bool","floatNaN","floatExp","float","init_float","intResolve","n","intStringify","intIdentify","intOct","int","intHex","init_int","schema","set","map","res","schema","init_schema","init_bool","init_float","init_int","intOct","int","intHex","floatNaN","floatExp","float","tag","init_schema","schema","merge","schema","sortMapEntries","name","tag","res","name","code","message","src","tag","last","composeNode","composeEmptyNode","tag","map","composeNode","composeEmptyNode","tag","seq","type","composeNode","composeEmptyNode","tag","isMap","map","name","CN","tag","message","type","value","end","message","src","length","split","type","code","last","length","type","tag","schema","tag","message","src","code","message","code","message","context","type","stringify","visit","BREAK","REMOVE","SKIP","index","SCALAR","isCollection","isScalar","stringify","visit","i","ch","SCALAR","type","message","last","map","start","seq","src","stringify","stringify","cache","from","my","module","resolve","name","encode","length","i","j","decode","string","buffer","from","name","encode","decode","alphabet","string","buffer","decoder","exports","module","index","resolve","params","offset","exports","base64","length","string","encode","buffer","i","decode","exports","module","EventEmitter","exports","module","f32","f8b","buf","f64","exports","utf8","string","buffer","exports","module","pool","alloc","slice","size","buf","exports","module","LongBits","zero","from","hash","length","exports","isSet","Buffer","hash","merge","src","name","message","get","i","exports","module","LongBits","base64","utf8","Op","noop","State","create","alloc","push","writeByte","buf","writeVarint32","VarintOp","writeVarint64","writeFixed32","writeBytes","fork","exports","module","buf","writeStringBuffer","exports","module","LongBits","utf8","indexOutOfRange","buffer","create_array","create","buf","length","exports","module","buffer","exports","module","self","err","exports","exports","module","exports","configure","require_minimal","exports","module","exports","module","root","undefined","exports","module","exports","module","assign","code","exports","module","index","last","exists","exports","module","has","context","EventEmitter","name","length","name","base","NotFoundError","exports","module","encode","MSB","REST","MSBALL","INT","exports","module","read","MSB","REST","buf","exports","module","N1","N2","N3","N4","N5","N6","N7","N8","N9","exports","module","resolve","name","target","iterate","init_utils","name","NodeFileSystem","buffer","init_utils","init_utils","db","type","NotFoundError","exports","exports","encode","decode","open","close","exports","src_exports","NotFoundError","process","update","index","resolve","Block","create","decode","encode","encode","decode","buf","decode","code","int","code","digest","decode","equals","link","base","baseCache","code","digest","self","equals","base","decode","length","decoder","cache","cid","from","name","code","encode","digest","index","base","encode","hash","decode","Block","decode","hash","encode","create","parse","base","name","from","decode","encode","name","type","isBuffer","buf","toString","fromString","string","length","isBuffer","buf","buf","set","encodedSize","int","buf","encodedSize","compareTokens","length","buf","fromString","encodedSize","compareTokens","toToken","length","toString","toToken","length","buf","encodedSize","toToken","length","buf","encodedSize","buf","encodedSize","buf","float","encodedSize","ui8a","entries","isMap","length","buf","encoder","encode","decoder","BREAK","decode","buf","encode","decode","link","encode","decode","links","create","entries","encode","decode","link","root","entries","child","i","key","value","entry","get","parse","link","create","init","entries","base","put","link","traverse","create","i","root","message","put","result","data","event","root","batch","create","root","batch","create","get","entries","Batcher","entries","base","put","root","create","encodeFile","code","decode","encode","encodeLink","name","textDecoder","index","link","links","textEncoder","link","index","size","base","textEncoder","link","code","encode","link","decode","$protobuf","Data","encode","decode","toJSON","UnixTime","Metadata","code","name","links","encode","entries","encodeLink","encode","root","decode","message","type","links","links","length","link","root","name","message","message","name","effect","effects","tag","tag","group","self","group","fork","from","index","Future","BLANK","error","init","message","none","empty","slice","buffer","empty","get","EMPTY_BUFFER","EMPTY","config","empty","EMPTY","buffer","EMPTY","has","link","links","BLANK","EMPTY","has","link","EMPTY","BLANK","message","write","close","config","link","root","fork","encoder","EMPTY_BUFFER","hash","links","buffer","name","name","open","write","close","EMPTY","layout","root","index","length","defaults","configure","config","code","name","create","settings","defaults","configure","write","close","effect","message","defaults","create","settings","set","name","link","close","entries","links","digest","code","fork","murmur","import_murmurhash3js_revisited","from","mur","utf8","utf8","configure","bitWidth","hash","read","from","digest","bitCount","configure","settings","defaults","close","configure","create","code","decode","encode","name","res","message","buf","is","fromString","mapSorter","defaultEncodeOptions","encode","float","decode","toByteView","buf","cidEncoder","undefinedEncoder","numberEncoder","encodeOptions","decodeOptions","code","encode","encodeOptions","decode","buf","toByteView","decodeOptions","format","parse","decode","textDecoder","decodeVarint","decodeBytes","decodeKey","index","decodeLink","link","decodeNode","links","textEncoder","maxInt32","maxUInt32","textEncoder","toByteView","buf","code","decode","buf","toByteView","decodeNode","link","textEncoder","textDecoder","code","decode","textDecoder","code","name","encode","name","name","resolve","decode","resolve","name","decode","type","blockLength","length","buf","resolve","name","decode","resolve","name","decode","rawContent","buf","resolve","name","buf","buf","buf","buf","length","string","read","buffer","write","buf","buffer","length","read","buf","encode","decode","from","identity_exports","identity","from","buf","identity_exports","name","encode","decode","string","buf","decoder","encoder","fromString","string","base","size","buf","alloc","length","write","buf","fromString","createWriter","message","createWriter","CODEC_TYPES","createCodec","name","type","encode","decode","encode","decode","createCodec","encode","decode","createCodec","Data","DataType","__DataTypeValues","UnixTime","length","tag","buf","Metadata","DEFAULT_FILE_MODE","DEFAULT_DIRECTORY_MODE","message","Data","type","errcode","index","SparseArray","map","acc","index","fromString","hash","asUint8Array","buf","concat","length","asUint8Array","length","hashFn","hash","concat","buffer","buf","links","link","name","context","decode","src_default","isAsyncIterable","index","peekable","src_default","isAsyncIterable","map","index","peekable","src_default","resolve","pDefer","resolve","last","message","code","buffer","buffer","pushable","pDefer","resolve","push","options","_pushable","isAsyncIterable","src_default","isAsyncIterable","source","src_default","resolve","length","links","src_default","link","import_index","message","AbortError","resolve","step","index","EventEmitter","resolve","filter","buf","src_default","link","code","decode","resolve","read","resolve","links","src_default","link","name","decode","entries","name","link","resolve","decode","code","resolve","name","name","configure","collect","encodeFile","name","create","Node","current","resolve","enqueue","import_varint","decodeVarint","varint","length","v","entries","cborEncoders","defaultEncodeOptions","cborEncoders","defaultEncodeOptions","encoder","import_varint","root","close","varint","writeBytes","encode","length","createWriter","buffer","root","length","decodeVarint","decode","bytes","multihash","blockLength","index","read","index","decoder","import_varint","decode","name","resolve","name","KeyBagProviderIndexDB","buffer","createWriter","encode","encoder","commit","cid","resolve","remove","name","commit","cid","cache","got","batchSize","batch","slice","decode","crypto","hash","encode","decode","decode","ofs","encode","buffer","name","parse","format","init_utils","parse","dbMeta","format","name","message","base64","name","encodeFile","IndexDBGateway","IndexDBTestStore","name","name","tag","toString","batch","create","update","link","put","encode","type","name","get","decode","entries","parse","Block","buffer","identity","entries","compare","last","del","Node","root","newBranchEntries","cache","result","entry","visit","cids","keys","results","LeafClass","BranchClass","entries2","final","opts","block","encode","create","hash","entries","get","cache","compare","LeafClass","BranchClass","decoder","create","value","compare","entries","key","classes","defaults","create","load","refCompare","compare","del","charwise","create","load","root","name","process","task","name","name","NotFoundError","del","updates","set"]}