---
title: "Tutorial"
---

Welcome to ControlFlow! In this tutorial, we’ll introduce the basics of working with LLM agents, starting with a single, simple task and ending with a fully dynamic AI workflow. You'll also become with ControlFlow's three main concepts: tasks, flows, and agents.

# A simple task

The starting point of every agentic workflow is a `Task`. Each task represents an objective that we want an AI agent to complete. 

Let’s start with a simple task to say hello:
<CodeGroup>
    
```python Code
import controlflow as cf

task = cf.Task("say hello")
```

```python Result
>> print(task)

Task(
    id='6930c',
    objective='say hello',
    instructions=None,
    agents=None,
    context={},
    parent=None,
    depends_on=set(),
    status=<TaskStatus.INCOMPLETE: 'INCOMPLETE'>,
    result=None,
    result_type=<class 'str'>,
    error=None,
    tools=[],
    user_access=False,
    created_at=datetime.datetime(2024, 6, 8, 15, 19, 14, 725121),
    is_ready=True
)
```
</CodeGroup>


If you examine this task, you’ll notice a few important things: it's in an `INCOMPLETE` state, its `result_type` is a string, and it has no `result` value. This means that the task has not been completed yet, and its result is expected to be a string.

When the task is run, an agent will be told that its job is to mark it as completed by providing a result that complies with all of the task's requirements. In this case, we expect a string value that says "Hello".

Now let's run the task:

<CodeGroup>
```python Code
task.run()
```

```python Result
>> print(task)

Task(
    status=<TaskStatus.SUCCESSFUL: 'SUCCESSFUL'>,
    result='Hello',
    ... # unchanged fields ommitted 
)
```

</CodeGroup>

The task is now in a `SUCCESSFUL` state, and its result has been updated to `"Hello"`. The agent successfully completed the task!

## Task results

Building an effective AI workflow requires moving back and forth between between the observable, structured world of your Python script, and the autonomous, natural language world of your AI agents. 

A `Task` is the bridge between these two worlds. Each task is essentially a contract between you and your agents: you temporarily yield control of the script, and their job is to provide a result that satisfies the task's objective.

The key to making this work is the `result_type` field. This tells the agent what kind of result you expect, and lets you take its output back into your script with confidence that it matches the datatype you're expecting.

Let's ask our agent to generate a list of character names for a story. These will be represented as Pydantic models, allowing us to apply complex typing or validation, if needed:

<CodeGroup>
```python Code
import controlflow as cf
from pydantic import BaseModel


class Name(BaseModel):
    first: str
    last: str


task = cf.Task("generate 3 character names for an RPG", result_type=list[Name])
task.run()
```

```python Result
[
    Name(first='Thalric', last='Stormbringer'),
    Name(first='Eldryn', last='Moonshadow'),
    Name(first='Kael', last='Ironfist'),
]
 ```
</CodeGroup>

## Dependent tasks

Agentic workflows often involve multiple tasks that depend on each other. ControlFlow makes it easy to define these dependencies and ensure tasks are executed in the correct order.

For the next example, we'll use ask the user for their name, then use that information to write a personalized greeting. In addition to showing how to create dependent tasks, this also illustrates how to allow agents to communicate with the user by setting `user_access=True`. By default, agents can not talk anyone but other agents; this is to prevent your agentic workflow from devolving into a chatbot. However, human input is sometimes a critical part of the process, so you can enable it when needed.

<CodeGroup>
```python Code
import controlflow as cf

name = cf.Task("Get the user's name", user_access=True)
greeting = cf.Task("Write a personalized greeting", context=dict(name=name))

greeting.run()
```

```python Result
>> print(name.result)
"Marvin"

>> print(greeting.result)
"Hello Marvin! It's great to meet you. How can I assist you today?"
```
</CodeGroup>

There are a few things to note here:

When the agent asked for your name, you may have given it immediately ("My name is Marvin") or you may have taken a few turns to get there ("Sorry, did you say you need my name?"). In either case, the agent would have continued working until it was able to mark the task as complete. This is an important aspect of building an agentic workflow; we declare what we need (the name) and the agent figures out how to get it.

The `name` task was provided as part of the context for the `greeting` task. This is how we define dependencies between tasks. When the `greeting` task is run, the agent knows that it needs to run the `name` task first in order to get the name value.

We didn't actually run the `name` task in this example. Instead, we only ran the `greeting` task, which depended on the `name` task. Part of ControlFlow's orchestration is to ensure that all dependencies are run before running a task. If the `name` task had already been run, ControlFlow would have used the existing result.

